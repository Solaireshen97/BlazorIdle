# BlazorIdle 数据库读取优化实施方案 - 中篇（Repository 改造）

**项目**: BlazorIdle 数据库读取优化  
**文档版本**: 1.0  
**阶段**: Phase 2 - Repository 层改造  
**创建日期**: 2025-10-19  
**预计工时**: 20-28 小时  
**前置条件**: Phase 1 (基础设施) 已完成

---

## 📋 目录

1. [阶段概述](#阶段概述)
2. [改造策略](#改造策略)
3. [核心 Repository 改造](#核心-repository-改造)
4. [配置数据 Repository 改造](#配置数据-repository-改造)
5. [查询优化](#查询优化)
6. [数据一致性保证](#数据一致性保证)
7. [测试验证](#测试验证)
8. [检查清单](#检查清单)

---

## 阶段概述

### 目标

Phase 2 改造所有 Repository 使用缓存优先策略：
1. ✅ 核心运行态数据 Repository（Character, BattleSnapshot, ActivityPlan, GearInstance）
2. ✅ 配置数据 Repository（GearDefinition, Affix, GearSet）
3. ✅ 保持接口向后兼容
4. ✅ 确保读写一致性

### 改造范围

| Repository | 改造类型 | 优先级 | 预计工时 |
|-----------|---------|-------|---------|
| CharacterRepository | 使用 ReadThroughCacheManager | 🔥 高 | 4h |
| BattleRepository | 部分改造（读取优化） | 🔥 高 | 3h |
| ActivityPlanRepository | 使用 ReadThroughCacheManager | 🔥 高 | 4h |
| GearInstanceRepository | 使用 ReadThroughCacheManager | ⚠️ 中 | 5h |
| GearDefinitionRepository | 使用 ConfigurationCacheService | 🔥 高 | 3h |
| AffixRepository | 使用 ConfigurationCacheService | 🔥 高 | 2h |
| GearSetRepository | 使用 ConfigurationCacheService | ⚠️ 中 | 2h |
| **总计** | - | - | **23h** |

### 改造原则

1. **接口不变**：保持现有接口签名，对上层透明
2. **双路径支持**：配置开关控制使用缓存还是直接查数据库
3. **读写统一**：读写都通过缓存管理器，避免不一致
4. **向后兼容**：改造失败可快速回滚

---

## 改造策略

### 通用改造模式

#### 改造前（直接查数据库）

```csharp
public class CharacterRepository : ICharacterRepository
{
    private readonly GameDbContext _db;
    
    public CharacterRepository(GameDbContext db) => _db = db;
    
    public Task<Character?> GetAsync(Guid id, CancellationToken ct = default) =>
        _db.Characters.FirstOrDefaultAsync(c => c.Id == id, ct);  // ❌ 直接查数据库
}
```

#### 改造后（缓存优先）

```csharp
public class CharacterRepository : ICharacterRepository
{
    private readonly GameDbContext _db;
    private readonly IReadThroughCacheManager<Character> _cacheManager;
    private readonly IConfiguration _configuration;
    
    public CharacterRepository(
        GameDbContext db,
        IReadThroughCacheManager<Character> cacheManager,
        IConfiguration configuration)
    {
        _db = db;
        _cacheManager = cacheManager;
        _configuration = configuration;
    }
    
    public Task<Character?> GetAsync(Guid id, CancellationToken ct = default)
    {
        // 检查是否启用读取缓存
        var enableReadCache = _configuration.GetValue<bool>("ReadCache:EnableReadCache", true);
        
        if (enableReadCache)
        {
            return _cacheManager.GetByIdAsync(id, ct);  // ✅ 缓存优先
        }
        else
        {
            // Fallback: 直接查数据库（向后兼容）
            return _db.Characters.FirstOrDefaultAsync(c => c.Id == id, ct);
        }
    }
}
```

### 依赖注入变更

#### 改造前

```csharp
services.AddScoped<ICharacterRepository, CharacterRepository>();
```

#### 改造后

```csharp
services.AddScoped<ICharacterRepository, CharacterRepository>();
// ReadThroughCacheManager 已在 Phase 1 注册为 Singleton
```

**注意**：Repository 保持 Scoped，CacheManager 是 Singleton。

---

## 核心 Repository 改造

### 1. CharacterRepository 改造（4 小时）

#### 1.1 构造函数改造

```csharp
public class CharacterRepository : ICharacterRepository
{
    private readonly GameDbContext _db;
    private readonly IReadThroughCacheManager<Character> _cacheManager;
    private readonly IConfiguration _configuration;
    private readonly ILogger<CharacterRepository> _logger;
    
    public CharacterRepository(
        GameDbContext db,
        IReadThroughCacheManager<Character> cacheManager,
        IConfiguration configuration,
        ILogger<CharacterRepository> logger)
    {
        _db = db;
        _cacheManager = cacheManager;
        _configuration = configuration;
        _logger = logger;
    }
}
```

#### 1.2 GetAsync 改造

```csharp
/// <summary>
/// 按角色 ID 异步查询一个角色
/// Get character by ID asynchronously
/// </summary>
/// <param name="id">角色 ID / Character ID</param>
/// <param name="ct">取消令牌 / Cancellation token</param>
/// <returns>角色或 null / Character or null</returns>
public Task<Character?> GetAsync(Guid id, CancellationToken ct = default)
{
    var enableReadCache = _configuration.GetValue<bool>("ReadCache:EnableReadCache", true);
    
    if (enableReadCache)
    {
        _logger.LogTrace("使用缓存查询角色 {CharacterId}", id);
        return _cacheManager.GetByIdAsync(id, ct);
    }
    else
    {
        _logger.LogTrace("直接查询数据库获取角色 {CharacterId}", id);
        return _db.Characters.FirstOrDefaultAsync(c => c.Id == id, ct);
    }
}
```

#### 1.3 写入方法保持不变

```csharp
// 写入方法继续使用 MemoryStateManager（已在 Phase 1-2 实施）
// 不需要改动
```

**关键点**：
- ✅ 读取使用 ReadThroughCacheManager
- ✅ 写入继续使用 MemoryStateManager（已有）
- ✅ 保证读写一致性（同一个 MemoryStateManager）

### 2. ActivityPlanRepository 改造（4 小时）

#### 2.1 GetAsync 改造

```csharp
public Task<ActivityPlan?> GetAsync(Guid id, CancellationToken ct = default)
{
    var enableReadCache = _configuration.GetValue<bool>("ReadCache:EnableReadCache", true);
    
    return enableReadCache
        ? _cacheManager.GetByIdAsync(id, ct)
        : _db.ActivityPlans.FirstOrDefaultAsync(p => p.Id == id, ct);
}
```

#### 2.2 GetPendingOrRunningAsync 改造（列表查询）

**原实现**：
```csharp
public Task<List<ActivityPlan>> GetPendingOrRunningAsync(Guid characterId, CancellationToken ct = default) =>
    _db.ActivityPlans
        .Where(p => p.CharacterId == characterId &&
                   (p.Status == ActivityPlanStatus.Pending || p.Status == ActivityPlanStatus.Running))
        .ToListAsync(ct);
```

**改造后**：
```csharp
public Task<List<ActivityPlan>> GetPendingOrRunningAsync(Guid characterId, CancellationToken ct = default)
{
    var enableReadCache = _configuration.GetValue<bool>("ReadCache:EnableReadCache", true);
    
    if (enableReadCache)
    {
        // 使用缓存查询结果
        var cacheKey = $"ActivityPlan:Character:{characterId}:PendingOrRunning";
        
        return _cacheManager.GetListAsync(
            p => p.CharacterId == characterId &&
                 (p.Status == ActivityPlanStatus.Pending || p.Status == ActivityPlanStatus.Running),
            cacheKey,
            ct);
    }
    else
    {
        // Fallback: 直接查数据库
        return _db.ActivityPlans
            .Where(p => p.CharacterId == characterId &&
                       (p.Status == ActivityPlanStatus.Pending || p.Status == ActivityPlanStatus.Running))
            .ToListAsync(ct);
    }
}
```

#### 2.3 UpdateAsync 改造（写入时更新缓存）

```csharp
public async Task UpdateAsync(ActivityPlan plan, CancellationToken ct = default)
{
    var enableMemoryBuffering = _configuration.GetValue<bool>("Persistence:EnableMemoryBuffering", false);
    
    if (enableMemoryBuffering && _memoryStateManager != null)
    {
        // 更新内存状态（已有逻辑）
        _memoryStateManager.Update(plan);
        
        // 同步更新读取缓存
        var enableReadCache = _configuration.GetValue<bool>("ReadCache:EnableReadCache", true);
        if (enableReadCache)
        {
            _cacheManager.AddOrUpdate(plan);
            
            // 失效相关的列表查询缓存
            var cacheKey = $"ActivityPlan:Character:{plan.CharacterId}:PendingOrRunning";
            _cacheManager.InvalidateList(cacheKey);
        }
    }
    else
    {
        // Fallback: 直接保存
        await DatabaseRetryPolicy.SaveChangesWithRetryAsync(_db, ct);
    }
}
```

**关键点**：
- ✅ 写入时同时更新单实体缓存和失效列表缓存
- ✅ 保证缓存一致性

### 3. GearInstanceRepository 改造（5 小时）

#### 3.1 GetByIdAsync 改造

```csharp
public Task<GearInstance?> GetByIdAsync(Guid id, CancellationToken ct = default)
{
    var enableReadCache = _configuration.GetValue<bool>("ReadCache:EnableReadCache", true);
    
    return enableReadCache
        ? _cacheManager.GetByIdAsync(id, ct)
        : _db.GearInstances
            .Include(g => g.Affixes)
            .Include(g => g.GearDefinition)
            .FirstOrDefaultAsync(g => g.Id == id, ct);
}
```

**注意**：如果使用缓存，需要确保 Include 的关联数据也被缓存。

**解决方案 1**：缓存包含关联数据的完整实体
```csharp
// 数据库加载时使用 Include
entity = await db.Set<GearInstance>()
    .Include(g => g.Affixes)
    .Include(g => g.GearDefinition)
    .AsNoTracking()
    .FirstOrDefaultAsync(e => e.Id == id, ct);
```

**解决方案 2**：分别缓存，使用时组合
```csharp
var gearInstance = await _cacheManager.GetByIdAsync(id, ct);
if (gearInstance != null)
{
    // 从配置缓存加载 GearDefinition
    gearInstance.GearDefinition = await _configCache.GetGearDefinitionAsync(gearInstance.GearDefinitionId);
    
    // 从 Affix 缓存加载 Affixes
    var affixIds = gearInstance.AffixIds;
    gearInstance.Affixes = await _affixCache.GetByIdsAsync(affixIds);
}
```

**推荐**：解决方案 1（简单直接）

#### 3.2 GetByCharacterIdAsync 改造（列表查询）

```csharp
public Task<List<GearInstance>> GetByCharacterIdAsync(Guid characterId, CancellationToken ct = default)
{
    var enableReadCache = _configuration.GetValue<bool>("ReadCache:EnableReadCache", true);
    
    if (enableReadCache)
    {
        var cacheKey = $"GearInstance:Character:{characterId}";
        
        return _cacheManager.GetListAsync(
            g => g.CharacterId == characterId,
            cacheKey,
            ct);
    }
    else
    {
        return _db.GearInstances
            .Where(g => g.CharacterId == characterId)
            .Include(g => g.Affixes)
            .Include(g => g.GearDefinition)
            .ToListAsync(ct);
    }
}
```

#### 3.3 GetEquippedBySlotAsync 改造

```csharp
public Task<GearInstance?> GetEquippedBySlotAsync(
    Guid characterId,
    EquipmentSlot slot,
    CancellationToken ct = default)
{
    var enableReadCache = _configuration.GetValue<bool>("ReadCache:EnableReadCache", true);
    
    if (enableReadCache)
    {
        // 策略1：从列表缓存中筛选
        var cacheKey = $"GearInstance:Character:{characterId}";
        
        var allGear = await _cacheManager.GetListAsync(
            g => g.CharacterId == characterId,
            cacheKey,
            ct);
        
        return allGear.FirstOrDefault(g => g.IsEquipped && g.SlotType == slot);
    }
    else
    {
        return _db.GearInstances
            .FirstOrDefaultAsync(g => 
                g.CharacterId == characterId && 
                g.IsEquipped && 
                g.SlotType == slot, 
                ct);
    }
}
```

---

## 配置数据 Repository 改造

### 4. GearDefinitionRepository 改造（3 小时）

#### 4.1 完全重写为使用 ConfigurationCacheService

```csharp
public class GearDefinitionRepository : IGearDefinitionRepository
{
    private readonly IConfigurationCacheService _configCache;
    private readonly ILogger<GearDefinitionRepository> _logger;
    
    public GearDefinitionRepository(
        IConfigurationCacheService configCache,
        ILogger<GearDefinitionRepository> logger)
    {
        _configCache = configCache;
        _logger = logger;
    }
    
    public Task<GearDefinition?> GetByIdAsync(Guid id, CancellationToken ct = default)
    {
        _logger.LogTrace("从配置缓存获取 GearDefinition {Id}", id);
        return _configCache.GetGearDefinitionAsync(id);
    }
    
    public Task<List<GearDefinition>> GetBySlotAsync(EquipmentSlot slot, CancellationToken ct = default)
    {
        _logger.LogTrace("从配置缓存获取 GearDefinition by Slot {Slot}", slot);
        return _configCache.GetGearDefinitionsBySlotAsync(slot);
    }
    
    public Task<List<GearDefinition>> GetAllAsync(CancellationToken ct = default)
    {
        _logger.LogTrace("从配置缓存获取所有 GearDefinition");
        return _configCache.GetAllGearDefinitionsAsync();
    }
}
```

**关键点**：
- ✅ 移除 GameDbContext 依赖
- ✅ 完全使用配置缓存
- ✅ 几乎零数据库查询

### 5. AffixRepository 改造（2 小时）

```csharp
public class AffixRepository : IAffixRepository
{
    private readonly IConfigurationCacheService _configCache;
    private readonly ILogger<AffixRepository> _logger;
    
    public AffixRepository(
        IConfigurationCacheService configCache,
        ILogger<AffixRepository> logger)
    {
        _configCache = configCache;
        _logger = logger;
    }
    
    public Task<Affix?> GetByIdAsync(Guid id, CancellationToken ct = default)
    {
        return _configCache.GetAffixAsync(id);
    }
    
    public Task<List<Affix>> GetAllAsync(CancellationToken ct = default)
    {
        return _configCache.GetAllAffixesAsync();
    }
    
    public Task<List<Affix>> GetByRarityAsync(AffixRarity rarity, CancellationToken ct = default)
    {
        return _configCache.GetAffixesByRarityAsync(rarity);
    }
}
```

### 6. GearSetRepository 改造（2 小时）

```csharp
public class GearSetRepository : IGearSetRepository
{
    private readonly IConfigurationCacheService _configCache;
    private readonly ILogger<GearSetRepository> _logger;
    
    public GearSetRepository(
        IConfigurationCacheService configCache,
        ILogger<GearSetRepository> logger)
    {
        _configCache = configCache;
        _logger = logger;
    }
    
    public Task<GearSet?> GetByIdAsync(Guid id, CancellationToken ct = default)
    {
        return _configCache.GetGearSetAsync(id);
    }
    
    public Task<List<GearSet>> GetAllAsync(CancellationToken ct = default)
    {
        return _configCache.GetAllGearSetsAsync();
    }
}
```

---

## 查询优化

### 缓存键命名规范

**格式**：`{EntityType}:{Scope}:{Identifier}:{Filter}`

**示例**：
- `Character:Id:123e4567-e89b-12d3-a456-426614174000`
- `ActivityPlan:Character:123e4567:PendingOrRunning`
- `GearInstance:Character:123e4567:Equipped`
- `GearDefinition:Slot:Weapon`

### 常见查询模式优化

#### 模式 1：按单个 ID 查询

```csharp
// 使用 GetByIdAsync - 自动缓存
var entity = await _cacheManager.GetByIdAsync(id, ct);
```

#### 模式 2：按外键查询列表

```csharp
// 使用 GetListAsync - 缓存查询结果
var cacheKey = $"EntityType:ForeignKey:{foreignKeyId}";
var results = await _cacheManager.GetListAsync(
    e => e.ForeignKeyId == foreignKeyId,
    cacheKey,
    ct);
```

#### 模式 3：复杂条件查询

```csharp
// 组合缓存键
var cacheKey = $"EntityType:ComplexQuery:{param1}:{param2}";
var results = await _cacheManager.GetListAsync(
    e => e.Param1 == param1 && e.Param2 == param2,
    cacheKey,
    ct);
```

---

## 数据一致性保证

### 写入时同步更新缓存

**规则**：
1. 更新实体 → 更新单实体缓存
2. 更新实体 → 失效相关列表缓存

**示例**（ActivityPlanRepository.UpdateAsync）：

```csharp
public async Task UpdateAsync(ActivityPlan plan, CancellationToken ct = default)
{
    // 1. 更新内存状态（写入优化）
    _memoryStateManager.Update(plan);
    
    // 2. 同步更新读取缓存
    _cacheManager.AddOrUpdate(plan);
    
    // 3. 失效相关列表缓存
    var relatedCacheKeys = new[]
    {
        $"ActivityPlan:Character:{plan.CharacterId}:PendingOrRunning",
        $"ActivityPlan:Character:{plan.CharacterId}:All"
    };
    
    foreach (var key in relatedCacheKeys)
    {
        _cacheManager.InvalidateList(key);
    }
}
```

### 删除时清理缓存

```csharp
public async Task DeleteAsync(Guid id, CancellationToken ct = default)
{
    var plan = await GetAsync(id, ct);
    if (plan == null) return;
    
    // 1. 从内存状态移除
    _memoryStateManager.Remove(id);
    
    // 2. 从读取缓存移除
    _cacheManager.Invalidate(id);
    
    // 3. 失效相关列表缓存
    _cacheManager.InvalidateList($"ActivityPlan:Character:{plan.CharacterId}:PendingOrRunning");
}
```

---

## 测试验证

### 单元测试

#### CharacterRepository 测试

**文件路径**: `tests/BlazorIdle.Tests/Repositories/CharacterRepositoryTests.cs`

**测试用例**：
1. ✅ `GetAsync_WithCacheEnabled_UsesCache`
2. ✅ `GetAsync_WithCacheDisabled_QueriesDatabase`
3. ✅ `GetAsync_CacheMiss_LoadsFromDatabase`
4. ✅ `GetAsync_CacheHit_ReturnsFromCache`

#### ActivityPlanRepository 测试

**测试用例**：
1. ✅ `GetPendingOrRunningAsync_CachesResults`
2. ✅ `UpdateAsync_InvalidatesRelatedCaches`
3. ✅ `DeleteAsync_ClearsAllRelatedCaches`

#### GearDefinitionRepository 测试

**测试用例**：
1. ✅ `GetByIdAsync_ReturnsFromConfigCache`
2. ✅ `GetBySlotAsync_ReturnsFromConfigCache`
3. ✅ `GetAllAsync_NeverQueriesDatabase`

### 集成测试

#### 数据一致性测试

```csharp
[Fact]
public async Task UpdateEntity_ReadImmediately_ReturnsUpdatedData()
{
    // Arrange
    var character = await _repo.GetAsync(characterId);
    character.Name = "NewName";
    
    // Act
    await _repo.UpdateAsync(character);
    
    // Assert - 立即读取应该看到更新后的数据
    var updated = await _repo.GetAsync(characterId);
    Assert.Equal("NewName", updated.Name);
}
```

#### 缓存失效测试

```csharp
[Fact]
public async Task UpdatePlan_ListQuery_ReturnsUpdatedList()
{
    // Arrange
    var plans = await _repo.GetPendingOrRunningAsync(characterId);
    var count = plans.Count;
    
    // Act - 更新一个 plan 的状态
    var plan = plans.First();
    plan.Status = ActivityPlanStatus.Completed;
    await _repo.UpdateAsync(plan);
    
    // Assert - 列表查询应该反映变更
    var updatedPlans = await _repo.GetPendingOrRunningAsync(characterId);
    Assert.Equal(count - 1, updatedPlans.Count);
}
```

---

## 检查清单

### Phase 2 完成标准

#### 代码改造

- [ ] CharacterRepository 已改造并测试
- [ ] ActivityPlanRepository 已改造并测试
- [ ] GearInstanceRepository 已改造并测试
- [ ] GearDefinitionRepository 已改造并测试
- [ ] AffixRepository 已改造并测试
- [ ] GearSetRepository 已改造并测试

#### 功能验证

- [ ] 缓存优先读取正常工作
- [ ] Fallback 机制正常工作
- [ ] 写入时缓存同步更新
- [ ] 列表缓存失效机制正确
- [ ] 配置缓存零数据库查询

#### 性能验证

- [ ] 数据库读取减少 > 70%
- [ ] API 响应时间改善 > 30%
- [ ] 缓存命中率 > 80%
- [ ] 内存增长在预期范围内

#### 质量保证

- [ ] 单元测试覆盖率 > 80%
- [ ] 集成测试通过
- [ ] 数据一致性测试通过
- [ ] 并发测试通过
- [ ] 代码审查通过

---

## 下一步

Phase 2 完成后，进入 **Phase 3：监控与优化**（下篇），添加缓存监控、性能分析和优化调整。

---

**文档状态**：✅ Phase 2 实施方案完成  
**预计完成时间**：2-3 个工作日  
**最后更新**：2025-10-19
