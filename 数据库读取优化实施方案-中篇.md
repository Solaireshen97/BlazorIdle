# BlazorIdle 数据库读取优化实施方案 - 中篇

**阶段**: Phase 2 - 分阶段迁移读取操作  
**文档版本**: 1.0  
**创建日期**: 2025-10-18  
**工作量估算**: 4-6 天  
**前置条件**: Phase 1 (上篇) 已完成

---

## 📋 目录

1. [阶段目标](#阶段目标)
2. [迁移策略](#迁移策略)
3. [三个迁移阶段](#三个迁移阶段)
4. [详细实施步骤](#详细实施步骤)
5. [数据一致性保证](#数据一致性保证)
6. [测试验证](#测试验证)
7. [验收标准](#验收标准)

---

## 阶段目标

### 主要目标

**将现有数据库读取操作逐步迁移到缓存优先模式。**

具体目标：
1. ✅ 第一阶段：迁移静态配置数据（低风险）
2. ✅ 第二阶段：迁移用户核心数据（中风险）
3. ✅ 第三阶段：迁移活动和战斗数据（高风险）
4. ✅ 每个阶段独立测试和验证
5. ✅ 保证数据一致性

### 关键原则

1. **渐进式迁移**：从低风险到高风险，分阶段推进
2. **独立验证**：每个阶段完成后独立测试
3. **可回退**：通过配置开关快速回退
4. **保持接口**：不改变 Repository 接口定义
5. **数据一致性**：读写操作协同，确保数据最新

### 迁移优先级

| 阶段 | 实体类型 | 风险等级 | 缓存命中率预期 | 工作量 |
|-----|---------|---------|--------------|--------|
| 第一阶段 | GearDefinition, Affix, GearSet | 低 | 95-100% | 1-2天 |
| 第二阶段 | Character, GearInstance | 中 | 80-90% | 2-3天 |
| 第三阶段 | ActivityPlan, RunningBattleSnapshot | 高 | 70-85% | 1-2天 |

---

## 迁移策略

### 总体策略

```
┌─────────────────────────────────────────────┐
│  迁移阶段        │  实体类型                 │
├─────────────────────────────────────────────┤
│  第一阶段 (低风险) │ GearDefinition          │
│                  │ Affix                   │
│                  │ GearSet                 │
│                  │                         │
│  特点：          │ • 静态配置数据            │
│                  │ • 启动时预加载            │
│                  │ • 永久缓存                │
├─────────────────────────────────────────────┤
│  第二阶段 (中风险) │ Character               │
│                  │ GearInstance            │
│                  │                         │
│  特点：          │ • 用户核心数据            │
│                  │ • 临时缓存 + TTL          │
│                  │ • 读写频繁                │
├─────────────────────────────────────────────┤
│  第三阶段 (高风险) │ ActivityPlan            │
│                  │ RunningBattleSnapshot   │
│                  │                         │
│  特点：          │ • 活动和战斗数据          │
│                  │ • 临时缓存 + 短TTL        │
│                  │ • 已有写入优化            │
└─────────────────────────────────────────────┘
```

### 迁移模式

**模式 1：Repository 适配器模式**（推荐）

```csharp
// 在 Repository 中透明地使用缓存

public class GearDefinitionRepository : IGearDefinitionRepository
{
    private readonly GameDbContext _db;
    private readonly IMemoryStateManager<GearDefinition> _memoryManager;
    private readonly IConfiguration _configuration;
    
    public async Task<GearDefinition?> GetAsync(Guid id, CancellationToken ct = default)
    {
        // 检查是否启用读取缓存
        var enableCaching = _configuration.GetValue<bool>(
            "CacheConfiguration:GlobalSettings:EnableReadCaching", true);
        
        if (enableCaching && _memoryManager != null)
        {
            // 使用缓存
            return await _memoryManager.TryGetAsync(
                id,
                async (id, ct) => await _db.GearDefinitions
                    .FirstOrDefaultAsync(g => g.Id == id, ct),
                ct
            );
        }
        else
        {
            // 回退：直接查数据库
            return await _db.GearDefinitions
                .FirstOrDefaultAsync(g => g.Id == id, ct);
        }
    }
}
```

**优点**：
- ✅ 对调用方透明
- ✅ 易于回退
- ✅ 局部修改

**模式 2：Service 层缓存模式**（可选）

```csharp
// 在 Service 层使用缓存

public class EquipmentService
{
    public async Task<GearDefinition?> GetGearDefinitionAsync(Guid id)
    {
        // 显式使用缓存
        var cached = await _cacheManager.GetAsync<GearDefinition>(id);
        if (cached != null)
            return cached;
        
        var fromDb = await _repository.GetAsync(id);
        if (fromDb != null)
        {
            await _cacheManager.SetAsync(id, fromDb);
        }
        
        return fromDb;
    }
}
```

**选择**：本项目采用**模式 1 - Repository 适配器模式**

### 数据一致性策略

**策略 1：写入时同步更新内存**

```csharp
// Repository.UpdateAsync
public async Task UpdateAsync(GearInstance gear, CancellationToken ct = default)
{
    // 1. 更新 EF Core 跟踪的实体
    _db.GearInstances.Update(gear);
    
    // 2. 检查是否启用内存缓冲
    var enableMemoryBuffering = _configuration.GetValue<bool>(
        "Persistence:EnableMemoryBuffering", false);
    
    if (enableMemoryBuffering && _memoryManager != null)
    {
        // 3. 同步更新内存
        _memoryManager.Update(gear.Id, gear);
        // 不立即保存数据库，由 PersistenceCoordinator 批量保存
    }
    else
    {
        // 4. 回退：立即保存数据库
        await DatabaseRetryPolicy.SaveChangesWithRetryAsync(_db, ct);
    }
}
```

**策略 2：读取时确保最新**

```csharp
// MemoryStateManager.TryGetAsync
public async Task<T?> TryGetAsync(...)
{
    // 1. 查内存
    if (_store.TryGetValue(id, out var cached))
    {
        // 2. 检查是否 Dirty（有未保存的更新）
        if (_dirtyEntities.ContainsKey(id))
        {
            // 内存中的是最新的（尚未保存但已更新）
            return cached;
        }
        
        // 3. 非 Dirty，直接返回
        return cached;
    }
    
    // 4. 未命中，查数据库
    var entity = await databaseLoader(id, ct);
    if (entity != null)
    {
        _store.TryAdd(id, entity);
    }
    
    return entity;
}
```

---

## 三个迁移阶段

### 第一阶段：静态配置数据（1-2天）

#### 目标实体

1. **GearDefinition（装备定义）**
   - 静态配置，极少变化
   - 启动时预加载
   - 永久缓存

2. **Affix（词缀定义）**
   - 静态配置，不变化
   - 启动时预加载
   - 永久缓存

3. **GearSet（装备套装）**
   - 静态配置，不变化
   - 启动时预加载
   - 永久缓存

#### 迁移任务清单

##### Task 1: 迁移 GearDefinitionRepository
- [ ] 修改 GetAsync 方法使用缓存
- [ ] 修改 GetBySlotAsync 方法使用缓存
- [ ] 修改 GetAllAsync 方法使用缓存
- [ ] 添加配置开关
- [ ] 单元测试

##### Task 2: 迁移 AffixRepository
- [ ] 修改 GetAsync 方法使用缓存
- [ ] 修改 GetAllAsync 方法使用缓存
- [ ] 修改 GetByRarityAsync 方法使用缓存
- [ ] 添加配置开关
- [ ] 单元测试

##### Task 3: 迁移 GearSetRepository
- [ ] 修改 GetAsync 方法使用缓存
- [ ] 修改 GetAllAsync 方法使用缓存
- [ ] 添加配置开关
- [ ] 单元测试

##### Task 4: 测试验证
- [ ] 启动服务，验证预加载
- [ ] 测试查询性能（应该 <1ms）
- [ ] 验证缓存命中率（应该 100%）
- [ ] 集成测试

---

### 第二阶段：用户核心数据（2-3天）

#### 目标实体

1. **Character（角色）**
   - 用户核心数据
   - 临时缓存（TTL 1小时）
   - 读写频繁

2. **GearInstance（装备实例）**
   - 用户装备数据
   - 临时缓存（TTL 30分钟）
   - 包含关联查询（Definition, Affixes）

#### 特殊挑战

**挑战 1：复杂查询**

```csharp
// 当前查询包含 Include
var gear = await _db.GearInstances
    .Include(g => g.Definition)
    .Include(g => g.Affixes)
    .Where(g => g.CharacterId == characterId)
    .ToListAsync();
```

**解决方案**：分步缓存

```csharp
// 1. 先查 GearInstance（缓存）
var gearInstances = await GetGearInstancesByCharacterAsync(characterId);

// 2. 再查关联的 Definition 和 Affixes（也缓存）
foreach (var gear in gearInstances)
{
    gear.Definition = await _gearDefRepo.GetAsync(gear.DefinitionId);
    gear.Affixes = await GetAffixesForGearAsync(gear.Id);
}
```

**挑战 2：与写入优化协同**

角色和装备实例已在写入时使用 MemoryStateManager，需要确保读写使用同一份内存数据。

**解决方案**：读写共享 MemoryStateManager

```csharp
// 写入操作（已实现）
_memoryManager.Update(character.Id, character);

// 读取操作（新增）
var character = await _memoryManager.TryGetAsync(
    id,
    async (id, ct) => await _db.Characters.FirstOrDefaultAsync(...),
    ct
);
```

#### 迁移任务清单

##### Task 1: 迁移 CharacterRepository
- [ ] 修改 GetAsync 方法使用缓存
- [ ] 确保与写入操作共享内存
- [ ] 添加配置开关
- [ ] 单元测试

##### Task 2: 迁移 GearInstanceRepository
- [ ] 修改 GetAsync 方法使用缓存
- [ ] 修改 GetByCharacterIdAsync 处理关联查询
- [ ] 修改 GetEquippedBySlotAsync 使用缓存
- [ ] 确保与写入操作共享内存
- [ ] 添加配置开关
- [ ] 单元测试

##### Task 3: 处理关联查询
- [ ] 优化 Include 查询为分步缓存查询
- [ ] 确保关联数据也从缓存读取
- [ ] 性能测试

##### Task 4: 测试验证
- [ ] 测试读写一致性
- [ ] 测试缓存命中率（目标 80-90%）
- [ ] 压力测试（100 个在线用户）
- [ ] 集成测试

---

### 第三阶段：活动和战斗数据（1-2天）

#### 目标实体

1. **ActivityPlan（活动计划）**
   - 活动状态数据
   - 临时缓存（TTL 10分钟）
   - 已有写入优化

2. **RunningBattleSnapshotRecord（战斗快照）**
   - 战斗状态数据
   - 临时缓存（TTL 5分钟）
   - 已有写入优化

#### 特殊挑战

**挑战 1：频繁更新**

活动计划和战斗快照更新非常频繁（每 30-60 秒），需要确保缓存不会过时。

**解决方案**：写入时立即更新内存

```csharp
// 在 ActivityPlanRepository.UpdateAsync 中
public async Task UpdateAsync(ActivityPlan plan, CancellationToken ct = default)
{
    _db.ActivityPlans.Update(plan);
    
    if (_enableMemoryBuffering && _memoryManager != null)
    {
        // 立即更新内存（标记为 Dirty）
        _memoryManager.Update(plan.Id, plan);
        // 数据库保存由 PersistenceCoordinator 批量处理
    }
    else
    {
        await DatabaseRetryPolicy.SaveChangesWithRetryAsync(_db, ct);
    }
}

// 读取时从内存获取（总是最新）
public async Task<ActivityPlan?> GetAsync(Guid id, CancellationToken ct = default)
{
    if (_enableCaching && _memoryManager != null)
    {
        return await _memoryManager.TryGetAsync(
            id,
            async (id, ct) => await _db.ActivityPlans
                .FirstOrDefaultAsync(p => p.Id == id, ct),
            ct
        );
    }
    
    return await _db.ActivityPlans.FirstOrDefaultAsync(p => p.Id == id, ct);
}
```

#### 迁移任务清单

##### Task 1: 迁移 ActivityPlanRepository
- [ ] 修改 GetAsync 使用缓存
- [ ] 修改 GetByCharacterIdAsync 使用缓存
- [ ] 修改 GetRunningPlanAsync 使用缓存
- [ ] 确保读写共享内存
- [ ] 添加配置开关
- [ ] 单元测试

##### Task 2: 迁移战斗快照读取
- [ ] 修改 StepBattleSnapshotService.LoadAsync 使用缓存
- [ ] 确保与写入操作共享内存
- [ ] 测试战斗恢复功能
- [ ] 单元测试

##### Task 3: 测试验证
- [ ] 测试活动状态一致性
- [ ] 测试战斗快照恢复
- [ ] 压力测试（多个并发战斗）
- [ ] 集成测试

---

## 详细实施步骤

### 第一阶段实施（1-2天）

#### Step 1: 迁移 GearDefinitionRepository（2-3小时）

**文件**：`Infrastructure/Persistence/Repositories/GearDefinitionRepository.cs`

**当前代码**：
```csharp
public Task<GearDefinition?> GetAsync(Guid id, CancellationToken ct = default) =>
    _db.GearDefinitions.FirstOrDefaultAsync(g => g.Id == id, ct);
```

**修改为**：
```csharp
/// <summary>
/// 获取装备定义（使用缓存）
/// Get gear definition (with caching)
/// </summary>
public async Task<GearDefinition?> GetAsync(Guid id, CancellationToken ct = default)
{
    // 检查是否启用读取缓存
    var enableCaching = _configuration.GetValue<bool>(
        "CacheConfiguration:GlobalSettings:EnableReadCaching", true);
    
    if (enableCaching && _memoryManager != null)
    {
        // 使用缓存优先策略
        return await _memoryManager.TryGetAsync(
            id,
            async (id, ct) => await _db.GearDefinitions
                .FirstOrDefaultAsync(g => g.Id == id, ct),
            ct
        );
    }
    else
    {
        // 回退：直接查数据库
        _logger?.LogDebug(
            "读取缓存已禁用或 MemoryManager 未注册，直接查询数据库"
        );
        return await _db.GearDefinitions
            .FirstOrDefaultAsync(g => g.Id == id, ct);
    }
}
```

**修改构造函数**：
```csharp
private readonly GameDbContext _db;
private readonly IConfiguration _configuration;
private readonly IMemoryStateManager<GearDefinition>? _memoryManager;
private readonly ILogger<GearDefinitionRepository>? _logger;

public GearDefinitionRepository(
    GameDbContext db,
    IConfiguration configuration,
    IMemoryStateManager<GearDefinition>? memoryManager = null,
    ILogger<GearDefinitionRepository>? logger = null)
{
    _db = db;
    _configuration = configuration;
    _memoryManager = memoryManager;
    _logger = logger;
}
```

**修改 GetBySlotAsync**：
```csharp
public async Task<List<GearDefinition>> GetBySlotAsync(
    SlotType slot, 
    CancellationToken ct = default)
{
    var enableCaching = _configuration.GetValue<bool>(
        "CacheConfiguration:GlobalSettings:EnableReadCaching", true);
    
    if (enableCaching && _memoryManager != null)
    {
        // 从缓存中筛选
        var allCached = _memoryManager.GetAll();
        return allCached
            .Where(g => g.Slot == slot)
            .ToList();
    }
    else
    {
        // 直接查数据库
        return await _db.GearDefinitions
            .Where(g => g.Slot == slot)
            .ToListAsync(ct);
    }
}
```

**添加 GetAll 方法到 MemoryStateManager**：
```csharp
// 在 MemoryStateManager<T> 中添加：

/// <summary>
/// 获取所有缓存的实体
/// Get all cached entities
/// </summary>
public IEnumerable<T> GetAll()
{
    return _store.Values.ToList();
}
```

#### Step 2: 迁移 AffixRepository（1-2小时）

类似 GearDefinitionRepository 的修改模式。

#### Step 3: 迁移 GearSetRepository（1小时）

类似 GearDefinitionRepository 的修改模式。

#### Step 4: 第一阶段测试（2-3小时）

**测试 1: 预加载验证**

```csharp
[Fact]
public async Task GearDefinition_PreloadOnStartup_Success()
{
    // 启动服务
    var host = CreateTestHost();
    await host.StartAsync();
    
    // 等待预加载
    await Task.Delay(2000);
    
    // 验证
    var repo = host.Services.GetRequiredService<GearDefinitionRepository>();
    var allGear = await repo.GetAllAsync();
    
    Assert.True(allGear.Count > 0);
    
    // 验证缓存命中率
    var manager = host.Services.GetRequiredService<
        IMemoryStateManager<GearDefinition>>();
    var stats = manager.GetCacheStatistics();
    Assert.Equal(stats.CachedCount, allGear.Count);
    
    await host.StopAsync();
}
```

**测试 2: 缓存命中率测试**

```csharp
[Fact]
public async Task GearDefinition_GetAsync_CacheHitRate100Percent()
{
    var repo = CreateRepository();
    var id = Guid.NewGuid(); // 假设存在
    
    // 第一次查询：未命中，从数据库加载
    var gear1 = await repo.GetAsync(id);
    Assert.NotNull(gear1);
    
    // 第二次查询：应该命中缓存
    var gear2 = await repo.GetAsync(id);
    Assert.NotNull(gear2);
    
    // 验证命中率
    var manager = GetMemoryManager();
    var hitRate = manager.GetCacheHitRate();
    Assert.Equal(0.5, hitRate); // 1 hit, 1 miss = 50%
    
    // 第三次查询
    var gear3 = await repo.GetAsync(id);
    hitRate = manager.GetCacheHitRate();
    Assert.True(hitRate > 0.6); // 2 hit, 1 miss = 66.7%
}
```

**测试 3: 性能测试**

```csharp
[Fact]
public async Task GearDefinition_GetAsync_PerformanceUnder1ms()
{
    var repo = CreateRepository();
    var id = Guid.NewGuid();
    
    // 预热：加载到缓存
    await repo.GetAsync(id);
    
    // 性能测试
    var sw = Stopwatch.StartNew();
    for (int i = 0; i < 1000; i++)
    {
        await repo.GetAsync(id);
    }
    sw.Stop();
    
    var avgMs = sw.ElapsedMilliseconds / 1000.0;
    Assert.True(avgMs < 1.0, $"平均查询时间 {avgMs}ms 超过 1ms");
}
```

---

### 第二阶段实施（2-3天）

#### Step 1: 迁移 CharacterRepository（2-3小时）

**文件**：`Infrastructure/Persistence/Repositories/CharacterRepository.cs`

**当前代码**：
```csharp
public Task<Character?> GetAsync(Guid id, CancellationToken ct = default) =>
    _db.Characters.FirstOrDefaultAsync(c => c.Id == id, ct);
```

**修改为**：
```csharp
/// <summary>
/// 获取角色（使用缓存）
/// Get character (with caching)
/// </summary>
public async Task<Character?> GetAsync(Guid id, CancellationToken ct = default)
{
    var enableCaching = _configuration.GetValue<bool>(
        "CacheConfiguration:GlobalSettings:EnableReadCaching", true);
    
    if (enableCaching && _memoryManager != null)
    {
        // 注意：角色数据已在写入时使用 MemoryStateManager
        // 这里读取时也使用同一个 MemoryStateManager
        // 确保读写共享同一份内存数据
        return await _memoryManager.TryGetAsync(
            id,
            async (id, ct) => await _db.Characters
                .FirstOrDefaultAsync(c => c.Id == id, ct),
            ct
        );
    }
    else
    {
        return await _db.Characters
            .FirstOrDefaultAsync(c => c.Id == id, ct);
    }
}
```

**关键点**：
- ✅ 使用已存在的 `IMemoryStateManager<Character>`（写入优化时已注册）
- ✅ 读写共享同一份内存数据
- ✅ 确保数据一致性

#### Step 2: 迁移 GearInstanceRepository（4-6小时）

**挑战**：处理复杂的 Include 查询

**当前代码**：
```csharp
public async Task<List<GearInstance>> GetByCharacterIdAsync(
    Guid characterId, 
    CancellationToken ct = default)
{
    return await _db.GearInstances
        .Include(g => g.Definition)
        .Include(g => g.Affixes)
        .Where(g => g.CharacterId == characterId)
        .ToListAsync(ct);
}
```

**优化策略**：分步查询 + 缓存

**修改为**：
```csharp
/// <summary>
/// 获取角色的所有装备（优化：分步查询 + 缓存）
/// Get all gear instances for a character (optimized: step-by-step + caching)
/// </summary>
public async Task<List<GearInstance>> GetByCharacterIdAsync(
    Guid characterId, 
    CancellationToken ct = default)
{
    var enableCaching = _configuration.GetValue<bool>(
        "CacheConfiguration:GlobalSettings:EnableReadCaching", true);
    
    if (enableCaching && _memoryManager != null)
    {
        // 1. 查询所有装备实例（从缓存或数据库）
        var gearInstances = await GetGearInstancesFromCacheOrDbAsync(
            characterId, ct);
        
        // 2. 批量加载关联数据（Definition 和 Affixes）
        await LoadRelatedDataAsync(gearInstances, ct);
        
        return gearInstances;
    }
    else
    {
        // 回退：使用原有的 Include 查询
        return await _db.GearInstances
            .Include(g => g.Definition)
            .Include(g => g.Affixes)
            .Where(g => g.CharacterId == characterId)
            .ToListAsync(ct);
    }
}

/// <summary>
/// 从缓存或数据库获取装备实例
/// Get gear instances from cache or database
/// </summary>
private async Task<List<GearInstance>> GetGearInstancesFromCacheOrDbAsync(
    Guid characterId, 
    CancellationToken ct)
{
    // 尝试从缓存获取所有装备实例
    var allCached = _memoryManager!.GetAll();
    var cachedForCharacter = allCached
        .Where(g => g.CharacterId == characterId)
        .ToList();
    
    if (cachedForCharacter.Any())
    {
        // 命中缓存
        return cachedForCharacter;
    }
    
    // 未命中：从数据库加载
    var fromDb = await _db.GearInstances
        .Where(g => g.CharacterId == characterId)
        .ToListAsync(ct);
    
    // 加载到缓存
    foreach (var gear in fromDb)
    {
        _memoryManager.Add(gear);
    }
    
    return fromDb;
}

/// <summary>
/// 加载关联数据（Definition 和 Affixes）
/// Load related data (Definition and Affixes)
/// </summary>
private async Task LoadRelatedDataAsync(
    List<GearInstance> gearInstances, 
    CancellationToken ct)
{
    // 加载 Definition（从 GearDefinition 缓存）
    var gearDefRepo = _serviceProvider.GetRequiredService<
        IGearDefinitionRepository>();
    
    foreach (var gear in gearInstances)
    {
        if (gear.DefinitionId != Guid.Empty)
        {
            gear.Definition = await gearDefRepo.GetAsync(
                gear.DefinitionId, ct);
        }
    }
    
    // 加载 Affixes（从 Affix 缓存）
    var affixRepo = _serviceProvider.GetRequiredService<
        IAffixRepository>();
    
    // TODO: 实现 Affix 关联加载
    // 需要一个映射表：GearInstance -> Affixes
}
```

**注意**：
- ⚠️ 需要处理 Affix 的多对多关系
- ⚠️ 可能需要缓存关联表（GearInstanceAffixes）

#### Step 3: 第二阶段测试（3-4小时）

**测试 1: 读写一致性测试**

```csharp
[Fact]
public async Task Character_ReadWriteConsistency()
{
    var repo = CreateRepository();
    var character = new Character 
    { 
        Id = Guid.NewGuid(), 
        Name = "TestChar",
        Level = 10
    };
    
    // 写入（应该更新内存）
    await repo.AddAsync(character);
    
    // 立即读取（应该从内存读到最新数据）
    var retrieved = await repo.GetAsync(character.Id);
    
    Assert.NotNull(retrieved);
    Assert.Equal(character.Name, retrieved.Name);
    Assert.Equal(character.Level, retrieved.Level);
    
    // 更新
    character.Level = 20;
    await repo.UpdateAsync(character);
    
    // 再次读取（应该读到更新后的数据）
    var updated = await repo.GetAsync(character.Id);
    Assert.Equal(20, updated.Level);
}
```

**测试 2: 缓存命中率测试**

```csharp
[Fact]
public async Task Character_CacheHitRate_Above80Percent()
{
    var repo = CreateRepository();
    var characterId = Guid.NewGuid();
    
    // 模拟 100 次查询
    for (int i = 0; i < 100; i++)
    {
        await repo.GetAsync(characterId);
    }
    
    // 验证命中率
    var manager = GetMemoryManager();
    var hitRate = manager.GetCacheHitRate();
    
    Assert.True(hitRate >= 0.8, 
        $"缓存命中率 {hitRate:P} 低于 80%");
}
```

---

### 第三阶段实施（1-2天）

#### Step 1: 迁移 ActivityPlanRepository（2-3小时）

**文件**：`Infrastructure/Persistence/Repositories/ActivityPlanRepository.cs`

**关键点**：
- ✅ 活动计划已在写入时使用 MemoryStateManager
- ✅ 读取时也使用同一个 MemoryStateManager
- ✅ 确保频繁更新的数据读到最新

**修改 GetAsync**：
```csharp
public async Task<ActivityPlan?> GetAsync(Guid id, CancellationToken ct = default)
{
    var enableCaching = _configuration.GetValue<bool>(
        "CacheConfiguration:GlobalSettings:EnableReadCaching", true);
    
    if (enableCaching && _memoryStateManager != null)
    {
        // 使用已有的 MemoryStateManager（写入优化时已注册）
        return await _memoryStateManager.TryGetAsync(
            id,
            async (id, ct) => await _db.ActivityPlans
                .FirstOrDefaultAsync(p => p.Id == id, ct),
            ct
        );
    }
    else
    {
        return await _db.ActivityPlans
            .FirstOrDefaultAsync(p => p.Id == id, ct);
    }
}
```

**修改 GetByCharacterIdAsync**：
```csharp
public async Task<List<ActivityPlan>> GetByCharacterIdAsync(
    Guid characterId, 
    CancellationToken ct = default)
{
    var enableCaching = _configuration.GetValue<bool>(
        "CacheConfiguration:GlobalSettings:EnableReadCaching", true);
    
    if (enableCaching && _memoryStateManager != null)
    {
        // 从缓存筛选
        var allCached = _memoryStateManager.GetAll();
        return allCached
            .Where(p => p.CharacterId == characterId)
            .ToList();
    }
    else
    {
        return await _db.ActivityPlans
            .Where(p => p.CharacterId == characterId)
            .ToListAsync(ct);
    }
}
```

#### Step 2: 迁移战斗快照读取（1-2小时）

**文件**：`Application/Battles/Step/StepBattleSnapshotService.cs`

**当前代码**：
```csharp
public async Task<RunningBattleSnapshotRecord?> LoadAsync(
    Guid characterId, 
    CancellationToken ct = default)
{
    return await _db.RunningBattleSnapshots
        .FirstOrDefaultAsync(s => s.CharacterId == characterId, ct);
}
```

**修改为**：
```csharp
public async Task<RunningBattleSnapshotRecord?> LoadAsync(
    Guid characterId, 
    CancellationToken ct = default)
{
    var enableCaching = _configuration.GetValue<bool>(
        "CacheConfiguration:GlobalSettings:EnableReadCaching", true);
    
    if (enableCaching && _snapshotManager != null)
    {
        // 从缓存查找
        var allCached = _snapshotManager.GetAll();
        var cached = allCached
            .FirstOrDefault(s => s.CharacterId == characterId);
        
        if (cached != null)
        {
            _logger?.LogDebug(
                "战斗快照缓存命中: CharacterId={CharacterId}",
                characterId
            );
            return cached;
        }
        
        // 未命中：查数据库并加载到缓存
        var fromDb = await _db.RunningBattleSnapshots
            .FirstOrDefaultAsync(s => s.CharacterId == characterId, ct);
        
        if (fromDb != null)
        {
            _snapshotManager.Add(fromDb);
        }
        
        return fromDb;
    }
    else
    {
        return await _db.RunningBattleSnapshots
            .FirstOrDefaultAsync(s => s.CharacterId == characterId, ct);
    }
}
```

#### Step 3: 第三阶段测试（2-3小时）

**测试 1: 活动状态一致性测试**

```csharp
[Fact]
public async Task ActivityPlan_StateUpdateConsistency()
{
    var repo = CreateRepository();
    var plan = new ActivityPlan
    {
        Id = Guid.NewGuid(),
        CharacterId = Guid.NewGuid(),
        State = ActivityPlanState.Pending
    };
    
    // 添加
    await repo.AddAsync(plan);
    
    // 更新状态
    plan.State = ActivityPlanState.Running;
    await repo.UpdateAsync(plan);
    
    // 读取（应该是最新状态）
    var retrieved = await repo.GetAsync(plan.Id);
    Assert.Equal(ActivityPlanState.Running, retrieved.State);
}
```

**测试 2: 战斗快照恢复测试**

```csharp
[Fact]
public async Task BattleSnapshot_LoadAndRestore()
{
    var service = CreateSnapshotService();
    var characterId = Guid.NewGuid();
    
    // 保存快照
    var snapshot = new RunningBattleSnapshotRecord
    {
        CharacterId = characterId,
        // ... 其他字段
    };
    await service.SaveAsync(snapshot);
    
    // 加载快照（应该从缓存读取）
    var loaded = await service.LoadAsync(characterId);
    
    Assert.NotNull(loaded);
    Assert.Equal(characterId, loaded.CharacterId);
}
```

---

## 数据一致性保证

### 一致性检查清单

- [ ] **写入时同步更新内存**：所有 Repository 的 UpdateAsync 方法都同步更新 MemoryStateManager
- [ ] **读取时优先内存**：所有 Repository 的 GetAsync 方法都优先查内存
- [ ] **Dirty 数据优先**：MemoryStateManager 返回未保存的最新数据
- [ ] **批量保存不影响读取**：PersistenceCoordinator 保存时，内存数据已是最新
- [ ] **测试覆盖**：每个迁移的实体都有读写一致性测试

### 一致性测试模板

```csharp
[Fact]
public async Task EntityType_ReadWriteConsistency_Template()
{
    // 1. 写入新数据
    var entity = CreateTestEntity();
    await repo.AddAsync(entity);
    
    // 2. 立即读取（验证写入成功）
    var retrieved = await repo.GetAsync(entity.Id);
    Assert.NotNull(retrieved);
    AssertEqual(entity, retrieved);
    
    // 3. 更新数据
    UpdateEntity(entity);
    await repo.UpdateAsync(entity);
    
    // 4. 再次读取（验证更新成功）
    var updated = await repo.GetAsync(entity.Id);
    AssertEqual(entity, updated);
    
    // 5. 触发批量保存（模拟 PersistenceCoordinator）
    await TriggerBatchSaveAsync();
    
    // 6. 清空缓存（模拟服务重启）
    ClearCache();
    
    // 7. 从数据库读取（验证已保存）
    var fromDb = await repo.GetAsync(entity.Id);
    AssertEqual(entity, fromDb);
}
```

---

## 测试验证

### 综合测试计划

#### 功能测试

1. **缓存读取功能测试**
   - [ ] 首次查询从数据库加载
   - [ ] 二次查询从缓存读取
   - [ ] 缓存命中率统计正确

2. **读写一致性测试**
   - [ ] 写入后立即读取到最新数据
   - [ ] 更新后立即读取到更新数据
   - [ ] 批量保存不影响一致性

3. **关联查询测试**
   - [ ] Include 查询正确加载关联数据
   - [ ] 关联数据也从缓存读取
   - [ ] 性能不降低

#### 性能测试

1. **响应时间测试**
   - [ ] 缓存命中：<1ms
   - [ ] 缓存未命中：5-50ms（数据库查询）

2. **吞吐量测试**
   - [ ] 100 并发请求/秒
   - [ ] 内存使用稳定

3. **缓存命中率测试**
   - [ ] 静态数据：95-100%
   - [ ] 用户数据：80-90%
   - [ ] 活动数据：70-85%

#### 压力测试

1. **高负载测试**
   - [ ] 100 个在线用户
   - [ ] 持续运行 1 小时
   - [ ] 无内存泄漏

2. **并发测试**
   - [ ] 10 个并发战斗
   - [ ] 无数据竞争
   - [ ] 无死锁

---

## 验收标准

### 功能完整性

- [ ] 第一阶段：3 个 Repository 迁移完成（GearDefinition, Affix, GearSet）
- [ ] 第二阶段：2 个 Repository 迁移完成（Character, GearInstance）
- [ ] 第三阶段：2 个模块迁移完成（ActivityPlan, BattleSnapshot）
- [ ] 所有迁移保留配置开关（可回退）
- [ ] 所有迁移不改变 Repository 接口

### 性能指标

- [ ] 缓存命中率：静态数据 >95%, 用户数据 >80%, 活动数据 >70%
- [ ] 数据库读取减少 >85%
- [ ] API 响应时间改善 >30%
- [ ] 内存增加 <200MB

### 代码质量

- [ ] 编译成功，零错误
- [ ] 所有代码有详细注释
- [ ] 遵循项目命名规范
- [ ] 通过代码审查

### 测试覆盖

- [ ] 每个迁移的实体有单元测试（至少 3 个测试）
- [ ] 读写一致性测试（每个实体 1 个）
- [ ] 性能测试（每个阶段 1 个）
- [ ] 压力测试（整体 1 个）
- [ ] 所有测试通过

### 文档完整性

- [ ] 本实施方案文档
- [ ] 代码注释完整
- [ ] 测试文档
- [ ] 回退流程文档

---

## 风险和回退计划

### 回退机制

**配置回退**：
```json
{
  "CacheConfiguration": {
    "GlobalSettings": {
      "EnableReadCaching": false  // 设为 false 立即回退
    }
  }
}
```

**代码回退**：
```csharp
// Repository 中都保留了回退逻辑
if (enableCaching && _memoryManager != null)
{
    // 使用缓存
}
else
{
    // 回退：直接查数据库
}
```

### 问题处理流程

1. **发现问题** → 评估严重程度
2. **严重问题**（数据不一致、功能异常）→ 立即配置回退
3. **轻微问题**（性能不达标）→ 调整配置参数
4. **修复代码** → 测试验证 → 重新部署

---

## 后续步骤

完成 Phase 2 后，进入 **下篇 - 优化、监控和验收**。

---

**阶段状态**：⏳ 待实施  
**预计完成时间**：4-6 天  
**责任人**：开发团队  
**最后更新**：2025-10-18
