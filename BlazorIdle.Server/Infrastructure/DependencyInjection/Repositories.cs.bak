using BlazorIdle.Server.Application.Abstractions;
using BlazorIdle.Server.Infrastructure.Persistence.Repositories;
using Microsoft.Extensions.DependencyInjection;

namespace BlazorIdle.Server.Infrastructure;

/// <summary>
/// 仓储（Repository）实现的集中注册扩展。
/// 目的：把所有“数据访问实现”在一个地方统一注入到 DI 容器，
/// 避免在 Program.cs 里到处写 AddScoped。
/// </summary>
public static class RepositoryRegistration
{
    /// <summary>
    /// 向 IServiceCollection 注册仓储实现。
    /// 调用位置：Program.cs -> services.AddRepositories()
    /// 返回自身以便链式调用（Fluent API）。
    /// </summary>
    public static IServiceCollection AddRepositories(this IServiceCollection services)
    {
        // AddScoped：每个 HTTP 请求创建一个实例（与 DbContext 生命周期匹配）。
        // IBattleRepository -> BattleRepository:
        //   * 负责战斗记录(BattleRecord + Segments)的持久化与读取（含 Include Segments）。
        services.AddScoped<IBattleRepository, BattleRepository>();

        // ICharacterRepository -> CharacterRepository:
        //   * 封装获取角色（Character）的数据访问。保持上层不用直接依赖 DbContext。
        services.AddScoped<ICharacterRepository, CharacterRepository>();

        // IActivityPlanRepository -> ActivityPlanRepository:
        //   * 封装活动计划（ActivityPlan）的持久化与读取。
        services.AddScoped<IActivityPlanRepository, ActivityPlanRepository>();

        // 装备系统仓储
        services.AddScoped<IGearDefinitionRepository, GearDefinitionRepository>();
        services.AddScoped<IGearInstanceRepository, GearInstanceRepository>();
        services.AddScoped<IAffixRepository, AffixRepository>();
        services.AddScoped<IGearSetRepository, GearSetRepository>();

        return services;
    }
}
    /// <summary>
    /// 注册缓存感知的仓储装饰器
    /// Register cache-aware repository decorators
    /// 
    /// 通过装饰器模式，在不修改原有Repository的情况下添加缓存功能
    /// Uses decorator pattern to add caching without modifying original repositories
    /// </summary>
    /// <param name="services">服务集合</param>
    /// <param name="configuration">配置对象</param>
    public static IServiceCollection AddCacheAwareRepositories(this IServiceCollection services, IConfiguration configuration)
    {
        // 检查是否启用读缓存
        // Check if read cache is enabled
        var enableReadCache = configuration.GetValue<bool>("ReadCache:EnableReadCache", false);
        
        if (!enableReadCache)
        {
            // 如果未启用，直接返回，使用原有的仓储实现
            // If not enabled, return directly, using original repository implementations
            return services;
        }
        
        // === CharacterRepository 缓存装饰器 ===
        // CharacterRepository cache decorator
        
        // 1. 先移除原有的 ICharacterRepository 注册
        // First remove the original ICharacterRepository registration
        var characterRepoDescriptor = services.FirstOrDefault(d => d.ServiceType == typeof(ICharacterRepository));
        if (characterRepoDescriptor != null)
        {
            services.Remove(characterRepoDescriptor);
        }
        
        // 2. 注册原始仓储为具体类型（不通过接口）
        // Register original repository as concrete type (not through interface)
        services.AddScoped<CharacterRepository>();
        
        // 3. 注册缓存装饰器，将原始仓储注入其中
        // Register cache decorator, injecting original repository
        services.AddScoped<ICharacterRepository>(sp =>
        {
            var innerRepo = sp.GetRequiredService<CharacterRepository>();
            var cacheManager = sp.GetRequiredService<IMultiTierCacheManager>();
            var invalidationCoordinator = sp.GetRequiredService<ICacheInvalidationCoordinator>();
            var cacheOptions = sp.GetRequiredService<IOptions<ReadCacheOptions>>();
            var logger = sp.GetRequiredService<ILogger<CacheAwareCharacterRepository>>();
            
            return new CacheAwareCharacterRepository(
                innerRepo,
                cacheManager,
                invalidationCoordinator,
                cacheOptions,
                logger
            );
        });
        
        return services;
    }
}
