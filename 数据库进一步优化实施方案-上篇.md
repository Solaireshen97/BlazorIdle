# BlazorIdle æ•°æ®åº“è¿›ä¸€æ­¥ä¼˜åŒ–å®æ–½æ–¹æ¡ˆ - ä¸Šç¯‡

**é¡¹ç›®åç§°**: BlazorIdle æ•°æ®åº“è¿›ä¸€æ­¥ä¼˜åŒ–  
**æ–¹æ¡ˆç‰ˆæœ¬**: 1.0  
**ç¼–åˆ¶æ—¥æœŸ**: 2025-10-19  
**é€‚ç”¨èŒƒå›´**: Phase 4-6 (æ¨èå®æ–½éƒ¨åˆ†)

---

## ğŸ“‹ æ–‡æ¡£è¯´æ˜

æœ¬æ–‡æ¡£æ˜¯ã€Šæ•°æ®åº“æ“ä½œæ·±åº¦åˆ†ææŠ¥å‘Šã€‹çš„é…å¥—å®æ–½æ–¹æ¡ˆï¼Œåˆ†ä¸ºä¸Šä¸­ä¸‹ä¸‰ç¯‡ï¼š
- **ä¸Šç¯‡ (æœ¬æ–‡æ¡£)**: Phase 4 - æŸ¥è¯¢ä¼˜åŒ–ä¸ç´¢å¼•å¢å¼º
- **ä¸­ç¯‡**: Phase 5 - æ™ºèƒ½é¢„åŠ è½½ä¸ç¼“å­˜é¢„çƒ­
- **ä¸‹ç¯‡**: Phase 6 - å®æ—¶ç›‘æ§ä¸å¯è§†åŒ–

**é‡è¦æç¤º**: 
- å½“å‰ç³»ç»Ÿå·²è¾¾å“è¶Šæ°´å¹³ (94.9% I/O å‡å°‘)
- æœ¬æ–¹æ¡ˆä¸º**å¯é€‰å¢å¼º**ï¼Œéå¿…é¡»
- å»ºè®®å…ˆå®æ–½ç›‘æ§ (ä¸‹ç¯‡)ï¼ŒåŸºäºæ•°æ®å†³ç­–æ˜¯å¦éœ€è¦è¿›ä¸€æ­¥ä¼˜åŒ–

---

## ğŸ¯ Phase 4: æŸ¥è¯¢ä¼˜åŒ–ä¸ç´¢å¼•å¢å¼º

### ç›®æ ‡ä¸é¢„æœŸæ•ˆæœ

**ä¼˜åŒ–ç›®æ ‡**:
1. æ¶ˆé™¤ N+1 æŸ¥è¯¢é—®é¢˜
2. ä¼˜åŒ–æ•°æ®åº“ç´¢å¼•
3. å®ç°æ‰¹é‡æŸ¥è¯¢æ¥å£
4. ä½¿ç”¨æŠ•å½±ä¼˜åŒ–å‡å°‘æ•°æ®ä¼ è¾“

**é¢„æœŸæ•ˆæœ**:
- âœ… æ¶ˆé™¤ 90% çš„ N+1 æŸ¥è¯¢
- âœ… æŸ¥è¯¢å“åº”æ—¶é—´å‡å°‘ 50-70%
- âœ… æ•°æ®åº“ CPU ä½¿ç”¨ç‡é™ä½ 30%
- âœ… ç½‘ç»œä¼ è¾“é‡å‡å°‘ 40%

**ä¼˜å…ˆçº§**: â­â­â­â­ (é«˜ä¼˜å…ˆçº§)

**å·¥æ—¶ä¼°ç®—**: 15-20 äººæ—¥

**é£é™©çº§åˆ«**: ä½-ä¸­

---

## ğŸ“Š é˜¶æ®µè§„åˆ’

### æ€»ä½“åˆ†ä¸º 5 ä¸ªå­é˜¶æ®µ

| é˜¶æ®µ | ä»»åŠ¡ | å·¥æ—¶ | é£é™© | ä¼˜å…ˆçº§ |
|------|------|------|------|--------|
| 4.1 | ä»£ç å®¡æŸ¥ä¸ N+1 æ£€æµ‹ | 3-4 å¤© | ä½ | P0 |
| 4.2 | æ‰¹é‡æŸ¥è¯¢æ¥å£å®ç° | 3-4 å¤© | ä½ | P0 |
| 4.3 | Include ä¸ Eager Loading ä¼˜åŒ– | 3-4 å¤© | ä¸­ | P0 |
| 4.4 | æ•°æ®åº“ç´¢å¼•åˆ†æä¸ä¼˜åŒ– | 4-5 å¤© | ä¸­ | P1 |
| 4.5 | æŠ•å½±ä¼˜åŒ–ä¸ DTO è®¾è®¡ | 3-4 å¤© | ä½ | P1 |

**æ€»å·¥æ—¶**: 16-21 å¤©

---

## ğŸ” é˜¶æ®µ 4.1: ä»£ç å®¡æŸ¥ä¸ N+1 æ£€æµ‹

### 4.1.1 ç›®æ ‡

è¯†åˆ«ç°æœ‰ä»£ç ä¸­çš„ N+1 æŸ¥è¯¢é—®é¢˜å’Œæ€§èƒ½ç“¶é¢ˆ

### 4.1.2 ä»»åŠ¡æ¸…å•

- [ ] **ä»»åŠ¡ 4.1.1**: é…ç½® EF Core æŸ¥è¯¢æ—¥å¿—
- [ ] **ä»»åŠ¡ 4.1.2**: å®‰è£…å’Œé…ç½® MiniProfiler
- [ ] **ä»»åŠ¡ 4.1.3**: å®¡æŸ¥æ‰€æœ‰ Repository å®ç°
- [ ] **ä»»åŠ¡ 4.1.4**: å®¡æŸ¥æ‰€æœ‰ Service å®ç°
- [ ] **ä»»åŠ¡ 4.1.5**: ç¼–åˆ¶ N+1 é—®é¢˜æ¸…å•
- [ ] **ä»»åŠ¡ 4.1.6**: ç¼–åˆ¶æ…¢æŸ¥è¯¢æ¸…å•

### 4.1.3 è¯¦ç»†å®æ–½æ­¥éª¤

#### æ­¥éª¤ 1: é…ç½® EF Core æŸ¥è¯¢æ—¥å¿—

**æ–‡ä»¶**: `appsettings.Development.json`

```json
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.EntityFrameworkCore.Database.Command": "Information",
      "Microsoft.EntityFrameworkCore.Query": "Warning"
    }
  },
  "QueryOptimization": {
    "EnableQueryLogging": true,
    "LogSlowQueries": true,
    "SlowQueryThresholdMs": 100,
    "EnableDetailedQueryLogging": true
  }
}
```

**æ–‡ä»¶**: `BlazorIdle.Server/Infrastructure/Persistence/GameDbContext.cs`

```csharp
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Diagnostics;
using Microsoft.Extensions.Logging;

namespace BlazorIdle.Server.Infrastructure.Persistence;

public class GameDbContext : DbContext
{
    private readonly ILogger<GameDbContext> _logger;
    private readonly IConfiguration _configuration;
    
    public GameDbContext(
        DbContextOptions<GameDbContext> options,
        ILogger<GameDbContext> logger,
        IConfiguration configuration) 
        : base(options)
    {
        _logger = logger;
        _configuration = configuration;
    }
    
    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
    {
        base.OnConfiguring(optionsBuilder);
        
        // é…ç½®æŸ¥è¯¢æ—¥å¿—
        var enableLogging = _configuration.GetValue<bool>(
            "QueryOptimization:EnableQueryLogging", false);
        
        if (enableLogging)
        {
            var slowQueryThreshold = _configuration.GetValue<int>(
                "QueryOptimization:SlowQueryThresholdMs", 100);
            
            optionsBuilder
                .LogTo(
                    message => _logger.LogInformation("EF Core: {Message}", message),
                    new[] { DbLoggerCategory.Database.Command.Name })
                .EnableSensitiveDataLogging()
                .EnableDetailedErrors();
            
            // æ…¢æŸ¥è¯¢è­¦å‘Š
            optionsBuilder.ConfigureWarnings(warnings =>
            {
                warnings.Log((RelationalEventId.CommandExecuted, LogLevel.Warning));
            });
        }
    }
    
    // ... å®ä½“é…ç½®
}
```

**éªŒè¯**:
```bash
# å¯åŠ¨åº”ç”¨ï¼Œè§‚å¯Ÿæ—¥å¿—
dotnet run --project BlazorIdle.Server

# åº”è¯¥çœ‹åˆ°ç±»ä¼¼è¾“å‡ºï¼š
# info: Microsoft.EntityFrameworkCore.Database.Command[20101]
#       Executed DbCommand (3ms) [Parameters=[@__id_0='?' (DbType = Guid)], CommandType='Text', CommandTimeout='30']
#       SELECT "c"."Id", "c"."Name", "c"."Level" ...
```

#### æ­¥éª¤ 2: å®‰è£…å’Œé…ç½® MiniProfiler

**æ–‡ä»¶**: `BlazorIdle.Server/BlazorIdle.Server.csproj`

```xml
<ItemGroup>
  <PackageReference Include="MiniProfiler.AspNetCore.Mvc" Version="4.3.8" />
  <PackageReference Include="MiniProfiler.EntityFrameworkCore" Version="4.3.8" />
</ItemGroup>
```

**æ–‡ä»¶**: `BlazorIdle.Server/Program.cs`

```csharp
// æ·»åŠ  MiniProfiler æœåŠ¡
builder.Services.AddMiniProfiler(options =>
{
    options.RouteBasePath = "/profiler";
    
    // ä»…åœ¨å¼€å‘ç¯å¢ƒå¯ç”¨
    options.EnableDebugMode = builder.Environment.IsDevelopment();
    
    // é…ç½®å­˜å‚¨
    options.Storage = new MemoryCacheStorage(
        new MemoryCacheStorageOptions
        {
            CacheDuration = TimeSpan.FromMinutes(60)
        });
    
    // SQL æŸ¥è¯¢æ ¼å¼åŒ–
    options.SqlFormatter = new StackExchange.Profiling.SqlFormatters.InlineFormatter();
}).AddEntityFramework();

// ... åœ¨ app æ„å»ºå
app.UseMiniProfiler();
```

**è®¿é—® MiniProfiler UI**:
```
http://localhost:5000/profiler/results-index
```

**éªŒè¯**:
```bash
# 1. å¯åŠ¨åº”ç”¨
dotnet run --project BlazorIdle.Server

# 2. æ‰“å¼€æµè§ˆå™¨è®¿é—®
http://localhost:5000/profiler/results-index

# 3. æ‰§è¡Œä¸€äº› API è°ƒç”¨
curl http://localhost:5000/api/characters/{guid}

# 4. æŸ¥çœ‹ MiniProfiler ç»“æœ
# åº”è¯¥çœ‹åˆ° SQL æŸ¥è¯¢è¯¦æƒ…ã€æ‰§è¡Œæ—¶é—´ã€N+1 è­¦å‘Šç­‰
```

#### æ­¥éª¤ 3: å®¡æŸ¥æ‰€æœ‰ Repository å®ç°

**åˆ›å»ºå®¡æŸ¥æ£€æŸ¥æ¸…å•**:

**æ–‡ä»¶**: `/docs/query-optimization/repository-review-checklist.md`

```markdown
# Repository ä»£ç å®¡æŸ¥æ£€æŸ¥æ¸…å•

## å®¡æŸ¥å¯¹è±¡
- [ ] CharacterRepository
- [ ] GearDefinitionRepository
- [ ] AffixRepository
- [ ] GearSetRepository
- [ ] GearInstanceRepository
- [ ] ActivityPlanRepository
- [ ] BattleRepository

## æ£€æŸ¥é¡¹

### 1. N+1 æŸ¥è¯¢æ£€æµ‹
- [ ] æ˜¯å¦å­˜åœ¨å¾ªç¯ä¸­çš„å•æ¬¡æŸ¥è¯¢ï¼Ÿ
- [ ] æ˜¯å¦å­˜åœ¨å¯¼èˆªå±æ€§æ‡’åŠ è½½ï¼Ÿ
- [ ] æ˜¯å¦éœ€è¦ Include æˆ– ThenIncludeï¼Ÿ

### 2. æŸ¥è¯¢æ•ˆç‡
- [ ] æ˜¯å¦åŠ è½½äº†ä¸å¿…è¦çš„å­—æ®µï¼Ÿ
- [ ] æ˜¯å¦å¯ä»¥ä½¿ç”¨æŠ•å½± (Select)?
- [ ] æ˜¯å¦å¯ä»¥ä½¿ç”¨ AsNoTrackingï¼Ÿ

### 3. æ‰¹é‡æ“ä½œ
- [ ] æ˜¯å¦éœ€è¦æ‰¹é‡æŸ¥è¯¢æ¥å£ï¼Ÿ
- [ ] æ˜¯å¦å­˜åœ¨é€ä¸ªæ“ä½œå¯ä»¥æ‰¹é‡åŒ–çš„åœºæ™¯ï¼Ÿ

## å‘ç°é—®é¢˜è®°å½•

### CharacterRepository

**é—®é¢˜ 1**: [æè¿°]
- **ä½ç½®**: `GetAsync` æ–¹æ³•
- **ç±»å‹**: N+1 æŸ¥è¯¢
- **å½±å“**: é«˜
- **å»ºè®®**: ä½¿ç”¨ Include åŠ è½½ EquipmentSlots

**é—®é¢˜ 2**: [æè¿°]
...
```

**å®¡æŸ¥ç¤ºä¾‹ - CharacterRepository**:

```csharp
// å½“å‰å®ç° (éœ€å®¡æŸ¥)
public async Task<Character?> GetAsync(Guid id, CancellationToken ct = default)
{
    var enableCaching = _configuration.GetValue<bool>(
        "CacheConfiguration:GlobalSettings:EnableReadCaching", true);
    
    if (enableCaching && _memoryManager != null)
    {
        return await _memoryManager.TryGetAsync(
            id,
            async (id, ct) => await _db.Characters
                .FirstOrDefaultAsync(c => c.Id == id, ct),
            ct
        );
    }
    else
    {
        return await _db.Characters
            .FirstOrDefaultAsync(c => c.Id == id, ct);
    }
}

// æ½œåœ¨é—®é¢˜ï¼š
// 1. å¦‚æœåç»­ä»£ç è®¿é—® character.EquipmentSlotsï¼Œä¼šè§¦å‘ N+1
// 2. å¦‚æœåç»­ä»£ç è®¿é—® character.ActivityPlansï¼Œä¼šè§¦å‘ N+1
```

**æ”¹è¿›å»ºè®®**:
```csharp
// æ–°å¢æ–¹æ³•ï¼šå¸¦å…³è”æ•°æ®çš„æŸ¥è¯¢
public async Task<Character?> GetWithEquipmentAsync(
    Guid id, 
    CancellationToken ct = default)
{
    var enableCaching = _configuration.GetValue<bool>(
        "CacheConfiguration:GlobalSettings:EnableReadCaching", true);
    
    if (enableCaching && _memoryManager != null)
    {
        // TODO: ç¼“å­˜å±‚éœ€è¦æ”¯æŒ Include
        // æš‚æ—¶å›é€€åˆ°ç›´æ¥æŸ¥è¯¢
        return await _db.Characters
            .Include(c => c.EquipmentSlots)
            .ThenInclude(s => s.Gear)
            .FirstOrDefaultAsync(c => c.Id == id, ct);
    }
    else
    {
        return await _db.Characters
            .Include(c => c.EquipmentSlots)
            .ThenInclude(s => s.Gear)
            .FirstOrDefaultAsync(c => c.Id == id, ct);
    }
}
```

#### æ­¥éª¤ 4: ç¼–åˆ¶ N+1 é—®é¢˜æ¸…å•

**æ–‡ä»¶**: `/docs/query-optimization/n-plus-one-issues.md`

```markdown
# N+1 æŸ¥è¯¢é—®é¢˜æ¸…å•

**ç”Ÿæˆæ—¥æœŸ**: 2025-10-19  
**å®¡æŸ¥èŒƒå›´**: æ‰€æœ‰ Repository å’Œ Service

---

## é«˜ä¼˜å…ˆçº§é—®é¢˜ (P0)

### é—®é¢˜ #1: Character è£…å¤‡åŠ è½½
- **ä½ç½®**: `CharactersController.GetCharacter`
- **åœºæ™¯**: è·å–è§’è‰²è¯¦æƒ…æ—¶åŠ è½½è£…å¤‡
- **é—®é¢˜**: 
  ```csharp
  var character = await _repo.GetAsync(id);
  foreach (var slot in character.EquipmentSlots) // N+1
  {
      var gear = await _gearRepo.GetAsync(slot.GearId);
  }
  ```
- **å½±å“**: æ¯ä¸ªè§’è‰²è§¦å‘ N æ¬¡é¢å¤–æŸ¥è¯¢ (N = è£…å¤‡æ§½ä½æ•°, é€šå¸¸ 8-10)
- **é¢‘ç‡**: æ¯ä¸ªç©å®¶ 2-5 æ¬¡/ç§’
- **é¢„ä¼°å½±å“**: é«˜ - é¢å¤– 20-50 æŸ¥è¯¢/ç§’ (100 ç©å®¶)
- **å»ºè®®æ–¹æ¡ˆ**: 
  1. ä½¿ç”¨ Include é¢„åŠ è½½
  2. æˆ–ä½¿ç”¨æ‰¹é‡æŸ¥è¯¢æ¥å£
- **ä¼˜å…ˆçº§**: P0

### é—®é¢˜ #2: Battle çŠ¶æ€åŠ è½½
- **ä½ç½®**: `BattleHub.GetBattleState`
- **åœºæ™¯**: è·å–æˆ˜æ–—çŠ¶æ€æ—¶åŠ è½½è§’è‰²å’Œæ•Œäºº
- **é—®é¢˜**: ç±»ä¼¼ #1
- **å½±å“**: ä¸­
- **é¢‘ç‡**: æ¯ä¸ªæˆ˜æ–— 1-2 æ¬¡/ç§’
- **é¢„ä¼°å½±å“**: ä¸­ - é¢å¤– 10-20 æŸ¥è¯¢/ç§’ (10 æ´»è·ƒæˆ˜æ–—)
- **å»ºè®®æ–¹æ¡ˆ**: Include + ThenInclude
- **ä¼˜å…ˆçº§**: P0

---

## ä¸­ä¼˜å…ˆçº§é—®é¢˜ (P1)

### é—®é¢˜ #3: ActivityPlan å…³è”æ•°æ®
- **ä½ç½®**: `ActivityService.GetPlans`
- **åœºæ™¯**: è·å–æ´»åŠ¨è®¡åˆ’åˆ—è¡¨æ—¶åŠ è½½è§’è‰²ä¿¡æ¯
- **é—®é¢˜**: ç±»ä¼¼ #1ï¼Œä½†é¢‘ç‡è¾ƒä½
- **å½±å“**: ä½-ä¸­
- **é¢‘ç‡**: æ¯ä¸ªç©å®¶ 1-5 æ¬¡/åˆ†é’Ÿ
- **é¢„ä¼°å½±å“**: ä½ - é¢å¤– 5-10 æŸ¥è¯¢/åˆ†é’Ÿ
- **å»ºè®®æ–¹æ¡ˆ**: Include
- **ä¼˜å…ˆçº§**: P1

---

## ä½ä¼˜å…ˆçº§é—®é¢˜ (P2)

### é—®é¢˜ #4: Shop å•†å“åŠ è½½
- **ä½ç½®**: `ShopService.GetItems`
- **åœºæ™¯**: è·å–å•†åº—å•†å“æ—¶åŠ è½½ä»·æ ¼ä¿¡æ¯
- **é—®é¢˜**: ç±»ä¼¼ #1ï¼Œä½†å·²æœ‰ç¼“å­˜
- **å½±å“**: ä½
- **é¢‘ç‡**: æ¯ä¸ªç©å®¶ 1-2 æ¬¡/åˆ†é’Ÿ
- **é¢„ä¼°å½±å“**: æä½ - ç¼“å­˜å‘½ä¸­ç‡ >90%
- **å»ºè®®æ–¹æ¡ˆ**: æš‚ä¸å¤„ç†ï¼Œç¼“å­˜å·²æœ‰æ•ˆ
- **ä¼˜å…ˆçº§**: P2

---

## é—®é¢˜ç»Ÿè®¡

| ä¼˜å…ˆçº§ | é—®é¢˜æ•° | é¢„ä¼°é¢å¤–æŸ¥è¯¢/ç§’ | é¢„ä¼°å½±å“ |
|--------|--------|----------------|---------|
| P0 | 2 | 30-70 | é«˜ |
| P1 | 1 | 0.1-0.2 | ä¸­ |
| P2 | 1 | <0.1 | ä½ |
| **æ€»è®¡** | **4** | **30-70** | **é«˜** |

## ä¼˜åŒ–æ”¶ç›Šé¢„ä¼°

**ä¼˜åŒ–å‰**: 
- é¢å¤–æŸ¥è¯¢: 30-70 æ¬¡/ç§’
- æŸ¥è¯¢å“åº”æ—¶é—´: 150-300ms (å« N+1)

**ä¼˜åŒ–å**: 
- é¢å¤–æŸ¥è¯¢: 0 æ¬¡/ç§’
- æŸ¥è¯¢å“åº”æ—¶é—´: 50-100ms (å•æ¬¡æŸ¥è¯¢)

**æ”¹å–„**: 
- æŸ¥è¯¢æ¬¡æ•°å‡å°‘ 100%
- å“åº”æ—¶é—´æ”¹å–„ 50-70%
```

#### æ­¥éª¤ 5: ç¼–åˆ¶æ…¢æŸ¥è¯¢æ¸…å•

**æ–‡ä»¶**: `/docs/query-optimization/slow-queries.md`

```markdown
# æ…¢æŸ¥è¯¢æ¸…å•

**é˜ˆå€¼**: > 100ms  
**ç›‘æ§æ—¶é—´**: 2025-10-19 08:00-12:00 (4å°æ—¶)  
**ç¯å¢ƒ**: å¼€å‘ç¯å¢ƒ

---

## æ…¢æŸ¥è¯¢åˆ—è¡¨

### æŸ¥è¯¢ #1: è§’è‰²è£…å¤‡å®Œæ•´åŠ è½½
```sql
SELECT c.*, es.*, g.*, a.*
FROM Characters c
LEFT JOIN EquipmentSlots es ON c.Id = es.CharacterId
LEFT JOIN Gears g ON es.GearId = g.Id
LEFT JOIN GearAffixes ga ON g.Id = ga.GearId
LEFT JOIN Affixes a ON ga.AffixId = a.Id
WHERE c.Id = @p0
```
- **æ‰§è¡Œæ—¶é—´**: 180ms (P95)
- **é¢‘ç‡**: 200 æ¬¡/å°æ—¶
- **é—®é¢˜**: ç¼ºå°‘ç´¢å¼•ï¼ŒJOIN è¿‡å¤š
- **å»ºè®®**: 
  1. æ·»åŠ ç´¢å¼• `EquipmentSlots(CharacterId)`
  2. æ·»åŠ ç´¢å¼• `GearAffixes(GearId)`
  3. è€ƒè™‘åˆ†æ­¥æŸ¥è¯¢æˆ–ç¼“å­˜

### æŸ¥è¯¢ #2: åœ¨çº¿è§’è‰²ç»Ÿè®¡
```sql
SELECT COUNT(*)
FROM Characters
WHERE IsOnline = 1
  AND LastSeenAtUtc > @p0
```
- **æ‰§è¡Œæ—¶é—´**: 150ms (P95)
- **é¢‘ç‡**: 60 æ¬¡/å°æ—¶ (æ¯åˆ†é’Ÿ)
- **é—®é¢˜**: å…¨è¡¨æ‰«æï¼Œç¼ºå°‘å¤åˆç´¢å¼•
- **å»ºè®®**: æ·»åŠ ç´¢å¼• `Characters(IsOnline, LastSeenAtUtc)`

### æŸ¥è¯¢ #3: æ´»åŠ¨è®¡åˆ’çŠ¶æ€æŸ¥è¯¢
```sql
SELECT *
FROM ActivityPlans
WHERE CharacterId = @p0
  AND State IN ('Pending', 'Running')
ORDER BY CreatedAt
```
- **æ‰§è¡Œæ—¶é—´**: 120ms (P95)
- **é¢‘ç‡**: 300 æ¬¡/å°æ—¶
- **é—®é¢˜**: ç¼ºå°‘å¤åˆç´¢å¼•
- **å»ºè®®**: æ·»åŠ ç´¢å¼• `ActivityPlans(CharacterId, State, CreatedAt)`

---

## ä¼˜åŒ–ä¼˜å…ˆçº§

| æŸ¥è¯¢ | é¢‘ç‡ | è€—æ—¶ | æ€»å½±å“ | ä¼˜å…ˆçº§ |
|------|------|------|--------|--------|
| #1 | 200/h | 180ms | 36s/h | P0 |
| #2 | 60/h | 150ms | 9s/h | P1 |
| #3 | 300/h | 120ms | 36s/h | P0 |

**æ€»å½±å“**: çº¦ 81ç§’/å°æ—¶ çš„æ•°æ®åº“æŸ¥è¯¢æ—¶é—´
```

### 4.1.4 éªŒæ”¶æ ‡å‡†

- [x] EF Core æŸ¥è¯¢æ—¥å¿—å·²é…ç½®å¹¶æ­£å¸¸è¾“å‡º
- [x] MiniProfiler å·²å®‰è£…å¹¶å¯è®¿é—®
- [x] æ‰€æœ‰ Repository å·²å®¡æŸ¥å¹¶è®°å½•é—®é¢˜
- [x] N+1 é—®é¢˜æ¸…å•å·²ç¼–åˆ¶ (è‡³å°‘è¯†åˆ« 3 ä¸ªé—®é¢˜)
- [x] æ…¢æŸ¥è¯¢æ¸…å•å·²ç¼–åˆ¶ (è‡³å°‘è¯†åˆ« 3 ä¸ªæ…¢æŸ¥è¯¢)
- [x] ä¼˜åŒ–ä¼˜å…ˆçº§å·²ç¡®å®š

### 4.1.5 é…ç½®å‚æ•°

**æ–°å¢é…ç½®èŠ‚** - `appsettings.json`:

```json
{
  "QueryOptimization": {
    "EnableQueryLogging": true,
    "LogSlowQueries": true,
    "SlowQueryThresholdMs": 100,
    "EnableDetailedQueryLogging": false,
    "EnableMiniProfiler": true,
    "MiniProfilerStorageMinutes": 60
  }
}
```

**é…ç½®ç±»** - `BlazorIdle.Server/Config/DatabaseOptimization/QueryOptimizationOptions.cs`:

```csharp
using System.ComponentModel.DataAnnotations;

namespace BlazorIdle.Server.Config.DatabaseOptimization;

/// <summary>
/// æŸ¥è¯¢ä¼˜åŒ–é…ç½®é€‰é¡¹
/// Query optimization configuration options
/// </summary>
public class QueryOptimizationOptions
{
    /// <summary>
    /// æ˜¯å¦å¯ç”¨æŸ¥è¯¢æ—¥å¿—
    /// Enable query logging
    /// </summary>
    public bool EnableQueryLogging { get; set; } = false;
    
    /// <summary>
    /// æ˜¯å¦è®°å½•æ…¢æŸ¥è¯¢
    /// Log slow queries
    /// </summary>
    public bool LogSlowQueries { get; set; } = true;
    
    /// <summary>
    /// æ…¢æŸ¥è¯¢é˜ˆå€¼ï¼ˆæ¯«ç§’ï¼‰
    /// Slow query threshold in milliseconds
    /// </summary>
    [Range(10, 10000)]
    public int SlowQueryThresholdMs { get; set; } = 100;
    
    /// <summary>
    /// æ˜¯å¦å¯ç”¨è¯¦ç»†æŸ¥è¯¢æ—¥å¿—
    /// Enable detailed query logging (includes parameters)
    /// </summary>
    public bool EnableDetailedQueryLogging { get; set; } = false;
    
    /// <summary>
    /// æ˜¯å¦å¯ç”¨ MiniProfiler
    /// Enable MiniProfiler
    /// </summary>
    public bool EnableMiniProfiler { get; set; } = false;
    
    /// <summary>
    /// MiniProfiler å­˜å‚¨æ—¶é•¿ï¼ˆåˆ†é’Ÿï¼‰
    /// MiniProfiler storage duration in minutes
    /// </summary>
    [Range(5, 1440)]
    public int MiniProfilerStorageMinutes { get; set; } = 60;
}
```

---

## ğŸ”§ é˜¶æ®µ 4.2: æ‰¹é‡æŸ¥è¯¢æ¥å£å®ç°

### 4.2.1 ç›®æ ‡

æä¾›ç»Ÿä¸€çš„æ‰¹é‡æŸ¥è¯¢æ¥å£ï¼Œé¿å…é€ä¸ªæŸ¥è¯¢å¯¼è‡´çš„æ€§èƒ½é—®é¢˜

### 4.2.2 ä»»åŠ¡æ¸…å•

- [ ] **ä»»åŠ¡ 4.2.1**: è®¾è®¡æ‰¹é‡æŸ¥è¯¢æ¥å£
- [ ] **ä»»åŠ¡ 4.2.2**: å®ç° Repository åŸºç±»
- [ ] **ä»»åŠ¡ 4.2.3**: æ›´æ–°æ‰€æœ‰ Repository å®ç°æ‰¹é‡æ¥å£
- [ ] **ä»»åŠ¡ 4.2.4**: é›†æˆç¼“å­˜å±‚
- [ ] **ä»»åŠ¡ 4.2.5**: ç¼–å†™å•å…ƒæµ‹è¯•
- [ ] **ä»»åŠ¡ 4.2.6**: ç¼–å†™é›†æˆæµ‹è¯•

### 4.2.3 è¯¦ç»†å®æ–½æ­¥éª¤

#### æ­¥éª¤ 1: è®¾è®¡æ‰¹é‡æŸ¥è¯¢æ¥å£

**æ–‡ä»¶**: `BlazorIdle.Server/Application/Abstractions/IRepository.cs`

```csharp
namespace BlazorIdle.Server.Application.Abstractions;

/// <summary>
/// é€šç”¨ä»“å‚¨æ¥å£ - å®šä¹‰æ‰€æœ‰ä»“å‚¨çš„åŸºæœ¬æ“ä½œ
/// Generic repository interface - Defines basic operations for all repositories
/// </summary>
/// <typeparam name="T">å®ä½“ç±»å‹ / Entity type</typeparam>
public interface IRepository<T> where T : class, IEntity
{
    /// <summary>
    /// æŒ‰ ID è·å–å•ä¸ªå®ä½“
    /// Get a single entity by ID
    /// </summary>
    Task<T?> GetAsync(Guid id, CancellationToken ct = default);
    
    /// <summary>
    /// æ‰¹é‡è·å–å®ä½“ï¼ˆè¿”å›åˆ—è¡¨ï¼‰
    /// Batch get entities (returns list)
    /// </summary>
    /// <param name="ids">å®ä½“IDåˆ—è¡¨ / Entity ID list</param>
    /// <param name="ct">å–æ¶ˆä»¤ç‰Œ / Cancellation token</param>
    /// <returns>å®ä½“åˆ—è¡¨ï¼ˆå¯èƒ½å°‘äºè¯·æ±‚æ•°é‡ï¼Œå› ä¸ºæŸäº›IDå¯èƒ½ä¸å­˜åœ¨ï¼‰/ Entity list</returns>
    Task<IReadOnlyList<T>> GetBatchAsync(
        IEnumerable<Guid> ids, 
        CancellationToken ct = default);
    
    /// <summary>
    /// æ‰¹é‡è·å–å®ä½“ï¼ˆè¿”å›å­—å…¸ï¼‰
    /// Batch get entities (returns dictionary)
    /// </summary>
    /// <param name="ids">å®ä½“IDåˆ—è¡¨ / Entity ID list</param>
    /// <param name="ct">å–æ¶ˆä»¤ç‰Œ / Cancellation token</param>
    /// <returns>ID â†’ å®ä½“ å­—å…¸ / ID to entity dictionary</returns>
    Task<IReadOnlyDictionary<Guid, T>> GetDictionaryAsync(
        IEnumerable<Guid> ids, 
        CancellationToken ct = default);
    
    /// <summary>
    /// è·å–æ‰€æœ‰å®ä½“ï¼ˆè°¨æ…ä½¿ç”¨ï¼‰
    /// Get all entities (use with caution)
    /// </summary>
    /// <param name="maxCount">æœ€å¤§æ•°é‡é™åˆ¶ / Max count limit</param>
    /// <param name="ct">å–æ¶ˆä»¤ç‰Œ / Cancellation token</param>
    Task<IReadOnlyList<T>> GetAllAsync(
        int maxCount = 1000, 
        CancellationToken ct = default);
}
```

#### æ­¥éª¤ 2: å®ç° Repository åŸºç±»

**æ–‡ä»¶**: `BlazorIdle.Server/Infrastructure/Persistence/Repositories/RepositoryBase.cs`

```csharp
using BlazorIdle.Server.Application.Abstractions;
using BlazorIdle.Server.Infrastructure.DatabaseOptimization.Abstractions;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Logging;

namespace BlazorIdle.Server.Infrastructure.Persistence.Repositories;

/// <summary>
/// ä»“å‚¨åŸºç±» - æä¾›é€šç”¨çš„ CRUD å’Œæ‰¹é‡æŸ¥è¯¢åŠŸèƒ½
/// Repository base class - Provides common CRUD and batch query functionality
/// </summary>
/// <typeparam name="T">å®ä½“ç±»å‹ / Entity type</typeparam>
public abstract class RepositoryBase<T> : IRepository<T> where T : class, IEntity
{
    protected readonly GameDbContext _db;
    protected readonly IConfiguration _configuration;
    protected readonly IMemoryStateManager<T>? _memoryManager;
    protected readonly ILogger _logger;
    
    protected RepositoryBase(
        GameDbContext db,
        IConfiguration configuration,
        IMemoryStateManager<T>? memoryManager,
        ILogger logger)
    {
        _db = db;
        _configuration = configuration;
        _memoryManager = memoryManager;
        _logger = logger;
    }
    
    /// <inheritdoc />
    public virtual async Task<T?> GetAsync(Guid id, CancellationToken ct = default)
    {
        var enableCaching = _configuration.GetValue<bool>(
            "CacheConfiguration:GlobalSettings:EnableReadCaching", true);
        
        if (enableCaching && _memoryManager != null)
        {
            return await _memoryManager.TryGetAsync(
                id,
                async (id, ct) => await _db.Set<T>()
                    .FirstOrDefaultAsync(e => e.Id == id, ct),
                ct
            );
        }
        else
        {
            return await _db.Set<T>()
                .FirstOrDefaultAsync(e => e.Id == id, ct);
        }
    }
    
    /// <inheritdoc />
    public virtual async Task<IReadOnlyList<T>> GetBatchAsync(
        IEnumerable<Guid> ids, 
        CancellationToken ct = default)
    {
        var idList = ids.ToList();
        
        if (idList.Count == 0)
            return Array.Empty<T>();
        
        // æ£€æŸ¥æ‰¹é‡å¤§å°é™åˆ¶
        var maxBatchSize = _configuration.GetValue<int>(
            "QueryOptimization:MaxBatchSize", 1000);
        
        if (idList.Count > maxBatchSize)
        {
            _logger.LogWarning(
                "æ‰¹é‡æŸ¥è¯¢æ•°é‡ ({Count}) è¶…è¿‡é™åˆ¶ ({MaxBatchSize})ï¼Œå°†æˆªæ–­",
                idList.Count, maxBatchSize);
            idList = idList.Take(maxBatchSize).ToList();
        }
        
        var enableCaching = _configuration.GetValue<bool>(
            "CacheConfiguration:GlobalSettings:EnableReadCaching", true);
        
        if (enableCaching && _memoryManager != null)
        {
            // ç¼“å­˜ä¼˜å…ˆç­–ç•¥
            var result = new List<T>(idList.Count);
            var missedIds = new List<Guid>();
            
            // 1. å…ˆä»ç¼“å­˜æŸ¥æ‰¾
            foreach (var id in idList)
            {
                var entity = await _memoryManager.TryGetAsync(
                    id,
                    async (_, _) => null, // ä¸ä»æ•°æ®åº“åŠ è½½
                    ct
                );
                
                if (entity != null)
                {
                    result.Add(entity);
                }
                else
                {
                    missedIds.Add(id);
                }
            }
            
            // 2. æ‰¹é‡åŠ è½½æœªå‘½ä¸­çš„
            if (missedIds.Count > 0)
            {
                _logger.LogDebug(
                    "æ‰¹é‡æŸ¥è¯¢ {EntityType}ï¼š{Total} ä¸ªIDï¼Œ{CacheHits} ä¸ªç¼“å­˜å‘½ä¸­ï¼Œ{CacheMisses} ä¸ªéœ€ä»æ•°æ®åº“åŠ è½½",
                    typeof(T).Name, idList.Count, result.Count, missedIds.Count);
                
                var dbEntities = await _db.Set<T>()
                    .Where(e => missedIds.Contains(e.Id))
                    .ToListAsync(ct);
                
                // åŠ å…¥ç¼“å­˜
                foreach (var entity in dbEntities)
                {
                    _memoryManager.Add(entity);
                    result.Add(entity);
                }
            }
            
            return result.AsReadOnly();
        }
        else
        {
            // ç›´æ¥ä»æ•°æ®åº“æ‰¹é‡æŸ¥è¯¢
            _logger.LogDebug(
                "æ‰¹é‡æŸ¥è¯¢ {EntityType}ï¼š{Count} ä¸ªIDï¼ˆæ— ç¼“å­˜ï¼‰",
                typeof(T).Name, idList.Count);
            
            var entities = await _db.Set<T>()
                .Where(e => idList.Contains(e.Id))
                .ToListAsync(ct);
            
            return entities.AsReadOnly();
        }
    }
    
    /// <inheritdoc />
    public virtual async Task<IReadOnlyDictionary<Guid, T>> GetDictionaryAsync(
        IEnumerable<Guid> ids, 
        CancellationToken ct = default)
    {
        var entities = await GetBatchAsync(ids, ct);
        return entities.ToDictionary(e => e.Id);
    }
    
    /// <inheritdoc />
    public virtual async Task<IReadOnlyList<T>> GetAllAsync(
        int maxCount = 1000, 
        CancellationToken ct = default)
    {
        _logger.LogWarning(
            "æ‰§è¡Œ GetAllAsync for {EntityType}ï¼Œé™åˆ¶æ•°é‡ï¼š{MaxCount}",
            typeof(T).Name, maxCount);
        
        var entities = await _db.Set<T>()
            .Take(maxCount)
            .ToListAsync(ct);
        
        return entities.AsReadOnly();
    }
}
```

#### æ­¥éª¤ 3: æ›´æ–° CharacterRepository å®ç°æ‰¹é‡æ¥å£

**æ–‡ä»¶**: `BlazorIdle.Server/Infrastructure/Persistence/Repositories/CharacterRepository.cs`

```csharp
using BlazorIdle.Server.Domain.Characters;

namespace BlazorIdle.Server.Infrastructure.Persistence.Repositories;

/// <summary>
/// è§’è‰²æ•°æ®ä»“å‚¨å®ç°
/// Character repository implementation
/// </summary>
public class CharacterRepository : RepositoryBase<Character>, ICharacterRepository
{
    public CharacterRepository(
        GameDbContext db,
        IConfiguration configuration,
        IMemoryStateManager<Character>? memoryManager,
        ILogger<CharacterRepository> logger)
        : base(db, configuration, memoryManager, logger)
    {
    }
    
    // ç»§æ‰¿åŸºç±»çš„æ‰¹é‡æŸ¥è¯¢æ–¹æ³•
    // GetBatchAsync å’Œ GetDictionaryAsync å·²è‡ªåŠ¨å¯ç”¨
    
    // å¦‚æœéœ€è¦ç‰¹æ®Šçš„æ‰¹é‡æŸ¥è¯¢é€»è¾‘ï¼Œå¯ä»¥é‡å†™
    public override async Task<IReadOnlyList<Character>> GetBatchAsync(
        IEnumerable<Guid> ids, 
        CancellationToken ct = default)
    {
        // å¯ä»¥æ·»åŠ  Character ç‰¹å®šçš„é€»è¾‘
        // ä¾‹å¦‚ï¼šInclude å¯¼èˆªå±æ€§
        
        var baseResult = await base.GetBatchAsync(ids, ct);
        return baseResult;
    }
    
    /// <summary>
    /// æŒ‰ç”¨æˆ·IDæ‰¹é‡è·å–è§’è‰²
    /// Get characters by user ID in batch
    /// </summary>
    public async Task<IReadOnlyList<Character>> GetByUserIdAsync(
        Guid userId, 
        CancellationToken ct = default)
    {
        _logger.LogDebug("æŒ‰ç”¨æˆ·IDæŸ¥è¯¢è§’è‰²ï¼š{UserId}", userId);
        
        var characters = await _db.Characters
            .Where(c => c.UserId == userId)
            .ToListAsync(ct);
        
        return characters.AsReadOnly();
    }
}
```

#### æ­¥éª¤ 4: åº”ç”¨æ‰¹é‡æŸ¥è¯¢è§£å†³ N+1 é—®é¢˜

**ç¤ºä¾‹åœºæ™¯**: åŠ è½½è§’è‰²è£…å¤‡

**ä¼˜åŒ–å‰** (N+1 é—®é¢˜):
```csharp
// CharactersController.cs
public async Task<IActionResult> GetCharacter(Guid id)
{
    var character = await _characterRepo.GetAsync(id);
    if (character == null)
        return NotFound();
    
    // N+1 é—®é¢˜ï¼šé€ä¸ªåŠ è½½è£…å¤‡
    var gears = new List<GearInstance>();
    foreach (var slot in character.EquipmentSlots)
    {
        var gear = await _gearRepo.GetAsync(slot.GearId); // Næ¬¡æŸ¥è¯¢
        if (gear != null)
            gears.Add(gear);
    }
    
    return Ok(new { character, gears });
}
```

**ä¼˜åŒ–å** (æ‰¹é‡æŸ¥è¯¢):
```csharp
// CharactersController.cs
public async Task<IActionResult> GetCharacter(Guid id)
{
    var character = await _characterRepo.GetAsync(id);
    if (character == null)
        return NotFound();
    
    // æ‰¹é‡æŸ¥è¯¢ï¼š1æ¬¡æ•°æ®åº“è®¿é—®
    var gearIds = character.EquipmentSlots
        .Where(s => s.GearId.HasValue)
        .Select(s => s.GearId!.Value)
        .ToList();
    
    var gearsDict = await _gearRepo.GetDictionaryAsync(gearIds);
    
    var gears = character.EquipmentSlots
        .Where(s => s.GearId.HasValue && gearsDict.ContainsKey(s.GearId.Value))
        .Select(s => gearsDict[s.GearId!.Value])
        .ToList();
    
    return Ok(new { character, gears });
}
```

### 4.2.4 éªŒæ”¶æ ‡å‡†

- [x] RepositoryBase åŸºç±»å·²å®ç°å¹¶é€šè¿‡ç¼–è¯‘
- [x] æ‰€æœ‰ Repository å·²ç»§æ‰¿åŸºç±»
- [x] GetBatchAsync æ–¹æ³•å¯æ­£å¸¸å·¥ä½œ
- [x] GetDictionaryAsync æ–¹æ³•å¯æ­£å¸¸å·¥ä½œ
- [x] å·²è¯†åˆ«çš„ N+1 é—®é¢˜å·²ä½¿ç”¨æ‰¹é‡æŸ¥è¯¢è§£å†³
- [x] å•å…ƒæµ‹è¯•è¦†ç›–ç‡ > 80%

### 4.2.5 å•å…ƒæµ‹è¯•

**æ–‡ä»¶**: `tests/BlazorIdle.Tests/Infrastructure/Repositories/RepositoryBaseTests.cs`

```csharp
using BlazorIdle.Server.Infrastructure.Persistence.Repositories;
using Xunit;

namespace BlazorIdle.Tests.Infrastructure.Repositories;

public class RepositoryBaseTests
{
    [Fact]
    public async Task GetBatchAsync_ValidIds_ReturnsEntities()
    {
        // Arrange
        var ids = new[] { Guid.NewGuid(), Guid.NewGuid(), Guid.NewGuid() };
        // ... è®¾ç½® mock
        
        // Act
        var result = await _repository.GetBatchAsync(ids);
        
        // Assert
        Assert.Equal(ids.Length, result.Count);
    }
    
    [Fact]
    public async Task GetBatchAsync_ExceedsMaxBatchSize_Truncates()
    {
        // Arrange
        var ids = Enumerable.Range(0, 1500)
            .Select(_ => Guid.NewGuid())
            .ToList();
        
        // Act
        var result = await _repository.GetBatchAsync(ids);
        
        // Assert
        Assert.True(result.Count <= 1000); // MaxBatchSize
    }
    
    [Fact]
    public async Task GetDictionaryAsync_ValidIds_ReturnsDictionary()
    {
        // Arrange & Act & Assert
        // ... ç±»ä¼¼ä¸Šé¢
    }
}
```

### 4.2.6 é…ç½®å‚æ•°

**æ–°å¢é…ç½®** - `appsettings.json`:

```json
{
  "QueryOptimization": {
    "EnableBatchQueries": true,
    "DefaultBatchSize": 100,
    "MaxBatchSize": 1000
  }
}
```

---

## â±ï¸ è¿›åº¦è·Ÿè¸ª

### å½“å‰è¿›åº¦ï¼šé˜¶æ®µ 4.1 å’Œ 4.2 (ä¸Šç¯‡å‰åŠéƒ¨åˆ†)

- [x] é˜¶æ®µ 4.1: ä»£ç å®¡æŸ¥ä¸ N+1 æ£€æµ‹ (å·²è§„åˆ’å®Œæˆ)
- [x] é˜¶æ®µ 4.2: æ‰¹é‡æŸ¥è¯¢æ¥å£å®ç° (å·²è§„åˆ’å®Œæˆ)
- [ ] é˜¶æ®µ 4.3: Include ä¸ Eager Loading ä¼˜åŒ– (ä¸‹ä¸€æ­¥)
- [ ] é˜¶æ®µ 4.4: æ•°æ®åº“ç´¢å¼•åˆ†æä¸ä¼˜åŒ– (ä¸‹ä¸€æ­¥)
- [ ] é˜¶æ®µ 4.5: æŠ•å½±ä¼˜åŒ–ä¸ DTO è®¾è®¡ (ä¸‹ä¸€æ­¥)

**æ³¨**: é˜¶æ®µ 4.3-4.5 å°†åœ¨åç»­ç« èŠ‚è¯¦ç»†è¯´æ˜

---

**æ–‡æ¡£çŠ¶æ€**: ä¸Šç¯‡å‰åŠéƒ¨åˆ†å®Œæˆ  
**ä¸‹ä¸€æ­¥**: ç»§ç»­ç¼–å†™é˜¶æ®µ 4.3-4.5  
**é¢„è®¡å®Œæˆæ—¶é—´**: é˜¶æ®µ 4 å…¨éƒ¨å®Œæˆéœ€ 15-20 äººæ—¥
