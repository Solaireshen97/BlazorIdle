# BlazorIdle 数据库进一步优化实施方案 - 上篇

**项目名称**: BlazorIdle 数据库进一步优化  
**方案版本**: 1.0  
**编制日期**: 2025-10-19  
**适用范围**: Phase 4-6 (推荐实施部分)

---

## 📋 文档说明

本文档是《数据库操作深度分析报告》的配套实施方案，分为上中下三篇：
- **上篇 (本文档)**: Phase 4 - 查询优化与索引增强
- **中篇**: Phase 5 - 智能预加载与缓存预热
- **下篇**: Phase 6 - 实时监控与可视化

**重要提示**: 
- 当前系统已达卓越水平 (94.9% I/O 减少)
- 本方案为**可选增强**，非必须
- 建议先实施监控 (下篇)，基于数据决策是否需要进一步优化

---

## 🎯 Phase 4: 查询优化与索引增强

### 目标与预期效果

**优化目标**:
1. 消除 N+1 查询问题
2. 优化数据库索引
3. 实现批量查询接口
4. 使用投影优化减少数据传输

**预期效果**:
- ✅ 消除 90% 的 N+1 查询
- ✅ 查询响应时间减少 50-70%
- ✅ 数据库 CPU 使用率降低 30%
- ✅ 网络传输量减少 40%

**优先级**: ⭐⭐⭐⭐ (高优先级)

**工时估算**: 15-20 人日

**风险级别**: 低-中

---

## 📊 阶段规划

### 总体分为 5 个子阶段

| 阶段 | 任务 | 工时 | 风险 | 优先级 |
|------|------|------|------|--------|
| 4.1 | 代码审查与 N+1 检测 | 3-4 天 | 低 | P0 |
| 4.2 | 批量查询接口实现 | 3-4 天 | 低 | P0 |
| 4.3 | Include 与 Eager Loading 优化 | 3-4 天 | 中 | P0 |
| 4.4 | 数据库索引分析与优化 | 4-5 天 | 中 | P1 |
| 4.5 | 投影优化与 DTO 设计 | 3-4 天 | 低 | P1 |

**总工时**: 16-21 天

---

## 🔍 阶段 4.1: 代码审查与 N+1 检测

### 4.1.1 目标

识别现有代码中的 N+1 查询问题和性能瓶颈

### 4.1.2 任务清单

- [ ] **任务 4.1.1**: 配置 EF Core 查询日志
- [ ] **任务 4.1.2**: 安装和配置 MiniProfiler
- [ ] **任务 4.1.3**: 审查所有 Repository 实现
- [ ] **任务 4.1.4**: 审查所有 Service 实现
- [ ] **任务 4.1.5**: 编制 N+1 问题清单
- [ ] **任务 4.1.6**: 编制慢查询清单

### 4.1.3 详细实施步骤

#### 步骤 1: 配置 EF Core 查询日志

**文件**: `appsettings.Development.json`

```json
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.EntityFrameworkCore.Database.Command": "Information",
      "Microsoft.EntityFrameworkCore.Query": "Warning"
    }
  },
  "QueryOptimization": {
    "EnableQueryLogging": true,
    "LogSlowQueries": true,
    "SlowQueryThresholdMs": 100,
    "EnableDetailedQueryLogging": true
  }
}
```

**文件**: `BlazorIdle.Server/Infrastructure/Persistence/GameDbContext.cs`

```csharp
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Diagnostics;
using Microsoft.Extensions.Logging;

namespace BlazorIdle.Server.Infrastructure.Persistence;

public class GameDbContext : DbContext
{
    private readonly ILogger<GameDbContext> _logger;
    private readonly IConfiguration _configuration;
    
    public GameDbContext(
        DbContextOptions<GameDbContext> options,
        ILogger<GameDbContext> logger,
        IConfiguration configuration) 
        : base(options)
    {
        _logger = logger;
        _configuration = configuration;
    }
    
    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
    {
        base.OnConfiguring(optionsBuilder);
        
        // 配置查询日志
        var enableLogging = _configuration.GetValue<bool>(
            "QueryOptimization:EnableQueryLogging", false);
        
        if (enableLogging)
        {
            var slowQueryThreshold = _configuration.GetValue<int>(
                "QueryOptimization:SlowQueryThresholdMs", 100);
            
            optionsBuilder
                .LogTo(
                    message => _logger.LogInformation("EF Core: {Message}", message),
                    new[] { DbLoggerCategory.Database.Command.Name })
                .EnableSensitiveDataLogging()
                .EnableDetailedErrors();
            
            // 慢查询警告
            optionsBuilder.ConfigureWarnings(warnings =>
            {
                warnings.Log((RelationalEventId.CommandExecuted, LogLevel.Warning));
            });
        }
    }
    
    // ... 实体配置
}
```

**验证**:
```bash
# 启动应用，观察日志
dotnet run --project BlazorIdle.Server

# 应该看到类似输出：
# info: Microsoft.EntityFrameworkCore.Database.Command[20101]
#       Executed DbCommand (3ms) [Parameters=[@__id_0='?' (DbType = Guid)], CommandType='Text', CommandTimeout='30']
#       SELECT "c"."Id", "c"."Name", "c"."Level" ...
```

#### 步骤 2: 安装和配置 MiniProfiler

**文件**: `BlazorIdle.Server/BlazorIdle.Server.csproj`

```xml
<ItemGroup>
  <PackageReference Include="MiniProfiler.AspNetCore.Mvc" Version="4.3.8" />
  <PackageReference Include="MiniProfiler.EntityFrameworkCore" Version="4.3.8" />
</ItemGroup>
```

**文件**: `BlazorIdle.Server/Program.cs`

```csharp
// 添加 MiniProfiler 服务
builder.Services.AddMiniProfiler(options =>
{
    options.RouteBasePath = "/profiler";
    
    // 仅在开发环境启用
    options.EnableDebugMode = builder.Environment.IsDevelopment();
    
    // 配置存储
    options.Storage = new MemoryCacheStorage(
        new MemoryCacheStorageOptions
        {
            CacheDuration = TimeSpan.FromMinutes(60)
        });
    
    // SQL 查询格式化
    options.SqlFormatter = new StackExchange.Profiling.SqlFormatters.InlineFormatter();
}).AddEntityFramework();

// ... 在 app 构建后
app.UseMiniProfiler();
```

**访问 MiniProfiler UI**:
```
http://localhost:5000/profiler/results-index
```

**验证**:
```bash
# 1. 启动应用
dotnet run --project BlazorIdle.Server

# 2. 打开浏览器访问
http://localhost:5000/profiler/results-index

# 3. 执行一些 API 调用
curl http://localhost:5000/api/characters/{guid}

# 4. 查看 MiniProfiler 结果
# 应该看到 SQL 查询详情、执行时间、N+1 警告等
```

#### 步骤 3: 审查所有 Repository 实现

**创建审查检查清单**:

**文件**: `/docs/query-optimization/repository-review-checklist.md`

```markdown
# Repository 代码审查检查清单

## 审查对象
- [ ] CharacterRepository
- [ ] GearDefinitionRepository
- [ ] AffixRepository
- [ ] GearSetRepository
- [ ] GearInstanceRepository
- [ ] ActivityPlanRepository
- [ ] BattleRepository

## 检查项

### 1. N+1 查询检测
- [ ] 是否存在循环中的单次查询？
- [ ] 是否存在导航属性懒加载？
- [ ] 是否需要 Include 或 ThenInclude？

### 2. 查询效率
- [ ] 是否加载了不必要的字段？
- [ ] 是否可以使用投影 (Select)?
- [ ] 是否可以使用 AsNoTracking？

### 3. 批量操作
- [ ] 是否需要批量查询接口？
- [ ] 是否存在逐个操作可以批量化的场景？

## 发现问题记录

### CharacterRepository

**问题 1**: [描述]
- **位置**: `GetAsync` 方法
- **类型**: N+1 查询
- **影响**: 高
- **建议**: 使用 Include 加载 EquipmentSlots

**问题 2**: [描述]
...
```

**审查示例 - CharacterRepository**:

```csharp
// 当前实现 (需审查)
public async Task<Character?> GetAsync(Guid id, CancellationToken ct = default)
{
    var enableCaching = _configuration.GetValue<bool>(
        "CacheConfiguration:GlobalSettings:EnableReadCaching", true);
    
    if (enableCaching && _memoryManager != null)
    {
        return await _memoryManager.TryGetAsync(
            id,
            async (id, ct) => await _db.Characters
                .FirstOrDefaultAsync(c => c.Id == id, ct),
            ct
        );
    }
    else
    {
        return await _db.Characters
            .FirstOrDefaultAsync(c => c.Id == id, ct);
    }
}

// 潜在问题：
// 1. 如果后续代码访问 character.EquipmentSlots，会触发 N+1
// 2. 如果后续代码访问 character.ActivityPlans，会触发 N+1
```

**改进建议**:
```csharp
// 新增方法：带关联数据的查询
public async Task<Character?> GetWithEquipmentAsync(
    Guid id, 
    CancellationToken ct = default)
{
    var enableCaching = _configuration.GetValue<bool>(
        "CacheConfiguration:GlobalSettings:EnableReadCaching", true);
    
    if (enableCaching && _memoryManager != null)
    {
        // TODO: 缓存层需要支持 Include
        // 暂时回退到直接查询
        return await _db.Characters
            .Include(c => c.EquipmentSlots)
            .ThenInclude(s => s.Gear)
            .FirstOrDefaultAsync(c => c.Id == id, ct);
    }
    else
    {
        return await _db.Characters
            .Include(c => c.EquipmentSlots)
            .ThenInclude(s => s.Gear)
            .FirstOrDefaultAsync(c => c.Id == id, ct);
    }
}
```

#### 步骤 4: 编制 N+1 问题清单

**文件**: `/docs/query-optimization/n-plus-one-issues.md`

```markdown
# N+1 查询问题清单

**生成日期**: 2025-10-19  
**审查范围**: 所有 Repository 和 Service

---

## 高优先级问题 (P0)

### 问题 #1: Character 装备加载
- **位置**: `CharactersController.GetCharacter`
- **场景**: 获取角色详情时加载装备
- **问题**: 
  ```csharp
  var character = await _repo.GetAsync(id);
  foreach (var slot in character.EquipmentSlots) // N+1
  {
      var gear = await _gearRepo.GetAsync(slot.GearId);
  }
  ```
- **影响**: 每个角色触发 N 次额外查询 (N = 装备槽位数, 通常 8-10)
- **频率**: 每个玩家 2-5 次/秒
- **预估影响**: 高 - 额外 20-50 查询/秒 (100 玩家)
- **建议方案**: 
  1. 使用 Include 预加载
  2. 或使用批量查询接口
- **优先级**: P0

### 问题 #2: Battle 状态加载
- **位置**: `BattleHub.GetBattleState`
- **场景**: 获取战斗状态时加载角色和敌人
- **问题**: 类似 #1
- **影响**: 中
- **频率**: 每个战斗 1-2 次/秒
- **预估影响**: 中 - 额外 10-20 查询/秒 (10 活跃战斗)
- **建议方案**: Include + ThenInclude
- **优先级**: P0

---

## 中优先级问题 (P1)

### 问题 #3: ActivityPlan 关联数据
- **位置**: `ActivityService.GetPlans`
- **场景**: 获取活动计划列表时加载角色信息
- **问题**: 类似 #1，但频率较低
- **影响**: 低-中
- **频率**: 每个玩家 1-5 次/分钟
- **预估影响**: 低 - 额外 5-10 查询/分钟
- **建议方案**: Include
- **优先级**: P1

---

## 低优先级问题 (P2)

### 问题 #4: Shop 商品加载
- **位置**: `ShopService.GetItems`
- **场景**: 获取商店商品时加载价格信息
- **问题**: 类似 #1，但已有缓存
- **影响**: 低
- **频率**: 每个玩家 1-2 次/分钟
- **预估影响**: 极低 - 缓存命中率 >90%
- **建议方案**: 暂不处理，缓存已有效
- **优先级**: P2

---

## 问题统计

| 优先级 | 问题数 | 预估额外查询/秒 | 预估影响 |
|--------|--------|----------------|---------|
| P0 | 2 | 30-70 | 高 |
| P1 | 1 | 0.1-0.2 | 中 |
| P2 | 1 | <0.1 | 低 |
| **总计** | **4** | **30-70** | **高** |

## 优化收益预估

**优化前**: 
- 额外查询: 30-70 次/秒
- 查询响应时间: 150-300ms (含 N+1)

**优化后**: 
- 额外查询: 0 次/秒
- 查询响应时间: 50-100ms (单次查询)

**改善**: 
- 查询次数减少 100%
- 响应时间改善 50-70%
```

#### 步骤 5: 编制慢查询清单

**文件**: `/docs/query-optimization/slow-queries.md`

```markdown
# 慢查询清单

**阈值**: > 100ms  
**监控时间**: 2025-10-19 08:00-12:00 (4小时)  
**环境**: 开发环境

---

## 慢查询列表

### 查询 #1: 角色装备完整加载
```sql
SELECT c.*, es.*, g.*, a.*
FROM Characters c
LEFT JOIN EquipmentSlots es ON c.Id = es.CharacterId
LEFT JOIN Gears g ON es.GearId = g.Id
LEFT JOIN GearAffixes ga ON g.Id = ga.GearId
LEFT JOIN Affixes a ON ga.AffixId = a.Id
WHERE c.Id = @p0
```
- **执行时间**: 180ms (P95)
- **频率**: 200 次/小时
- **问题**: 缺少索引，JOIN 过多
- **建议**: 
  1. 添加索引 `EquipmentSlots(CharacterId)`
  2. 添加索引 `GearAffixes(GearId)`
  3. 考虑分步查询或缓存

### 查询 #2: 在线角色统计
```sql
SELECT COUNT(*)
FROM Characters
WHERE IsOnline = 1
  AND LastSeenAtUtc > @p0
```
- **执行时间**: 150ms (P95)
- **频率**: 60 次/小时 (每分钟)
- **问题**: 全表扫描，缺少复合索引
- **建议**: 添加索引 `Characters(IsOnline, LastSeenAtUtc)`

### 查询 #3: 活动计划状态查询
```sql
SELECT *
FROM ActivityPlans
WHERE CharacterId = @p0
  AND State IN ('Pending', 'Running')
ORDER BY CreatedAt
```
- **执行时间**: 120ms (P95)
- **频率**: 300 次/小时
- **问题**: 缺少复合索引
- **建议**: 添加索引 `ActivityPlans(CharacterId, State, CreatedAt)`

---

## 优化优先级

| 查询 | 频率 | 耗时 | 总影响 | 优先级 |
|------|------|------|--------|--------|
| #1 | 200/h | 180ms | 36s/h | P0 |
| #2 | 60/h | 150ms | 9s/h | P1 |
| #3 | 300/h | 120ms | 36s/h | P0 |

**总影响**: 约 81秒/小时 的数据库查询时间
```

### 4.1.4 验收标准

- [x] EF Core 查询日志已配置并正常输出
- [x] MiniProfiler 已安装并可访问
- [x] 所有 Repository 已审查并记录问题
- [x] N+1 问题清单已编制 (至少识别 3 个问题)
- [x] 慢查询清单已编制 (至少识别 3 个慢查询)
- [x] 优化优先级已确定

### 4.1.5 配置参数

**新增配置节** - `appsettings.json`:

```json
{
  "QueryOptimization": {
    "EnableQueryLogging": true,
    "LogSlowQueries": true,
    "SlowQueryThresholdMs": 100,
    "EnableDetailedQueryLogging": false,
    "EnableMiniProfiler": true,
    "MiniProfilerStorageMinutes": 60
  }
}
```

**配置类** - `BlazorIdle.Server/Config/DatabaseOptimization/QueryOptimizationOptions.cs`:

```csharp
using System.ComponentModel.DataAnnotations;

namespace BlazorIdle.Server.Config.DatabaseOptimization;

/// <summary>
/// 查询优化配置选项
/// Query optimization configuration options
/// </summary>
public class QueryOptimizationOptions
{
    /// <summary>
    /// 是否启用查询日志
    /// Enable query logging
    /// </summary>
    public bool EnableQueryLogging { get; set; } = false;
    
    /// <summary>
    /// 是否记录慢查询
    /// Log slow queries
    /// </summary>
    public bool LogSlowQueries { get; set; } = true;
    
    /// <summary>
    /// 慢查询阈值（毫秒）
    /// Slow query threshold in milliseconds
    /// </summary>
    [Range(10, 10000)]
    public int SlowQueryThresholdMs { get; set; } = 100;
    
    /// <summary>
    /// 是否启用详细查询日志
    /// Enable detailed query logging (includes parameters)
    /// </summary>
    public bool EnableDetailedQueryLogging { get; set; } = false;
    
    /// <summary>
    /// 是否启用 MiniProfiler
    /// Enable MiniProfiler
    /// </summary>
    public bool EnableMiniProfiler { get; set; } = false;
    
    /// <summary>
    /// MiniProfiler 存储时长（分钟）
    /// MiniProfiler storage duration in minutes
    /// </summary>
    [Range(5, 1440)]
    public int MiniProfilerStorageMinutes { get; set; } = 60;
}
```

---

## 🔧 阶段 4.2: 批量查询接口实现

### 4.2.1 目标

提供统一的批量查询接口，避免逐个查询导致的性能问题

### 4.2.2 任务清单

- [ ] **任务 4.2.1**: 设计批量查询接口
- [ ] **任务 4.2.2**: 实现 Repository 基类
- [ ] **任务 4.2.3**: 更新所有 Repository 实现批量接口
- [ ] **任务 4.2.4**: 集成缓存层
- [ ] **任务 4.2.5**: 编写单元测试
- [ ] **任务 4.2.6**: 编写集成测试

### 4.2.3 详细实施步骤

#### 步骤 1: 设计批量查询接口

**文件**: `BlazorIdle.Server/Application/Abstractions/IRepository.cs`

```csharp
namespace BlazorIdle.Server.Application.Abstractions;

/// <summary>
/// 通用仓储接口 - 定义所有仓储的基本操作
/// Generic repository interface - Defines basic operations for all repositories
/// </summary>
/// <typeparam name="T">实体类型 / Entity type</typeparam>
public interface IRepository<T> where T : class, IEntity
{
    /// <summary>
    /// 按 ID 获取单个实体
    /// Get a single entity by ID
    /// </summary>
    Task<T?> GetAsync(Guid id, CancellationToken ct = default);
    
    /// <summary>
    /// 批量获取实体（返回列表）
    /// Batch get entities (returns list)
    /// </summary>
    /// <param name="ids">实体ID列表 / Entity ID list</param>
    /// <param name="ct">取消令牌 / Cancellation token</param>
    /// <returns>实体列表（可能少于请求数量，因为某些ID可能不存在）/ Entity list</returns>
    Task<IReadOnlyList<T>> GetBatchAsync(
        IEnumerable<Guid> ids, 
        CancellationToken ct = default);
    
    /// <summary>
    /// 批量获取实体（返回字典）
    /// Batch get entities (returns dictionary)
    /// </summary>
    /// <param name="ids">实体ID列表 / Entity ID list</param>
    /// <param name="ct">取消令牌 / Cancellation token</param>
    /// <returns>ID → 实体 字典 / ID to entity dictionary</returns>
    Task<IReadOnlyDictionary<Guid, T>> GetDictionaryAsync(
        IEnumerable<Guid> ids, 
        CancellationToken ct = default);
    
    /// <summary>
    /// 获取所有实体（谨慎使用）
    /// Get all entities (use with caution)
    /// </summary>
    /// <param name="maxCount">最大数量限制 / Max count limit</param>
    /// <param name="ct">取消令牌 / Cancellation token</param>
    Task<IReadOnlyList<T>> GetAllAsync(
        int maxCount = 1000, 
        CancellationToken ct = default);
}
```

#### 步骤 2: 实现 Repository 基类

**文件**: `BlazorIdle.Server/Infrastructure/Persistence/Repositories/RepositoryBase.cs`

```csharp
using BlazorIdle.Server.Application.Abstractions;
using BlazorIdle.Server.Infrastructure.DatabaseOptimization.Abstractions;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Logging;

namespace BlazorIdle.Server.Infrastructure.Persistence.Repositories;

/// <summary>
/// 仓储基类 - 提供通用的 CRUD 和批量查询功能
/// Repository base class - Provides common CRUD and batch query functionality
/// </summary>
/// <typeparam name="T">实体类型 / Entity type</typeparam>
public abstract class RepositoryBase<T> : IRepository<T> where T : class, IEntity
{
    protected readonly GameDbContext _db;
    protected readonly IConfiguration _configuration;
    protected readonly IMemoryStateManager<T>? _memoryManager;
    protected readonly ILogger _logger;
    
    protected RepositoryBase(
        GameDbContext db,
        IConfiguration configuration,
        IMemoryStateManager<T>? memoryManager,
        ILogger logger)
    {
        _db = db;
        _configuration = configuration;
        _memoryManager = memoryManager;
        _logger = logger;
    }
    
    /// <inheritdoc />
    public virtual async Task<T?> GetAsync(Guid id, CancellationToken ct = default)
    {
        var enableCaching = _configuration.GetValue<bool>(
            "CacheConfiguration:GlobalSettings:EnableReadCaching", true);
        
        if (enableCaching && _memoryManager != null)
        {
            return await _memoryManager.TryGetAsync(
                id,
                async (id, ct) => await _db.Set<T>()
                    .FirstOrDefaultAsync(e => e.Id == id, ct),
                ct
            );
        }
        else
        {
            return await _db.Set<T>()
                .FirstOrDefaultAsync(e => e.Id == id, ct);
        }
    }
    
    /// <inheritdoc />
    public virtual async Task<IReadOnlyList<T>> GetBatchAsync(
        IEnumerable<Guid> ids, 
        CancellationToken ct = default)
    {
        var idList = ids.ToList();
        
        if (idList.Count == 0)
            return Array.Empty<T>();
        
        // 检查批量大小限制
        var maxBatchSize = _configuration.GetValue<int>(
            "QueryOptimization:MaxBatchSize", 1000);
        
        if (idList.Count > maxBatchSize)
        {
            _logger.LogWarning(
                "批量查询数量 ({Count}) 超过限制 ({MaxBatchSize})，将截断",
                idList.Count, maxBatchSize);
            idList = idList.Take(maxBatchSize).ToList();
        }
        
        var enableCaching = _configuration.GetValue<bool>(
            "CacheConfiguration:GlobalSettings:EnableReadCaching", true);
        
        if (enableCaching && _memoryManager != null)
        {
            // 缓存优先策略
            var result = new List<T>(idList.Count);
            var missedIds = new List<Guid>();
            
            // 1. 先从缓存查找
            foreach (var id in idList)
            {
                var entity = await _memoryManager.TryGetAsync(
                    id,
                    async (_, _) => null, // 不从数据库加载
                    ct
                );
                
                if (entity != null)
                {
                    result.Add(entity);
                }
                else
                {
                    missedIds.Add(id);
                }
            }
            
            // 2. 批量加载未命中的
            if (missedIds.Count > 0)
            {
                _logger.LogDebug(
                    "批量查询 {EntityType}：{Total} 个ID，{CacheHits} 个缓存命中，{CacheMisses} 个需从数据库加载",
                    typeof(T).Name, idList.Count, result.Count, missedIds.Count);
                
                var dbEntities = await _db.Set<T>()
                    .Where(e => missedIds.Contains(e.Id))
                    .ToListAsync(ct);
                
                // 加入缓存
                foreach (var entity in dbEntities)
                {
                    _memoryManager.Add(entity);
                    result.Add(entity);
                }
            }
            
            return result.AsReadOnly();
        }
        else
        {
            // 直接从数据库批量查询
            _logger.LogDebug(
                "批量查询 {EntityType}：{Count} 个ID（无缓存）",
                typeof(T).Name, idList.Count);
            
            var entities = await _db.Set<T>()
                .Where(e => idList.Contains(e.Id))
                .ToListAsync(ct);
            
            return entities.AsReadOnly();
        }
    }
    
    /// <inheritdoc />
    public virtual async Task<IReadOnlyDictionary<Guid, T>> GetDictionaryAsync(
        IEnumerable<Guid> ids, 
        CancellationToken ct = default)
    {
        var entities = await GetBatchAsync(ids, ct);
        return entities.ToDictionary(e => e.Id);
    }
    
    /// <inheritdoc />
    public virtual async Task<IReadOnlyList<T>> GetAllAsync(
        int maxCount = 1000, 
        CancellationToken ct = default)
    {
        _logger.LogWarning(
            "执行 GetAllAsync for {EntityType}，限制数量：{MaxCount}",
            typeof(T).Name, maxCount);
        
        var entities = await _db.Set<T>()
            .Take(maxCount)
            .ToListAsync(ct);
        
        return entities.AsReadOnly();
    }
}
```

#### 步骤 3: 更新 CharacterRepository 实现批量接口

**文件**: `BlazorIdle.Server/Infrastructure/Persistence/Repositories/CharacterRepository.cs`

```csharp
using BlazorIdle.Server.Domain.Characters;

namespace BlazorIdle.Server.Infrastructure.Persistence.Repositories;

/// <summary>
/// 角色数据仓储实现
/// Character repository implementation
/// </summary>
public class CharacterRepository : RepositoryBase<Character>, ICharacterRepository
{
    public CharacterRepository(
        GameDbContext db,
        IConfiguration configuration,
        IMemoryStateManager<Character>? memoryManager,
        ILogger<CharacterRepository> logger)
        : base(db, configuration, memoryManager, logger)
    {
    }
    
    // 继承基类的批量查询方法
    // GetBatchAsync 和 GetDictionaryAsync 已自动可用
    
    // 如果需要特殊的批量查询逻辑，可以重写
    public override async Task<IReadOnlyList<Character>> GetBatchAsync(
        IEnumerable<Guid> ids, 
        CancellationToken ct = default)
    {
        // 可以添加 Character 特定的逻辑
        // 例如：Include 导航属性
        
        var baseResult = await base.GetBatchAsync(ids, ct);
        return baseResult;
    }
    
    /// <summary>
    /// 按用户ID批量获取角色
    /// Get characters by user ID in batch
    /// </summary>
    public async Task<IReadOnlyList<Character>> GetByUserIdAsync(
        Guid userId, 
        CancellationToken ct = default)
    {
        _logger.LogDebug("按用户ID查询角色：{UserId}", userId);
        
        var characters = await _db.Characters
            .Where(c => c.UserId == userId)
            .ToListAsync(ct);
        
        return characters.AsReadOnly();
    }
}
```

#### 步骤 4: 应用批量查询解决 N+1 问题

**示例场景**: 加载角色装备

**优化前** (N+1 问题):
```csharp
// CharactersController.cs
public async Task<IActionResult> GetCharacter(Guid id)
{
    var character = await _characterRepo.GetAsync(id);
    if (character == null)
        return NotFound();
    
    // N+1 问题：逐个加载装备
    var gears = new List<GearInstance>();
    foreach (var slot in character.EquipmentSlots)
    {
        var gear = await _gearRepo.GetAsync(slot.GearId); // N次查询
        if (gear != null)
            gears.Add(gear);
    }
    
    return Ok(new { character, gears });
}
```

**优化后** (批量查询):
```csharp
// CharactersController.cs
public async Task<IActionResult> GetCharacter(Guid id)
{
    var character = await _characterRepo.GetAsync(id);
    if (character == null)
        return NotFound();
    
    // 批量查询：1次数据库访问
    var gearIds = character.EquipmentSlots
        .Where(s => s.GearId.HasValue)
        .Select(s => s.GearId!.Value)
        .ToList();
    
    var gearsDict = await _gearRepo.GetDictionaryAsync(gearIds);
    
    var gears = character.EquipmentSlots
        .Where(s => s.GearId.HasValue && gearsDict.ContainsKey(s.GearId.Value))
        .Select(s => gearsDict[s.GearId!.Value])
        .ToList();
    
    return Ok(new { character, gears });
}
```

### 4.2.4 验收标准

- [x] RepositoryBase 基类已实现并通过编译
- [x] 所有 Repository 已继承基类
- [x] GetBatchAsync 方法可正常工作
- [x] GetDictionaryAsync 方法可正常工作
- [x] 已识别的 N+1 问题已使用批量查询解决
- [x] 单元测试覆盖率 > 80%

### 4.2.5 单元测试

**文件**: `tests/BlazorIdle.Tests/Infrastructure/Repositories/RepositoryBaseTests.cs`

```csharp
using BlazorIdle.Server.Infrastructure.Persistence.Repositories;
using Xunit;

namespace BlazorIdle.Tests.Infrastructure.Repositories;

public class RepositoryBaseTests
{
    [Fact]
    public async Task GetBatchAsync_ValidIds_ReturnsEntities()
    {
        // Arrange
        var ids = new[] { Guid.NewGuid(), Guid.NewGuid(), Guid.NewGuid() };
        // ... 设置 mock
        
        // Act
        var result = await _repository.GetBatchAsync(ids);
        
        // Assert
        Assert.Equal(ids.Length, result.Count);
    }
    
    [Fact]
    public async Task GetBatchAsync_ExceedsMaxBatchSize_Truncates()
    {
        // Arrange
        var ids = Enumerable.Range(0, 1500)
            .Select(_ => Guid.NewGuid())
            .ToList();
        
        // Act
        var result = await _repository.GetBatchAsync(ids);
        
        // Assert
        Assert.True(result.Count <= 1000); // MaxBatchSize
    }
    
    [Fact]
    public async Task GetDictionaryAsync_ValidIds_ReturnsDictionary()
    {
        // Arrange & Act & Assert
        // ... 类似上面
    }
}
```

### 4.2.6 配置参数

**新增配置** - `appsettings.json`:

```json
{
  "QueryOptimization": {
    "EnableBatchQueries": true,
    "DefaultBatchSize": 100,
    "MaxBatchSize": 1000
  }
}
```

---

## ⏱️ 进度跟踪

### 当前进度：阶段 4.1 和 4.2 (上篇前半部分)

- [x] 阶段 4.1: 代码审查与 N+1 检测 (已规划完成)
- [x] 阶段 4.2: 批量查询接口实现 (已规划完成)
- [ ] 阶段 4.3: Include 与 Eager Loading 优化 (下一步)
- [ ] 阶段 4.4: 数据库索引分析与优化 (下一步)
- [ ] 阶段 4.5: 投影优化与 DTO 设计 (下一步)

**注**: 阶段 4.3-4.5 将在后续章节详细说明

---

**文档状态**: 上篇前半部分完成  
**下一步**: 继续编写阶段 4.3-4.5  
**预计完成时间**: 阶段 4 全部完成需 15-20 人日
