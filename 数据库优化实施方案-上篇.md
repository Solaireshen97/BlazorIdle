# BlazorIdle 数据库优化实施方案 - 上篇：基础设施建设

**文档版本**: 1.0  
**阶段**: Phase 1 - 基础设施  
**预计工时**: 48-64 小时（6-8 个工作日）  
**优先级**: P0（必须完成）  
**依赖**: 无  

---

## 📋 目录

1. [阶段目标](#阶段目标)
2. [核心任务清单](#核心任务清单)
3. [详细实施步骤](#详细实施步骤)
4. [代码实现](#代码实现)
5. [测试策略](#测试策略)
6. [验收标准](#验收标准)

---

## 阶段目标

### 主要目标

✅ **建立内存缓冲基础设施**
- 实现 MemoryStateManager 通用组件
- 支持多种实体类型的内存管理
- 提供线程安全的并发访问

✅ **实现持久化协调器**
- 定期批量保存机制
- 可配置的保存策略
- 错误重试和恢复

✅ **增强优雅关闭**
- 监听关闭信号
- 强制最终保存
- 设置所有角色离线

✅ **配置化支持**
- 定义配置选项类
- 支持运行时配置
- 提供合理默认值

### 不改变的部分

- ✅ 现有 API 接口保持不变
- ✅ 数据模型结构不变
- ✅ 业务逻辑不变
- ✅ 客户端代码无需修改

### 成功标准

- [ ] 所有核心组件通过单元测试
- [ ] 集成测试验证基础设施正常工作
- [ ] 性能测试显示无明显性能退化
- [ ] 配置文件可正常加载和应用

---

## 核心任务清单

### Task 1.1: 创建通用接口和抽象 ⏱️ 4-6h

**文件**:
- `BlazorIdle.Server/Application/Abstractions/IMemoryStateManager.cs`
- `BlazorIdle.Server/Application/Abstractions/IEntity.cs`
- `BlazorIdle.Server/Application/Abstractions/IPersistenceCoordinator.cs`

**任务**:
1. 定义 `IEntity` 接口（所有需要内存管理的实体）
2. 定义 `IMemoryStateManager<T>` 接口
3. 定义 `IPersistenceCoordinator` 接口
4. 添加 XML 文档注释

**验收**:
- [ ] 接口编译通过
- [ ] 注释完整清晰
- [ ] 遵循 SOLID 原则

---

### Task 1.2: 实现 MemoryStateManager ⏱️ 12-16h

**文件**:
- `BlazorIdle.Server/Infrastructure/Memory/MemoryStateManager.cs`
- `BlazorIdle.Server/Infrastructure/Memory/DirtyTracker.cs`

**任务**:
1. 实现内存存储（ConcurrentDictionary）
2. 实现 Dirty 追踪
3. 实现读写锁保护快照操作
4. 实现 LRU 缓存清理策略
5. 添加日志记录
6. 编写单元测试

**关键实现点**:

```csharp
public class MemoryStateManager<T> : IMemoryStateManager<T> 
    where T : class, IEntity
{
    private readonly ConcurrentDictionary<Guid, T> _store;
    private readonly ConcurrentDictionary<Guid, DateTime> _dirtyEntities;
    private readonly ConcurrentDictionary<Guid, DateTime> _accessTimes; // LRU
    private readonly ReaderWriterLockSlim _lock;
    private readonly MemoryCacheOptions _options;
    private readonly ILogger<MemoryStateManager<T>> _logger;
    
    // 核心方法
    public async Task<T?> GetAsync(Guid id, CancellationToken ct);
    public void Update(T entity);
    public void Add(T entity);
    public void Remove(Guid id);
    public IEnumerable<(Guid Id, T Entity)> GetDirtyEntities();
    public void ClearDirty(IEnumerable<Guid> ids);
    public IReadOnlyDictionary<Guid, T> GetSnapshot();
    
    // 辅助方法
    private void EvictIfNeeded();
    private void UpdateAccessTime(Guid id);
}
```

**单元测试覆盖**:
- [ ] 并发读写测试
- [ ] Dirty 追踪测试
- [ ] LRU 清理测试
- [ ] 快照隔离测试

**验收**:
- [ ] 所有单元测试通过
- [ ] 代码覆盖率 > 90%
- [ ] 并发压力测试通过（1000+ 并发操作）

---

### Task 1.3: 实现 PersistenceCoordinator ⏱️ 16-20h

**文件**:
- `BlazorIdle.Server/Infrastructure/Persistence/PersistenceCoordinator.cs`
- `BlazorIdle.Server/Infrastructure/Persistence/BatchSaveStrategy.cs`

**任务**:
1. 继承 BackgroundService
2. 实现定期保存循环
3. 实现批量保存逻辑
4. 实现分实体类型保存策略
5. 实现重试机制
6. 实现关闭时最终保存
7. 添加性能监控埋点
8. 编写集成测试

**核心实现**:

```csharp
public class PersistenceCoordinator : BackgroundService
{
    private readonly IServiceScopeFactory _scopeFactory;
    private readonly IOptions<PersistenceOptions> _options;
    private readonly ILogger<PersistenceCoordinator> _logger;
    
    // 各类型实体的状态管理器
    private MemoryStateManager<Character> _characterManager;
    private MemoryStateManager<RunningBattleSnapshotRecord> _battleSnapshotManager;
    private MemoryStateManager<ActivityPlan> _activityPlanManager;
    
    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        _logger.LogInformation("持久化协调器已启动");
        
        while (!stoppingToken.IsCancellationRequested)
        {
            try
            {
                await Task.Delay(_options.Value.SaveIntervalMs, stoppingToken);
                await PeriodicSaveAsync(stoppingToken);
            }
            catch (OperationCanceledException)
            {
                _logger.LogInformation("持久化协调器停止信号已接收");
                break;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "定期保存发生错误");
            }
        }
        
        // 关闭时最终保存
        await FinalSaveAsync();
        _logger.LogInformation("持久化协调器已停止");
    }
    
    private async Task PeriodicSaveAsync(CancellationToken ct)
    {
        var sw = Stopwatch.StartNew();
        
        using var scope = _scopeFactory.CreateScope();
        var db = scope.ServiceProvider.GetRequiredService<GameDbContext>();
        
        // 按策略保存不同实体类型
        int totalSaved = 0;
        
        // 战斗快照（如果到了保存时间）
        if (ShouldSave("BattleSnapshot"))
        {
            totalSaved += await SaveEntityTypeAsync(
                _battleSnapshotManager, 
                db.RunningBattleSnapshots, 
                ct
            );
        }
        
        // 角色心跳
        if (ShouldSave("CharacterHeartbeat"))
        {
            totalSaved += await SaveEntityTypeAsync(
                _characterManager,
                db.Characters,
                ct
            );
        }
        
        // 活动计划
        if (ShouldSave("ActivityPlan"))
        {
            totalSaved += await SaveEntityTypeAsync(
                _activityPlanManager,
                db.ActivityPlans,
                ct
            );
        }
        
        sw.Stop();
        
        if (totalSaved > 0)
        {
            _logger.LogInformation(
                "定期保存完成：{Count} 个实体，耗时 {ElapsedMs}ms",
                totalSaved, sw.ElapsedMilliseconds
            );
        }
    }
    
    private async Task<int> SaveEntityTypeAsync<T>(
        MemoryStateManager<T> manager,
        DbSet<T> dbSet,
        CancellationToken ct) where T : class, IEntity
    {
        var dirtyEntities = manager.GetDirtyEntities().ToList();
        if (!dirtyEntities.Any())
            return 0;
            
        var maxBatch = _options.Value.MaxBatchSize;
        var batches = dirtyEntities.Chunk(maxBatch);
        
        int saved = 0;
        foreach (var batch in batches)
        {
            foreach (var (id, entity) in batch)
            {
                dbSet.Update(entity);
            }
            
            await DatabaseRetryPolicy.SaveChangesWithRetryAsync(
                dbSet.Context as GameDbContext, 
                ct, 
                _logger
            );
            
            manager.ClearDirty(batch.Select(x => x.Id));
            saved += batch.Length;
        }
        
        return saved;
    }
    
    public async Task FinalSaveAsync()
    {
        _logger.LogWarning("执行最终保存...");
        
        var sw = Stopwatch.StartNew();
        
        using var scope = _scopeFactory.CreateScope();
        var db = scope.ServiceProvider.GetRequiredService<GameDbContext>();
        
        // 强制保存所有 Dirty 实体
        int totalSaved = 0;
        totalSaved += await SaveEntityTypeAsync(_battleSnapshotManager, db.RunningBattleSnapshots, CancellationToken.None);
        totalSaved += await SaveEntityTypeAsync(_characterManager, db.Characters, CancellationToken.None);
        totalSaved += await SaveEntityTypeAsync(_activityPlanManager, db.ActivityPlans, CancellationToken.None);
        
        sw.Stop();
        
        _logger.LogInformation(
            "最终保存完成：{Count} 个实体，耗时 {ElapsedMs}ms",
            totalSaved, sw.ElapsedMilliseconds
        );
    }
    
    private bool ShouldSave(string entityType)
    {
        // 根据配置的保存策略判断是否应该保存
        // 实现省略...
    }
}
```

**集成测试场景**:
- [ ] 启动后正常定期保存
- [ ] 停止时触发最终保存
- [ ] 保存失败重试机制
- [ ] 大批量数据保存性能

**验收**:
- [ ] 集成测试通过
- [ ] 日志输出完整
- [ ] 性能符合预期（批量保存 < 500ms）

---

### Task 1.4: 增强 ShutdownManager ⏱️ 8-10h

**文件**:
- `BlazorIdle.Server/Services/EnhancedShutdownManager.cs`

**任务**:
1. 替换现有 GracefulShutdownCoordinator
2. 集成 PersistenceCoordinator 最终保存
3. 实现设置所有角色离线功能
4. 实现超时保护
5. 添加日志和监控
6. 编写集成测试

**核心实现**:

```csharp
public class EnhancedShutdownManager : IHostedService
{
    private readonly IHostApplicationLifetime _appLifetime;
    private readonly IServiceScopeFactory _scopeFactory;
    private readonly PersistenceCoordinator _persistenceCoordinator;
    private readonly IOptions<ShutdownOptions> _options;
    private readonly ILogger<EnhancedShutdownManager> _logger;
    private readonly CancellationTokenSource _shutdownCts = new();
    
    public static CancellationToken ShutdownToken => _instance?._shutdownCts.Token ?? CancellationToken.None;
    private static EnhancedShutdownManager? _instance;
    
    public Task StartAsync(CancellationToken cancellationToken)
    {
        _instance = this;
        _logger.LogInformation("增强的关闭管理器已启动");
        
        _appLifetime.ApplicationStopping.Register(() =>
        {
            _logger.LogWarning("========================================");
            _logger.LogWarning("服务器关闭开始 - 执行优雅关闭流程");
            _logger.LogWarning("========================================");
            
            // 触发关闭信号
            _shutdownCts.Cancel();
            
            // 执行关闭流程（同步等待）
            ExecuteShutdownAsync().GetAwaiter().GetResult();
        });
        
        return Task.CompletedTask;
    }
    
    private async Task ExecuteShutdownAsync()
    {
        var sw = Stopwatch.StartNew();
        
        try
        {
            // Step 1: 触发协调器最终保存
            _logger.LogInformation("[1/3] 开始保存所有数据...");
            var saveTask = _persistenceCoordinator.FinalSaveAsync();
            
            // Step 2: 设置所有角色离线
            _logger.LogInformation("[2/3] 设置所有在线角色为离线...");
            var offlineTask = SetAllCharactersOfflineAsync();
            
            // Step 3: 等待任务完成（带超时）
            var timeoutTask = Task.Delay(
                TimeSpan.FromSeconds(_options.Value.ShutdownTimeoutSeconds)
            );
            
            var completedTask = await Task.WhenAny(
                Task.WhenAll(saveTask, offlineTask),
                timeoutTask
            );
            
            if (completedTask == timeoutTask)
            {
                _logger.LogWarning("关闭流程超时（{Timeout}秒），强制继续",
                    _options.Value.ShutdownTimeoutSeconds);
            }
            else
            {
                _logger.LogInformation("[3/3] 所有关闭任务已完成");
            }
            
            // Step 4: 强制执行 WAL 检查点（如果配置启用）
            if (_options.Value.ForceWalCheckpointOnShutdown)
            {
                _logger.LogInformation("执行 WAL 检查点...");
                await ForceWalCheckpointAsync();
            }
            
            sw.Stop();
            
            _logger.LogInformation("========================================");
            _logger.LogInformation("优雅关闭流程完成，耗时 {ElapsedMs}ms", sw.ElapsedMilliseconds);
            _logger.LogInformation("========================================");
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "关闭流程发生错误");
        }
    }
    
    private async Task SetAllCharactersOfflineAsync()
    {
        using var scope = _scopeFactory.CreateScope();
        var db = scope.ServiceProvider.GetRequiredService<GameDbContext>();
        
        var sw = Stopwatch.StartNew();
        
        try
        {
            // 使用 ExecuteUpdateAsync 批量更新（EF Core 7+）
            int updatedCount = await db.Characters
                .Where(c => c.IsOnline)
                .ExecuteUpdateAsync(setters => setters
                    .SetProperty(c => c.IsOnline, false)
                    .SetProperty(c => c.LastSeenAtUtc, DateTime.UtcNow)
                );
            
            sw.Stop();
            
            _logger.LogInformation(
                "已将 {Count} 个在线角色设置为离线（耗时 {ElapsedMs}ms）",
                updatedCount, sw.ElapsedMilliseconds
            );
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "设置角色离线时发生错误");
            
            // 降级方案：逐个更新
            await SetCharactersOfflineFallbackAsync(db);
        }
    }
    
    private async Task SetCharactersOfflineFallbackAsync(GameDbContext db)
    {
        var onlineCharacters = await db.Characters
            .Where(c => c.IsOnline)
            .ToListAsync();
            
        foreach (var character in onlineCharacters)
        {
            character.IsOnline = false;
            character.LastSeenAtUtc = DateTime.UtcNow;
        }
        
        await db.SaveChangesAsync();
        
        _logger.LogInformation(
            "使用降级方案设置了 {Count} 个角色为离线",
            onlineCharacters.Count
        );
    }
    
    private async Task ForceWalCheckpointAsync()
    {
        using var scope = _scopeFactory.CreateScope();
        var db = scope.ServiceProvider.GetRequiredService<GameDbContext>();
        
        await db.Database.ExecuteSqlRawAsync("PRAGMA wal_checkpoint(TRUNCATE)");
        
        _logger.LogInformation("WAL 检查点已执行");
    }
    
    public Task StopAsync(CancellationToken cancellationToken)
    {
        _logger.LogInformation("增强的关闭管理器已停止");
        _shutdownCts.Dispose();
        return Task.CompletedTask;
    }
}
```

**集成测试场景**:
- [ ] 正常关闭流程完整执行
- [ ] 超时保护生效
- [ ] 所有在线角色正确设为离线
- [ ] WAL 检查点正确执行

**验收**:
- [ ] 测试通过
- [ ] 日志完整清晰
- [ ] 关闭时间 < 30 秒

---

### Task 1.5: 配置选项定义和注册 ⏱️ 4-6h

**文件**:
- `BlazorIdle.Server/Config/PersistenceOptions.cs`
- `BlazorIdle.Server/Config/ShutdownOptions.cs`
- `BlazorIdle.Server/Config/MemoryCacheOptions.cs`

**任务**:
1. 定义配置类
2. 添加数据验证特性
3. 提供默认值
4. 在 Program.cs 注册
5. 更新 appsettings.json
6. 编写配置验证测试

**配置类实现**:

```csharp
/// <summary>
/// 持久化配置选项
/// </summary>
public class PersistenceOptions
{
    /// <summary>
    /// 是否启用内存缓冲（用于回退）
    /// </summary>
    public bool EnableMemoryBuffering { get; set; } = true;
    
    /// <summary>
    /// 定期保存间隔（毫秒）
    /// </summary>
    [Range(1000, 300000)]
    public int SaveIntervalMs { get; set; } = 30000; // 30秒
    
    /// <summary>
    /// 批量保存大小限制
    /// </summary>
    [Range(100, 10000)]
    public int MaxBatchSize { get; set; } = 1000;
    
    /// <summary>
    /// 强制保存阈值（Dirty 实体数量）
    /// </summary>
    [Range(1000, 100000)]
    public int ForceSaveThreshold { get; set; } = 5000;
    
    /// <summary>
    /// 保存失败重试次数
    /// </summary>
    [Range(1, 10)]
    public int SaveRetryAttempts { get; set; } = 3;
    
    /// <summary>
    /// 不同实体类型的保存策略
    /// </summary>
    public Dictionary<string, EntitySaveStrategy> EntitySaveStrategies { get; set; } = new();
}

/// <summary>
/// 实体保存策略
/// </summary>
public class EntitySaveStrategy
{
    [Range(1000, 600000)]
    public int SaveIntervalMs { get; set; }
    
    [Range(10, 5000)]
    public int MaxBatchSize { get; set; }
}

/// <summary>
/// 关闭配置选项
/// </summary>
public class ShutdownOptions
{
    /// <summary>
    /// 优雅关闭超时（秒）
    /// </summary>
    [Range(10, 300)]
    public int ShutdownTimeoutSeconds { get; set; } = 30;
    
    /// <summary>
    /// 是否在关闭时设置所有角色为离线
    /// </summary>
    public bool SetCharactersOfflineOnShutdown { get; set; } = true;
    
    /// <summary>
    /// 是否在关闭时强制执行 WAL 检查点
    /// </summary>
    public bool ForceWalCheckpointOnShutdown { get; set; } = true;
    
    /// <summary>
    /// 关闭时保存重试次数
    /// </summary>
    [Range(1, 10)]
    public int ShutdownSaveRetryAttempts { get; set; } = 5;
}

/// <summary>
/// 内存缓存配置选项
/// </summary>
public class MemoryCacheOptions
{
    /// <summary>
    /// 内存缓存最大实体数（防止内存溢出）
    /// </summary>
    [Range(1000, 1000000)]
    public int MaxCachedEntities { get; set; } = 100000;
    
    /// <summary>
    /// 超过阈值时的清理策略（LRU / TTL）
    /// </summary>
    public string EvictionPolicy { get; set; } = "LRU";
    
    /// <summary>
    /// TTL（秒，仅当 EvictionPolicy = TTL）
    /// </summary>
    [Range(60, 86400)]
    public int TimeToLiveSeconds { get; set; } = 3600;
}
```

**appsettings.json 更新**:

```json
{
  "Persistence": {
    "EnableMemoryBuffering": true,
    "SaveIntervalMs": 30000,
    "MaxBatchSize": 1000,
    "ForceSaveThreshold": 5000,
    "SaveRetryAttempts": 3,
    "EntitySaveStrategies": {
      "BattleSnapshot": {
        "SaveIntervalMs": 60000,
        "MaxBatchSize": 500
      },
      "CharacterHeartbeat": {
        "SaveIntervalMs": 300000,
        "MaxBatchSize": 1000
      },
      "ActivityPlan": {
        "SaveIntervalMs": 30000,
        "MaxBatchSize": 200
      }
    }
  },
  "Shutdown": {
    "ShutdownTimeoutSeconds": 30,
    "SetCharactersOfflineOnShutdown": true,
    "ForceWalCheckpointOnShutdown": true,
    "ShutdownSaveRetryAttempts": 5
  },
  "MemoryCache": {
    "MaxCachedEntities": 100000,
    "EvictionPolicy": "LRU",
    "TimeToLiveSeconds": 3600
  }
}
```

**Program.cs 注册**:

```csharp
// 配置选项注册
builder.Services.Configure<PersistenceOptions>(
    builder.Configuration.GetSection("Persistence"));
builder.Services.Configure<ShutdownOptions>(
    builder.Configuration.GetSection("Shutdown"));
builder.Services.Configure<MemoryCacheOptions>(
    builder.Configuration.GetSection("MemoryCache"));

// 配置验证
builder.Services.AddOptions<PersistenceOptions>()
    .Bind(builder.Configuration.GetSection("Persistence"))
    .ValidateDataAnnotations()
    .ValidateOnStart();
```

**验收**:
- [ ] 配置正常加载
- [ ] 验证规则生效
- [ ] 默认值正确

---

### Task 1.6: 依赖注入和服务注册 ⏱️ 4-6h

**文件**:
- `BlazorIdle.Server/Infrastructure/DependencyInjection.cs`

**任务**:
1. 注册 MemoryStateManager 为单例
2. 注册 PersistenceCoordinator 为后台服务
3. 替换 GracefulShutdownCoordinator 为 EnhancedShutdownManager
4. 更新 Program.cs

**DependencyInjection.cs 更新**:

```csharp
public static class DependencyInjection
{
    public static IServiceCollection AddInfrastructure(
        this IServiceCollection services, 
        IConfiguration configuration)
    {
        // ... 现有代码 ...
        
        // 内存状态管理器（单例 - 全局共享）
        services.AddSingleton<MemoryStateManager<Character>>();
        services.AddSingleton<MemoryStateManager<RunningBattleSnapshotRecord>>();
        services.AddSingleton<MemoryStateManager<ActivityPlan>>();
        
        // 持久化协调器（后台服务）
        services.AddHostedService<PersistenceCoordinator>();
        
        // 增强的关闭管理器（优先注册，最先接收关闭信号）
        services.AddHostedService<EnhancedShutdownManager>();
        
        return services;
    }
}
```

**验收**:
- [ ] 服务正常启动
- [ ] 依赖注入正常工作
- [ ] 服务生命周期正确

---

## 测试策略

### 单元测试

**测试项目**: `BlazorIdle.Server.Tests`

**覆盖范围**:
1. MemoryStateManager
   - 并发读写
   - Dirty 追踪
   - LRU 清理
   - 快照隔离

2. PersistenceCoordinator
   - 批量保存逻辑
   - 重试机制
   - 最终保存

3. EnhancedShutdownManager
   - 关闭流程
   - 超时保护
   - 设置角色离线

**测试工具**:
- xUnit
- Moq
- FluentAssertions

### 集成测试

**测试场景**:
1. 启动流程
   - 所有服务正常启动
   - 配置正确加载

2. 运行时行为
   - 定期保存正常触发
   - 批量保存正确执行

3. 关闭流程
   - 优雅关闭完整执行
   - 所有数据正确保存
   - 角色状态正确更新

### 性能测试

**测试指标**:
- 内存使用（不超过 +200MB）
- CPU 使用（不超过 +10%）
- 批量保存时间（< 500ms for 1000 entities）
- 关闭时间（< 30s）

---

## 验收标准

### 功能完整性

- [ ] 所有核心类实现完成
- [ ] 所有接口定义完成
- [ ] 配置选项完整

### 代码质量

- [ ] 单元测试覆盖率 > 90%
- [ ] 所有测试通过
- [ ] 代码审查通过
- [ ] 遵循编码规范

### 性能要求

- [ ] 并发测试通过（1000+ 并发操作）
- [ ] 内存占用符合预期
- [ ] 批量保存性能达标

### 文档完整性

- [ ] 所有公共 API 有 XML 注释
- [ ] README 更新
- [ ] 配置说明文档

### 兼容性

- [ ] 现有 API 接口不变
- [ ] 数据模型不变
- [ ] 向后兼容

---

## 风险和缓解

### 风险 1: 时间估算不准

**缓解**:
- 预留 20% 缓冲时间
- 每日进度跟踪
- 及时调整计划

### 风险 2: 并发问题

**缓解**:
- 充分的并发测试
- 使用成熟的并发工具（ConcurrentDictionary）
- Code Review 重点关注线程安全

### 风险 3: 集成问题

**缓解**:
- 分步集成测试
- 保留回退机制
- 详细日志记录

---

## 下一步

完成上篇后，进入中篇：**高频操作迁移**

预览中篇核心任务：
1. 迁移角色心跳到内存管理
2. 迁移战斗快照到内存管理
3. 迁移活动计划到内存管理
4. 全面测试和验证

---

**文档状态**: ✅ 待实施  
**开始前准备**:
1. [ ] 创建 Feature 分支
2. [ ] 配置开发环境
3. [ ] 审阅本文档
4. [ ] 分配开发任务
