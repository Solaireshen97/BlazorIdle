# 离线战斗系统实施方案

> 📋 本文档提供离线战斗系统的完整实施方案，包含需求分析、缺失组件、详细实施步骤和测试计划。

---

## 📌 问题描述

当前项目已实现：
- ✅ 账号创建角色
- ✅ 角色可以创建活动计划
- ✅ 活动计划支持长时间战斗放置
- ✅ 在线战斗事件解锁

**需要实现的功能**：
用户在线设置战斗计划后，即使下线或关闭网页，系统也能记录离线期间的战斗事件，等用户下次上线时：
1. 自动计算离线期间的收益
2. 展示离线收益详情（时长、金币、经验、物品）
3. 如果计划未完成，继续执行剩余任务
4. 如果计划已完成，自动启动下一个待执行的计划

---

## ✅ 当前实施状态

### 已有组件（可直接使用）
- ✅ **ActivityPlan模型** - 完整的活动计划系统
- ✅ **ActivityPlanService** - 计划创建、启动、停止服务
- ✅ **BattleSimulator** - 战斗快进模拟器
- ✅ **OfflineSettlementService（基础版）** - 手动离线结算
- ✅ **Character实体** - 已包含`LastSeenAtUtc`和`LastOfflineSettledAtUtc`字段

### 缺失组件（需要实现）

#### 后端核心组件
1. **OfflineFastForwardEngine** - 专用离线快进引擎 🔴 高优先级
2. **自动离线检测机制** - 登录时自动触发离线结算 🔴 高优先级
3. **活动计划自动衔接** - 完善计划完成后的自动启动逻辑 🔴 高优先级
4. **新增API端点**：
   - `GET /api/offline/check` - 检查离线收益
   - `POST /api/offline/apply` - 应用离线结算
   - `POST /api/characters/{id}/heartbeat` - 更新心跳

#### 前端组件
1. **OfflineSettlementDialog组件** - 离线结算弹窗 🔴 高优先级
2. **ApiClient扩展** - 离线API调用方法
3. **Characters页面集成** - 加载时自动检查离线收益

---

## 📚 完整文档

所有详细文档位于 `docs/` 目录：

### 1. 快速开始（推荐首先阅读）
📄 **文件**: `docs/离线战斗快速开始.md`

**内容**:
- 5分钟快速了解核心概念
- 需要新增的代码清单（含代码框架）
- 按步骤的实施指南
- 测试方法和常见问题

**适合**: 开发者快速上手实施

---

### 2. 实施总结（中文详细版）
📄 **文件**: `docs/离线战斗系统实施总结.md`

**内容**:
- 核心需求与设计原则
- 已有vs缺失组件对比
- 详细实施步骤（含完整代码示例）
- 完整流程示例（带时间轴）
- 数据模型、配置项、测试要点
- 预估工作量：5-6天

**适合**: 需要全面理解的开发者和技术负责人

---

### 3. 流程图文档
📄 **文件**: `docs/离线战斗流程图.md`

**内容**:
- 用户上线完整流程图
- 后端离线收益计算流程
- OfflineFastForwardEngine工作流程
- 活动计划自动衔接流程
- 前端用户交互流程
- 时间轴示例
- 边界情况处理

**适合**: 视觉学习者，需要理解系统流程

---

### 4. 详细实施方案（英文完整版）
📄 **文件**: `docs/OfflineBattleImplementationPlan.md`

**内容**:
- 完整需求分析
- 当前实现状态详细分析
- 缺失组件清单（含优先级）
- 分阶段实施方案（Phase 1-4）
- 数据库变更设计
- API设计（含请求/响应示例）
- 前端集成方案
- 测试验证计划
- 风险与注意事项

**适合**: 架构师、技术负责人进行全面评估

---

### 5. 文档索引
📄 **文件**: `docs/离线战斗文档索引.md`

**内容**:
- 所有文档的完整索引
- 推荐阅读顺序
- 核心概念速查
- 数据模型速查
- 配置速查
- 测试检查清单

**适合**: 查找特定信息

---

## 🎯 快速实施路径

### Phase 1: 核心功能（必须实现，2-3天）

1. **创建OfflineFastForwardEngine**
   - 文件: `BlazorIdle.Server/Application/Battles/Offline/OfflineFastForwardEngine.cs`
   - 功能: 快进模拟离线期间的战斗

2. **扩展OfflineSettlementService**
   - 文件: `BlazorIdle.Server/Application/Battles/Offline/Offline.cs`
   - 新增: `CheckAndSettleAsync()` 方法
   - 功能: 登录时自动检测并结算离线收益

3. **添加API端点**
   - 文件: `BlazorIdle.Server/Api/OfflineController.cs`
   - 新增: `/api/offline/check` 和 `/api/offline/apply`

4. **前端集成**
   - 创建: `BlazorIdle/Components/OfflineSettlementDialog.razor`
   - 修改: `BlazorIdle/Pages/Characters.razor`
   - 扩展: `BlazorIdle/Services/ApiClient.cs`

### Phase 2: 测试与优化（1-2天）

5. **单元测试**
   - OfflineFastForwardEngine测试
   - 时长计算测试
   - 计划状态更新测试

6. **集成测试**
   - 完整离线流程测试
   - 自动衔接测试
   - 边界情况测试

7. **手动测试**
   - UI展示验证
   - 数据准确性验证
   - 用户体验验证

---

## 🔧 核心技术要点

### 1. 离线时长计算
```csharp
// 用户上线时计算离线时长
var offlineSeconds = (DateTime.UtcNow - character.LastSeenAtUtc).TotalSeconds;

// 应用12小时上限
var cappedSeconds = Math.Min(offlineSeconds, 43200); // 12小时
```

### 2. 计划剩余时长处理
```csharp
// Duration类型计划
if (plan.LimitType == LimitType.Duration)
{
    var remaining = plan.LimitValue - plan.ExecutedSeconds;
    var simulated = Math.Min(remaining, cappedSeconds);
}

// Infinite类型计划
if (plan.LimitType == LimitType.Infinite)
{
    var simulated = cappedSeconds; // 模拟全部离线时长
}
```

### 3. 活动计划自动衔接
```csharp
// 当前计划完成后
if (plan.IsLimitReached())
{
    plan.State = ActivityState.Completed;
    
    // 查找并启动下一个Pending计划
    var nextPlan = await FindNextPendingPlanAsync(characterId);
    if (nextPlan != null)
    {
        await StartPlanAsync(nextPlan.Id);
    }
}
```

---

## 📊 关键数据结构

### OfflineFastForwardResult
离线快进结果

```csharp
{
    CharacterId: Guid,           // 角色ID
    PlanId: Guid,                // 计划ID
    SimulatedSeconds: double,    // 模拟时长
    PlanCompleted: bool,         // 计划是否完成
    Gold: long,                  // 金币收益
    Exp: long,                   // 经验收益
    Loot: Dictionary<string, double>  // 物品掉落
}
```

### OfflineCheckResult
离线检查结果

```csharp
{
    HasOfflineTime: bool,        // 是否有离线时间
    OfflineSeconds: double,      // 离线总时长
    HasRunningPlan: bool,        // 是否有运行计划
    Settlement: OfflineFastForwardResult?,  // 结算结果
    PlanCompleted: bool,         // 计划是否完成
    NextPlanStarted: bool,       // 是否启动下一个
    NextPlanId: Guid?            // 下一个计划ID
}
```

---

## ⚙️ 配置项

在 `appsettings.json` 中添加：

```json
{
  "Offline": {
    "MaxOfflineSeconds": 43200,     // 12小时上限（可调整）
    "EnableAutoSettlement": true    // 是否启用自动结算
  }
}
```

---

## 🧪 测试验证

### 快速手动测试步骤

1. **创建角色和计划**
```bash
# 创建角色
POST /api/characters
{
  "name": "TestChar",
  "profession": "Warrior"
}

# 创建1小时战斗计划
POST /api/activity-plans/combat?characterId=xxx&limitType=duration&limitValue=3600
```

2. **模拟离线**
```sql
-- 直接修改数据库，将LastSeenAtUtc设为1小时前
UPDATE Characters 
SET LastSeenAtUtc = datetime('now', '-1 hour')
WHERE Id = 'your-character-id';
```

3. **重新登录验证**
- 打开Characters页面
- 应该看到离线结算弹窗
- 检查显示的收益（金币、经验、击杀）
- 点击"确认领取"
- 验证角色数据已更新

---

## 📈 预估工作量

| 任务 | 时间 |
|------|------|
| 后端核心实现 | 2-3天 |
| 前端集成 | 1-2天 |
| 测试与优化 | 1-2天 |
| **总计** | **4-7天** |

---

## ⚠️ 注意事项

### 关键风险点

1. **时间同步** - 所有时间使用UTC，服务端权威
2. **并发控制** - 防止重复结算，使用事务保护
3. **性能考虑** - 12小时快进可能耗时，设置合理超时
4. **游戏平衡** - 12小时上限保护，防止过度挂机

### 最佳实践

1. 使用`BattleSimulator`的快进功能（已优化）
2. 生成聚合的`CombatSegment`而非逐事件存储
3. 两阶段提交：先返回预览，用户确认后再发放
4. 记录离线结算历史（可选，用于审计）

---

## ✅ 完成标志

系统实施完成的标志：

- ✅ 用户下线后再上线能看到离线收益弹窗
- ✅ 离线收益数据准确（金币、经验、击杀）
- ✅ 点击领取后角色数据正确更新
- ✅ 活动计划状态正确（完成/继续）
- ✅ 如果计划完成，下一个计划自动启动
- ✅ 所有单元测试和集成测试通过

---

## �� 下一步

1. **阅读快速开始文档**
   ```
   docs/离线战斗快速开始.md
   ```

2. **查看流程图理解系统**
   ```
   docs/离线战斗流程图.md
   ```

3. **参考详细实施方案**
   ```
   docs/离线战斗系统实施总结.md
   docs/OfflineBattleImplementationPlan.md
   ```

4. **开始实施**
   - 按照Phase 1的步骤逐步实现
   - 每完成一个组件进行单元测试
   - 完成后进行集成测试

---

## 💬 获取帮助

如果在实施过程中遇到问题，请参考：

- **代码实现问题**: `docs/离线战斗快速开始.md`
- **流程理解问题**: `docs/离线战斗流程图.md`
- **详细设计问题**: `docs/OfflineBattleImplementationPlan.md`
- **查找特定信息**: `docs/离线战斗文档索引.md`

---

**开始实施吧！** 🚀

所有文档已准备就绪，祝实施顺利！
