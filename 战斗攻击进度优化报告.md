# 战斗攻击进度优化实施报告

## 概述

本次优化针对游戏内战斗系统的攻击进度机制进行了改进，实现了以下目标：

1. **攻击进度从怪物刷新后从0开始**
2. **攻击进度连续增长直到触发攻击**
3. **怪物死亡或切换目标时重置攻击进度**
4. **前端UI显示平滑的进度条动画**

## 实施内容

### 1. 后端战斗引擎修改

#### 1.1 添加攻击进度重置方法

在 `BattleEngine.cs` 中新增 `ResetAttackProgress()` 方法：

```csharp
// 重置攻击进度：将攻击Track的下次触发时间设为当前时间 + 攻击间隔
private void ResetAttackProgress()
{
    var attackTrack = Context.Tracks.FirstOrDefault(t => t.TrackType == TrackType.Attack);
    if (attackTrack is not null)
    {
        attackTrack.NextTriggerAt = Clock.CurrentTime + attackTrack.CurrentInterval;
    }
}
```

#### 1.2 怪物刷新时重置攻击进度

修改 `TryPerformPendingSpawn()` 方法，在新一波怪物刷新后调用重置：

```csharp
private void TryPerformPendingSpawn()
{
    if (_waitingSpawn && _pendingSpawnAt.HasValue && _pendingNextGroup is not null && 
        Clock.CurrentTime + 1e-9 >= _pendingSpawnAt.Value)
    {
        Context.ResetEncounterGroup(_pendingNextGroup);
        Context.RefreshPrimaryEncounter();

        _pendingNextGroup = null;
        _pendingSpawnAt = null;
        _waitingSpawn = false;

        ClearDeathMarks();

        // 重置攻击进度：怪物刷新后从0开始
        ResetAttackProgress();

        Collector.OnTag("spawn_performed", 1);
    }
}
```

#### 1.3 目标切换时重置攻击进度

修改 `TryRetargetPrimaryIfDead()` 方法，在切换目标后调用重置：

```csharp
private void TryRetargetPrimaryIfDead()
{
    if (_waitingSpawn) return;
    var grp = Context.EncounterGroup;
    if (grp is null) return;

    if (Context.Encounter is null || Context.Encounter.IsDead)
    {
        var next = grp.PrimaryAlive();
        if (next is not null && !next.IsDead)
        {
            Context.RefreshPrimaryEncounter();
            Collector.OnTag("retarget_primary", 1);
            
            // 重置攻击进度：切换目标后从0开始
            ResetAttackProgress();
        }
    }
}
```

### 2. DTO数据传输优化

#### 2.1 添加攻击间隔字段

在 `StepBattleStatusDto` (后端) 和 `StepStatusResponse` (前端) 中添加攻击间隔字段：

```csharp
/// <summary>普通攻击间隔（秒）</summary>
public double AttackIntervalSeconds { get; set; }

/// <summary>特殊攻击间隔（秒）</summary>
public double SpecialIntervalSeconds { get; set; }
```

#### 2.2 填充攻击间隔数据

在 `StepBattleCoordinator.cs` 的 `GetStatus()` 方法中填充这些字段：

```csharp
// 获取下次攻击时间及间隔
double? nextAttackAt = null;
double? nextSpecialAt = null;
double attackInterval = rb.Engine.Battle.AttackIntervalSeconds;
double specialInterval = rb.Engine.Battle.SpecialIntervalSeconds;
foreach (var track in ctx2.Tracks)
{
    if (track.TrackType == Domain.Combat.TrackType.Attack)
    {
        nextAttackAt = track.NextTriggerAt;
        attackInterval = track.CurrentInterval;
    }
    else if (track.TrackType == Domain.Combat.TrackType.Special)
    {
        nextSpecialAt = track.NextTriggerAt;
        specialInterval = track.CurrentInterval;
    }
}
```

### 3. 前端UI优化

#### 3.1 改进进度条计算逻辑

在 `Characters.razor` 中修改攻击进度的计算方式，从二进制（0或1）改为连续进度：

**修改前：**
```csharp
var attackProgress = currentPlanBattle.CurrentTime >= currentPlanBattle.NextAttackAt.Value ? 1.0 : 0.0;
```

**修改后：**
```csharp
var attackTime = currentPlanBattle.NextAttackAt.Value - currentPlanBattle.CurrentTime;
var attackProgress = currentPlanBattle.AttackIntervalSeconds > 0
    ? Math.Max(0.0, Math.Min(1.0, 1.0 - attackTime / currentPlanBattle.AttackIntervalSeconds))
    : (attackTime <= 0 ? 1.0 : 0.0);
```

#### 3.2 计算公式说明

新的进度计算公式：
```
progress = 1 - (NextAttackAt - CurrentTime) / AttackInterval
```

- `NextAttackAt - CurrentTime`：距离下次攻击还有多少时间
- 除以 `AttackInterval`：计算剩余时间占整个间隔的比例
- `1 - ratio`：得到已完成的进度比例（0.0到1.0）
- `Math.Max(0.0, Math.Min(1.0, ...))`：确保进度值在0到1之间

这样，攻击进度条会平滑地从0增长到100%，而不是跳跃式地在0和100%之间切换。

## 测试验证

### 测试用例

创建了 `AttackProgressResetTests.cs`，包含3个测试用例：

#### 测试1：持续模式下怪物刷新时重置攻击进度
```csharp
[Fact]
public void AttackProgress_ResetsOnMonsterRespawn_InContinuousMode()
```

**测试内容：**
- 创建持续模式战斗，带有2秒刷新延迟
- 击杀第一个怪物
- 等待刷新
- 验证刷新后攻击进度已重置到当前时间之后

**测试结果：** ✅ 通过

#### 测试2：多敌人战斗中切换目标时重置攻击进度
```csharp
[Fact]
public void AttackProgress_ResetsOnTargetSwitch_InMultiEnemyBattle()
```

**测试内容：**
- 创建有3个敌人的战斗
- 击杀第一个敌人
- 验证自动切换到新目标
- 验证攻击进度已重置

**测试结果：** ✅ 通过

#### 测试3：攻击进度计算显示平滑进度
```csharp
[Fact]
public void AttackProgress_CalculationShowsSmoothProgress()
```

**测试内容：**
- 在不同时间点（0%, 25%, 50%, 75%, 90%）检查攻击进度
- 验证使用前端相同公式计算的进度值接近预期
- 确保进度条能够平滑过渡

**测试结果：** ✅ 通过

### 测试执行结果

```
Test Run Successful.
Total tests: 3
     Passed: 3
 Total time: 0.6656 Seconds
```

所有测试用例均通过，验证了：
1. 怪物刷新后攻击进度正确重置
2. 切换目标后攻击进度正确重置
3. 前端进度条计算公式准确可靠

## 代码风格保持

本次修改遵循了项目现有的代码风格：

1. **命名约定**：使用PascalCase的方法名、camelCase的局部变量
2. **注释风格**：使用中文注释说明关键逻辑
3. **代码结构**：保持现有的方法组织和调用顺序
4. **架构一致性**：在现有的事件驱动战斗引擎框架内实现功能

## 文件修改清单

### 后端文件（BlazorIdle.Server）

1. **BattleEngine.cs**
   - 新增 `ResetAttackProgress()` 方法
   - 修改 `TryPerformPendingSpawn()` 方法
   - 修改 `TryRetargetPrimaryIfDead()` 方法

2. **StepBattleCoordinator.cs**
   - 在 `StepBattleStatusDto` 中添加 `AttackIntervalSeconds` 和 `SpecialIntervalSeconds` 字段
   - 修改 `GetStatus()` 方法以填充这些字段

### 前端文件（BlazorIdle）

3. **ApiModels.cs**
   - 在 `StepStatusResponse` 中添加 `AttackIntervalSeconds` 和 `SpecialIntervalSeconds` 字段

4. **Characters.razor**
   - 修改普通攻击进度条计算逻辑（两处：活动计划战斗和步骤战斗）
   - 修改特殊攻击进度条计算逻辑（两处）

### 测试文件（tests/BlazorIdle.Tests）

5. **AttackProgressResetTests.cs** (新建)
   - 创建3个完整的测试用例
   - 包含测试用的 `TestContinuousProvider` 辅助类

## 功能影响

### 正面影响

1. **用户体验提升**
   - 攻击进度条平滑过渡，视觉效果更好
   - 更清晰地展示攻击时机
   - 战斗节奏更加直观

2. **游戏逻辑改进**
   - 怪物刷新后不会立即触发攻击
   - 切换目标时有合理的攻击延迟
   - 符合典型RPG游戏的战斗机制

3. **代码质量提升**
   - 添加了完整的测试覆盖
   - 代码逻辑更加清晰
   - 易于后续维护和扩展

### 潜在风险评估

**风险等级：低**

- 所有修改都在战斗引擎的现有框架内进行
- 不影响伤害计算、技能系统等核心机制
- 仅改变攻击触发的时机控制
- 已通过完整的单元测试验证

## 后续建议

1. **性能优化**（可选）
   - 如果战斗规模扩大，可考虑缓存 `AttackTrack` 引用避免重复查找

2. **功能扩展**（可选）
   - 考虑为特殊攻击也添加类似的重置机制
   - 可以为不同职业设置不同的重置策略（如法师可能需要更长的准备时间）

3. **UI增强**（可选）
   - 在重置时添加视觉反馈（如进度条快速回退动画）
   - 在目标切换时显示"重新瞄准"等提示

## 总结

本次优化成功实现了攻击进度系统的改进，使其更加符合直觉和游戏体验预期。主要成果包括：

- ✅ 怪物刷新后攻击进度从0开始
- ✅ 切换目标时攻击进度重置
- ✅ 前端显示平滑的进度条动画
- ✅ 保持现有代码风格和架构
- ✅ 完整的测试覆盖（3个测试用例全部通过）
- ✅ 修改范围小，风险可控

所有修改已提交并通过测试验证，可以安全合并到主分支。
