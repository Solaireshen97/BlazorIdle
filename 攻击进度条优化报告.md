# 攻击进度条优化报告

## 概述

本次优化针对游戏前端战斗系统的攻击进度条，实现了基于攻击速度的平滑增长效果，并在每次轮询时进行服务器状态修正，正确处理怪物刷新和死亡时的进度条重置。

## 优化目标

1. **平滑进度显示**：攻击进度条不再是二进制状态（0% 或 100%），而是根据攻击间隔平滑增长
2. **轮询修正**：每次从服务器获取状态时，重新同步进度条，确保准确性
3. **正确重置**：在怪物死亡、刷新或切换目标时，进度条能正确重置
4. **代码风格一致**：维持现有的代码组织和命名约定

## 技术实现

### 1. 后端增强

#### 1.1 添加攻击间隔信息到 DTO

**修改文件**：`BlazorIdle.Server/Application/Battles/Step/StepBattleCoordinator.cs`

在 `StepBattleStatusDto` 中添加了两个新属性：

```csharp
/// <summary>普通攻击间隔（秒）</summary>
public double? AttackInterval { get; set; }

/// <summary>特殊攻击间隔（秒）</summary>
public double? SpecialInterval { get; set; }
```

在 `GetStatus` 方法中提取并返回攻击间隔：

```csharp
// 获取下次攻击时间和攻击间隔
double? nextAttackAt = null;
double? nextSpecialAt = null;
double? attackInterval = null;
double? specialInterval = null;
foreach (var track in ctx2.Tracks)
{
    if (track.TrackType == Domain.Combat.TrackType.Attack)
    {
        nextAttackAt = track.NextTriggerAt;
        attackInterval = track.CurrentInterval;  // 新增
    }
    else if (track.TrackType == Domain.Combat.TrackType.Special)
    {
        nextSpecialAt = track.NextTriggerAt;
        specialInterval = track.CurrentInterval;  // 新增
    }
}
```

**意义**：
- `AttackInterval` 和 `SpecialInterval` 提供了完整的攻击周期信息
- 客户端可以根据间隔计算当前进度在整个周期中的位置
- 支持急速等属性对攻击间隔的动态影响

#### 1.2 客户端 API 模型同步

**修改文件**：`BlazorIdle/Services/ApiModels.cs`

在 `StepStatusResponse` 中添加相应属性：

```csharp
public double? AttackInterval { get; set; }
public double? SpecialInterval { get; set; }
```

### 2. 前端实现

#### 2.1 客户端状态追踪

**修改文件**：`BlazorIdle/Pages/Characters.razor`

添加了客户端状态追踪字段，用于记录上次服务器更新的时间点和状态：

```csharp
// Step 战斗攻击进度追踪
private DateTime _lastStepUpdateTime = DateTime.UtcNow;
private double _lastServerCurrentTime = 0;
private double? _lastServerNextAttackAt = null;
private double? _lastServerNextSpecialAt = null;
private double? _lastServerAttackInterval = null;
private double? _lastServerSpecialInterval = null;

// 活动计划战斗攻击进度追踪
private DateTime _lastPlanUpdateTime = DateTime.UtcNow;
private double _lastPlanServerCurrentTime = 0;
private double? _lastPlanServerNextAttackAt = null;
private double? _lastPlanServerNextSpecialAt = null;
private double? _lastPlanServerAttackInterval = null;
private double? _lastPlanServerSpecialInterval = null;
```

**设计思路**：
- 分别追踪 Step 战斗和活动计划战斗的状态，互不干扰
- 记录客户端的时间戳 `_lastXxxUpdateTime`，用于计算客户端时间流逝
- 记录服务器的战斗时间和攻击时间点，用于估算当前服务器状态

#### 2.2 UI 刷新定时器

添加了 100ms 的 UI 刷新定时器，确保进度条平滑动画：

```csharp
// UI 刷新定时器（用于平滑进度条动画）
private System.Timers.Timer? _uiRefreshTimer;

private void StartUiRefreshTimer()
{
    if (_uiRefreshTimer != null) return;
    
    _uiRefreshTimer = new System.Timers.Timer(100); // 每100ms刷新一次UI
    _uiRefreshTimer.Elapsed += async (_, _) => await InvokeAsync(StateHasChanged);
    _uiRefreshTimer.AutoReset = true;
    _uiRefreshTimer.Start();
}

private void StopUiRefreshTimer()
{
    _uiRefreshTimer?.Stop();
    _uiRefreshTimer?.Dispose();
    _uiRefreshTimer = null;
}
```

**关键点**：
- 100ms 刷新频率提供流畅的视觉效果，不会造成性能问题
- 定时器仅在战斗轮询期间启动，避免不必要的资源消耗
- 在组件销毁时正确清理定时器

#### 2.3 平滑进度计算

实现了四个辅助方法，分别计算不同场景下的攻击进度：

```csharp
/// <summary>
/// 计算当前平滑的攻击进度（Step 战斗）
/// </summary>
private (double progress, double timeRemaining) CalculateStepAttackProgress()
{
    if (stepStatus?.NextAttackAt == null || stepStatus?.AttackInterval == null)
        return (0.0, 0.0);

    // 计算从上次服务器更新到现在经过的客户端时间
    var clientElapsed = (DateTime.UtcNow - _lastStepUpdateTime).TotalSeconds;
    
    // 估算当前服务器时间（基于客户端时间推进）
    var estimatedServerTime = _lastServerCurrentTime + clientElapsed;
    
    // 计算攻击进度起始时间（NextAttackAt - AttackInterval）
    var attackStartTime = _lastServerNextAttackAt!.Value - _lastServerAttackInterval!.Value;
    
    // 计算进度（0.0 到 1.0）
    var elapsedSinceStart = estimatedServerTime - attackStartTime;
    var progress = Math.Clamp(elapsedSinceStart / _lastServerAttackInterval!.Value, 0.0, 1.0);
    
    // 计算剩余时间
    var timeRemaining = Math.Max(0, _lastServerNextAttackAt!.Value - estimatedServerTime);
    
    return (progress, timeRemaining);
}
```

**算法说明**：

1. **时间推进**：
   - 客户端时间流逝 = 当前 UTC 时间 - 上次更新时间
   - 估算的服务器时间 = 上次服务器时间 + 客户端时间流逝

2. **进度计算**：
   - 攻击起始时间 = 下次攻击时间 - 攻击间隔
   - 从起始到现在的时间 = 估算服务器时间 - 攻击起始时间
   - 进度百分比 = 从起始到现在的时间 / 攻击间隔
   - 使用 `Math.Clamp` 确保进度在 [0.0, 1.0] 范围内

3. **剩余时间**：
   - 剩余时间 = 下次攻击时间 - 估算服务器时间
   - 使用 `Math.Max` 确保不为负数

#### 2.4 轮询时的状态更新

在每次轮询获取服务器状态后，更新追踪变量：

```csharp
async Task PollStepOnceAsync(CancellationToken ct)
{
    if (stepBattleId is null) return;
    var s = await Api.GetStepBattleStatusAsync(stepBattleId.Value, stepDropMode, ct);
    if (s is not null)
    {
        stepStatus = s;
        // 更新攻击进度追踪状态
        _lastStepUpdateTime = DateTime.UtcNow;
        _lastServerCurrentTime = s.CurrentTime;
        _lastServerNextAttackAt = s.NextAttackAt;
        _lastServerNextSpecialAt = s.NextSpecialAt;
        _lastServerAttackInterval = s.AttackInterval;
        _lastServerSpecialInterval = s.SpecialInterval;
    }
}
```

**重要性**：
- 每次轮询都会重新校准客户端状态，防止时间漂移
- 服务器是真实的时间源，客户端只是在两次轮询之间进行插值
- 如果怪物死亡或刷新，服务器会返回新的 `NextAttackAt` 和 `AttackInterval`，客户端会立即同步

#### 2.5 UI 模板更新

移除了旧的二进制进度计算，使用新的平滑计算方法：

**之前**：
```razor
var attackProgress = stepStatus.CurrentTime >= stepStatus.NextAttackAt.Value ? 1.0 : 0.0;
var attackTime = stepStatus.NextAttackAt.Value - stepStatus.CurrentTime;
```

**现在**：
```razor
var (attackProgress, attackTime) = CalculateStepAttackProgress();
```

同时移除了 `transition: width 0.1s` 样式，因为进度现在是连续更新的，不需要 CSS 过渡。

## 进度条重置处理

### 怪物死亡和刷新时的重置

进度条的重置是通过服务器状态同步自动实现的，无需客户端特殊处理：

1. **怪物死亡**：
   - 服务器的 `BattleEngine` 在怪物死亡后会调用 `ResetAttackProgress()`
   - 这会重置 `Track.NextTriggerAt = CurrentTime + AttackInterval`
   - 客户端下次轮询时会获取到新的 `NextAttackAt`
   - 进度计算会自动从 0% 开始

2. **怪物刷新**：
   - 服务器在安排刷新等待时也会调用 `ResetAttackProgress()`
   - 同样会重置攻击进度到新周期的起点
   - 客户端通过轮询获取新状态后自动同步

3. **切换目标**：
   - 服务器在 `TryRetargetPrimaryIfDead()` 中会调用 `ResetAttackProgress()`
   - 确保切换目标时攻击进度从头开始

### 客户端修正机制

客户端的时间估算只在两次轮询之间使用，每次轮询都会：

1. 更新 `_lastXxxUpdateTime` 为当前客户端时间
2. 更新 `_lastServerCurrentTime` 为服务器返回的当前战斗时间
3. 更新 `_lastServerNextAttackAt` 等为服务器的最新值

这确保了即使客户端时钟有偏差，或者服务器端发生了重置，客户端都能在下次轮询时立即修正。

## 代码风格维护

本次修改严格遵循了现有的代码风格：

1. **命名约定**：
   - 私有字段使用 `_camelCase` 前缀（如 `_lastStepUpdateTime`）
   - 方法使用 `PascalCase`（如 `CalculateStepAttackProgress`）
   - 局部变量使用 `camelCase`（如 `clientElapsed`）

2. **注释风格**：
   - 使用 XML 文档注释 `/// <summary>` 描述公共和重要的私有方法
   - 使用行内注释 `//` 解释复杂的逻辑

3. **代码组织**：
   - 将相关的追踪变量放在一起
   - 将辅助方法放在文件末尾，使用分隔注释
   - 保持 `@code` 块的逻辑分组

4. **错误处理**：
   - 在进度计算方法开始时检查必要的值是否为 null
   - 使用 `Math.Clamp` 和 `Math.Max` 确保值在有效范围内

## 测试场景

本优化应该在以下场景下进行测试：

### 1. 普通战斗（Duration 模式）
- 启动一个固定时长的 Step 战斗
- 观察攻击进度条是否平滑增长
- 确认进度条在攻击触发时重置到 0%
- 验证倒计时时间准确

### 2. 持续战斗（Continuous 模式）
- 启动持续战斗模式
- 观察怪物死亡时进度条是否正确重置
- 确认新怪物刷新时进度条从头开始
- 验证长时间战斗中进度条不会漂移

### 3. 地城模式（Dungeon Single/Loop）
- 启动地城战斗
- 观察波次切换时的进度条行为
- 确认刷新等待期间进度条的状态
- 验证多轮地城中进度条的稳定性

### 4. 活动计划战斗
- 创建并启动一个战斗类型的活动计划
- 观察计划实况中的进度条显示
- 确认长时间运行中进度条的准确性
- 验证离线后恢复时进度条能正确同步

### 5. 特殊攻击进度
- 对于有特殊攻击的职业（如 Warrior），验证特殊攻击进度条
- 确认普通攻击和特殊攻击进度条独立工作

## 性能影响

1. **UI 刷新频率**：
   - 每 100ms 刷新一次 UI（10 FPS）
   - 仅在战斗进行中启动，不战斗时无额外开销
   - 刷新只触发 Blazor 的 `StateHasChanged`，不进行网络请求

2. **计算开销**：
   - 进度计算只涉及简单的算术运算
   - 没有复杂的对象创建或内存分配
   - 可以忽略不计

3. **内存开销**：
   - 新增了约 12 个字段（6 个 Step + 6 个 Plan）
   - 一个 Timer 对象（仅在战斗时）
   - 总内存增加 < 1KB

## 向后兼容性

本优化完全向后兼容：

1. **API 变更**：
   - 只添加了新字段，没有修改或删除现有字段
   - 旧的 `NextAttackAt` 和 `NextSpecialAt` 仍然保留
   - 如果 `AttackInterval` 为 null，进度计算返回 (0.0, 0.0)

2. **行为变更**：
   - 进度条的行为更加平滑，但逻辑保持一致
   - 没有改变战斗引擎的任何逻辑
   - 服务器端的重置逻辑保持不变

## 未来可能的改进

1. **自适应刷新频率**：
   - 在攻击即将触发时（如最后 0.5 秒）提高刷新频率
   - 在攻击刚刚触发后降低刷新频率以节省资源

2. **视觉增强**：
   - 添加攻击触发时的闪光效果
   - 进度条快满时改变颜色
   - 添加触发音效

3. **延迟补偿**：
   - 估算客户端到服务器的网络延迟
   - 在进度计算中考虑延迟因素

4. **多目标显示**：
   - 当有多个怪物时，显示对每个怪物的攻击进度
   - 区分当前目标和其他目标

## 总结

本次优化成功实现了攻击进度条的平滑显示，通过客户端时间插值和服务器状态修正的组合，在保持准确性的同时提供了流畅的用户体验。实现方式遵循了现有的代码风格和架构设计，对性能影响可以忽略不计，并且完全向后兼容。

主要技术亮点：

1. **客户端插值**：在两次轮询之间估算进度，提供平滑动画
2. **服务器修正**：每次轮询都重新同步状态，确保准确性
3. **自动重置**：通过服务器状态同步自动处理怪物死亡和刷新
4. **低开销**：100ms 刷新定时器和简单的算术计算
5. **类型安全**：使用强类型和 nullable 检查，避免运行时错误

## 修改文件清单

1. **BlazorIdle.Server/Application/Battles/Step/StepBattleCoordinator.cs**
   - 添加 `AttackInterval` 和 `SpecialInterval` 属性到 `StepBattleStatusDto`
   - 在 `GetStatus` 方法中提取和返回攻击间隔

2. **BlazorIdle/Services/ApiModels.cs**
   - 添加 `AttackInterval` 和 `SpecialInterval` 属性到 `StepStatusResponse`

3. **BlazorIdle/Pages/Characters.razor**
   - 添加客户端状态追踪字段
   - 添加 UI 刷新定时器
   - 实现平滑进度计算方法
   - 更新轮询逻辑以同步状态
   - 更新 UI 模板使用新的进度计算
   - 在组件销毁时清理定时器

## 构建和测试

**构建状态**：✅ 成功（仅 1 个无关警告）

```
Build succeeded.
    1 Warning(s)
    0 Error(s)
```

**测试建议**：

建议进行以下手动测试：
1. 创建一个角色并启动 Step 战斗
2. 观察攻击进度条是否平滑增长
3. 等待怪物死亡，观察进度条是否重置
4. 在持续模式下观察多次怪物刷新
5. 在地城模式下测试波次切换

---

**报告生成时间**：2025-01-17  
**优化版本**：1.0  
**作者**：GitHub Copilot
