# 离线战斗系统实施总结（简化版）

## 📌 核心需求

实现离线战斗收益：用户下线后，系统自动计算离线期间的战斗收益，上线时展示并发放。

---

## ✅ 已有组件（可直接使用）

1. **ActivityPlan模型** - 活动计划实体，已完整实现
2. **ActivityPlanService** - 活动计划服务，支持创建、启动、停止
3. **BattleSimulator** - 战斗模拟器，支持快进功能
4. **OfflineSettlementService（基础版）** - 已有离线模拟代码
5. **Character实体** - 已包含`LastSeenAtUtc`和`LastOfflineSettledAtUtc`字段

---

## ❌ 缺失组件（需要实现）

### 后端缺失

1. **OfflineFastForwardEngine** - 专用离线快进引擎
   - 复用BattleSimulator
   - 处理活动计划限制（Duration/Infinite）
   - 更新计划执行状态

2. **自动离线检测** - 登录时自动触发离线结算
   - 检查`LastSeenAtUtc`计算离线时长
   - 调用快进引擎模拟
   - 更新计划状态
   - 自动启动下一个计划（如果当前计划完成）

3. **新增API端点**
   - `GET /api/offline/check` - 检查离线收益
   - `POST /api/offline/apply` - 应用离线结算并发放
   - `POST /api/characters/{id}/heartbeat` - 更新在线心跳

### 前端缺失

1. **离线结算弹窗组件** - 展示离线收益详情
2. **ApiClient扩展** - 调用离线相关API
3. **Characters页面集成** - 加载时自动检查离线收益

---

## 🔧 实施步骤

### Step 1: 创建OfflineFastForwardEngine

**文件**: `BlazorIdle.Server/Application/Battles/Offline/OfflineFastForwardEngine.cs`

**核心逻辑**:
```
输入: Character, ActivityPlan, OfflineSeconds
处理:
  1. 计算实际模拟时长 = Min(离线时长, 12小时上限)
  2. 计算计划剩余时长:
     - 如果是Duration类型: 剩余 = LimitValue - ExecutedSeconds
     - 如果是Infinite类型: 剩余 = 全部离线时长
  3. 使用BattleSimulator快进模拟
  4. 更新计划的ExecutedSeconds
  5. 判断计划是否完成
输出: OfflineFastForwardResult (收益、状态、段数据)
```

---

### Step 2: 扩展OfflineSettlementService

**文件**: `BlazorIdle.Server/Application/Battles/Offline/Offline.cs`

**新增方法**: `CheckAndSettleAsync(characterId)`

**核心逻辑**:
```
1. 获取角色，计算离线时长 = Now - LastSeenAtUtc
2. 如果离线时长 <= 0，直接返回（无离线）
3. 查找离线时正在运行的ActivityPlan
4. 如果有运行计划：
   - 调用OfflineFastForwardEngine.FastForward()
   - 更新计划ExecutedSeconds和状态
   - 如果计划完成，标记为Completed
   - 如果计划完成，尝试启动下一个Pending计划
5. 更新LastSeenAtUtc = Now
6. 返回离线结算结果（但不立即发放收益）
```

**新增方法**: `ApplySettlementAsync(characterId, settlement)`

**核心逻辑**:
```
1. 获取角色
2. 更新角色Gold += settlement.Gold
3. 更新角色Experience += settlement.Exp
4. 发放物品到背包（如果有）
5. 保存角色数据
```

---

### Step 3: 添加API端点

**文件**: `BlazorIdle.Server/Api/OfflineController.cs`

**新增端点1**: `GET /api/offline/check?characterId={id}`
- 调用`OfflineSettlementService.CheckAndSettleAsync()`
- 返回`OfflineCheckResult`（包含离线时长、收益预览、计划状态）

**新增端点2**: `POST /api/offline/apply`
- 接收`{ characterId, settlement }`
- 调用`OfflineSettlementService.ApplySettlementAsync()`
- 实际发放金币、经验、物品

**文件**: `BlazorIdle.Server/Api/CharactersController.cs`

**新增端点3**: `POST /api/characters/{id}/heartbeat`
- 更新`character.LastSeenAtUtc = DateTime.UtcNow`
- 用于记录玩家在线时间

---

### Step 4: 前端集成

#### 4.1 扩展ApiClient

**文件**: `BlazorIdle/Services/ApiClient.cs`

**新增方法**:
```csharp
// 检查离线收益
public Task<OfflineCheckResult?> CheckOfflineAsync(Guid characterId)

// 应用离线结算
public Task ApplyOfflineSettlementAsync(Guid characterId, OfflineFastForwardResult settlement)

// 更新心跳
public Task UpdateHeartbeatAsync(Guid characterId)
```

---

#### 4.2 创建离线结算弹窗

**文件**: `BlazorIdle/Components/OfflineSettlementDialog.razor`

**功能**:
- 显示"欢迎回来！离线X小时Y分钟"
- 展示收益：金币+XXX，经验+XXX，击杀XXX
- 展示掉落物品列表
- "确认领取"按钮
- 如果计划完成且启动了下一个，显示提示信息

---

#### 4.3 修改Characters页面

**文件**: `BlazorIdle/Pages/Characters.razor`

**修改OnInitializedAsync**:
```csharp
protected override async Task OnInitializedAsync()
{
    // 原有加载逻辑...
    
    // 如果有选中角色
    if (selectedCharacter != null)
    {
        // 1. 更新心跳
        await apiClient.UpdateHeartbeatAsync(selectedCharacter.Id);
        
        // 2. 检查离线收益
        var offlineResult = await apiClient.CheckOfflineAsync(selectedCharacter.Id);
        
        // 3. 如果有离线收益，显示弹窗
        if (offlineResult?.HasOfflineTime == true)
        {
            showOfflineDialog = true;
            offlineCheckResult = offlineResult;
        }
    }
}
```

**新增方法**:
```csharp
private async Task ApplyOfflineSettlement()
{
    // 调用API应用离线结算
    await apiClient.ApplyOfflineSettlementAsync(
        selectedCharacter.Id, 
        offlineCheckResult.Settlement
    );
    
    // 刷新角色数据
    await RefreshCharacterAsync();
    
    // 关闭弹窗
    showOfflineDialog = false;
}
```

---

## 🔄 完整流程示例

### 场景1: 用户下线1小时，计划未完成

**初始状态**:
- 角色在线，有一个3小时战斗计划正在运行
- 已执行0.5小时（ExecutedSeconds=1800）
- LastSeenAtUtc = 2025-01-07 10:00:00

**用户下线**:
- 用户关闭浏览器，LastSeenAtUtc保持不变

**1小时后用户上线**:
- 前端加载，调用`GET /api/offline/check?characterId=xxx`

**后端处理**:
```
1. 计算离线时长 = Now(11:00) - LastSeen(10:00) = 3600秒
2. 查找运行计划，找到3小时战斗计划
3. 计算剩余时长:
   - LimitValue = 10800秒（3小时）
   - ExecutedSeconds = 1800秒
   - 剩余 = 10800 - 1800 = 9000秒
   - 实际模拟 = Min(3600, 9000) = 3600秒
4. 快进模拟3600秒战斗
5. 更新ExecutedSeconds = 1800 + 3600 = 5400秒
6. 判断是否完成: 5400 < 10800，未完成
7. 计算收益: Gold=+2000, Exp=+3000
8. 返回结果
```

**前端展示**:
```
弹窗显示:
  离线时长: 1小时0分钟
  金币: +2000
  经验: +3000
  击杀: 60
  [确认领取]按钮
```

**用户点击"确认领取"**:
- 前端调用`POST /api/offline/apply`
- 后端更新角色Gold、Experience
- 战斗计划继续运行（剩余1.5小时）

---

### 场景2: 用户下线3小时，计划完成并启动下一个

**初始状态**:
- 角色有两个计划:
  - Plan1: 2小时战斗（Running，已执行0小时）
  - Plan2: 1小时战斗（Pending）
- LastSeenAtUtc = 2025-01-07 10:00:00

**3小时后用户上线**:

**后端处理**:
```
1. 计算离线时长 = 10800秒（3小时）
2. 查找运行计划，找到Plan1
3. 计算剩余时长:
   - LimitValue = 7200秒
   - ExecutedSeconds = 0
   - 剩余 = 7200秒
   - 实际模拟 = Min(10800, 7200) = 7200秒
4. 快进模拟7200秒
5. 更新Plan1:
   - ExecutedSeconds = 7200
   - State = Completed
   - CompletedAt = Now
6. 计算收益: Gold=+5000, Exp=+8000
7. 查找下一个Pending计划，找到Plan2
8. 自动启动Plan2
9. 返回结果（包含NextPlanStarted=true）
```

**前端展示**:
```
弹窗显示:
  离线时长: 3小时0分钟（实际计算2小时）
  金币: +5000
  经验: +8000
  击杀: 120
  
  提示: "活动计划已完成，已自动开始下一个计划"
  
  [确认领取]按钮
```

---

## 📊 数据模型

### OfflineFastForwardResult
```csharp
{
    CharacterId: Guid,
    PlanId: Guid,
    SimulatedSeconds: double,      // 实际模拟时长
    PlanCompleted: bool,            // 计划是否完成
    TotalDamage: long,
    TotalKills: int,
    Gold: long,                     // 金币收益
    Exp: long,                      // 经验收益
    Loot: Dictionary<string, double>,  // 物品掉落
    UpdatedExecutedSeconds: double  // 更新后的已执行时长
}
```

### OfflineCheckResult
```csharp
{
    HasOfflineTime: bool,           // 是否有离线时间
    OfflineSeconds: double,         // 离线总时长
    HasRunningPlan: bool,           // 离线时是否有运行计划
    Settlement: OfflineFastForwardResult?,  // 结算结果
    PlanCompleted: bool,            // 计划是否完成
    NextPlanStarted: bool,          // 是否启动了下一个计划
    NextPlanId: Guid?               // 下一个计划ID
}
```

---

## ⚙️ 配置项（appsettings.json）

```json
{
  "Offline": {
    "MaxOfflineSeconds": 43200,     // 12小时上限
    "EnableAutoSettlement": true,   // 是否自动结算
    "RequireManualConfirm": true    // 是否需要前端确认才发放
  }
}
```

---

## 🧪 测试要点

### 后端单元测试
1. OfflineFastForwardEngine:
   - 测试离线时长上限（超过12小时只计算12小时）
   - 测试Duration计划剩余时长计算
   - 测试Infinite计划模拟全部离线时长
   - 测试计划完成状态判断

2. OfflineSettlementService:
   - 测试无离线时间场景
   - 测试有离线无计划场景
   - 测试计划完成自动衔接

### 前端集成测试
1. 创建角色和计划
2. 模拟下线（修改数据库LastSeenAtUtc）
3. 重新登录
4. 验证弹窗显示正确
5. 点击领取，验证数据更新

---

## ⏱️ 预估工作量

| 任务 | 时间 |
|------|------|
| OfflineFastForwardEngine实现 | 0.5天 |
| OfflineSettlementService扩展 | 0.5天 |
| API端点添加 | 0.5天 |
| 前端ApiClient扩展 | 0.5天 |
| 离线结算弹窗组件 | 1天 |
| Characters页面集成 | 0.5天 |
| 单元测试 | 1天 |
| 集成测试与调优 | 1天 |
| **总计** | **5-6天** |

---

## 🎯 优先级

### 必须实现（Phase 1）
1. ✅ OfflineFastForwardEngine
2. ✅ OfflineSettlementService.CheckAndSettleAsync
3. ✅ API端点（check、apply）
4. ✅ 前端弹窗组件
5. ✅ Characters页面集成

### 推荐实现（Phase 2）
6. ✅ 心跳机制
7. ✅ 自动衔接完善
8. ✅ 配置项

### 可选实现（Phase 3）
9. ⭕ 离线结算历史记录表
10. ⭕ 收益衰减机制

---

**文档结束**
