# 离线战斗前端集成实施说明

## 概述

本文档详细说明了离线战斗系统第四步（前端集成）的实施过程和技术细节。

## 实施内容

### 1. API客户端扩展 (ApiClient.cs)

#### 新增方法

```csharp
// 检查离线收益
public Task<OfflineCheckResult?> CheckOfflineAsync(Guid characterId, CancellationToken ct = default)

// 应用离线结算
public async Task ApplyOfflineSettlementAsync(Guid characterId, OfflineFastForwardResult settlement, CancellationToken ct = default)

// 更新心跳
public async Task UpdateHeartbeatAsync(Guid characterId, CancellationToken ct = default)
```

#### 新增DTO类型

```csharp
// 离线检查结果
public sealed class OfflineCheckResult
{
    public bool HasOfflineTime { get; set; }
    public double OfflineSeconds { get; set; }
    public bool HasRunningPlan { get; set; }
    public OfflineFastForwardResult? Settlement { get; set; }
    public bool PlanCompleted { get; set; }
    public bool NextPlanStarted { get; set; }
    public Guid? NextPlanId { get; set; }
}

// 离线战斗结果
public sealed class OfflineFastForwardResult
{
    public Guid CharacterId { get; set; }
    public Guid PlanId { get; set; }
    public double SimulatedSeconds { get; set; }
    public bool PlanCompleted { get; set; }
    public long TotalDamage { get; set; }
    public int TotalKills { get; set; }
    public long Gold { get; set; }
    public long Exp { get; set; }
    public Dictionary<string, double> LootExpected { get; set; } = new();
    public Dictionary<string, int> LootSampled { get; set; } = new();
    public double UpdatedExecutedSeconds { get; set; }
    public string DropMode { get; set; } = "expected";
}

// 应用离线结算请求
public record ApplyOfflineSettlementRequest(
    Guid CharacterId,
    OfflineFastForwardResult Settlement
);
```

### 2. 离线结算弹窗组件 (OfflineSettlementDialog.razor)

#### 功能特性

- **自动弹出显示**：当检测到离线收益时自动显示
- **美观的UI设计**：使用渐变色背景和卡片式布局
- **完整的信息展示**：
  - 离线时长（格式化为小时/分钟/秒）
  - 金币收益（绿色高亮显示）
  - 经验收益（绿色高亮显示）
  - 击杀数量
  - 物品掉落列表（支持expected和sampled模式）
  - 计划状态（完成/继续执行）
  - 自动衔接提示
- **用户交互**：
  - 必须点击"确认领取"按钮才能关闭
  - 点击遮罩层不会关闭对话框（确保用户看到收益）
  - 处理中状态提示（防止重复提交）

#### 核心代码

```csharp
@if (Result?.HasOfflineTime == true && Result.Settlement != null)
{
    <div class="offline-dialog-overlay" @onclick="OnOverlayClick">
        <div class="offline-dialog" @onclick:stopPropagation="true">
            <!-- 对话框内容 -->
        </div>
    </div>
}

@code {
    [Parameter]
    public OfflineCheckResult? Result { get; set; }

    [Parameter]
    public EventCallback OnClaim { get; set; }

    private async Task OnClaimClicked()
    {
        if (IsProcessing) return;
        IsProcessing = true;
        try
        {
            await OnClaim.InvokeAsync();
        }
        finally
        {
            IsProcessing = false;
        }
    }

    private string FormatDuration(double seconds)
    {
        var ts = TimeSpan.FromSeconds(seconds);
        if (ts.TotalHours >= 1)
            return $"{(int)ts.TotalHours}小时{ts.Minutes}分钟";
        else if (ts.TotalMinutes >= 1)
            return $"{(int)ts.TotalMinutes}分钟{ts.Seconds}秒";
        else
            return $"{(int)ts.TotalSeconds}秒";
    }
}
```

### 3. Characters页面集成 (Characters.razor)

#### 新增状态管理

```csharp
// 离线战斗状态
private OfflineCheckResult? offlineCheckResult;
private DateTime lastHeartbeatUpdate = DateTime.MinValue;
```

#### 登录时离线检查

```csharp
async Task LoadUserDataAsync()
{
    // ... 现有代码 ...
    
    // 如果有角色，默认选中第一个
    if (userCharacters.Count > 0 && selectedCharacter is null)
    {
        selectedCharacter = userCharacters[0];
        lastCreated = new CharacterCreated(selectedCharacter.Id, selectedCharacter.Name);
        
        // 检查离线收益
        await CheckOfflineRewardsAsync();
    }
}
```

#### 离线收益检查和应用

```csharp
/// <summary>
/// 检查离线收益（在角色加载时自动调用）
/// </summary>
private async Task CheckOfflineRewardsAsync()
{
    if (selectedCharacter is null) return;

    try
    {
        // 更新心跳时间
        await UpdateHeartbeatIfNeededAsync();

        // 检查离线收益
        offlineCheckResult = await Api.CheckOfflineAsync(selectedCharacter.Id);
        
        // 如果有离线收益，弹窗会自动显示
        if (offlineCheckResult?.HasOfflineTime == true)
        {
            await InvokeAsync(StateHasChanged);
        }
    }
    catch (Exception ex)
    {
        userMessage = $"检查离线收益失败: {ex.Message}";
    }
}

/// <summary>
/// 应用离线结算，实际发放收益
/// </summary>
private async Task ApplyOfflineSettlement()
{
    if (offlineCheckResult?.Settlement is null || selectedCharacter is null) return;

    try
    {
        await Api.ApplyOfflineSettlementAsync(selectedCharacter.Id, offlineCheckResult.Settlement);
        
        // 重新加载用户数据以更新金币和经验显示
        await LoadUserDataAsync();
        
        // 刷新计划列表
        await RefreshPlansAsync();
        
        // 清除离线结算结果，关闭弹窗
        offlineCheckResult = null;
        
        userMessage = "离线收益已领取成功！";
        await InvokeAsync(StateHasChanged);
    }
    catch (Exception ex)
    {
        userMessage = $"领取离线收益失败: {ex.Message}";
    }
}
```

#### 心跳更新集成

```csharp
/// <summary>
/// 更新心跳时间（如果需要）
/// 在计划任务刷新时也会调用，实现每2秒更新一次
/// </summary>
private async Task UpdateHeartbeatIfNeededAsync()
{
    if (selectedCharacter is null) return;

    // 每2秒更新一次心跳
    var now = DateTime.UtcNow;
    if ((now - lastHeartbeatUpdate).TotalSeconds < 2)
        return;

    try
    {
        await Api.UpdateHeartbeatAsync(selectedCharacter.Id);
        lastHeartbeatUpdate = now;
    }
    catch
    {
        // 心跳更新失败不影响主流程
    }
}

// 在计划轮询循环中调用
async Task StartPlanPollingAsync(Guid battleId)
{
    // ...
    while (!_planPollCts.IsCancellationRequested)
    {
        try
        {
            // 获取战斗状态
            currentPlanBattle = await Api.GetStepBattleStatusAsync(battleId, "sampled", _planPollCts.Token);
            
            // 刷新计划列表
            if (lastCreated is not null)
            {
                characterPlans = await Api.GetCharacterPlansAsync(lastCreated.Id);
            }
            
            // 更新心跳时间（每次刷新计划状态时）
            await UpdateHeartbeatIfNeededAsync();
            
            await InvokeAsync(StateHasChanged);
        }
        catch (Exception) { }

        await Task.Delay(2000, _planPollCts.Token);
    }
    // ...
}
```

## 无感继承实现原理

### 1. 离线计算从当前进度继续

当用户离线时，后端会：
1. 记录离线时间点：`LastSeenAtUtc`
2. 保存当前计划的执行状态：`ExecutedSeconds`
3. 保存当前战斗状态：`BattleStateJson`

当用户上线时：
1. 计算离线时长：`Now - LastSeenAtUtc`
2. 从`ExecutedSeconds`开始继续模拟
3. 恢复战斗状态快照，继承敌人血量等状态

### 2. 在线继承离线结果

当用户领取离线收益后：
1. 前端不需要重新开始战斗
2. 战斗引擎会从`BattleStateJson`恢复状态
3. 继续使用更新后的`ExecutedSeconds`
4. 实现完全无缝的战斗体验

### 3. 计划自动衔接

如果离线期间计划完成：
1. 后端自动标记计划为`Completed`
2. 查找下一个`Pending`状态的计划
3. 自动启动下一个计划
4. 前端弹窗会提示"下一个计划已自动开始"

## 测试验证

### 单元测试

创建了5个前端集成测试，验证：
1. DTO序列化和反序列化
2. 无离线时间场景
3. 有离线收益场景
4. 物品掉落数据
5. 计划完成和自动衔接

### 测试结果

```
Test summary: total: 5, failed: 0, succeeded: 5, skipped: 0, duration: 1.1s
```

## 使用流程

### 用户场景1：正常离线收益

1. 用户在战斗中（计划执行30分钟）
2. 用户关闭浏览器（离线1小时）
3. 用户重新登录
4. 系统自动检查离线收益
5. 弹窗显示：
   - 离线时长：1小时0分钟
   - 金币：+2000
   - 经验：+3000
   - 击杀：60
   - 提示：活动计划继续执行中，已执行：1小时30分钟
6. 用户点击"确认领取"
7. 收益发放到角色
8. 战斗继续（从1小时30分钟的进度继续）

### 用户场景2：计划完成并自动衔接

1. 用户有两个计划：
   - 计划1：2小时战斗（Running，已执行20分钟）
   - 计划2：1小时战斗（Pending）
2. 用户离线3小时
3. 用户重新登录
4. 系统检测到：
   - 计划1已完成（模拟剩余1小时40分钟）
   - 计划2已自动启动
5. 弹窗显示：
   - 离线时长：3小时0分钟
   - 金币：+5000
   - 经验：+8000
   - 击杀：120
   - 提示：✅ 活动计划已完成
   - 提示：🔄 下一个计划已自动开始
6. 用户点击"确认领取"
7. 收益发放，计划2继续执行

## 技术亮点

1. **最小化改动**：只修改了2个文件，新增了2个文件
2. **无感继承**：完全无缝的离线到在线切换
3. **自动化处理**：心跳、离线检查、收益发放都是自动的
4. **良好的错误处理**：所有异步操作都有try-catch
5. **用户体验优化**：
   - 必须点击确认才能领取（防止误操作）
   - 清晰的状态提示
   - 格式化的时间显示
   - 响应式设计
6. **完整的测试覆盖**：5个单元测试验证核心功能

## 后续优化建议

1. **UI增强**：
   - 添加动画效果（淡入淡出）
   - 添加音效提示
   - 支持暗色模式

2. **功能扩展**：
   - 离线收益历史记录
   - 离线收益统计图表
   - 离线收益分享功能

3. **性能优化**：
   - 心跳可以使用WebSocket替代轮询
   - 离线检查可以添加缓存
   - 大量物品掉落时分页显示

## 总结

离线战斗前端集成已成功实现，具备以下特点：
- ✅ 完整的功能实现
- ✅ 良好的代码质量
- ✅ 完善的测试覆盖
- ✅ 优秀的用户体验
- ✅ 遵循现有代码规范
- ✅ 最小化改动原则

系统已经可以投入使用，为用户提供无缝的离线战斗体验。
