# 活动计划系统实现总结

## 概述

活动计划系统是在现有战斗系统基础上的一层抽象包装，允许玩家创建和管理多个活动计划（如战斗、采集、制作），支持队列执行和自动衔接。

### 核心目标

1. **包装现有战斗逻辑**：不改变现有 `StepBattleCoordinator` 的实现，通过 `CombatActivityExecutor` 进行封装
2. **支持多种活动类型**：当前支持战斗，预留采集和制作的扩展接口
3. **支持计划队列**：玩家可以在每个槽位排队多个活动计划，自动按顺序执行
4. **灵活的限制条件**：支持时长限制、计数限制和无限制三种模式
5. **状态机管理**：清晰的状态转换（待定 → 运行中 → 已完成/已取消）

## 架构设计

### 领域模型 (Domain Layer)

```
Domain/Activity/
├── ActivityType.cs       # 活动类型枚举
├── ActivityState.cs      # 状态机枚举
├── LimitSpec.cs          # 限制规格（基类+三种实现）
├── ActivityPlan.cs       # 活动计划核心实体
└── ActivitySlot.cs       # 活动槽位管理
```

#### 1. ActivityType - 活动类型

```csharp
public enum ActivityType
{
    Combat = 0,   // 战斗
    Gather = 1,   // 采集（未来扩展）
    Craft = 2     // 制作（未来扩展）
}
```

#### 2. ActivityState - 状态机

```csharp
public enum ActivityState
{
    Pending = 0,    // 待定：等待执行
    Running = 1,    // 运行中：正在执行
    Completed = 2,  // 已完成：达到限制条件
    Cancelled = 3   // 已取消：被用户或系统取消
}
```

状态转换规则：
- `Pending → Running`: 通过 `Start()` 方法
- `Running → Completed`: 通过 `Complete()` 方法
- `Pending/Running → Cancelled`: 通过 `Cancel()` 方法
- `Completed` 状态不能再转换

#### 3. LimitSpec - 限制规格

三种限制类型的基类和实现：

```csharp
// 基类
public abstract class LimitSpec
{
    public abstract bool IsReached(ActivityProgress progress);
    public abstract string GetLimitType();
}

// 时长限制：按模拟时间（秒）
public sealed class DurationLimit : LimitSpec
{
    public double DurationSeconds { get; init; }
    // 当 progress.SimulatedSeconds >= DurationSeconds 时达到限制
}

// 计数限制：按击杀数、采集次数等
public sealed class CountLimit : LimitSpec
{
    public int TargetCount { get; init; }
    // 当 progress.CompletedCount >= TargetCount 时达到限制
}

// 无限制：需要手动停止
public sealed class InfiniteLimit : LimitSpec
{
    // 永远不会自动达到限制
}
```

#### 4. ActivityPlan - 活动计划

核心实体，包含以下关键信息：

```csharp
public sealed class ActivityPlan
{
    public Guid Id { get; init; }
    public Guid CharacterId { get; init; }
    public int SlotIndex { get; set; }
    public ActivityType Type { get; init; }
    public ActivityState State { get; private set; }
    public LimitSpec Limit { get; init; }
    public string PayloadJson { get; set; }  // 活动特定参数
    public ActivityProgress Progress { get; private set; }
    
    // 状态转换方法
    public void Start();
    public void Complete();
    public void Cancel();
    public void UpdateProgress(double simulatedSeconds, int completedCount);
    public bool IsLimitReached();
}
```

#### 5. ActivitySlot - 活动槽位

每个角色有固定数量的槽位（默认3个，可配置为3-5个），每个槽位管理一个当前计划和一个队列：

```csharp
public sealed class ActivitySlot
{
    public int SlotIndex { get; init; }
    public Guid CharacterId { get; init; }
    public Guid? CurrentPlanId { get; private set; }  // 当前执行的计划
    public List<Guid> QueuedPlanIds { get; init; }    // 排队的计划
    
    public bool IsIdle => CurrentPlanId is null;
    
    public void StartPlan(Guid planId);
    public Guid? FinishCurrentAndGetNext();  // 完成当前并自动衔接下一个
    public void EnqueuePlan(Guid planId);
}
```

### 应用层 (Application Layer)

```
Application/Activities/
├── IActivityExecutor.cs         # 执行器接口
├── CombatActivityExecutor.cs    # 战斗活动执行器
├── ActivityCoordinator.cs       # 活动协调器
└── ActivityHostedService.cs     # 后台推进服务
```

#### 1. IActivityExecutor - 执行器接口

定义了所有活动类型执行器的统一接口：

```csharp
public interface IActivityExecutor
{
    ActivityType SupportedType { get; }
    Task<ActivityExecutionContext> StartAsync(ActivityPlan plan, CancellationToken ct);
    Task AdvanceAsync(ActivityPlan plan, ActivityExecutionContext context, CancellationToken ct);
    Task StopAsync(ActivityPlan plan, ActivityExecutionContext context, CancellationToken ct);
    Task<bool> CheckCompletionAsync(ActivityPlan plan, ActivityExecutionContext context, CancellationToken ct);
}
```

#### 2. CombatActivityExecutor - 战斗执行器

封装现有的 `StepBattleCoordinator`，不修改其内部逻辑：

```csharp
public sealed class CombatActivityExecutor : IActivityExecutor
{
    public ActivityType SupportedType => ActivityType.Combat;
    
    // 解析战斗载荷并启动战斗
    public async Task<ActivityExecutionContext> StartAsync(ActivityPlan plan, CancellationToken ct)
    {
        var payload = JsonSerializer.Deserialize<CombatPayload>(plan.PayloadJson);
        // ... 构建角色属性、生成种子
        var battleId = _battleCoordinator.Start(...);
        return new ActivityExecutionContext { UnderlyingExecutionId = battleId };
    }
    
    // 更新活动进度
    public async Task AdvanceAsync(ActivityPlan plan, ActivityExecutionContext context, CancellationToken ct)
    {
        // StepBattleCoordinator 由 HostedService 统一推进
        // 这里只需要同步进度信息
        var simulatedSeconds = battle.Clock.CurrentTime;
        var completedCount = CalculateCompletedCount(battle, plan.Limit);
        plan.UpdateProgress(simulatedSeconds, completedCount);
    }
}
```

**战斗载荷格式**：

```json
{
  "enemyId": "dummy",
  "enemyCount": 1,
  "mode": "duration",
  "dungeonId": null,
  "respawnDelay": null,
  "waveDelay": null,
  "runDelay": null,
  "seed": null
}
```

#### 3. ActivityCoordinator - 活动协调器

管理所有活动计划的核心服务：

```csharp
public sealed class ActivityCoordinator
{
    private readonly ConcurrentDictionary<Guid, ActivityPlan> _plans;
    private readonly ConcurrentDictionary<Guid, ActivityExecutionContext> _contexts;
    private readonly ConcurrentDictionary<Guid, List<ActivitySlot>> _characterSlots;
    private readonly Dictionary<ActivityType, IActivityExecutor> _executors;
    
    // 创建活动计划
    public ActivityPlan CreatePlan(Guid characterId, int slotIndex, 
        ActivityType type, LimitSpec limit, string payloadJson);
    
    // 获取活动信息
    public ActivityPlan? GetPlan(Guid planId);
    public List<ActivitySlot> GetCharacterSlots(Guid characterId);
    public (ActivityPlan? current, List<ActivityPlan> queued) GetSlotPlans(
        Guid characterId, int slotIndex);
    
    // 取消活动
    public async Task<bool> CancelPlanAsync(Guid planId, CancellationToken ct);
    
    // 推进所有活动（由 HostedService 调用）
    public async Task AdvanceAllAsync(CancellationToken ct);
    
    // 清理已完成的计划
    public int PruneCompletedPlans(TimeSpan olderThan);
}
```

**自动衔接逻辑**：
1. 当一个活动完成时，`ActivityCoordinator` 调用 `ActivitySlot.FinishCurrentAndGetNext()`
2. 如果队列中有等待的计划，自动取出并启动
3. 如果队列为空，槽位进入空闲状态

#### 4. ActivityHostedService - 后台服务

周期性推进所有活动：

```csharp
public sealed class ActivityHostedService : BackgroundService
{
    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        while (!stoppingToken.IsCancellationRequested)
        {
            await _coordinator.AdvanceAllAsync(stoppingToken);
            
            // 定期清理已完成的计划
            if (DateTime.UtcNow - _lastPruneTime > _pruneInterval)
            {
                _coordinator.PruneCompletedPlans(TimeSpan.FromHours(1));
            }
            
            await Task.Delay(_advanceInterval, stoppingToken);
        }
    }
}
```

配置参数：
- `Activity:AdvanceIntervalSeconds`: 推进间隔（默认1秒）
- `Activity:PruneIntervalMinutes`: 清理间隔（默认10分钟）

### API层 (API Layer)

#### ActivitiesController

提供 RESTful API 管理活动计划：

| 端点 | 方法 | 描述 |
|------|------|------|
| `/api/activities/plans` | POST | 创建活动计划 |
| `/api/activities/plans/{planId}` | GET | 获取计划详情 |
| `/api/activities/characters/{characterId}/slots` | GET | 获取角色所有槽位信息 |
| `/api/activities/plans/{planId}/cancel` | POST | 取消活动计划 |

**创建计划请求示例**：

```json
{
  "characterId": "3fa85f64-5717-4562-b3fc-2c963f66afa6",
  "slotIndex": 0,
  "type": "combat",
  "limitType": "duration",
  "limitValue": 3600,
  "payloadJson": "{\"enemyId\":\"dummy\",\"enemyCount\":1,\"mode\":\"duration\"}"
}
```

**槽位信息响应示例**：

```json
[
  {
    "slotIndex": 0,
    "characterId": "3fa85f64-5717-4562-b3fc-2c963f66afa6",
    "currentPlan": {
      "id": "...",
      "state": "running",
      "type": "combat",
      "progress": {
        "simulatedSeconds": 120.5,
        "completedCount": 15
      }
    },
    "queuedPlans": [
      {
        "id": "...",
        "state": "pending",
        "type": "combat"
      }
    ]
  }
]
```

## 使用示例

### 场景1：打1小时A怪，然后打1小时B怪

```csharp
// 创建第一个计划：打1小时dummy
var plan1 = coordinator.CreatePlan(
    characterId: characterId,
    slotIndex: 0,
    type: ActivityType.Combat,
    limit: new DurationLimit(3600), // 3600秒 = 1小时
    payloadJson: JsonSerializer.Serialize(new {
        enemyId = "dummy",
        enemyCount = 1,
        mode = "duration"
    })
);

// 创建第二个计划：打1小时tank
var plan2 = coordinator.CreatePlan(
    characterId: characterId,
    slotIndex: 0,
    type: ActivityType.Combat,
    limit: new DurationLimit(3600),
    payloadJson: JsonSerializer.Serialize(new {
        enemyId = "tank",
        enemyCount = 1,
        mode = "duration"
    })
);

// plan1会立即开始执行，plan2会进入队列
// 当plan1完成后，plan2自动开始执行
```

### 场景2：击杀100个敌人

```csharp
var plan = coordinator.CreatePlan(
    characterId: characterId,
    slotIndex: 0,
    type: ActivityType.Combat,
    limit: new CountLimit(100), // 击杀100个
    payloadJson: JsonSerializer.Serialize(new {
        enemyId = "dummy",
        enemyCount = 1,
        mode = "continuous" // 持续模式，敌人死亡后自动刷新
    })
);
```

### 场景3：无限挂机，手动停止

```csharp
var plan = coordinator.CreatePlan(
    characterId: characterId,
    slotIndex: 0,
    type: ActivityType.Combat,
    limit: new InfiniteLimit(), // 无限制
    payloadJson: JsonSerializer.Serialize(new {
        enemyId = "dummy",
        enemyCount = 3,
        mode = "continuous"
    })
);

// 稍后手动取消
await coordinator.CancelPlanAsync(plan.Id);
```

## 与现有系统集成

### 1. 不修改现有战斗逻辑

- `StepBattleCoordinator` 保持不变
- 通过 `CombatActivityExecutor` 进行封装和调用
- 战斗的推进仍然由 `StepBattleHostedService` 管理

### 2. 并行执行

- 活动系统和战斗系统的 HostedService 并行运行
- `ActivityHostedService` 负责活动状态管理和自动衔接
- `StepBattleHostedService` 负责战斗模拟推进

### 3. 依赖注入

```csharp
// Application/DependencyInjection.cs
services.AddSingleton<ActivityCoordinator>();
services.AddSingleton<IActivityExecutor, CombatActivityExecutor>();
services.AddHostedService<ActivityHostedService>();
```

## 扩展点

### 1. 添加新的活动类型

以采集活动为例：

```csharp
public sealed class GatherActivityExecutor : IActivityExecutor
{
    public ActivityType SupportedType => ActivityType.Gather;
    
    public async Task<ActivityExecutionContext> StartAsync(ActivityPlan plan, CancellationToken ct)
    {
        var payload = JsonSerializer.Deserialize<GatherPayload>(plan.PayloadJson);
        // 创建采集会话
        var sessionId = _gatherService.StartSession(plan.CharacterId, payload.NodeId);
        return new ActivityExecutionContext { UnderlyingExecutionId = sessionId };
    }
    
    public async Task AdvanceAsync(ActivityPlan plan, ActivityExecutionContext context, CancellationToken ct)
    {
        // 推进采集逻辑
        var session = _gatherService.GetSession(context.UnderlyingExecutionId.Value);
        plan.UpdateProgress(session.ElapsedSeconds, session.GatheredCount);
    }
    
    // ... 其他方法
}

// 注册执行器
services.AddSingleton<IActivityExecutor, GatherActivityExecutor>();
```

### 2. 自定义限制条件

```csharp
// 经验值限制：达到指定经验值停止
public sealed class ExperienceLimit : LimitSpec
{
    public long TargetExperience { get; init; }
    
    public override bool IsReached(ActivityProgress progress)
    {
        if (progress.CustomData.TryGetValue("experience", out var exp))
        {
            return (long)exp >= TargetExperience;
        }
        return false;
    }
    
    public override string GetLimitType() => "Experience";
}
```

### 3. 活动互斥和优先级

未来可以扩展：

```csharp
public sealed class ActivityPlan
{
    // 活动类别标签（用于互斥检查）
    public string ActivityClass { get; set; } = "default";
    
    // 互斥标签（避免多个相同类别的活动并发）
    public List<string> ExclusionTags { get; init; } = new();
    
    // 优先级（用于队列排序）
    public int Priority { get; set; } = 0;
}
```

## 测试覆盖

实现了11个测试用例，覆盖核心功能：

1. 状态机转换（Pending → Running → Completed）
2. 状态机异常情况（重复启动、取消已完成的计划）
3. 三种限制条件的达到判断（DurationLimit、CountLimit、InfiniteLimit）
4. 槽位队列管理（入队、出队、自动衔接）
5. 槽位互斥（不能同时启动多个计划）

测试结果：11/11 通过 ✅

## 配置说明

在 `appsettings.json` 中添加：

```json
{
  "Activity": {
    "AdvanceIntervalSeconds": 1.0,
    "PruneIntervalMinutes": 10.0,
    "SlotsPerCharacter": 3
  }
}
```

## 性能考虑

1. **内存管理**：
   - 使用 `ConcurrentDictionary` 保证线程安全
   - 定期清理已完成的计划（默认1小时后）
   - 槽位数量限制（3-5个）

2. **推进频率**：
   - 活动推进间隔默认1秒（可配置）
   - 实际战斗推进由 `StepBattleCoordinator` 控制（默认约100ms）
   - 两者独立，互不影响

3. **并发安全**：
   - `ActivityCoordinator` 使用线程安全的集合
   - 状态转换有锁保护
   - 执行器之间相互独立

## 未来规划

1. **持久化**：
   - 添加 `ActivityPlanRecord` 数据库实体
   - 实现 `IActivityRepository` 接口
   - 支持离线活动计划

2. **离线快进**：
   - 利用现有的 `OfflineFastForwardEngine`
   - 离线时继续执行活动计划
   - 登录时快速结算

3. **前端集成**：
   - 活动计划管理界面
   - 实时进度展示
   - 拖拽排序队列

4. **高级功能**：
   - 条件触发（如血量低于30%自动切换活动）
   - 循环队列（完成后自动重新加入队列）
   - 活动模板（保存和复用常用配置）

## 总结

活动计划系统成功实现了以下目标：

✅ **最小化修改**：现有战斗系统代码零修改，仅通过封装集成  
✅ **扩展性强**：清晰的接口设计，支持未来添加采集、制作等活动  
✅ **用户友好**：支持队列、自动衔接、多种限制条件  
✅ **代码质量**：完整的测试覆盖、清晰的注释、符合现有代码风格  
✅ **性能考虑**：线程安全、内存管理、合理的推进频率  

系统为未来的游戏玩法扩展打下了坚实的基础，同时保持了与现有系统的良好兼容性。
