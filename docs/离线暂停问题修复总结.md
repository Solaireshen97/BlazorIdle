# 离线暂停问题修复总结

## 问题描述

原系统在 `CheckAndPauseOfflinePlayers` 中检测到玩家离线超过阈值时，会调用 `StopPlanAsync` 直接停止任务。这导致：

1. 任务状态被标记为 `Completed`（已完成）
2. 战斗状态 `BattleStateJson` 被清空
3. 离线结算后，任务无法重新开启
4. 玩家上线后需要手动创建新任务

## 核心问题

按照设计要求：
- **应该**：暂停任务并保存状态，等待玩家上线后恢复
- **实际**：直接完成任务，导致任务结束，无法恢复

## 解决方案

### 1. 新增暂停功能 (PausePlanAsync)

在 `ActivityPlanService` 中新增 `PausePlanAsync` 方法：

```csharp
public async Task<bool> PausePlanAsync(Guid planId, CancellationToken ct = default)
```

**功能特点**：
- ✅ 保存战斗状态到 `BattleStateJson`
- ✅ 更新已执行时长 `ExecutedSeconds`
- ✅ 停止内存中的战斗实例
- ✅ 清空 `BattleId`（释放内存）
- ✅ 清空 `StartedAt`（标记为暂停）
- ✅ **保持** `State = Running`（关键！）
- ✅ **保留** `BattleStateJson`（用于恢复）

### 2. 新增恢复功能 (ResumePlanAsync)

在 `ActivityPlanService` 中新增 `ResumePlanAsync` 方法：

```csharp
public async Task<Guid> ResumePlanAsync(Guid planId, CancellationToken ct = default)
```

**功能特点**：
- ✅ 从 `BattleStateJson` 加载战斗状态
- ✅ 重建角色战斗数据
- ✅ 创建新的战斗实例并恢复状态
- ✅ 设置新的 `BattleId` 和 `StartedAt`
- ✅ 继续执行任务（无缝衔接）

### 3. 更新离线检测服务

修改 `OfflineDetectionService.CheckAndPauseOfflinePlayers`：

```csharp
// 之前（错误）：
await planService.StopPlanAsync(plan.Id, ct);

// 现在（正确）：
await planService.PausePlanAsync(plan.Id, ct);
```

### 4. 增强心跳端点

在 `CharactersController.Heartbeat` 中添加自动恢复逻辑：

```csharp
// 检查是否有暂停的计划需要恢复
var runningPlan = await _db.ActivityPlans
    .FirstOrDefaultAsync(p => p.CharacterId == id 
        && p.State == ActivityState.Running
        && !p.BattleId.HasValue
        && !string.IsNullOrWhiteSpace(p.BattleStateJson));

if (runningPlan != null)
{
    await _planService.ResumePlanAsync(runningPlan.Id);
}
```

## 状态转换图

### 正常执行流程
```
Pending → Running (有BattleId) → Completed
```

### 离线暂停流程
```
Running (有BattleId) → [检测离线] → Running (无BattleId，保留状态) → [玩家上线] → Running (新BattleId) → Completed
```

## 三种计划状态

### 1. 活跃计划（Active Plan）
- `State == Running`
- `BattleId != null`
- `StartedAt != null`
- 内存中有战斗实例正在运行

### 2. 暂停计划（Paused Plan）
- `State == Running`（关键！仍然是Running）
- `BattleId == null`（内存已释放）
- `StartedAt == null`（标记暂停）
- `BattleStateJson != null`（保存了状态）

### 3. 完成计划（Completed Plan）
- `State == Completed`
- `BattleId == null`
- `BattleStateJson == null`（已清空）
- `CompletedAt != null`

## 完整工作流程

### 场景 1：玩家离线被暂停

```
1. 玩家正在战斗（活跃状态）
   State: Running, BattleId: xxx, BattleStateJson: {状态}

2. 玩家关闭浏览器

3. 60秒后，OfflineDetectionService 检测到离线
   
4. 调用 PausePlanAsync
   - 保存当前战斗状态
   - 停止内存中的战斗
   - 清空 BattleId 和 StartedAt
   
5. 暂停状态
   State: Running, BattleId: null, BattleStateJson: {保存的状态}
```

### 场景 2：玩家上线恢复

```
1. 玩家打开浏览器，发送心跳

2. Heartbeat 端点接收请求

3. 检测到有暂停的计划
   (State=Running, BattleId=null, BattleStateJson!=null)

4. 调用 ResumePlanAsync
   - 从 BattleStateJson 加载状态
   - 创建新的战斗实例
   - 恢复战斗进度
   - 设置新的 BattleId 和 StartedAt

5. 恢复后状态
   State: Running, BattleId: yyy (新的), BattleStateJson: {状态}

6. 任务继续执行
```

### 场景 3：离线期间任务完成

```
1. 玩家离线时有运行中的任务

2. 玩家上线，发送心跳

3. Heartbeat 检测到离线超过阈值

4. 调用 CheckAndSettleAsync（离线结算）
   - OfflineFastForwardEngine 快进模拟
   - 计算收益
   - 如果任务完成：标记为 Completed
   - 如果未完成：保持 Running 状态

5. 如果自动应用收益，直接发放
   
6. 如果任务完成，尝试启动下一个待执行任务
```

## 代码对比

### StopPlanAsync（用于正常停止）
```csharp
// 标记为完成
plan.State = ActivityState.Completed;
plan.CompletedAt = DateTime.UtcNow;

// 清空战斗状态
plan.BattleStateJson = null;

// 自动启动下一个任务
await TryStartNextPendingPlanAsync(plan.CharacterId, ct);
```

### PausePlanAsync（用于离线暂停）
```csharp
// 保持运行状态
// plan.State 保持为 Running

// 清空运行时信息（但保留状态）
plan.BattleId = null;
plan.StartedAt = null;

// 保留战斗状态（用于恢复）
// plan.BattleStateJson 保持不变

// 不启动下一个任务
```

## 测试验证

新增测试文件：`tests/BlazorIdle.Tests/OfflinePauseResumeTests.cs`

### 测试用例（全部通过 ✅）

1. **PausedPlan_ShouldKeepRunningState**
   - 验证：暂停后保持 Running 状态
   
2. **PausedPlan_ShouldNotBeCompleted**
   - 验证：暂停的计划不应标记为完成
   
3. **ResumedPlan_ShouldHaveBattleIdAndStartedAt**
   - 验证：恢复后设置 BattleId 和 StartedAt
   
4. **OfflineDetection_ShouldPauseNotStop**
   - 验证：离线检测使用暂停而非停止
   
5. **PausedPlan_IdentifiedByStateAndBattleId**
   - 验证：能正确识别暂停状态的计划

## 优势对比

| 特性 | 修复前（StopPlanAsync） | 修复后（PausePlanAsync） |
|-----|----------------------|----------------------|
| 任务状态 | ❌ Completed（完成） | ✅ Running（暂停） |
| 战斗状态 | ❌ 被清空 | ✅ 保留 |
| 玩家上线 | ❌ 需要手动重新创建任务 | ✅ 自动恢复 |
| 已执行时长 | ❌ 丢失（重新开始） | ✅ 保留（继续累计） |
| 战斗进度 | ❌ 丢失（从头开始） | ✅ 保留（无缝衔接） |
| 自动启动下一个 | ✅ 启动（但不合理） | ❌ 不启动（保持当前任务） |

## 配置说明

在 `appsettings.json` 中配置：

```json
{
  "Offline": {
    "OfflineDetectionSeconds": 60,    // 离线检测阈值（秒）
    "AutoApplyRewards": true           // 是否自动应用离线收益
  }
}
```

## API 端点变化

### POST /api/characters/{id}/heartbeat

**新增返回字段**：
```json
{
  "message": "心跳更新成功",
  "timestamp": "2024-01-01T12:00:00Z",
  "offlineSettlement": {
    // 离线结算信息（如果有）
  },
  "planResumed": true  // 🆕 是否恢复了暂停的任务
}
```

## 注意事项

### 1. 状态检查要完整
判断暂停状态时，必须同时检查三个字段：
```csharp
bool isPaused = plan.State == ActivityState.Running 
    && !plan.BattleId.HasValue 
    && !string.IsNullOrWhiteSpace(plan.BattleStateJson);
```

### 2. GetRunningPlanAsync 的行为
此方法返回所有 `State == Running` 的计划，**包括活跃和暂停的计划**。

在使用时需要进一步检查 `BattleId` 来区分：
```csharp
var runningPlan = await _plans.GetRunningPlanAsync(characterId, ct);
if (runningPlan != null && runningPlan.BattleId.HasValue)
{
    // 有活跃的计划
}
```

### 3. 离线结算优先
如果玩家离线期间任务本应完成，系统会优先执行离线结算，而不是恢复任务。

### 4. 内存管理
暂停时会清空内存中的战斗实例，节省服务器资源。

## 相关文档

- [离线暂停恢复机制](./离线暂停恢复机制.md) - 详细技术文档
- [活动计划自动执行功能](./activity-plan-auto-execution.md) - 任务执行流程
- [离线战斗系统实施总结](./离线战斗系统实施总结.md) - 离线战斗系统
- [OfflineFastForwardEngine实施文档](./OfflineFastForwardEngine实施文档.md) - 离线快进引擎

## 修复效果

### ✅ 修复前的问题
1. ✅ 任务被错误地标记为完成
2. ✅ 战斗状态丢失
3. ✅ 玩家上线后无法恢复任务
4. ✅ 需要手动重新创建任务

### ✅ 修复后的效果
1. ✅ 任务保持运行状态（暂停）
2. ✅ 战斗状态完整保存
3. ✅ 玩家上线后自动恢复
4. ✅ 任务无缝衔接，体验流畅

## 总结

本次修复通过引入 **暂停/恢复机制**，正确实现了离线玩家的任务管理：

1. **暂停而非停止**：离线时暂停任务而不是结束任务
2. **状态完整保存**：保存战斗状态以便恢复
3. **自动恢复**：玩家上线后自动恢复暂停的任务
4. **无缝衔接**：恢复后继续执行，体验流畅

这样既节省了服务器资源（暂停时清空内存），又保证了用户体验（自动恢复任务）。
