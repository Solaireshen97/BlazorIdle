# BlazorIdle 架构重建方案（中篇）- 实施路径

**文档版本**: 1.0  
**创建日期**: 2025-10-20  
**前置文档**: 架构重建方案（上篇）- 战略规划  
**文档类型**: 实施路径与阶段规划

---

## 一、实施总览

### 1.1 实施时间线

```
周期: 约 12-16 周（3-4 个月）

Week 1        : Phase 0 - 准备与评估
Week 2-4      : Phase 1 - 数据访问层重建
Week 5-6      : Phase 2 - 缓存体系统一
Week 7-8      : Phase 3 - SignalR 架构重构
Week 9-11     : Phase 4 - 业务服务层整理
Week 12-16+   : Phase 5 - 核心功能迁移
Week 16+      : Phase 6 - 持续优化与完善
```

### 1.2 关键里程碑

| 里程碑 | 时间点 | 交付物 | 验收标准 |
|--------|--------|--------|---------|
| M0 | Week 1 | 评估报告、迁移计划 | 团队评审通过 |
| M1 | Week 4 | 新数据访问层 | 单元测试通过、集成测试通过 |
| M2 | Week 6 | 统一缓存系统 | 缓存命中率 > 80% |
| M3 | Week 8 | SignalR 新架构 | 消息延迟 < 500ms |
| M4 | Week 11 | 服务层重构 | 无循环依赖、测试覆盖 > 80% |
| M5 | Week 16 | 核心功能迁移完成 | 所有 P0/P1 功能可用 |
| M6 | 持续 | 系统稳定运行 | 可用性 > 99.5% |

---

## 二、Phase 0: 准备与评估（Week 1）

### 2.1 目标
建立稳定的基线，为后续迁移做好准备

### 2.2 任务清单

#### Task 0.1: 代码审计（2 天）
**目标**: 全面了解当前代码状况

**子任务**:
1. ✅ 统计代码行数、文件数、模块数
2. ✅ 识别核心依赖关系
3. ✅ 标记可删除的代码（未使用、实验性）
4. ✅ 标记必须保留的代码（核心业务逻辑）
5. ✅ 生成依赖关系图

**工具**:
- Visual Studio Code Metrics
- NDepend（可选）
- 手工审查

**交付物**:
- `code-audit-report.md`: 代码审计报告
- `dependency-graph.png`: 依赖关系图
- `code-to-keep.md`: 必须保留的代码清单
- `code-to-remove.md`: 可删除代码清单

---

#### Task 0.2: 功能盘点（1 天）
**目标**: 明确哪些功能需要迁移

**子任务**:
1. ✅ 列出所有现有功能
2. ✅ 标记功能状态（完整/部分/实验性）
3. ✅ 确定优先级（P0/P1/P2/P3）
4. ✅ 评估迁移复杂度（简单/中等/复杂）
5. ✅ 制定迁移顺序

**交付物**:
- `feature-inventory.md`: 功能清单
- `migration-priority.md`: 迁移优先级表

**功能分类示例**:
```markdown
## P0 - 必须功能
- [ ] 用户认证（完整，简单）
- [ ] 角色管理（完整，简单）
- [ ] 战斗核心循环（完整，中等）
- [ ] 装备穿戴/卸下（完整，简单）
- [ ] 技能使用（完整，简单）

## P1 - 重要功能
- [ ] 活动计划（完整，中等）
- [ ] 离线战斗（完整，复杂）
- [ ] 商店购买（完整，简单）
- [ ] 装备分解（完整，简单）
- [ ] 装备重铸（完整，中等）

## P2 - 增强功能
- [ ] 任务系统（部分，中等）
- [ ] 声望系统（部分，简单）
- [ ] 多角色（完整，中等）

## P3 - 可选功能
- [ ] 战斗回放（未完成，延后）
- [ ] 统计面板（未完成，延后）
```

---

#### Task 0.3: 性能基准建立（1 天）
**目标**: 建立可对比的性能数据

**子任务**:
1. ✅ 设置性能测试环境
2. ✅ 编写性能测试脚本
3. ✅ 收集关键指标
4. ✅ 生成性能报告

**关键指标**:
- API 响应时间（P50, P95, P99）
- 数据库查询次数
- 缓存命中率
- 内存使用
- CPU 使用率
- 并发用户数

**工具**:
- Apache JMeter 或 K6
- Application Insights
- dotnet-counters

**交付物**:
- `performance-baseline.md`: 性能基准报告
- `performance-test-scripts/`: 测试脚本目录

---

#### Task 0.4: 测试环境准备（1 天）
**目标**: 建立独立的测试环境

**子任务**:
1. ✅ 克隆数据库到测试环境
2. ✅ 配置独立的 appsettings
3. ✅ 设置 CI/CD 流程
4. ✅ 配置监控和日志

**交付物**:
- 独立运行的测试环境
- CI/CD 配置文件
- 测试环境文档

---

#### Task 0.5: 制定迁移策略（1 天）
**目标**: 确定详细的迁移方案

**关键决策**:
1. **数据库迁移**: 是否需要 Schema 变更？
   - 选择: 保持现有 Schema，只调整访问方式
   
2. **代码组织**: 新旧代码如何共存？
   - 选择: 创建新的命名空间，旧代码标记 [Obsolete]
   
3. **功能切换**: 如何在新旧实现间切换？
   - 选择: 使用 Feature Flag（配置开关）
   
4. **测试策略**: 如何保证质量？
   - 选择: 单元测试 + 集成测试 + 手工验证

**交付物**:
- `migration-strategy.md`: 迁移策略文档
- `feature-flags-design.md`: 功能开关设计

---

### 2.3 Phase 0 验收标准

- ✅ 所有文档已创建并审查通过
- ✅ 性能基准数据已收集
- ✅ 测试环境可正常运行
- ✅ 迁移策略获得团队共识
- ✅ 风险已识别并有应对方案

---

## 三、Phase 1: 数据访问层重建（Week 2-4）

### 3.1 目标
建立简单、可靠、高性能的数据访问层

### 3.2 设计原则

#### 原则 1: 简化 Repository 模式
**当前问题**: 过度抽象，多层仓储
**新方案**: 
- 只保留必要的抽象
- 使用通用 Repository<T>
- 特殊需求在 Service 层处理

#### 原则 2: 明确事务边界
**当前问题**: 事务边界不清晰
**新方案**:
- Service 层方法是事务边界
- 使用 `[TransactionScope]` 特性标记
- 事务嵌套由框架处理

#### 原则 3: 延迟优化
**当前问题**: 过早引入复杂缓存
**新方案**:
- 先保证功能正确
- 通过监控识别热点
- 针对性添加缓存

### 3.3 架构设计

```
应用层 (Application Services)
    ↓ 使用
领域服务 (Domain Services)
    ↓ 使用
仓储接口 (IRepository<T>)
    ↓ 实现
仓储实现 (Repository<T>)
    ↓ 使用
DbContext (GameDbContext)
    ↓
EF Core
    ↓
SQLite
```

### 3.4 任务清单

#### Task 1.1: 定义核心抽象（2 天）

**子任务**:
1. ✅ 定义 `IEntity` 接口
   ```csharp
   public interface IEntity
   {
       Guid Id { get; }
   }
   ```

2. ✅ 定义 `IRepository<T>` 接口
   ```csharp
   public interface IRepository<T> where T : class, IEntity
   {
       // 基础 CRUD
       Task<T?> GetByIdAsync(Guid id, CancellationToken ct = default);
       Task<List<T>> GetAllAsync(CancellationToken ct = default);
       Task<T> AddAsync(T entity, CancellationToken ct = default);
       Task UpdateAsync(T entity, CancellationToken ct = default);
       Task DeleteAsync(Guid id, CancellationToken ct = default);
       
       // 查询支持
       IQueryable<T> Query();
   }
   ```

3. ✅ 定义 `IUnitOfWork` 接口（可选）
   ```csharp
   public interface IUnitOfWork : IDisposable
   {
       Task<int> SaveChangesAsync(CancellationToken ct = default);
       Task BeginTransactionAsync(CancellationToken ct = default);
       Task CommitTransactionAsync(CancellationToken ct = default);
       Task RollbackTransactionAsync(CancellationToken ct = default);
   }
   ```

**交付物**:
- `IRepository.cs`
- `IEntity.cs`
- `IUnitOfWork.cs`（如采用）

---

#### Task 1.2: 实现通用 Repository（3 天）

**实现要点**:
```csharp
public class Repository<T> : IRepository<T> where T : class, IEntity
{
    private readonly GameDbContext _context;
    private readonly DbSet<T> _dbSet;
    private readonly ILogger<Repository<T>> _logger;

    public Repository(
        GameDbContext context,
        ILogger<Repository<T>> logger)
    {
        _context = context;
        _dbSet = context.Set<T>();
        _logger = logger;
    }

    public async Task<T?> GetByIdAsync(Guid id, CancellationToken ct = default)
    {
        return await _dbSet.FindAsync(new object[] { id }, ct);
    }

    public async Task<T> AddAsync(T entity, CancellationToken ct = default)
    {
        await _dbSet.AddAsync(entity, ct);
        await _context.SaveChangesAsync(ct);
        return entity;
    }

    public async Task UpdateAsync(T entity, CancellationToken ct = default)
    {
        _dbSet.Update(entity);
        await _context.SaveChangesAsync(ct);
    }

    // ... 其他方法
}
```

**关键点**:
- ✅ 每个方法都调用 SaveChanges（简单直接）
- ✅ 使用 FindAsync 而非 FirstOrDefaultAsync（性能更好）
- ✅ 添加日志记录
- ✅ 异常处理

**交付物**:
- `Repository.cs`
- `RepositoryTests.cs`（单元测试）

---

#### Task 1.3: 迁移现有实体（3 天）

**子任务**:
1. ✅ 让所有实体实现 `IEntity`
   - Character
   - GearInstance
   - BattleRecord
   - ActivityPlan
   - 等等...

2. ✅ 统一主键类型（Guid）

3. ✅ 添加必要的导航属性

4. ✅ 配置 EF Core Fluent API

**注意事项**:
- 保持数据库 Schema 不变
- 只调整代码模型
- 充分测试迁移脚本

**交付物**:
- 更新后的实体类
- EF Core 配置类
- 单元测试

---

#### Task 1.4: 重构现有服务（4 天）

**目标**: 将现有服务迁移到新的 Repository

**策略**:
- 逐个服务迁移
- 保留旧代码作为对比
- 使用 Feature Flag 控制切换

**示例**:
```csharp
// 旧代码（保留，标记 Obsolete）
[Obsolete("Use CharacterService instead")]
public class LegacyCharacterService
{
    // ...
}

// 新代码
public class CharacterService
{
    private readonly IRepository<Character> _characterRepo;
    
    public CharacterService(IRepository<Character> characterRepo)
    {
        _characterRepo = characterRepo;
    }
    
    public async Task<Character?> GetCharacterAsync(Guid id)
    {
        return await _characterRepo.GetByIdAsync(id);
    }
    
    // ...
}
```

**迁移顺序**:
1. CharacterService（简单，风险低）
2. EquipmentService（中等复杂度）
3. CombatService（复杂，最后迁移）

**交付物**:
- 重构后的服务类
- 集成测试
- 迁移文档

---

#### Task 1.5: 性能测试与优化（2 天）

**测试场景**:
1. 单个查询性能
2. 批量查询性能
3. 写入性能
4. 并发场景

**优化手段**:
- 添加数据库索引（如需要）
- AsNoTracking（只读查询）
- 批量操作
- 查询优化

**交付物**:
- 性能测试报告
- 优化建议清单

---

### 3.5 Phase 1 验收标准

- ✅ 所有实体实现 `IEntity`
- ✅ 核心服务已迁移到新 Repository
- ✅ 单元测试覆盖率 > 80%
- ✅ 集成测试通过
- ✅ 性能不低于旧实现（允许 ±10%）
- ✅ 无数据一致性问题

---

## 四、Phase 2: 缓存体系统一（Week 5-6）

### 4.1 目标
建立简单、有效的统一缓存方案

### 4.2 设计原则

#### 原则 1: Cache-Aside 模式
```
应用请求数据
    ↓
检查缓存
    ↓ 命中
返回缓存数据

    ↓ 未命中
查询数据库
    ↓
写入缓存
    ↓
返回数据
```

#### 原则 2: 主动失效
```
写入数据
    ↓
更新数据库
    ↓
删除相关缓存
    ↓
完成
```

#### 原则 3: 短 TTL
- 配置数据: 30 分钟
- 用户数据: 5 分钟
- 战斗数据: 1 分钟（高频更新）

### 4.3 架构设计

```
应用服务
    ↓ 使用
ICache<T>
    ↓ 实现
MemoryCache (默认) / RedisCache (可选)
```

### 4.4 任务清单

#### Task 2.1: 定义缓存抽象（1 天）

**接口设计**:
```csharp
public interface ICache<T>
{
    Task<T?> GetAsync(string key, CancellationToken ct = default);
    Task SetAsync(string key, T value, TimeSpan? expiration = null, CancellationToken ct = default);
    Task RemoveAsync(string key, CancellationToken ct = default);
    Task<bool> ExistsAsync(string key, CancellationToken ct = default);
}
```

**交付物**:
- `ICache.cs`
- `CacheOptions.cs`

---

#### Task 2.2: 实现内存缓存（2 天）

**实现要点**:
```csharp
public class MemoryCache<T> : ICache<T>
{
    private readonly IMemoryCache _cache;
    private readonly ILogger<MemoryCache<T>> _logger;
    
    public async Task SetAsync(string key, T value, TimeSpan? expiration = null, CancellationToken ct = default)
    {
        var options = new MemoryCacheEntryOptions();
        if (expiration.HasValue)
        {
            options.AbsoluteExpirationRelativeToNow = expiration.Value;
        }
        else
        {
            options.SlidingExpiration = TimeSpan.FromMinutes(5); // 默认5分钟
        }
        
        _cache.Set(key, value, options);
        _logger.LogDebug("Cached {Key} with expiration {Expiration}", key, expiration);
    }
    
    // ... 其他方法
}
```

**交付物**:
- `MemoryCache.cs`
- `MemoryCacheTests.cs`

---

#### Task 2.3: 实现 Redis 缓存（可选，2 天）

**目标**: 为将来分布式部署做准备

**实现要点**:
- 使用 StackExchange.Redis
- 序列化/反序列化处理
- 连接池管理
- 失败降级（fallback to memory cache）

**交付物**:
- `RedisCache.cs`
- `RedisCacheTests.cs`
- `RedisConfiguration.md`

---

#### Task 2.4: 集成到服务层（3 天）

**集成模式**:
```csharp
public class CharacterService
{
    private readonly IRepository<Character> _characterRepo;
    private readonly ICache<Character> _cache;
    
    public async Task<Character?> GetCharacterAsync(Guid id)
    {
        var cacheKey = $"character:{id}";
        
        // 尝试从缓存获取
        var cached = await _cache.GetAsync(cacheKey);
        if (cached != null)
        {
            return cached;
        }
        
        // 缓存未命中，查数据库
        var character = await _characterRepo.GetByIdAsync(id);
        if (character != null)
        {
            // 写入缓存
            await _cache.SetAsync(cacheKey, character, TimeSpan.FromMinutes(5));
        }
        
        return character;
    }
    
    public async Task UpdateCharacterAsync(Character character)
    {
        await _characterRepo.UpdateAsync(character);
        
        // 删除缓存
        await _cache.RemoveAsync($"character:{character.Id}");
    }
}
```

**迁移顺序**:
1. 配置数据（装备定义、技能定义）- 高优先级
2. 角色数据 - 中优先级
3. 战斗数据 - 低优先级（高频更新）

**交付物**:
- 更新后的服务类
- 缓存命中率监控
- 集成测试

---

#### Task 2.5: 清理旧缓存代码（2 天）

**目标**: 移除旧的缓存实现

**清理项**:
- ✅ ShopCacheService
- ✅ MultiTierCacheManager
- ✅ CacheAwareRepository
- ✅ 相关配置类

**策略**:
- 先禁用（注释掉注册）
- 观察 1-2 天
- 确认无问题后删除

**交付物**:
- 清理清单
- 清理后的代码
- 验证报告

---

### 4.5 Phase 2 验收标准

- ✅ 统一的 ICache<T> 接口
- ✅ 内存缓存实现完成并集成
- ✅ 配置数据缓存命中率 > 80%
- ✅ 无数据一致性问题
- ✅ 旧缓存代码已清理
- ✅ 文档已更新

---

## 五、Phase 3: SignalR 架构重构（Week 7-8）

### 5.1 目标
建立解耦、高效的实时通信层

### 5.2 设计原则

#### 原则 1: Hub 职责单一
- Hub 只负责连接管理和消息路由
- 不包含业务逻辑
- 不直接访问数据库

#### 原则 2: 事件驱动
- 业务层发布领域事件
- 通知层订阅事件并推送

#### 原则 3: 消息聚合
- 高频消息聚合后批量推送
- 减少网络开销

### 5.3 架构设计

```
业务服务 (CharacterService, CombatService, ...)
    ↓ 发布事件
领域事件总线 (IEventBus)
    ↓ 订阅
通知服务 (INotificationService)
    ↓ 格式化 & 节流
IHubContext<BattleNotificationHub>
    ↓ 推送
客户端 (Blazor)
```

### 5.4 任务清单

#### Task 3.1: 定义领域事件（2 天）

**事件基类**:
```csharp
public abstract record DomainEvent
{
    public Guid EventId { get; init; } = Guid.NewGuid();
    public DateTime OccurredAt { get; init; } = DateTime.UtcNow;
}
```

**具体事件**:
```csharp
// 战斗事件
public record BattleStartedEvent(Guid BattleId, Guid CharacterId) : DomainEvent;
public record BattleCompletedEvent(Guid BattleId, bool Victory, int Exp, int Gold) : DomainEvent;
public record BattleProgressEvent(Guid BattleId, int MonsterHp, int MonsterMaxHp) : DomainEvent;

// 角色事件
public record LevelUpEvent(Guid CharacterId, int NewLevel) : DomainEvent;
public record EquipmentChangedEvent(Guid CharacterId, Guid GearId, string SlotName) : DomainEvent;

// 其他事件...
```

**交付物**:
- `DomainEvents/` 目录及所有事件类
- 事件文档

---

#### Task 3.2: 实现事件总线（2 天）

**简单实现（内存）**:
```csharp
public interface IEventBus
{
    Task PublishAsync<TEvent>(TEvent @event, CancellationToken ct = default) where TEvent : DomainEvent;
    void Subscribe<TEvent>(Func<TEvent, CancellationToken, Task> handler) where TEvent : DomainEvent;
}

public class InMemoryEventBus : IEventBus
{
    private readonly ConcurrentDictionary<Type, List<Delegate>> _handlers = new();
    
    public void Subscribe<TEvent>(Func<TEvent, CancellationToken, Task> handler) where TEvent : DomainEvent
    {
        _handlers.AddOrUpdate(
            typeof(TEvent),
            _ => new List<Delegate> { handler },
            (_, list) => { list.Add(handler); return list; }
        );
    }
    
    public async Task PublishAsync<TEvent>(TEvent @event, CancellationToken ct = default) where TEvent : DomainEvent
    {
        if (_handlers.TryGetValue(typeof(TEvent), out var handlers))
        {
            var tasks = handlers
                .Cast<Func<TEvent, CancellationToken, Task>>()
                .Select(h => h(@event, ct));
            
            await Task.WhenAll(tasks);
        }
    }
}
```

**交付物**:
- `IEventBus.cs`
- `InMemoryEventBus.cs`
- `EventBusTests.cs`

---

#### Task 3.3: 重构通知服务（3 天）

**新的通知服务**:
```csharp
public class NotificationService : INotificationService
{
    private readonly IHubContext<BattleNotificationHub> _hubContext;
    private readonly IEventBus _eventBus;
    private readonly MessageAggregator _aggregator;
    
    public NotificationService(
        IHubContext<BattleNotificationHub> hubContext,
        IEventBus eventBus,
        MessageAggregator aggregator)
    {
        _hubContext = hubContext;
        _eventBus = eventBus;
        _aggregator = aggregator;
        
        // 订阅事件
        SubscribeEvents();
    }
    
    private void SubscribeEvents()
    {
        _eventBus.Subscribe<BattleStartedEvent>(OnBattleStarted);
        _eventBus.Subscribe<BattleCompletedEvent>(OnBattleCompleted);
        _eventBus.Subscribe<BattleProgressEvent>(OnBattleProgress);
        // ... 其他事件
    }
    
    private async Task OnBattleStarted(BattleStartedEvent @event, CancellationToken ct)
    {
        // 高优先级，立即推送
        await _hubContext.Clients
            .Group($"battle_{@event.BattleId}")
            .SendAsync("BattleStarted", new { @event.BattleId }, ct);
    }
    
    private async Task OnBattleProgress(BattleProgressEvent @event, CancellationToken ct)
    {
        // 低优先级，聚合推送
        _aggregator.Aggregate(@event.BattleId, @event);
    }
    
    // ... 其他处理器
}
```

**消息聚合器**:
```csharp
public class MessageAggregator
{
    private readonly ConcurrentDictionary<Guid, List<DomainEvent>> _buffer = new();
    private readonly Timer _flushTimer;
    
    public MessageAggregator()
    {
        _flushTimer = new Timer(Flush, null, TimeSpan.FromMilliseconds(500), TimeSpan.FromMilliseconds(500));
    }
    
    public void Aggregate(Guid battleId, DomainEvent @event)
    {
        _buffer.AddOrUpdate(
            battleId,
            _ => new List<DomainEvent> { @event },
            (_, list) => { list.Add(@event); return list; }
        );
    }
    
    private void Flush(object? state)
    {
        // 批量推送逻辑
    }
}
```

**交付物**:
- `NotificationService.cs`
- `MessageAggregator.cs`
- 集成测试

---

#### Task 3.4: 更新业务服务（2 天）

**集成事件发布**:
```csharp
public class CombatService
{
    private readonly IEventBus _eventBus;
    private readonly IRepository<BattleRecord> _battleRepo;
    
    public async Task StartBattleAsync(Guid characterId, Guid monsterId)
    {
        // 创建战斗
        var battle = new BattleRecord { /* ... */ };
        await _battleRepo.AddAsync(battle);
        
        // 发布事件
        await _eventBus.PublishAsync(new BattleStartedEvent(battle.Id, characterId));
    }
    
    public async Task ProcessBattleTickAsync(Guid battleId)
    {
        // 处理战斗逻辑
        // ...
        
        // 发布进度事件
        await _eventBus.PublishAsync(new BattleProgressEvent(battleId, monster.Hp, monster.MaxHp));
    }
    
    // ... 其他方法
}
```

**交付物**:
- 更新后的服务类
- 事件集成测试

---

#### Task 3.5: 清理旧 SignalR 代码（1 天）

**清理项**:
- ✅ BattleNotificationService（旧版本）
- ✅ BattleMessageFormatter
- ✅ NotificationFilterPipeline
- ✅ NotificationThrottler
- ✅ 过度复杂的配置

**交付物**:
- 清理清单
- 清理后的代码

---

### 5.5 Phase 3 验收标准

- ✅ 事件总线实现完成
- ✅ 通知服务已重构
- ✅ Hub 代码简化（< 200 行）
- ✅ 消息延迟 P95 < 500ms
- ✅ 业务代码不直接依赖 SignalR
- ✅ 旧代码已清理

---

## 六、Phase 4-5 概述

由于篇幅限制，Phase 4（业务服务层整理）和 Phase 5（核心功能迁移）的详细内容将在《架构重建方案（下篇）- 技术细节》中展开。

### Phase 4 要点
- 服务职责划分
- 依赖关系梳理
- 接口规范化
- 单元测试补充

### Phase 5 要点
- 按优先级逐个迁移功能
- 每个功能独立验证
- 性能对比测试
- 灰度发布策略

---

## 七、进度跟踪

### 7.1 每日站会
- 时间: 每天早上 10:00
- 时长: 15 分钟
- 内容: 昨天完成 / 今天计划 / 遇到的问题

### 7.2 周报
- 时间: 每周五下午
- 内容: 本周进展 / 下周计划 / 风险与问题

### 7.3 里程碑评审
- 时间: 每个 Phase 结束时
- 参与: 全体团队成员
- 内容: 验收标准检查 / 代码审查 / 决定是否继续

---

## 八、质量保证

### 8.1 代码审查
- 所有代码必须经过 Code Review
- 至少 1 人审查，复杂代码需 2 人
- Review 清单: 功能正确性、性能、安全性、可读性

### 8.2 自动化测试
- 单元测试覆盖率目标: > 80%
- 集成测试: 关键路径全覆盖
- 性能测试: 每个 Phase 结束时执行

### 8.3 手工测试
- 功能测试清单
- 回归测试清单
- UAT 测试

---

## 九、总结

本文档详细规划了 Phase 0-3 的实施路径，包括：
- 每个阶段的目标和任务
- 详细的实施步骤
- 代码示例和架构设计
- 验收标准和质量保证

通过这个循序渐进的方案，我们将建立稳定、简洁、高效的底层架构，为后续功能迁移打下坚实基础。

---

**文档状态**: ✅ 实施路径完成  
**下一步**: 创建《架构重建方案（下篇）- 技术细节》  
**相关文档**: 架构重建方案（上篇）- 战略规划
