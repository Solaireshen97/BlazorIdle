# 离线任务暂停与恢复系统文档

## 概述

本系统确保玩家离线时，正在执行的任务能够被正确暂停并保存状态，而不是直接完成。当玩家重新上线时，任务可以从离线时的状态继续执行，实现无缝衔接。

## 核心特性

1. **离线检测与自动暂停**：后台服务定期检测离线玩家，自动暂停其正在运行的任务
2. **状态保存**：暂停时保存完整的战斗状态和已执行时长
3. **上线恢复**：玩家重新上线时自动结算离线收益并恢复任务
4. **服务器重启恢复**：服务器重启后自动恢复所有暂停的任务

## 活动状态流转

```
Pending (待执行)
    ↓ StartPlanAsync
Running (执行中)
    ↓ PausePlanAsync (离线)
Paused (已暂停)
    ↓ ResumePlanAsync (上线)
Running (执行中)
    ↓ StopPlanAsync (完成/取消)
Completed/Cancelled
```

## 核心组件

### 1. ActivityState 枚举

位置：`BlazorIdle.Server/Domain/Activities/ActivityState.cs`

```csharp
public enum ActivityState
{
    Pending = 0,      // 待执行
    Running = 1,      // 执行中
    Completed = 2,    // 已完成
    Cancelled = 3,    // 已取消
    Paused = 4        // 已暂停（新增）
}
```

### 2. ActivityPlanService 核心方法

位置：`BlazorIdle.Server/Application/Activities/ActivityPlanService.cs`

#### PausePlanAsync - 暂停任务

```csharp
public async Task<bool> PausePlanAsync(Guid planId, CancellationToken ct = default)
```

**功能**：
- 保存战斗状态快照（BattleStateJson）
- 停止战斗但不结算
- 将状态设置为 `Paused`
- 保存已执行时长（ExecutedSeconds）

**关键特点**：
- **保留** BattleStateJson（用于恢复）
- **不清空** 战斗状态
- **不触发** 下一个任务自动启动

#### ResumePlanAsync - 恢复任务

```csharp
public async Task<bool> ResumePlanAsync(Guid planId, CancellationToken ct = default)
```

**功能**：
- 将 `Paused` 状态改为 `Pending`
- 调用 `StartPlanAsync` 启动任务
- 自动加载 BattleStateJson 恢复战斗状态

#### StopPlanAsync - 停止任务（对比）

**与 PausePlanAsync 的区别**：
- 将状态设置为 `Completed`
- **清空** BattleStateJson
- **触发** 下一个任务自动启动
- 用于任务正常完成或用户主动停止

### 3. OfflineDetectionService - 离线检测服务

位置：`BlazorIdle.Server/Services/OfflineDetectionService.cs`

**功能**：
- 后台服务，每30秒检测一次
- 检查所有 `Running` 状态的任务
- 判断角色的 `LastSeenAtUtc` 是否超过阈值
- 超过阈值则调用 `PausePlanAsync` 暂停任务

**配置项**：
```json
{
  "Offline": {
    "OfflineDetectionSeconds": 60  // 默认60秒
  }
}
```

**关键代码修改**：
```csharp
// 之前（错误）
await planService.StopPlanAsync(plan.Id, ct);

// 现在（正确）
await planService.PausePlanAsync(plan.Id, ct);
```

### 4. PausedPlanRecoveryService - 服务器重启恢复服务

位置：`BlazorIdle.Server/Services/PausedPlanRecoveryService.cs`

**功能**：
- 实现 `IHostedService` 接口
- 在服务器启动时执行一次
- 查找所有 `Paused` 状态的任务
- 检查角色是否有其他运行中的任务
- 自动调用 `ResumePlanAsync` 恢复任务

**启动流程**：
1. 服务器启动
2. 查询所有 `State == Paused` 的计划
3. 对每个计划：
   - 验证角色存在
   - 检查是否有其他运行中的任务
   - 调用 `ResumePlanAsync` 恢复
4. 记录恢复成功/失败数量

**注册方式**：
```csharp
// Program.cs
builder.Services.AddHostedService<PausedPlanRecoveryService>();
```

### 5. OfflineSettlementService - 离线结算服务

位置：`BlazorIdle.Server/Application/Battles/Offline/Offline.cs`

**新增逻辑**：
```csharp
// CheckAndSettleAsync 方法中
// 查找运行中的计划
var runningPlan = await _plans.GetRunningPlanAsync(characterId, ct);

// 如果没有运行中的计划，检查是否有暂停的计划
if (runningPlan is null)
{
    var pausedPlan = await _plans.GetByCharacterIdAndStateAsync(
        characterId, ActivityState.Paused, ct);
    if (pausedPlan is not null)
    {
        // 将暂停的计划视为运行计划进行离线结算
        runningPlan = pausedPlan;
    }
}
```

**效果**：
- 玩家上线时，暂停的任务会被检测到
- 进行离线时长的快进模拟
- 结算离线收益
- 任务继续执行（如果未完成）或自动启动下一个任务（如果已完成）

### 6. Repository 扩展

新增接口方法：

```csharp
// IActivityPlanRepository
Task<ActivityPlan?> GetByCharacterIdAndStateAsync(
    Guid characterId, ActivityState state, CancellationToken ct = default);
    
Task<List<ActivityPlan>> GetAllPausedPlansAsync(
    CancellationToken ct = default);
```

实现：
```csharp
// ActivityPlanRepository
public Task<ActivityPlan?> GetByCharacterIdAndStateAsync(...)
    => _db.ActivityPlans
        .Where(p => p.CharacterId == characterId && p.State == state)
        .FirstOrDefaultAsync(ct);

public async Task<List<ActivityPlan>> GetAllPausedPlansAsync(...)
    => await _db.ActivityPlans
        .Where(p => p.State == ActivityState.Paused)
        .ToListAsync(ct);
```

## 完整流程示例

### 场景1：玩家离线后重新上线

1. **玩家在线执行任务**
   - 状态：`Running`
   - ExecutedSeconds: 1800（30分钟）
   - BattleStateJson: 保存当前战斗状态

2. **玩家离线**
   - LastSeenAtUtc 停止更新
   - 60秒后，OfflineDetectionService 检测到离线
   - 调用 `PausePlanAsync`
   - 状态变为：`Paused`
   - BattleStateJson 保留
   - ExecutedSeconds 保持为 1800

3. **玩家离线期间**
   - 状态保持：`Paused`
   - 任务不执行
   - 状态保存在数据库中

4. **玩家重新上线**
   - 调用 `/api/offline/check` 端点
   - `CheckAndSettleAsync` 检测到 `Paused` 计划
   - 计算离线时长：例如 1200 秒（20分钟）
   - 使用 `OfflineFastForwardEngine` 快进模拟
   - 从 ExecutedSeconds=1800 开始模拟
   - 结算离线收益
   - 如果未完成，状态恢复为 `Running` 继续执行

### 场景2：服务器重启

1. **服务器重启前**
   - 多个任务处于 `Paused` 状态
   - 状态保存在数据库中

2. **服务器启动**
   - `PausedPlanRecoveryService.StartAsync` 被调用
   - 查询所有 `Paused` 计划
   - 对每个计划调用 `ResumePlanAsync`
   - 任务恢复为 `Running` 状态

3. **恢复结果**
   - 成功恢复的任务继续执行
   - 失败的任务保持 `Paused` 状态（等待下次尝试或手动处理）

## 数据库状态对比

### 之前（错误实现）

离线检测时：
```
State: Running → Completed
BattleStateJson: 保存 → 清空
CompletedAt: null → DateTime.UtcNow
问题：任务被标记为完成，无法恢复
```

### 现在（正确实现）

离线检测时：
```
State: Running → Paused
BattleStateJson: 保存 → 保留
CompletedAt: null → null
优点：任务可以恢复执行
```

## 配置说明

### appsettings.json

```json
{
  "Offline": {
    "OfflineDetectionSeconds": 60,    // 离线检测阈值（秒）
    "MaxOfflineHours": 12              // 最大离线结算时长（小时）
  }
}
```

## 日志监控

### OfflineDetectionService 日志

```
[Information] 离线检测服务已启动
[Information] 检测到玩家 {CharacterId} 已离线 {OfflineSeconds} 秒，暂停计划 {PlanId}
[Error] 暂停计划 {PlanId} 时发生错误
```

### PausedPlanRecoveryService 日志

```
[Information] 开始恢复暂停的活动计划...
[Information] 找到 {Count} 个暂停的计划需要恢复
[Information] 成功恢复计划 {PlanId} (角色: {CharacterId})
[Warning] 恢复计划 {PlanId} 失败
[Information] 计划恢复完成：成功 {SuccessCount} 个，失败 {FailureCount} 个
```

## 潜在问题与解决方案

### 问题1：角色有多个暂停的任务

**场景**：服务器重启前，同一角色有多个暂停的任务

**解决方案**：
- `GetByCharacterIdAndStateAsync` 只返回第一个暂停的任务
- 其他暂停的任务会在第一个任务完成后自动启动（通过 `TryStartNextPendingPlanAsync`）

### 问题2：任务限制时间到期

**场景**：离线期间任务已达到 `LimitValue`

**解决方案**：
- `OfflineFastForwardEngine` 会检测任务是否完成
- 如果完成，`PlanCompleted = true`
- `CheckAndSettleAsync` 会触发下一个任务启动

### 问题3：战斗状态JSON损坏

**场景**：BattleStateJson 反序列化失败

**解决方案**：
- `StartPlanAsync` 中有 try-catch 处理
- 反序列化失败时，battleState = null
- 任务从头开始执行（但 ExecutedSeconds 保留）

## 测试建议

### 单元测试

1. **测试暂停功能**
   ```csharp
   [Fact]
   public async Task PausePlanAsync_ShouldSaveBattleState()
   {
       // 创建运行中的计划
       // 调用 PausePlanAsync
       // 验证：State == Paused
       // 验证：BattleStateJson != null
       // 验证：ExecutedSeconds 已保存
   }
   ```

2. **测试恢复功能**
   ```csharp
   [Fact]
   public async Task ResumePlanAsync_ShouldRestoreBattleState()
   {
       // 创建暂停的计划（含 BattleStateJson）
       // 调用 ResumePlanAsync
       // 验证：State == Running
       // 验证：战斗状态已恢复
   }
   ```

3. **测试离线检测**
   ```csharp
   [Fact]
   public async Task OfflineDetection_ShouldPauseTask_WhenPlayerOffline()
   {
       // 创建角色和运行中的计划
       // 设置 LastSeenAtUtc 为 2 分钟前
       // 调用 CheckAndPauseOfflinePlayers
       // 验证：State == Paused
   }
   ```

### 集成测试

1. **完整离线-上线流程**
   - 创建任务并启动
   - 模拟离线（不更新 LastSeenAtUtc）
   - 等待离线检测服务暂停任务
   - 模拟上线（调用 CheckAndSettleAsync）
   - 验证任务恢复执行

2. **服务器重启流程**
   - 创建并暂停任务
   - 重启应用（或直接调用 PausedPlanRecoveryService）
   - 验证任务自动恢复

## 相关文档

- [活动计划系统文档](./活动计划系统文档.md)
- [离线战斗实施方案](../docs/OfflineBattleImplementationPlan.md)
- [OfflineFastForwardEngine实施文档](./OfflineFastForwardEngine实施文档.md)
- [离线战斗快速开始](./离线战斗快速开始.md)

## 总结

本次修复确保了：

1. ✅ 离线玩家的任务会被**暂停**而不是**完成**
2. ✅ 任务状态（BattleStateJson、ExecutedSeconds）被正确保存
3. ✅ 玩家上线时任务可以从离线时的状态**继续执行**
4. ✅ 服务器重启后任务可以**自动恢复**
5. ✅ 离线结算功能正常工作（通过 OfflineFastForwardEngine）

系统现在符合原始设计要求：**"暂停当前任务并以玩家最后一次更新心跳时间的状态来保存当前任务状态然后清空内存等待下次玩家更新心跳后恢复任务"**。
