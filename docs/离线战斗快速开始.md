# 离线战斗系统 - 快速开始指南

> 🎯 **目标**: 5分钟了解如何实现离线战斗功能

---

## 📌 核心概念

**离线战斗** = 用户下线后，系统继续计算战斗收益，上线时一次性结算

**关键流程**:
1. 用户下线前有运行中的战斗计划
2. 系统记录下线时间
3. 用户上线时自动计算离线期间收益
4. 展示收益并发放

---

## ✅ 已有的代码（可直接复用）

| 组件 | 位置 | 功能 |
|------|------|------|
| `ActivityPlan` | `Domain/Activities/ActivityPlan.cs` | 活动计划模型（已完整） |
| `BattleSimulator` | `Application/Battles/BattleSimulator.cs` | 战斗快进模拟器 |
| `OfflineSettlementService` | `Application/Battles/Offline/Offline.cs` | 离线结算服务（基础版） |
| `LastSeenAtUtc` | `Character.cs` | 角色最后在线时间字段 |

---

## ❌ 需要新增的代码

### 1. 核心引擎（必须）

**文件**: `BlazorIdle.Server/Application/Battles/Offline/OfflineFastForwardEngine.cs`

**代码框架**:
```csharp
public class OfflineFastForwardEngine
{
    private readonly BattleSimulator _simulator;
    
    public OfflineFastForwardResult FastForward(
        Character character,
        ActivityPlan plan,
        double offlineSeconds,
        double maxCapSeconds = 43200) // 12小时
    {
        // 1. 限制离线时长
        var capped = Math.Min(offlineSeconds, maxCapSeconds);
        
        // 2. 计算计划剩余时长
        var remaining = CalculateRemaining(plan, capped);
        
        // 3. 快进模拟
        var result = Simulate(character, plan, remaining);
        
        // 4. 更新计划状态
        plan.ExecutedSeconds += remaining;
        if (plan.IsLimitReached())
            plan.State = ActivityState.Completed;
        
        return result;
    }
}
```

---

### 2. 自动检测（必须）

**文件**: `BlazorIdle.Server/Application/Battles/Offline/Offline.cs`（扩展）

**新增方法**:
```csharp
public async Task<OfflineCheckResult> CheckAndSettleAsync(
    Guid characterId, 
    CancellationToken ct)
{
    var character = await _characters.GetAsync(characterId, ct);
    
    // 计算离线时长
    var offline = (DateTime.UtcNow - character.LastSeenAtUtc).TotalSeconds;
    
    if (offline <= 0)
        return new OfflineCheckResult { HasOfflineTime = false };
    
    // 查找运行计划
    var plan = await _plans.GetRunningPlanAsync(characterId, ct);
    if (plan is null)
        return new OfflineCheckResult { 
            HasOfflineTime = true, 
            HasRunningPlan = false 
        };
    
    // 快进模拟
    var result = _engine.FastForward(character, plan, offline);
    
    // 更新计划
    await _plans.UpdateAsync(plan, ct);
    
    // 更新心跳
    character.LastSeenAtUtc = DateTime.UtcNow;
    await _characters.UpdateAsync(character, ct);
    
    return new OfflineCheckResult { 
        HasOfflineTime = true,
        Settlement = result 
    };
}
```

---

### 3. API端点（必须）

**文件**: `BlazorIdle.Server/Api/OfflineController.cs`（扩展）

**新增端点**:
```csharp
[HttpGet("check")]
public async Task<ActionResult<OfflineCheckResult>> CheckOffline(
    [FromQuery] Guid characterId,
    CancellationToken ct)
{
    var result = await _offline.CheckAndSettleAsync(characterId, ct);
    return Ok(result);
}

[HttpPost("apply")]
public async Task<ActionResult> ApplySettlement(
    [FromBody] ApplySettlementRequest request,
    CancellationToken ct)
{
    await _offline.ApplySettlementAsync(
        request.CharacterId,
        request.Settlement,
        ct);
    return Ok();
}
```

---

### 4. 前端弹窗（必须）

**文件**: `BlazorIdle/Components/OfflineSettlementDialog.razor`（新建）

**组件代码**:
```razor
@if (Result?.HasOfflineTime == true && Result.Settlement != null)
{
    <div class="offline-dialog">
        <h2>欢迎回来！</h2>
        <p>离线时长: @FormatDuration(Result.OfflineSeconds)</p>
        
        <div class="rewards">
            <div>金币: +@Result.Settlement.Gold</div>
            <div>经验: +@Result.Settlement.Exp</div>
            <div>击杀: @Result.Settlement.TotalKills</div>
        </div>
        
        <button @onclick="OnClaimClicked">确认领取</button>
    </div>
}

@code {
    [Parameter] public OfflineCheckResult? Result { get; set; }
    [Parameter] public EventCallback OnClaim { get; set; }
    
    private async Task OnClaimClicked()
    {
        await OnClaim.InvokeAsync();
    }
    
    private string FormatDuration(double seconds)
    {
        var ts = TimeSpan.FromSeconds(seconds);
        return $"{ts.Hours}小时{ts.Minutes}分钟";
    }
}
```

---

### 5. 前端集成（必须）

**文件**: `BlazorIdle/Pages/Characters.razor`（修改）

**在OnInitializedAsync中添加**:
```csharp
protected override async Task OnInitializedAsync()
{
    // ... 原有代码 ...
    
    // 检查离线收益
    if (selectedCharacter != null)
    {
        var offlineResult = await apiClient.CheckOfflineAsync(
            selectedCharacter.Id);
        
        if (offlineResult?.HasOfflineTime == true)
        {
            showOfflineDialog = true;
            this.offlineResult = offlineResult;
        }
    }
}

private async Task ClaimOfflineRewards()
{
    await apiClient.ApplyOfflineSettlementAsync(
        selectedCharacter.Id,
        offlineResult.Settlement);
    
    await RefreshCharacter();
    showOfflineDialog = false;
}
```

---

## 🚀 实施步骤（按顺序）

### Step 1: 后端核心（2天）
1. ✅ 创建`OfflineFastForwardEngine.cs`
2. ✅ 扩展`OfflineSettlementService`添加`CheckAndSettleAsync`
3. ✅ 添加API端点`/api/offline/check`和`/api/offline/apply`
4. ✅ 添加心跳端点`/api/characters/{id}/heartbeat`

### Step 2: 前端集成（1天）
5. ✅ 创建`OfflineSettlementDialog.razor`组件
6. ✅ 扩展`ApiClient.cs`添加离线API方法
7. ✅ 修改`Characters.razor`集成离线检查

### Step 3: 测试验证（1天）
8. ✅ 单元测试：快进引擎、时长计算
9. ✅ 集成测试：完整离线流程
10. ✅ 手动测试：UI展示与交互

---

## 🧪 测试方法

### 快速手动测试

1. **创建角色和计划**
```
POST /api/characters (创建角色)
POST /api/activity-plans/combat?characterId=xxx&limitType=duration&limitValue=3600
(创建1小时战斗计划)
```

2. **模拟离线**
```sql
-- 直接修改数据库
UPDATE Characters 
SET LastSeenAtUtc = datetime('now', '-1 hour')
WHERE Id = 'your-character-id';
```

3. **重新登录验证**
- 打开Characters页面
- 应该看到离线结算弹窗
- 检查收益数据是否正确
- 点击"确认领取"
- 验证角色数据已更新

---

## 📊 关键数据结构

### OfflineFastForwardResult
```csharp
public class OfflineFastForwardResult
{
    public Guid CharacterId { get; set; }
    public Guid PlanId { get; set; }
    public double SimulatedSeconds { get; set; }  // 模拟时长
    public bool PlanCompleted { get; set; }       // 计划是否完成
    public long Gold { get; set; }                // 金币收益
    public long Exp { get; set; }                 // 经验收益
    public Dictionary<string, double> Loot { get; set; }
}
```

### OfflineCheckResult
```csharp
public class OfflineCheckResult
{
    public bool HasOfflineTime { get; set; }      // 是否有离线时间
    public double OfflineSeconds { get; set; }    // 离线总时长
    public bool HasRunningPlan { get; set; }      // 是否有运行计划
    public OfflineFastForwardResult? Settlement { get; set; }
    public bool PlanCompleted { get; set; }       // 计划是否完成
    public bool NextPlanStarted { get; set; }     // 是否启动下一个
    public Guid? NextPlanId { get; set; }
}
```

---

## ⚙️ 配置项

**文件**: `appsettings.json`

```json
{
  "Offline": {
    "MaxOfflineSeconds": 43200,     // 12小时上限
    "EnableAutoSettlement": true     // 是否启用自动结算
  }
}
```

---

## 🔍 调试技巧

### 1. 查看离线时长计算
```csharp
// 在CheckAndSettleAsync方法中添加日志
var offlineSeconds = (DateTime.UtcNow - character.LastSeenAtUtc).TotalSeconds;
Console.WriteLine($"[Offline] Character {characterId} offline for {offlineSeconds}s");
```

### 2. 验证快进结果
```csharp
// 在FastForward方法中添加日志
Console.WriteLine($"[FastForward] Simulated {simulatedSeconds}s, Gold={result.Gold}, Exp={result.Exp}");
```

### 3. 前端调试
```javascript
// 在浏览器控制台查看API响应
await fetch('/api/offline/check?characterId=xxx')
  .then(r => r.json())
  .then(console.log);
```

---

## 📚 完整文档参考

- **详细设计**: `docs/OfflineBattleImplementationPlan.md`
- **流程图**: `docs/离线战斗流程图.md`
- **实施总结**: `docs/离线战斗系统实施总结.md`

---

## ❓ 常见问题

### Q1: 如何设置离线时长上限？
A: 在`appsettings.json`中修改`Offline:MaxOfflineSeconds`

### Q2: 离线期间计划会继续运行吗？
A: 不会。离线结算是在用户上线时"快进模拟"过去的时间

### Q3: 如果离线时间超过计划剩余时间怎么办？
A: 只模拟到计划完成，多余时间不计算（除非有下一个计划自动启动）

### Q4: 支持多个计划自动衔接吗？
A: 支持。当前计划完成后，会自动启动下一个Pending计划

### Q5: 前端需要定期心跳吗？
A: 推荐但非必须。可以在页面加载时调用一次`/heartbeat`即可

---

## ✅ 检查清单

实施完成后检查：

- [ ] `OfflineFastForwardEngine` 类已创建
- [ ] `OfflineSettlementService.CheckAndSettleAsync` 方法已添加
- [ ] API端点 `/api/offline/check` 可用
- [ ] API端点 `/api/offline/apply` 可用
- [ ] 前端弹窗组件已创建
- [ ] `Characters.razor` 已集成离线检查
- [ ] 单元测试已通过
- [ ] 手动测试流程正常

---

**开始实施吧！** 🚀

有问题参考详细文档：`docs/OfflineBattleImplementationPlan.md`
