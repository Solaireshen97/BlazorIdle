# BlazorIdle 装备系统优化总体方案（上篇）
## 系统分析与架构设计

**项目**: BlazorIdle  
**文档版本**: 2.0 整合版  
**创建日期**: 2025-10-11  
**状态**: 设计阶段 - 整合完成  
**作者**: 系统架构设计团队  

---

## 📋 文档说明

本文档为 BlazorIdle 装备系统优化的整合总体方案，由原有的两套设计方案（《装备系统优化方案.md》和《装备系统优化设计方案.md》）合并优化而成。

### 文档结构

本总体方案分为三个部分：

- **上篇（本文档）**: 系统分析与架构设计
  - 当前状态深度分析
  - 设计目标与原则
  - 核心架构设计
  - 领域模型详细设计

- **中篇**: 执行计划与技术规范
  - 详细的Phase执行计划（Phase 1-8）
  - 技术实现规范
  - 配置化设计方案
  - 与现有系统的集成方案

- **下篇**: 测试验证与扩展设计
  - 完整的测试策略
  - 数值平衡设计
  - 前端验证方案
  - 扩展性设计
  - 风险评估与应对

### 整合设计原则

本总体方案整合了两套原有方案的优点：
1. **方案一**的完整装备生成、掉落、增强系统设计（8个Phase）
2. **方案二**的17槽位系统、护甲类型、武器类型、战斗机制设计（5个Phase）

整合后的方案具备：
- ✅ **完整性**: 覆盖从基础槽位到高级增强的全流程
- ✅ **可操作性**: 分阶段实施，每个阶段可独立验证
- ✅ **前后端结合**: 明确前端验证点和UI实现要求
- ✅ **数据驱动**: 所有配置参数化，易于调整平衡
- ✅ **向后兼容**: 保护现有数据和功能
- ✅ **代码风格一致**: 遵循项目现有规范

---

## 目录

1. [愿景与核心定位](#1-愿景与核心定位)
2. [当前状态全面分析](#2-当前状态全面分析)
   - 2.1 [已完成的工作](#21-已完成的工作)
   - 2.2 [现有系统能力评估](#22-现有系统能力评估)
   - 2.3 [缺失的关键功能](#23-缺失的关键功能)
   - 2.4 [系统整合参考](#24-系统整合参考)
3. [设计目标与原则](#3-设计目标与原则)
   - 3.1 [核心目标](#31-核心目标)
   - 3.2 [设计原则](#32-设计原则)
   - 3.3 [成功标准](#33-成功标准)
4. [装备系统完整架构](#4-装备系统完整架构)
   - 4.1 [系统概览](#41-系统概览)
   - 4.2 [模块划分与职责](#42-模块划分与职责)
   - 4.3 [核心流程设计](#43-核心流程设计)
5. [装备槽位系统设计](#5-装备槽位系统设计)
   - 5.1 [槽位扩展方案（9→17个）](#51-槽位扩展方案917个)
   - 5.2 [槽位配置与分类](#52-槽位配置与分类)
   - 5.3 [双手武器占用机制](#53-双手武器占用机制)
6. [护甲类型系统设计](#6-护甲类型系统设计)
   - 6.1 [护甲类型定义](#61-护甲类型定义)
   - 6.2 [护甲特性与平衡](#62-护甲特性与平衡)
   - 6.3 [护甲减伤机制](#63-护甲减伤机制)
7. [武器类型系统设计](#7-武器类型系统设计)
   - 7.1 [武器类型分类](#71-武器类型分类)
   - 7.2 [攻击速度与伤害倍率](#72-攻击速度与伤害倍率)
   - 7.3 [双持机制](#73-双持机制)
   - 7.4 [格挡机制（盾牌）](#74-格挡机制盾牌)
8. [职业装备限制系统](#8-职业装备限制系统)
   - 8.1 [职业-装备兼容性](#81-职业装备兼容性)
   - 8.2 [装备验证机制](#82-装备验证机制)
9. [领域模型详细设计](#9-领域模型详细设计)
   - 9.1 [装备定义（GearDefinition）](#91-装备定义geardefinition)
   - 9.2 [装备实例（GearInstance）](#92-装备实例gearinstance)
   - 9.3 [词条系统（Affix）](#93-词条系统affix)
   - 9.4 [套装系统（GearSet）](#94-套装系统gearset)
10. [数据库设计](#10-数据库设计)
    - 10.1 [表结构设计](#101-表结构设计)
    - 10.2 [索引策略](#102-索引策略)
    - 10.3 [数据迁移方案](#103-数据迁移方案)

---

## 1. 愿景与核心定位

装备系统是 BlazorIdle 核心玩法的基石之一，本次优化旨在将其从简化的UI预留框架（Step 5）升级为完整、深度、可扩展的装备体系。

### 核心愿景

**打造一个"深度 + 策略 + 成长"的装备系统，为玩家提供持续的装备追求目标和多样化的构筑选择。**

### 关键特征

1. **完整的装备槽位**: 17个槽位（对标经典MMORPG）
2. **类型化系统**: 护甲类型（4种）+ 武器类型（15种）
3. **随机性与追求**: 稀有度、品级、词条系统提供装备进阶路径
4. **职业差异化**: 不同职业有不同的装备限制和属性倾向
5. **装备成长**: 分解、重铸、词条重置等增强玩法
6. **套装系统**: 提供构筑深度和长期目标
7. **数据驱动**: 所有参数配置化，便于平衡调整

### 对玩家的价值

- **短期**: 装备掉落的即时反馈和属性提升
- **中期**: 装备优化、套装收集的进阶目标
- **长期**: 极品装备追求、完美词条打造的持续动力

### 对系统的价值

- **战斗深度**: 装备属性直接影响战斗表现，增加策略性
- **经济循环**: 装备分解、重铸形成材料消耗闭环
- **内容扩展**: 易于添加新装备、新套装、新词条
- **数值管线**: 统一的属性计算保证平衡性

---

## 2. 当前状态全面分析

### 2.1 已完成的工作

根据项目文档（`装备系统UI完成报告.md`、`STEP5_SUMMARY.md`）和代码分析，装备系统在 **Step 5** 完成了UI框架预留。

#### ✅ 已实现部分

##### 1. 前端UI框架 (`EquipmentPanel.razor`)

```
当前装备面板布局（3x3网格）:
┌──────────┬──────────┬──────────┐
│   🪖      │    ⚔️     │   🛡️      │
│  头盔     │   武器    │   副手    │
├──────────┼──────────┼──────────┤
│   🧥      │    ⚖️     │   🦵      │
│  胸甲     │   腰带    │   腿部    │
├──────────┼──────────┼──────────┤
│   👟      │    💍     │   💍      │
│  鞋子     │  饰品1    │  饰品2    │
└──────────┴──────────┴──────────┘
```

**功能**:
- 9个装备槽位的UI展示
- 总属性展示面板
- 品质颜色系统（普通/稀有/史诗/传说）
- 基础的槽位布局

##### 2. 数据模型定义 (`BlazorIdle/Services/ApiModels.cs`)

```csharp
// 已定义的关键DTO
public sealed class EquipmentResponse
{
    public List<EquipmentSlotDto> Slots { get; set; }
    public Dictionary<string, double> TotalStats { get; set; }
}

public sealed class EquipmentSlotDto
{
    public string SlotType { get; set; }
    public string SlotName { get; set; }
    public GearInstanceDto? Gear { get; set; }
}

public sealed class GearInstanceDto
{
    public Guid Id { get; set; }
    public string DefinitionId { get; set; }
    public string Name { get; set; }
    public string Icon { get; set; }
    public string Rarity { get; set; }        // Common/Rare/Epic/Legendary
    public int Tier { get; set; }             // 1-3
    public int ItemLevel { get; set; }
    public int QualityScore { get; set; }
    public List<AffixDto> Affixes { get; set; }
    public string? SetId { get; set; }
    public Dictionary<string, double> Stats { get; set; }
}

public sealed class AffixDto
{
    public string AffixId { get; set; }
    public string DisplayText { get; set; }
    public double Value { get; set; }
}
```

##### 3. API接口预留 (`BlazorIdle.Server/Api/EquipmentController.cs`)

```csharp
// 当前为占位实现，返回空槽或501错误
[HttpGet("{characterId:guid}")]
public ActionResult<object> GetEquipment(Guid characterId)
{
    // 返回9个空槽位
}

[HttpPost("{characterId:guid}/{slot}")]
public ActionResult<object> EquipItem(Guid characterId, string slot, [FromBody] object request)
{
    // 返回 501 Not Implemented
}

[HttpDelete("{characterId:guid}/{slot}")]
public ActionResult<object> UnequipItem(Guid characterId, string slot)
{
    // 返回 501 Not Implemented
}
```

##### 4. 测试覆盖

- **单元测试**: 18个测试用例全部通过
- **测试内容**: 槽位类型、品质枚举、属性计算等核心功能
- **测试框架**: xUnit + FluentAssertions

#### ❌ 缺失部分

根据《整合设计总结.txt》第13节"装备与物品生态"分析：

##### 1. 领域模型层

```
缺失的核心实体:
❌ Domain/Equipment/Models/
   ├── GearDefinition.cs          # 装备定义（配置）
   ├── GearInstance.cs            # 装备实例（数据库实体）
   ├── Affix.cs                   # 词条定义
   ├── AffixInstance.cs           # 词条实例
   ├── GearSet.cs                 # 套装定义
   └── EquipmentSlot.cs           # 装备槽枚举（扩展版）
```

##### 2. 核心服务层

```
缺失的关键服务:
❌ Domain/Equipment/Services/
   ├── GearGenerationService.cs   # 装备生成（稀有度/品级/词条Roll）
   ├── EquipmentService.cs        # 装备管理（装备/卸下/验证）
   ├── StatsAggregationService.cs # 属性聚合（装备→总属性）
   ├── DisenchantService.cs       # 分解服务
   ├── ReforgeService.cs          # 重铸服务（品级提升）
   └── SetBonusService.cs         # 套装加成计算
```

##### 3. 数据持久化层

```
缺失的数据表:
❌ GearDefinitions      # 装备定义配置表
❌ GearInstances        # 装备实例表
❌ AffixDefinitions     # 词条定义表
❌ GearSets             # 套装定义表
```

##### 4. 核心功能

```
❌ 装备生成逻辑
   - 稀有度随机算法（加权随机）
   - 基础属性Roll（范围内随机）
   - 词条生成算法（根据稀有度决定数量和品质）
   - 装备评分计算
   - 品级系数应用

❌ 装备掉落系统
   - 集成到 EconomyRegistry
   - 掉落表配置（LootTable）
   - 与战斗系统集成

❌ 装备管理操作
   - 装备/卸下功能
   - 装备验证（等级/职业/槽位）
   - 属性计算与汇总
   - 套装效果触发

❌ 装备增强系统
   - 装备分解（获取材料）
   - 品级重铸（Tier提升）
   - 词条重置（Reroll）
   - 成本计算

❌ 战斗集成
   - 装备属性注入到 CharacterStats
   - 装备属性参与战斗计算
   - 装备特效/触发技能（未来扩展）

❌ 17槽位系统
   - 扩展到17个装备槽位
   - 双手武器占用机制
   - 护甲类型系统
   - 武器类型系统
   - 格挡机制
   - 职业装备限制
```

---

### 2.2 现有系统能力评估

#### 可复用的系统

##### 1. 经济系统 (`Domain/Combat/Economy/`)

```
已有能力:
✅ EconomyRegistry        # 物品注册中心
✅ LootTable              # 掉落表系统
✅ EconomyCalculator      # 掉落计算器
✅ RewardGrantService     # 奖励发放服务
✅ InventoryItem          # 背包物品表

复用方案:
- 将装备作为特殊物品类型（ItemType = "gear"）集成
- 扩展 LootEntry 支持装备生成参数
- 使用 RewardGrantService 发放装备到背包
```

##### 2. 战斗系统 (`Domain/Combat/`)

```
已有能力:
✅ CharacterStats         # 角色属性（攻击/暴击/急速/穿透）
✅ PlayerCombatant        # 玩家战斗单位
✅ StatsBuilder           # 属性构建器
✅ BuffManager            # Buff管理（可用于套装效果）

集成方案:
- 在 StatsBuilder.BuildStats() 中注入装备属性
- 装备属性通过 StatsAggregationService 计算后注入
- 套装效果可转换为 Buff 形式应用
```

##### 3. 角色系统 (`Domain/Characters/`)

```
已有能力:
✅ Character              # 角色实体（主属性/等级/职业）
✅ PrimaryAttributes      # 主属性（力量/敏捷/智力/耐力）
✅ ProfessionBaseStatsRegistry  # 职业基础属性

扩展方案:
- 添加 Character.EquippedGear 导航属性
- 实现装备与角色的关联查询
- 职业限制基于 Profession 字段验证
```

##### 4. 数据持久化 (`Infrastructure/Persistence/`)

```
已有能力:
✅ GameDbContext          # EF Core 数据库上下文
✅ *Configuration.cs      # 实体配置模式
✅ Migrations             # 数据库迁移机制

扩展方案:
- 添加装备相关表的 Configuration 类
- 创建数据库迁移脚本
- 使用种子数据（Seed Data）初始化装备定义
```

##### 5. RNG系统 (`Domain/Combat/RNG/`)

```
已有能力:
✅ RNGContext             # 随机数上下文（可回放）
✅ SeedSequence           # 种子序列管理

复用方案:
- 装备生成使用 RNGContext 保证可回放
- 稀有度、属性Roll、词条生成均基于种子
- 支持离线装备生成验证
```

---

### 2.3 缺失的关键功能

#### 功能缺失总结

| 功能模块 | 缺失程度 | 优先级 | 说明 |
|---------|---------|--------|------|
| **装备槽位扩展（17槽位）** | 100% | ⭐⭐⭐⭐⭐ | 从9个扩展到17个，核心基础 |
| **护甲类型系统** | 100% | ⭐⭐⭐⭐⭐ | 4种护甲类型，影响战斗平衡 |
| **武器类型系统** | 100% | ⭐⭐⭐⭐⭐ | 15种武器类型，决定攻击方式 |
| **装备生成逻辑** | 100% | ⭐⭐⭐⭐⭐ | 核心玩法，无此则无装备 |
| **装备管理服务** | 100% | ⭐⭐⭐⭐⭐ | 装备/卸下/验证 |
| **属性聚合计算** | 100% | ⭐⭐⭐⭐⭐ | 装备→总属性，影响战斗 |
| **装备掉落系统** | 90% | ⭐⭐⭐⭐ | 需集成到经济系统 |
| **格挡机制** | 100% | ⭐⭐⭐⭐ | 盾牌特性 |
| **职业装备限制** | 100% | ⭐⭐⭐⭐ | 职业差异化 |
| **套装系统** | 100% | ⭐⭐⭐ | 中长期目标 |
| **装备分解** | 100% | ⭐⭐⭐ | 经济循环 |
| **品级重铸** | 100% | ⭐⭐⭐ | 装备进阶 |
| **词条重置** | 100% | ⭐⭐⭐ | 装备优化 |
| **前端17槽位UI** | 100% | ⭐⭐⭐⭐ | 用户体验 |
| **装备对比功能** | 100% | ⭐⭐⭐ | 用户体验 |

---

### 2.4 系统整合参考

根据《整合设计总结.txt》第13节，装备系统设计要点：

#### 装备与物品生态（品级 / 词条 / 套装 / 分解 / 重铸）

| 设计点 | 内容 |
|--------|------|
| **GearDefinition** | 基础属性范围 / 允许词条池 / slot / 稀有度权重 |
| **GearInstance** | defId + tier(T1/T2/T3) + affixes[] + setId + qualityScore |
| **Tier 系数** | T1=0.8 / T2=1.0 / T3=1.2（可配置） |
| **Affix** | id, type (Flat/Percent/Proc), rollRange, rarityWeight |
| **套装** | setId + pieceBonuses + activeCount |
| **分解 (Disenchant)** | 输入：装备 → 材料（按 tier/rarity） |
| **品级重铸 (ReforgeTier)** | 消耗：材料+金币 → +Tier |
| **词条重置 (Reroll)** | 重生成 affixes；成本递增 / 保底机制 |
| **词条重铸 (Refine Future)** | 精炼指定 affix 小幅提升 |
| **装备技能/特效** | 特殊标签：在事件钩子 (OnHit/OnCast) 注册 |

#### 数值管线 (防膨胀)

```
final = clamp(((base + ΣAdditive) * Π(1+Mult)) + ΣFinalAdd)
```

**限制机制**:
- Mult 源数控制（乘法修饰符不能无限叠加）
- 攻速下限（防止攻击过慢）
- 暴击上限（100%封顶）

---

## 3. 设计目标与原则

### 3.1 核心目标

#### 目标1: 完善服务端装备功能

**实现范围**:
- ✅ 装备生成系统（稀有度/品级/词条）
- ✅ 装备掉落系统（集成到经济系统）
- ✅ 装备管理操作（装备/卸下/验证）
- ✅ 属性计算系统（装备→总属性→战斗）
- ✅ 装备增强系统（分解/重铸/词条重置）
- ✅ 套装系统（收集奖励）

**成功指标**:
- 装备生成算法稳定，数值合理
- 装备属性正确影响战斗结果
- 装备操作响应时间 < 500ms
- 单元测试覆盖率 ≥ 90%

#### 目标2: 扩展装备系统深度

**实现范围**:
- ✅ 17个装备槽位（对标经典MMORPG）
- ✅ 4种护甲类型（布/皮/锁/板）
- ✅ 15种武器类型（单手/双手/远程/盾牌）
- ✅ 护甲减伤机制
- ✅ 格挡机制（盾牌特性）
- ✅ 职业装备限制（职业差异化）

**成功指标**:
- 不同护甲类型有明显差异（≥30%属性差）
- 不同武器类型攻击方式区别明显
- 格挡机制正常触发，减伤效果合理
- 职业装备限制正确生效

#### 目标3: 实现前端装备管理

**实现范围**:
- ✅ 完善装备面板（17槽位布局）
- ✅ 装备详情展示（属性/词条/套装）
- ✅ 装备对比功能
- ✅ 装备筛选和排序
- ✅ 装备增强界面（分解/重铸/重置）

**成功指标**:
- UI美观易用，符合玩家习惯
- 装备操作流畅，无明显卡顿
- 装备对比信息清晰准确
- 用户满意度 ≥ 85%

#### 目标4: 保持系统一致性

**实现范围**:
- ✅ 遵循现有代码风格
- ✅ 复用现有系统能力
- ✅ 保持数据驱动设计
- ✅ 维护向后兼容性

**成功指标**:
- 新代码通过 Code Review
- 现有测试全部通过
- 无重大架构调整
- 现有装备数据可平滑迁移

---

### 3.2 设计原则

根据《整合设计总结.txt》第3节架构原则和项目实践：

#### 原则1: 服务端权威 (Server Authoritative)

```
所有关键操作在服务端执行:
├── 装备生成 → 服务端Roll属性
├── 装备验证 → 服务端检查职业/等级/槽位
├── 属性计算 → 服务端聚合并注入战斗
├── 装备增强 → 服务端扣除材料并修改
└── 掉落计算 → 服务端使用RNGContext

防止客户端作弊:
- 前端仅展示和发起请求
- 所有数值计算在服务端
- 使用种子序列保证可回放和审计
```

#### 原则2: 数据驱动 (Data-Driven)

```
配置化设计:
├── 装备定义 → GearDefinitions 表/JSON
├── 词条池 → AffixDefinitions 表
├── 掉落表 → LootTable 配置
├── 护甲类型系数 → ArmorTypeConfig JSON
├── 武器类型参数 → WeaponTypeConfig JSON
├── 职业限制 → ProfessionEquipmentConfig JSON
└── 战斗机制参数 → CombatMechanicsConfig JSON

优势:
- 便于平衡调整（无需改代码）
- 易于扩展新内容（新增配置行）
- 支持A/B测试（切换配置版本）
- 配置可版本化管理
```

#### 原则3: 领域驱动设计 (DDD)

```
清晰的领域边界:
Equipment Domain (装备领域)
├── Models (实体)
├── Services (领域服务)
├── Repositories (仓储接口)
└── Events (领域事件)

聚合根模式:
- GearInstance 作为聚合根
- Affix 作为值对象
- 装备操作通过聚合根方法

领域事件传播:
- EquipmentChanged → 通知属性重算
- GearDisenchanted → 通知经济系统
- SetBonusActivated → 通知Buff系统
```

#### 原则4: 可测试性 (Testability)

```
测试策略:
├── 单元测试 (≥90%覆盖率)
│   ├── 装备生成算法
│   ├── 属性计算逻辑
│   ├── 验证规则
│   └── 数值管线
├── 集成测试
│   ├── 装备-战斗集成
│   ├── 装备-经济集成
│   └── 装备-前端集成
└── E2E测试
    ├── 完整装备流程
    └── 用户操作场景

可注入依赖:
- RNGContext (测试时固定种子)
- Repository (测试时用Mock)
- GameClock (测试时可控制时间)
```

#### 原则5: 性能优化

```
性能策略:
├── 装备属性计算缓存
│   └── 装备变更时失效缓存
├── 装备数据懒加载
│   └── 仅加载当前需要的装备
├── 批量操作支持
│   └── 批量分解、批量装备验证
├── 数据库查询优化
│   ├── 为装备类型字段添加索引
│   ├── 使用 Include 预加载关联数据
│   └── 避免 N+1 查询
└── 前端渲染优化
    ├── 虚拟滚动（装备列表）
    ├── 图标懒加载
    └── 属性计算防抖

性能目标:
- 装备装备/卸下操作 < 200ms
- 装备列表加载 < 500ms
- 装备属性计算 < 50ms
- 装备生成 < 100ms
```

#### 原则6: 安全性

```
安全措施:
├── 装备操作限频
│   └── 防止刷装备/分解作弊
├── 交易验证
│   └── 防止装备复制
├── 装备绑定机制
│   ├── 拾取后绑定
│   └── 装备后绑定
└── RNG种子管理
    └── 服务端控制，客户端不可预测

审计机制:
- 记录所有装备操作
- 记录装备生成种子
- 记录装备增强历史
```

---

### 3.3 成功标准

#### 功能完整性

| 检查项 | 标准 | 验证方式 |
|--------|------|---------|
| 装备生成 | 各稀有度装备可正常生成 | 自动化测试 + 手动验证 |
| 装备掉落 | 掉落率符合预期 | 统计数据分析 |
| 装备操作 | 装备/卸下/验证正确 | 集成测试 |
| 属性计算 | 属性正确影响战斗 | 战斗日志验证 |
| 装备增强 | 分解/重铸/重置正常 | 功能测试 |
| 套装系统 | 套装效果正确触发 | 战斗测试 |
| 前端UI | 17槽位正常显示和操作 | UI测试 |
| 职业限制 | 职业限制正确生效 | 边界测试 |

#### 性能指标

| 指标 | 目标值 | 测量方法 |
|-----|--------|---------|
| 装备装备/卸下响应 | < 200ms | 性能监控 |
| 装备列表加载 | < 500ms | 前端性能分析 |
| 装备属性计算 | < 50ms | 性能测试 |
| 装备生成 | < 100ms | 基准测试 |
| 数据库查询 | < 100ms | SQL性能分析 |
| 内存占用 | < 100MB (服务端) | 内存分析 |

#### 质量指标

| 指标 | 目标值 | 测量方法 |
|-----|--------|---------|
| 单元测试覆盖率 | ≥ 90% | 代码覆盖率工具 |
| 集成测试通过率 | 100% | CI/CD |
| E2E测试通过率 | 100% | 自动化测试 |
| 代码Review通过率 | 100% | Code Review |
| Bug密度 | < 1 bug / 1000 LOC | 缺陷追踪 |
| 技术债务 | Low | SonarQube |

#### 用户体验指标

| 指标 | 目标值 | 测量方法 |
|-----|--------|---------|
| 用户满意度 | ≥ 85% | 问卷调查 |
| 装备相关操作次数 | +300% | 数据统计 |
| 平均游戏时长 | +40% | 用户行为分析 |
| 玩家留存率 | +50% | 留存分析 |

---

## 4. 装备系统完整架构

### 4.1 系统概览

```
装备系统架构全景图:

┌─────────────────────────────────────────────────────────────────┐
│                          前端层 (Blazor)                          │
├─────────────────────────────────────────────────────────────────┤
│  EquipmentPanel.razor     │  InventoryPanel.razor               │
│  GearEnhancementDialog    │  GearComparisonTooltip             │
└─────────────────┬───────────────────────────────────────────────┘
                  │ HTTP API
┌─────────────────▼───────────────────────────────────────────────┐
│                     API层 (Controllers)                          │
├─────────────────────────────────────────────────────────────────┤
│  EquipmentController      │  InventoryController               │
│  - GetEquipment           │  - GetGearInventory                │
│  - EquipItem              │  - CompareGear                     │
│  - UnequipItem            │  - SortGear                        │
│  - DisenchantGear         │  - FilterGear                      │
│  - ReforgeGear            │                                    │
│  - RerollAffixes          │                                    │
└─────────────────┬───────────────────────────────────────────────┘
                  │ Service调用
┌─────────────────▼───────────────────────────────────────────────┐
│                     服务层 (Services)                            │
├─────────────────────────────────────────────────────────────────┤
│  EquipmentService         │  GearGenerationService             │
│  - EquipItem              │  - GenerateGear                    │
│  - UnequipItem            │  - RollRarity                      │
│  - ValidateEquipment      │  - RollBaseStats                   │
│  - SwapGear               │  - GenerateAffixes                 │
│                           │  - CalculateQualityScore           │
├───────────────────────────┼────────────────────────────────────┤
│  StatsAggregationService  │  SetBonusService                   │
│  - CalculateEquipmentStats│  - CalculateSetBonuses             │
│  - AggregateStats         │  - GetActiveSetCounts              │
│  - ApplyPipeline          │  - ApplySetEffects                 │
│  - CacheResults           │                                    │
├───────────────────────────┼────────────────────────────────────┤
│  DisenchantService        │  ReforgeService                    │
│  - Disenchant             │  - ReforgeTier                     │
│  - CalculateMaterials     │  - CalculateCost                   │
│  - GrantMaterials         │  - ApplyTierModifier               │
│                           │  - RerollAffixes                   │
└─────────────────┬───────────────────────────────────────────────┘
                  │ Repository调用
┌─────────────────▼───────────────────────────────────────────────┐
│                     仓储层 (Repositories)                        │
├─────────────────────────────────────────────────────────────────┤
│  IGearDefinitionRepo      │  IGearInstanceRepo                 │
│  - GetById                │  - GetEquippedGear                 │
│  - GetBySlot              │  - GetGearByCharacter              │
│  - GetAll                 │  - Create / Update / Delete        │
├───────────────────────────┼────────────────────────────────────┤
│  IAffixRepository         │  IGearSetRepository                │
│  - GetByPool              │  - GetById                         │
│  - GetAll                 │  - GetAll                          │
└─────────────────┬───────────────────────────────────────────────┘
                  │ EF Core
┌─────────────────▼───────────────────────────────────────────────┐
│                     数据层 (Database)                            │
├─────────────────────────────────────────────────────────────────┤
│  GearDefinitions          │  GearInstances                     │
│  AffixDefinitions         │  GearSets                          │
└─────────────────────────────────────────────────────────────────┘

集成点:
├── Economy (掉落) → GearGenerationService
├── Combat (属性) → StatsAggregationService
├── Characters (职业) → EquipmentService (验证)
└── Buff (套装效果) → SetBonusService
```

---

### 4.2 模块划分与职责

#### Equipment Domain 核心模块

```
Domain/Equipment/
├── Models/                           # 领域实体
│   ├── GearDefinition.cs             # 装备定义（配置实体）
│   ├── GearInstance.cs               # 装备实例（运行时实体）
│   ├── Affix.cs                      # 词条定义
│   ├── AffixInstance.cs              # 词条实例（值对象）
│   ├── GearSet.cs                    # 套装定义
│   ├── EquipmentSlot.cs              # 装备槽枚举（17个）
│   ├── ArmorType.cs                  # 护甲类型枚举
│   ├── WeaponType.cs                 # 武器类型枚举
│   ├── Rarity.cs                     # 稀有度枚举
│   └── TierLevel.cs                  # 品级值对象
│
├── Services/                         # 领域服务
│   ├── GearGenerationService.cs      # 装备生成核心服务
│   ├── EquipmentService.cs           # 装备管理服务
│   ├── StatsAggregationService.cs    # 属性聚合服务
│   ├── DisenchantService.cs          # 分解服务
│   ├── ReforgeService.cs             # 重铸服务
│   ├── SetBonusService.cs            # 套装加成服务
│   ├── ArmorCalculator.cs            # 护甲减伤计算器
│   ├── BlockCalculator.cs            # 格挡计算器
│   └── EquipmentValidator.cs         # 装备验证器
│
├── Repositories/                     # 仓储接口
│   ├── IGearDefinitionRepository.cs
│   ├── IGearInstanceRepository.cs
│   ├── IAffixRepository.cs
│   └── IGearSetRepository.cs
│
├── ValueObjects/                     # 值对象
│   ├── StatModifier.cs               # 属性修饰符
│   ├── StatRange.cs                  # 属性范围
│   └── AffixRoll.cs                  # 词条Roll结果
│
├── Events/                           # 领域事件
│   ├── EquipmentChangedEvent.cs
│   ├── GearDisenchantedEvent.cs
│   ├── GearReforgedEvent.cs
│   └── SetBonusActivatedEvent.cs
│
└── Configuration/                    # 配置类
    ├── ArmorTypeConfig.cs
    ├── WeaponTypeConfig.cs
    ├── EquipmentSlotConfig.cs
    ├── ProfessionEquipmentConfig.cs
    └── CombatMechanicsConfig.cs
```

#### 职责矩阵

| 模块 | 职责 | 输入 | 输出 |
|------|------|------|------|
| **GearGenerationService** | 装备生成（Roll属性/词条） | GearDefId, CharLevel, RNG | GearInstance |
| **EquipmentService** | 装备管理（装备/卸下/验证） | CharacterId, GearId, Slot | Success/Error |
| **StatsAggregationService** | 属性聚合（装备→总属性） | CharacterId | EquipmentStats |
| **DisenchantService** | 装备分解（获取材料） | GearInstanceId | Materials[] |
| **ReforgeService** | 品级重铸/词条重置 | GearInstanceId, Cost | UpdatedGear |
| **SetBonusService** | 套装加成计算 | EquippedGear[] | SetBonuses |
| **ArmorCalculator** | 护甲减伤计算 | Armor, AttackerLevel | DamageReduction% |
| **BlockCalculator** | 格挡概率/减伤计算 | Shield, Strength | BlockChance, BlockReduction |
| **EquipmentValidator** | 职业/等级/槽位验证 | Character, Gear | Valid/Invalid |

---

### 4.3 核心流程设计

#### 流程1: 装备生成流程

```
装备生成流程 (GearGenerationService.Generate)

输入: GearDefinitionId, CharacterLevel, RNGContext
输出: GearInstance

步骤:
1. [加载定义] 从Repository获取GearDefinition
   ├── 验证定义存在
   └── 加载允许的词条池

2. [确定稀有度] 根据权重随机（Common/Rare/Epic/Legendary）
   ├── 使用RNG.NextWeighted(RarityWeights)
   └── 稀有度影响后续词条数量

3. [确定品级] 默认T1，后续可通过重铸提升
   └── Tier = 1

4. [计算物品等级] 基于角色等级和稀有度
   ├── ItemLevel = CharacterLevel + RarityBonus
   └── RarityBonus: Common=0, Rare=2, Epic=5, Legendary=10

5. [Roll基础属性] 在范围内随机，受Tier影响
   ├── For each BaseStat in Definition:
   │   ├── Min = BaseStat.Min * TierMultiplier
   │   ├── Max = BaseStat.Max * TierMultiplier
   │   └── RolledValue = RNG.NextDouble(Min, Max)
   └── TierMultiplier: T1=0.8, T2=1.0, T3=1.2

6. [生成词条] 根据稀有度决定数量
   ├── AffixCount = GetAffixCount(Rarity)
   │   ├── Common: 0
   │   ├── Rare: RNG.Next(1, 2)
   │   ├── Epic: RNG.Next(2, 3)
   │   └── Legendary: RNG.Next(3, 4)
   ├── For i = 1 to AffixCount:
   │   ├── 从允许的词条池随机选择（防止重复）
   │   ├── Roll词条数值（RNG.NextDouble(Min, Max)）
   │   └── 添加到AffixInstance列表
   └── 词条权重影响抽取概率

7. [计算装备评分] 综合评估装备品质
   ├── BaseScore = Sum(RolledStats) / Sum(MaxStats) * 100
   ├── AffixScore = Sum(AffixValues) / Sum(MaxAffixValues) * 100
   ├── RarityBonus = Rarity乘数
   ├── TierBonus = Tier乘数
   └── QualityScore = (BaseScore + AffixScore) * RarityBonus * TierBonus

8. [返回实例] 创建GearInstance
   └── GearInstance {
       Id = NewGuid(),
       DefinitionId,
       Rarity,
       TierLevel = 1,
       ItemLevel,
       RolledStats,
       Affixes,
       QualityScore,
       IsEquipped = false,
       IsBound = false,
       CreatedAt = Now
   }
```

#### 流程2: 装备装备流程

```
装备装备流程 (EquipmentService.EquipItem)

输入: CharacterId, GearInstanceId, Slot
输出: Success/Error

步骤:
1. [加载数据]
   ├── Character = GetCharacter(CharacterId)
   ├── GearInstance = GetGearInstance(GearInstanceId)
   └── GearDefinition = GetGearDefinition(GearInstance.DefinitionId)

2. [验证前置条件]
   ├── [验证装备存在] GearInstance != null
   ├── [验证未装备] GearInstance.IsEquipped == false
   ├── [验证归属] GearInstance.CharacterId == CharacterId (在背包中)
   └── [验证槽位匹配] GearDefinition.Slot == Slot

3. [验证装备需求]
   ├── [等级需求] Character.Level >= GearDefinition.RequiredLevel
   ├── [职业限制] ValidateProfessionRestriction(Character.Profession, GearInstance)
   │   ├── 检查护甲类型限制
   │   └── 检查武器类型限制
   └── [特殊规则] 验证双手武器占用、双持能力等

4. [处理已装备物品]
   ├── CurrentGear = GetEquippedGear(CharacterId, Slot)
   ├── If CurrentGear != null:
   │   ├── CurrentGear.IsEquipped = false
   │   ├── CurrentGear.SlotType = null
   │   └── 移回背包

5. [装备新物品]
   ├── GearInstance.IsEquipped = true
   ├── GearInstance.SlotType = Slot
   ├── GearInstance.UpdatedAt = Now
   └── 保存到数据库

6. [失效缓存]
   ├── InvalidateEquipmentStatsCache(CharacterId)
   └── 触发 EquipmentChangedEvent

7. [返回结果]
   └── Success { UpdatedGear, PreviousGear }
```

#### 流程3: 装备属性计算流程

```
装备属性计算流程 (StatsAggregationService.CalculateEquipmentStats)

输入: CharacterId
输出: Dictionary<StatType, double> (装备总属性)

步骤:
1. [检查缓存]
   ├── CachedStats = GetFromCache(CharacterId)
   ├── If CachedStats != null && !Expired:
   │   └── Return CachedStats
   └── 否则继续计算

2. [加载装备]
   ├── EquippedGear = Repository.GetEquippedGear(CharacterId)
   └── 按槽位组织装备

3. [聚合基础属性]
   ├── Stats = new Dictionary<StatType, double>()
   ├── For each Gear in EquippedGear:
   │   ├── For each (Stat, Value) in Gear.RolledStats:
   │   │   └── Stats[Stat] += Value
   │   └── 护甲类型特殊处理:
   │       ├── If Gear.ArmorType != None:
   │       │   └── Stats["Armor"] += Gear.BaseArmor
   │       └── 武器类型特殊处理:
   │           ├── Stats["AttackSpeed"] = Gear.BaseAttackSpeed
   │           └── Stats["AttackPowerMult"] = Gear.AttackPowerMultiplier

4. [聚合词条属性]
   ├── For each Gear in EquippedGear:
   │   ├── For each Affix in Gear.Affixes:
   │   │   ├── Value = CalculateAffixValue(Affix)
   │   │   └── ApplyModifier(Stats, Affix.StatType, Affix.ModifierType, Value)
   └── ModifierType分类处理:
       ├── Flat: Stats[StatType] += Value
       ├── Percent: 记录乘法修饰符
       └── Proc: 触发效果（未来扩展）

5. [计算套装加成]
   ├── SetBonuses = SetBonusService.CalculateSetBonuses(EquippedGear)
   ├── For each (Stat, Value) in SetBonuses:
   │   └── ApplyModifier(Stats, Stat, ModifierType, Value)

6. [应用数值管线]
   ├── For each (Stat, BaseValue) in Stats:
   │   ├── AdditiveModifiers = GetAdditiveModifiers(Stat)
   │   ├── MultiplicativeModifiers = GetMultiplicativeModifiers(Stat)
   │   ├── FinalAdditiveModifiers = GetFinalAdditiveModifiers(Stat)
   │   └── FinalValue = ApplyPipeline(BaseValue, Additive, Mult, FinalAdd)
   └── Pipeline公式: clamp(((base + ΣAdd) * Π(1+Mult)) + ΣFinalAdd)

7. [应用数值上限]
   ├── CritChance = Min(CritChance, 1.0)        # 暴击≤100%
   ├── ArmorReduction = Min(ArmorReduction, 0.75)  # 护甲减伤≤75%
   ├── BlockChance = Min(BlockChance, 0.50)     # 格挡≤50%
   └── HastePercent = Max(HastePercent, -0.50)  # 急速≥-50%

8. [缓存结果]
   ├── CacheStats(CharacterId, Stats, TTL=5分钟)
   └── Return Stats
```

#### 流程4: 装备掉落流程

```
装备掉落流程 (经济系统集成)

触发点: 战斗结束 → EconomyCalculator.ComputeSampled

步骤:
1. [识别装备掉落]
   ├── For each LootEntry in LootTable:
   │   ├── If LootEntry.ItemType == "gear":
   │   │   └── 标记为装备掉落
   └── 使用RNG判定是否掉落

2. [生成装备]
   ├── GearDefId = LootEntry.ItemId
   ├── CharacterLevel = Character.Level
   ├── RNG = Context.RNG
   └── GearInstance = GearGenerationService.Generate(GearDefId, CharLevel, RNG)

3. [写入背包]
   ├── CreateInventoryItem {
   │   CharacterId,
   │   ItemType = "gear",
   │   ItemId = GearInstance.Id.ToString(),
   │   Quantity = 1,
   │   AcquiredAt = Now
   │ }
   └── 关联GearInstance.CharacterId = CharacterId

4. [通知玩家]
   ├── 发送装备掉落通知
   ├── 展示装备信息（稀有度/属性/词条）
   └── 可选：特效动画（史诗/传说装备）

5. [记录日志]
   └── Log { GearGenerated, GearDefId, Rarity, Seed, CharacterId }
```

---

(继续下一节...)

## 5. 装备槽位系统设计

### 5.1 槽位扩展方案（9→17个）

#### 当前槽位（9个）

```
现有槽位:
1. Head (头盔)
2. Weapon (武器)
3. Chest (胸甲)
4. OffHand (副手)
5. Waist (腰带)
6. Legs (腿部)
7. Feet (鞋子)
8. Trinket1 (饰品1)
9. Trinket2 (饰品2)
```

#### 扩展后槽位（17个）

```csharp
public enum EquipmentSlot
{
    //防具槽位 (10个)
    Head,           // 头部
    Neck,           // 颈部（新增）
    Shoulder,       // 肩部（新增）
    Back,           // 背部 - 披风（新增）
    Chest,          // 胸部
    Wrist,          // 手腕 - 护腕（新增）
    Hands,          // 手部 - 手套（新增）
    Waist,          // 腰部 - 腰带
    Legs,           // 腿部
    Feet,           // 脚部
    
    // 饰品槽位 (4个)
    Finger1,        // 第一个戒指（扩展Trinket1）
    Finger2,        // 第二个戒指（扩展Trinket2）
    Trinket1,       // 第一个饰品
    Trinket2,       // 第二个饰品
    
    // 武器槽位 (3个)
    MainHand,       // 主手武器（原Weapon）
    OffHand,        // 副手（武器或盾牌）
    TwoHand         // 双手武器（虚拟槽位，实际占用主副手）
}
```

#### 槽位分类

| 分类 | 槽位 | 数量 | 说明 |
|-----|------|------|------|
| **防具** | Head, Neck, Shoulder, Back, Chest, Wrist, Hands, Waist, Legs, Feet | 10 | 受护甲类型限制 |
| **饰品** | Finger1, Finger2, Trinket1, Trinket2 | 4 | 无护甲类型，纯属性 |
| **武器** | MainHand, OffHand, TwoHand | 3 | 受武器类型和职业限制 |

#### 槽位可视化布局

```
装备面板布局（推荐方案 - 左右分栏）:

左侧防具:                        右侧防具:
┌───────────┐                   ┌───────────┐
│ 🪖 Head   │                   │ 🎒 Back   │
├───────────┤                   ├───────────┤
│ 📿 Neck   │                   │ 👔 Chest  │
├───────────┤                   ├───────────┤
│ 👔 Shoulder│                  │ 💪 Wrist  │
└───────────┘                   └───────────┘

武器槽位（中央）:
┌───────────┬───────────┐
│ ⚔️ MainHand│ 🔰 OffHand │
└───────────┴───────────┘

下方防具:
┌───────────┬───────────┬───────────┐
│ 🤲 Hands  │ ⚖️ Waist   │ 🦵 Legs   │
└───────────┴───────────┴───────────┘
│ 👟 Feet   │
└───────────┘

饰品槽位（底部）:
┌───────────┬───────────┬───────────┬───────────┐
│ 💍 Finger1 │ 💍 Finger2 │ 💎 Trinket1│ 💎 Trinket2│
└───────────┴───────────┴───────────┴───────────┘
```

---

### 5.2 槽位配置与分类

#### 槽位配置类

```csharp
public class EquipmentSlotConfig
{
    public EquipmentSlot Slot { get; set; }
    public string SlotId { get; set; }           // "head", "neck", etc.
    public string DisplayName { get; set; }      // "头部", "颈部", etc.
    public string DisplayNameEn { get; set; }    // "Head", "Neck", etc.
    public string Icon { get; set; }             // emoji 或图标路径
    public SlotCategory Category { get; set; }   // Armor/Jewelry/Weapon
    public bool AllowsArmorType { get; set; }    // 是否受护甲类型限制
    public bool RequiresWeaponType { get; set; } // 是否需要武器类型
    public int DisplayOrder { get; set; }        // UI显示顺序
}

public enum SlotCategory
{
    Armor,      // 防具
    Jewelry,    // 饰品
    Weapon      // 武器
}
```

#### 槽位特性矩阵

| 槽位 | 分类 | 护甲限制 | 武器限制 | 主属性倾向 | 特殊机制 |
|-----|------|---------|---------|-----------|---------|
| Head | Armor | ✅ | ❌ | 全部 | - |
| Neck | Jewelry | ❌ | ❌ | 全部 | 无护甲值 |
| Shoulder | Armor | ✅ | ❌ | 全部 | - |
| Back | Armor | ❌ | ❌ | 次级属性 | 无护甲值/特殊词条 |
| Chest | Armor | ✅ | ❌ | 全部 | 护甲值最高 |
| Wrist | Armor | ✅ | ❌ | 次级属性 | - |
| Hands | Armor | ✅ | ❌ | 全部 | - |
| Waist | Armor | ✅ | ❌ | 次级属性 | - |
| Legs | Armor | ✅ | ❌ | 全部 | 护甲值第二 |
| Feet | Armor | ✅ | ❌ | 移速加成 | - |
| Finger1/2 | Jewelry | ❌ | ❌ | 次级属性 | 无护甲值 |
| Trinket1/2 | Jewelry | ❌ | ❌ | 特殊效果 | 触发技能/PROC |
| MainHand | Weapon | ❌ | ✅ | 攻击属性 | 决定攻击速度 |
| OffHand | Weapon | ❌ | ✅ | 攻击/防御 | 可装备武器或盾牌 |
| TwoHand | Weapon | ❌ | ✅ | 攻击属性 | 占用主副手 |

---

### 5.3 双手武器占用机制

#### 占用规则

```csharp
public class EquipmentSlotOccupancy
{
    public EquipmentSlot PrimarySlot { get; set; }
    public List<EquipmentSlot> OccupiedSlots { get; set; }
    
    // 双手武器配置
    public static readonly EquipmentSlotOccupancy TwoHandWeapon = new()
    {
        PrimarySlot = EquipmentSlot.TwoHand,
        OccupiedSlots = new List<EquipmentSlot>
        {
            EquipmentSlot.MainHand,
            EquipmentSlot.OffHand
        }
    };
}
```

#### 装备双手武器流程

```
装备双手武器:
1. 检查主副手是否有装备
2. 如果有装备:
   ├── 卸下主手武器 → 背包
   └── 卸下副手武器/盾牌 → 背包
3. 装备双手武器 → MainHand 和 OffHand 都标记为占用
4. UI显示: 主手显示武器图标，副手显示"已被双手武器占用"

卸下双手武器:
1. 移除双手武器 → 背包
2. MainHand 和 OffHand 槽位变为空闲
3. 玩家可分别装备主手和副手
```

#### 验证逻辑

```csharp
public class TwoHandWeaponValidator
{
    public bool CanEquipTwoHandWeapon(Character character)
    {
        // 检查主副手是否都为空，或者可以自动卸下
        var mainHand = GetEquippedGear(character, EquipmentSlot.MainHand);
        var offHand = GetEquippedGear(character, EquipmentSlot.OffHand);
        
        // 背包是否有足够空间容纳卸下的装备
        return HasInventorySpace(character, 2);
    }
    
    public bool CanEquipOffHand(Character character)
    {
        var mainHand = GetEquippedGear(character, EquipmentSlot.MainHand);
        
        // 如果主手是双手武器，不能装备副手
        if (mainHand != null && mainHand.WeaponType.IsTwoHanded)
        {
            return false;
        }
        
        return true;
    }
}
```

---

## 6. 护甲类型系统设计

### 6.1 护甲类型定义

```csharp
public enum ArmorType
{
    None,       // 无类型（饰品、披风、颈部）
    Cloth,      // 布甲
    Leather,    // 皮甲
    Mail,       // 锁甲
    Plate       // 板甲
}
```

#### 护甲类型适用槽位

| 槽位 | 适用护甲类型 | 说明 |
|-----|------------|------|
| Head, Shoulder, Chest, Wrist, Hands, Waist, Legs, Feet | Cloth/Leather/Mail/Plate | 主要防具 |
| Neck, Back | None | 无护甲类型 |
| Finger1/2, Trinket1/2 | None | 饰品无护甲 |
| MainHand, OffHand, TwoHand | None | 武器无护甲 |

---

### 6.2 护甲特性与平衡

#### 护甲类型配置

```csharp
public class ArmorTypeConfig
{
    public ArmorType Type { get; set; }
    public string TypeId { get; set; }
    public string DisplayName { get; set; }
    
    // 基础属性系数
    public double BaseArmorMultiplier { get; set; }  // 基础护甲倍率
    public double StaminaMultiplier { get; set; }    // 耐力加成倍率
    
    // 次级属性倾向（用于装备生成时权重）
    public Dictionary<string, double> SecondaryStatWeights { get; set; }
    
    // 适用槽位
    public List<EquipmentSlot> ApplicableSlots { get; set; }
}
```

#### 护甲类型特性表

| 护甲类型 | 护甲系数 | 耐力系数 | 主属性倾向 | 适用职业示例 | 特色 |
|---------|---------|---------|-----------|-------------|------|
| **None** | 0.0 | 1.0 | - | 所有职业 | 饰品、披风、颈部 |
| **Cloth (布甲)** | 0.5 | 1.0 | Intellect 高 | 法师、牧师 | 高法术强度，低护甲 |
| **Leather (皮甲)** | 1.0 | 1.1 | Agility 高 | 盗贼、德鲁伊 | 平衡型，闪避加成 |
| **Mail (锁甲)** | 1.5 | 1.3 | Agility/Intellect | 猎人、萨满 | 中等护甲，灵活性 |
| **Plate (板甲)** | 2.0 | 1.5 | Strength/Stamina 高 | 战士、圣骑士 | 高护甲，高生存 |

#### 护甲类型次级属性倾向

```json
{
  "ArmorTypes": [
    {
      "TypeId": "cloth",
      "SecondaryStatWeights": {
        "Intellect": 1.5,
        "SpellPower": 1.3,
        "Spirit": 1.2,
        "CritChance": 1.0
      }
    },
    {
      "TypeId": "leather",
      "SecondaryStatWeights": {
        "Agility": 1.4,
        "AttackPower": 1.2,
        "CritChance": 1.3,
        "Dodge": 1.2
      }
    },
    {
      "TypeId": "mail",
      "SecondaryStatWeights": {
        "Agility": 1.3,
        "Intellect": 1.2,
        "AttackPower": 1.1,
        "SpellPower": 1.1
      }
    },
    {
      "TypeId": "plate",
      "SecondaryStatWeights": {
        "Strength": 1.5,
        "Stamina": 1.4,
        "Block": 1.3,
        "Parry": 1.2
      }
    }
  ]
}
```

---

### 6.3 护甲减伤机制

#### 护甲减伤公式

```csharp
public class ArmorDamageReduction
{
    /// <summary>
    /// 计算护甲减伤百分比
    /// 公式: DamageReduction% = Armor / (Armor + K × AttackerLevel)
    /// 其中 K 是常数，用于控制护甲效果（默认400）
    /// </summary>
    public static double CalculateReduction(
        double armor, 
        int attackerLevel, 
        double k = 400)
    {
        if (armor <= 0) return 0;
        
        double reduction = armor / (armor + k * attackerLevel);
        
        // 护甲减伤上限 75%
        return Math.Min(reduction, 0.75);
    }
    
    /// <summary>
    /// 应用护甲减伤到伤害
    /// </summary>
    public static int ApplyArmorReduction(
        int rawDamage, 
        double armorReduction)
    {
        return (int)Math.Ceiling(rawDamage * (1.0 - armorReduction));
    }
}
```

#### 护甲减伤数值表

| 护甲值 | vs Lv10敌人 | vs Lv30敌人 | vs Lv50敌人 | 说明 |
|-------|------------|------------|------------|------|
| 100 | 20.0% | 11.1% | 4.8% | 布甲初期 |
| 300 | 42.9% | 27.3% | 13.0% | 皮甲中期 |
| 600 | 60.0% | 42.9% | 23.1% | 锁甲后期 |
| 1000 | 71.4% | 55.6% | 33.3% | 板甲中期 |
| 2000 | **75.0% ↑** | 71.4% | 50.0% | 板甲后期（达上限） |

**设计原则**:
- 同等级护甲约提供40-50%减伤
- 高等级敌人使护甲效果递减
- 75%上限防止无敌
- 护甲穿透可降低有效护甲

#### 护甲值计算公式

```
物品护甲值 = 基础护甲值 × 护甲类型系数 × 物品等级系数 × 品级系数

例如:
- T1布甲胸甲（物品等级30）:
  BaseArmor(10) × Cloth(0.5) × iLvl(30/10) × Tier(0.8) = 12
  
- T2板甲胸甲（物品等级30）:
  BaseArmor(10) × Plate(2.0) × iLvl(30/10) × Tier(1.0) = 60
  
- T3板甲胸甲（物品等级50）:
  BaseArmor(10) × Plate(2.0) × iLvl(50/10) × Tier(1.2) = 120
```

#### 护甲来源

1. **装备护甲**: 各部位装备提供的护甲值总和
2. **主属性加成**: Agility 可提供少量护甲（每点敏捷 +0.5护甲）
3. **Buff加成**: 技能和Buff可临时增加护甲
4. **职业技能**: 某些职业有护甲加成技能

#### 有效护甲计算

```
有效护甲 = (总护甲 - 固定穿透) × (1 - 百分比穿透)

例如:
- 总护甲 1000
- 敌人固定穿透 200
- 敌人百分比穿透 20%
- 有效护甲 = (1000 - 200) × (1 - 0.20) = 640
```

---

## 7. 武器类型系统设计

### 7.1 武器类型分类

```csharp
public enum WeaponType
{
    // 无类型
    None,           // 非武器（防具、饰品）
    
    // 单手近战武器
    Sword,          // 剑
    Dagger,         // 匕首
    Axe,            // 斧
    Mace,           // 锤
    Fist,           // 拳套
    
    // 远程单手
    Wand,           // 魔杖
    
    // 双手武器
    TwoHandSword,   // 双手剑
    TwoHandAxe,     // 双手斧
    TwoHandMace,    // 双手锤
    Staff,          // 法杖
    Polearm,        // 长柄武器
    
    // 远程武器
    Bow,            // 弓
    Crossbow,       // 弩
    Gun,            // 枪
    
    // 副手专用
    Shield          // 盾牌
}
```

---

### 7.2 攻击速度与伤害倍率

#### 武器类型配置

```csharp
public class WeaponTypeConfig
{
    public WeaponType Type { get; set; }
    public string TypeId { get; set; }
    public string DisplayName { get; set; }
    
    // 基础攻击属性
    public double BaseAttackSpeed { get; set; }      // 基础攻击速度（秒/次）
    public double AttackPowerMultiplier { get; set; } // 攻击倍率
    
    // 武器槽位限制
    public List<EquipmentSlot> AllowedSlots { get; set; }
    
    // 伤害类型倾向
    public DamageType PrimaryDamageType { get; set; }
    
    // 特殊机制
    public bool AllowsDualWield { get; set; }        // 是否可双持
    public bool IsRangedWeapon { get; set; }         // 是否远程武器
    public bool IsTwoHanded { get; set; }            // 是否双手武器
}
```

#### 武器类型数值设计

**基准**: 标准单手剑 = 攻击速度 2.5s/次，攻击倍率 1.0

| 武器类型 | 攻击速度 | 攻击倍率 | DPS系数 | 特点 | 适用职业 |
|---------|---------|---------|---------|------|---------|
| **Sword (剑)** | 2.5s | 1.00 | 0.40 | 基准武器，平衡 | 战士、游侠、盗贼 |
| **Dagger (匕首)** | 1.8s | 0.72 | 0.40 | 快速，低伤害 | 盗贼 |
| **Axe (斧)** | 2.8s | 1.12 | 0.40 | 慢速，高伤害 | 战士 |
| **Mace (锤)** | 2.6s | 1.04 | 0.40 | 平衡偏慢 | 战士、牧师、萨满 |
| **Fist (拳套)** | 2.0s | 0.80 | 0.40 | 快速近战 | 武僧 |
| **Wand (魔杖)** | 2.0s | 0.60 | 0.30 | 法术武器，低物理伤害 | 法师、牧师 |
| **TwoHandSword (双手剑)** | 3.5s | 1.75 | 0.50 | 慢速，高伤害 | 战士 |
| **TwoHandAxe (双手斧)** | 3.8s | 1.90 | 0.50 | 最慢，最高伤害 | 战士 |
| **TwoHandMace (双手锤)** | 3.6s | 1.80 | 0.50 | 慢速强力 | 战士、圣骑士 |
| **Staff (法杖)** | 3.2s | 1.12 | 0.35 | 法术双手武器 | 法师、德鲁伊 |
| **Polearm (长柄)** | 3.4s | 1.70 | 0.50 | 远程双手武器 | 战士、猎人 |
| **Bow (弓)** | 3.0s | 1.50 | 0.50 | 远程武器 | 猎人、游侠 |
| **Crossbow (弩)** | 3.6s | 1.80 | 0.50 | 慢速远程 | 游侠 |
| **Gun (枪)** | 3.2s | 1.60 | 0.50 | 机械远程 | 猎人 |
| **Shield (盾牌)** | - | - | - | 防御副手，提供格挡 | 战士、圣骑士 |

**DPS系数** = 攻击倍率 / 攻击速度  
保持相近以确保不同武器类型平衡

---

### 7.3 双持机制

#### 双持计算公式

```csharp
public class DualWieldCalculation
{
    // 平均攻击速度
    public double AverageSpeed => (MainHandSpeed + OffHandSpeed) / 2.0;
    
    // 总攻击力 = (主手 + 副手) × 双持系数
    public double TotalAttackPower => 
        (MainHandAP + OffHandAP) * DualWieldCoefficient;
    
    // 双持系数（默认 0.85，避免双持过强）
    public const double DualWieldCoefficient = 0.85;
    
    // 双持命中惩罚（额外19%Miss）
    public const double DualWieldMissPenalty = 0.19;
}
```

#### 双持武器验证

```csharp
public class DualWieldValidator
{
    public bool CanDualWield(Character character)
    {
        // 检查职业是否允许双持
        var professionConfig = GetProfessionConfig(character.Profession);
        return professionConfig.CanDualWield;
    }
    
    public bool IsValidDualWieldCombination(
        GearInstance mainHand, 
        GearInstance offHand)
    {
        // 主手必须是单手武器
        if (mainHand.WeaponType.IsTwoHanded)
            return false;
            
        // 副手必须是单手武器且允许双持
        if (!offHand.WeaponType.AllowsDualWield)
            return false;
            
        // 盾牌不能作为副手武器（双持场景）
        if (offHand.WeaponType == WeaponType.Shield)
            return false;
            
        return true;
    }
}
```

---

### 7.4 格挡机制（盾牌）

#### 格挡配置

```csharp
public class BlockMechanicsConfig
{
    // 基础格挡率（装备盾牌时）
    public double BaseBlockChance { get; set; } = 0.05;  // 5%
    
    // 格挡减伤百分比
    public double BlockDamageReduction { get; set; } = 0.30;  // 30%
    
    // 属性加成
    public double BlockChancePerStrength { get; set; } = 0.001;  // 每点力量 +0.1%
    public double BlockChancePerItemLevel { get; set; } = 0.002; // 每点装等 +0.2%
    
    // 格挡率上限
    public double MaxBlockChance { get; set; } = 0.50;  // 50%
}
```

#### 格挡计算

```csharp
public class BlockCalculator
{
    /// <summary>
    /// 计算格挡概率
    /// </summary>
    public static double CalculateBlockChance(
        bool hasShield,
        double baseBlockChance,
        int strength,
        int shieldItemLevel,
        BlockMechanicsConfig config)
    {
        if (!hasShield) return 0;
        
        double blockChance = baseBlockChance;
        blockChance += strength * config.BlockChancePerStrength;
        blockChance += shieldItemLevel * config.BlockChancePerItemLevel;
        
        return Math.Min(blockChance, config.MaxBlockChance);
    }
    
    /// <summary>
    /// 应用格挡减伤
    /// </summary>
    public static int ApplyBlockReduction(
        int rawDamage, 
        double blockReduction)
    {
        return (int)Math.Ceiling(rawDamage * (1.0 - blockReduction));
    }
}
```

#### 格挡触发流程

```
战斗伤害计算流程（含格挡）:
1. 敌人攻击命中
2. 判定格挡（Random < BlockChance）
3. If 格挡成功:
   ├── 伤害 × (1 - BlockDamageReduction)
   ├── 记录格挡事件到SegmentCollector
   └── 显示"格挡！"提示
4. Else 格挡失败:
   └── 继续正常护甲减伤计算
5. 最终伤害应用
```

---

## 8. 职业装备限制系统

### 8.1 职业-装备兼容性

#### 职业配置

```csharp
public class ProfessionEquipmentConfig
{
    public string ProfessionId { get; set; }
    public string DisplayName { get; set; }
    
    // 可装备的护甲类型（优先级从高到低）
    public List<ArmorType> AllowedArmorTypes { get; set; }
    
    // 可装备的武器类型
    public List<WeaponType> AllowedWeaponTypes { get; set; }
    
    // 是否可双持
    public bool CanDualWield { get; set; }
    
    // 特殊限制
    public Dictionary<string, bool> SpecialRules { get; set; }
}
```

#### 职业装备兼容性矩阵

| 职业 | 护甲类型 | 可用武器 | 双持 | 特殊规则 |
|-----|---------|---------|------|---------|
| **战士 (Warrior)** | Plate, Mail, Leather, Cloth | Sword, Axe, Mace, TwoHandSword, TwoHandAxe, TwoHandMace, Polearm, Shield | ✅ | 可装备所有近战武器 |
| **游侠 (Ranger)** | Mail, Leather, Cloth | Sword, Dagger, Axe, Bow, Crossbow, Gun | ✅ | 远程武器专精 |
| **法师 (Mage)** | Cloth | Dagger, Wand, Staff | ❌ | 仅法系武器 |
| **盗贼 (Rogue)** | Leather, Cloth | Dagger, Sword, Fist, Bow, Crossbow | ✅ | 快速武器专精 |
| **牧师 (Priest)** | Cloth | Mace, Wand, Staff | ❌ | 治疗职业 |
| **萨满 (Shaman)** | Mail, Leather, Cloth | Mace, Axe, Staff, Shield | ❌ | 元素/增强双修 |
| **圣骑士 (Paladin)** | Plate, Mail, Leather, Cloth | Sword, Mace, TwoHandSword, TwoHandMace, Polearm, Shield | ❌ | 盾牌专精 |

---

### 8.2 装备验证机制

```csharp
public class EquipmentValidator
{
    /// <summary>
    /// 验证职业是否可装备该物品
    /// </summary>
    public static ValidationResult CanEquip(
        Character character,
        GearInstance gear)
    {
        var config = GetProfessionConfig(character.Profession);
        var gearDef = GetGearDefinition(gear.DefinitionId);
        
        // 1. 检查等级需求
        if (character.Level < gearDef.RequiredLevel)
        {
            return ValidationResult.Fail(
                $"需要等级 {gearDef.RequiredLevel}");
        }
        
        // 2. 检查护甲类型限制
        if (gear.ArmorType != ArmorType.None && 
            !config.AllowedArmorTypes.Contains(gear.ArmorType))
        {
            return ValidationResult.Fail(
                $"{config.DisplayName}无法装备{gear.ArmorType}类型护甲");
        }
        
        // 3. 检查武器类型限制
        if (gear.WeaponType != WeaponType.None && 
            !config.AllowedWeaponTypes.Contains(gear.WeaponType))
        {
            return ValidationResult.Fail(
                $"{config.DisplayName}无法装备{gear.WeaponType}类型武器");
        }
        
        // 4. 检查双持能力
        if (IsOffHandWeapon(gear) && 
            !config.CanDualWield)
        {
            return ValidationResult.Fail(
                $"{config.DisplayName}无法双持武器");
        }
        
        // 5. 检查槽位匹配
        // (此处省略，在EquipmentService中处理)
        
        return ValidationResult.Success();
    }
}
```

---

## 9. 领域模型详细设计

### 9.1 装备定义（GearDefinition）

```csharp
/// <summary>
/// 装备定义（配置实体）
/// 存储在数据库或JSON配置文件中
/// </summary>
public class GearDefinition
{
    public string Id { get; set; }                    // 唯一标识，如 "sword_iron"
    public string Name { get; set; }                  // 显示名称
    public string Icon { get; set; }                  // 图标emoji或URL
    public EquipmentSlot Slot { get; set; }           // 装备槽位
    public ArmorType ArmorType { get; set; }          // 护甲类型
    public WeaponType WeaponType { get; set; }        // 武器类型
    public int RequiredLevel { get; set; }            // 需求等级
    
    // 基础属性范围
    public Dictionary<StatType, StatRange> BaseStats { get; set; }
    
    // 允许的词条池
    public List<string> AllowedAffixPool { get; set; }
    
    // 稀有度权重
    public Dictionary<Rarity, double> RarityWeights { get; set; }
    
    // 套装ID
    public string? SetId { get; set; }
    
    // 时间戳
    public DateTime CreatedAt { get; set; }
    public DateTime UpdatedAt { get; set; }
}

/// <summary>
/// 属性范围
/// </summary>
public class StatRange
{
    public double Min { get; set; }
    public double Max { get; set; }
}
```

---

### 9.2 装备实例（GearInstance）

```csharp
/// <summary>
/// 装备实例（运行时实体）
/// 每个装备实例都是唯一的，包含Roll后的属性
/// </summary>
public class GearInstance
{
    public Guid Id { get; set; }                      // 实例ID
    public string DefinitionId { get; set; }          // 关联GearDefinition
    public Guid? CharacterId { get; set; }            // 所属角色，null表示在背包
    public EquipmentSlot? SlotType { get; set; }      // 装备位置，null表示未装备
    
    // 装备品质
    public Rarity Rarity { get; set; }                // 稀有度
    public int TierLevel { get; set; }                // 品级（1-3）
    public int ItemLevel { get; set; }                // 物品等级
    
    // 已Roll的属性
    public Dictionary<StatType, double> RolledStats { get; set; }
    
    // 词条列表
    public List<AffixInstance> Affixes { get; set; }
    
    // 评分
    public int QualityScore { get; set; }             // 装备评分
    
    // 状态
    public bool IsEquipped { get; set; }              // 是否已装备
    public bool IsBound { get; set; }                 // 是否绑定
    public int RerollCount { get; set; }              // 词条重置次数
    
    // 时间戳
    public DateTime CreatedAt { get; set; }
    public DateTime UpdatedAt { get; set; }
    
    // 导航属性
    public Character? Character { get; set; }
    public GearDefinition Definition { get; set; }
}
```

---

### 9.3 词条系统（Affix）

#### 词条定义

```csharp
/// <summary>
/// 词条定义（配置）
/// </summary>
public class Affix
{
    public string Id { get; set; }                    // 唯一标识，如 "affix_strength"
    public string Name { get; set; }                  // 显示名称，如 "力量"
    public StatType StatType { get; set; }            // 影响的属性类型
    public ModifierType ModifierType { get; set; }    // 修饰符类型
    public double ValueMin { get; set; }              // 数值范围最小
    public double ValueMax { get; set; }              // 数值范围最大
    public double RarityWeight { get; set; }          // 稀有度权重（越低越稀有）
    
    // 槽位限制
    public List<EquipmentSlot>? AllowedSlots { get; set; }  // null表示全部
    
    // 时间戳
    public DateTime CreatedAt { get; set; }
    public DateTime UpdatedAt { get; set; }
}

/// <summary>
/// 修饰符类型
/// </summary>
public enum ModifierType
{
    Flat,       // 固定值加成，如 +15 力量
    Percent,    // 百分比加成，如 +5% 暴击
    Proc        // 触发效果（未来扩展）
}
```

#### 词条实例

```csharp
/// <summary>
/// 词条实例（值对象）
/// 附着在GearInstance上
/// </summary>
public class AffixInstance
{
    public string AffixId { get; set; }               // 词条定义ID
    public StatType StatType { get; set; }            // 影响的属性
    public ModifierType ModifierType { get; set; }    // 修饰符类型
    public double RolledValue { get; set; }           // 已Roll的数值
    public string DisplayText { get; set; }           // 显示文本，如 "+15 力量"
}
```

---

### 9.4 套装系统（GearSet）

```csharp
/// <summary>
/// 套装定义
/// </summary>
public class GearSet
{
    public string Id { get; set; }                    // 套装ID，如 "set_warrior"
    public string Name { get; set; }                  // 套装名称
    
    // 套装装备列表
    public List<string> Pieces { get; set; }          // 装备定义ID列表
    
    // 套装加成（件数 -> 加成列表）
    public Dictionary<int, List<StatModifier>> Bonuses { get; set; }
    // 例如: { 2: [+100 HP], 4: [+5% Crit], 6: [特殊效果] }
    
    // 时间戳
    public DateTime CreatedAt { get; set; }
    public DateTime UpdatedAt { get; set; }
}

/// <summary>
/// 属性修饰符（值对象）
/// </summary>
public class StatModifier
{
    public StatType StatType { get; set; }
    public ModifierType ModifierType { get; set; }
    public double Value { get; set; }
}
```

---

## 10. 数据库设计

### 10.1 表结构设计

#### GearDefinitions 表

```sql
CREATE TABLE GearDefinitions (
    Id VARCHAR(100) PRIMARY KEY,              -- 如 "sword_iron"
    Name VARCHAR(200) NOT NULL,               -- 显示名称
    Icon VARCHAR(50),                         -- 图标
    Slot VARCHAR(50) NOT NULL,                -- 装备槽位
    ArmorType VARCHAR(20),                    -- 护甲类型
    WeaponType VARCHAR(30),                   -- 武器类型
    RequiredLevel INT NOT NULL DEFAULT 1,     -- 需求等级
    BaseStatsJson TEXT,                       -- JSON: {"AttackPower": {"Min": 10, "Max": 15}}
    AllowedAffixPoolJson TEXT,                -- JSON: ["affix_strength", "affix_crit"]
    RarityWeightsJson TEXT,                   -- JSON: {"Common": 0.6, "Rare": 0.3}
    SetId VARCHAR(100),                       -- 套装ID，可为null
    CreatedAt DATETIME NOT NULL,
    UpdatedAt DATETIME NOT NULL,
    
    INDEX IX_GearDefinitions_Slot (Slot),
    INDEX IX_GearDefinitions_SetId (SetId)
);
```

#### GearInstances 表

```sql
CREATE TABLE GearInstances (
    Id UNIQUEIDENTIFIER PRIMARY KEY,
    DefinitionId VARCHAR(100) NOT NULL,       -- 外键到GearDefinitions
    CharacterId UNIQUEIDENTIFIER,             -- 外键到Characters，null表示在背包
    SlotType VARCHAR(50),                     -- 装备位置，null表示未装备
    Rarity VARCHAR(50) NOT NULL,              -- Common/Rare/Epic/Legendary
    TierLevel INT NOT NULL DEFAULT 1,         -- 品级 1-3
    ItemLevel INT NOT NULL,                   -- 物品等级
    RolledStatsJson TEXT NOT NULL,            -- JSON: {"AttackPower": 12.5}
    AffixesJson TEXT NOT NULL,                -- JSON: [{"AffixId": "...", "Value": ...}]
    QualityScore INT NOT NULL,                -- 装备评分
    IsEquipped BIT NOT NULL DEFAULT 0,        -- 是否已装备
    IsBound BIT NOT NULL DEFAULT 0,           -- 是否绑定
    RerollCount INT NOT NULL DEFAULT 0,       -- 词条重置次数
    CreatedAt DATETIME NOT NULL,
    UpdatedAt DATETIME NOT NULL,
    
    FOREIGN KEY (DefinitionId) REFERENCES GearDefinitions(Id),
    FOREIGN KEY (CharacterId) REFERENCES Characters(Id) ON DELETE CASCADE,
    
    INDEX IX_GearInstances_CharacterId (CharacterId),
    INDEX IX_GearInstances_IsEquipped (IsEquipped),
    INDEX IX_GearInstances_Rarity (Rarity),
    INDEX IX_GearInstances_DefinitionId (DefinitionId)
);
```

#### AffixDefinitions 表

```sql
CREATE TABLE AffixDefinitions (
    Id VARCHAR(100) PRIMARY KEY,              -- 如 "affix_strength"
    Name VARCHAR(200) NOT NULL,               -- 显示名称
    StatType VARCHAR(50) NOT NULL,            -- 属性类型
    ModifierType VARCHAR(50) NOT NULL,        -- Flat/Percent/Proc
    ValueMin FLOAT NOT NULL,                  -- 数值范围最小
    ValueMax FLOAT NOT NULL,                  -- 数值范围最大
    RarityWeight FLOAT NOT NULL DEFAULT 1.0,  -- 稀有度权重
    AllowedSlotsJson TEXT,                    -- JSON: ["weapon", "chest"] 或 null
    CreatedAt DATETIME NOT NULL,
    UpdatedAt DATETIME NOT NULL,
    
    INDEX IX_AffixDefinitions_StatType (StatType)
);
```

#### GearSets 表

```sql
CREATE TABLE GearSets (
    Id VARCHAR(100) PRIMARY KEY,              -- 如 "set_warrior"
    Name VARCHAR(200) NOT NULL,               -- 套装名称
    PiecesJson TEXT NOT NULL,                 -- JSON: ["gear_def_1", "gear_def_2", ...]
    BonusesJson TEXT NOT NULL,                -- JSON: {"2": [...], "4": [...], "6": [...]}
    CreatedAt DATETIME NOT NULL,
    UpdatedAt DATETIME NOT NULL
);
```

---

### 10.2 索引策略

| 表 | 索引字段 | 类型 | 用途 |
|---|---------|------|------|
| GearInstances | CharacterId | 普通索引 | 查询角色的所有装备 |
| GearInstances | IsEquipped | 普通索引 | 查询已装备/未装备的装备 |
| GearInstances | Rarity | 普通索引 | 按稀有度筛选 |
| GearInstances | DefinitionId | 普通索引 | 关联装备定义 |
| GearDefinitions | Slot | 普通索引 | 按槽位查询定义 |
| GearDefinitions | SetId | 普通索引 | 查询套装装备 |
| AffixDefinitions | StatType | 普通索引 | 按属性类型查询词条 |

---

### 10.3 数据迁移方案

#### 迁移策略

```
Phase 1: 新增表（无影响）
├── 创建 GearDefinitions 表
├── 创建 GearInstances 表
├── 创建 AffixDefinitions 表
└── 创建 GearSets 表

Phase 2: 扩展字段（兼容）
├── 扩展 GearInstanceDto 添加新字段
├── 扩展 EquipmentSlotDto 支持17槽位
└── API保持向后兼容（旧槽位映射到新槽位）

Phase 3: 数据迁移（可选）
├── 如果有现有装备数据（当前为空）
├── 编写迁移脚本将旧数据转换为新格式
└── 验证迁移结果

Phase 4: 前端更新
├── 更新前端使用新的槽位枚举
├── 更新UI布局为17槽位
└── 渐进式升级（旧版本仍可使用）
```

#### 迁移脚本示例

```csharp
public class EquipmentMigrationScript
{
    // 旧槽位 -> 新槽位映射
    private static readonly Dictionary<string, string> SlotMapping = new()
    {
        { "head", "Head" },
        { "weapon", "MainHand" },
        { "chest", "Chest" },
        { "offhand", "OffHand" },
        { "waist", "Waist" },
        { "legs", "Legs" },
        { "feet", "Feet" },
        { "trinket1", "Trinket1" },
        { "trinket2", "Trinket2" }
    };
    
    public async Task MigrateOldEquipmentData()
    {
        // 如果有旧数据需要迁移
        // 当前系统无旧数据，此方法为预留
    }
}
```

---

## 总结

本文档（上篇）完成了 BlazorIdle 装备系统优化的核心分析与架构设计，包括：

1. ✅ **当前状态全面分析**: 已完成工作、现有能力、缺失功能
2. ✅ **设计目标与原则**: 核心目标、设计原则、成功标准
3. ✅ **完整架构设计**: 系统概览、模块划分、核心流程
4. ✅ **17槽位系统设计**: 槽位扩展、配置、双手武器机制
5. ✅ **护甲类型系统**: 4种护甲类型、减伤机制、平衡设计
6. ✅ **武器类型系统**: 15种武器类型、攻击速度、双持、格挡
7. ✅ **职业装备限制**: 职业兼容性、验证机制
8. ✅ **领域模型设计**: GearDefinition, GearInstance, Affix, GearSet
9. ✅ **数据库设计**: 表结构、索引、迁移方案

---

## 下一步

请参阅：
- **《装备系统优化总体方案（中）》**: 详细的Phase执行计划、技术实现规范、配置化设计
- **《装备系统优化总体方案（下）》**: 测试策略、数值平衡、前端验证、扩展性设计

---

**文档版本**: 2.0 整合版  
**创建日期**: 2025-10-11  
**维护负责**: 开发团队  
**状态**: ✅ 已完成

---
