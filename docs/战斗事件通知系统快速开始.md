# 战斗事件通知系统 - 快速开始

## 简介

战斗事件通知系统为前端提供详细的战斗消息，包括攻击开始、伤害造成、伤害接收等信息。所有消息模板都可以通过配置文件自定义。

## 事件类型

系统支持三种战斗事件类型：

| 事件类型 | 说明 | 触发时机 |
|---------|------|---------|
| **AttackStart** | 攻击开始 | 攻击者开始对目标发起攻击时 |
| **DamageDealt** | 伤害造成 | 攻击者对目标造成伤害后 |
| **DamageReceived** | 伤害接收 | 接收者受到伤害后（仅玩家受伤时） |

## 配置文件位置

主配置文件：
- `BlazorIdle.Server/Config/BattleEvents/battle-events-config.json`

SignalR通知开关配置：
- `BlazorIdle.Server/Config/SignalR/signalr-config.json`

## 默认消息模板

### 攻击开始消息
- **玩家攻击敌人**：`{attacker} 开始攻击 {target}`
- **敌人攻击玩家**：`{attacker} 向 {target} 发起攻击`

### 伤害造成消息
- **普通伤害**：`{attacker} 对 {target} 造成 {damage} 点{damageType}伤害`
- **暴击伤害**：`{attacker} 对 {target} 造成 {damage} 点{damageType}暴击伤害！`

### 伤害接收消息
- **玩家受伤**：`{receiver} 受到 {attacker} 的 {damage} 点{damageType}伤害（剩余 {currentHp}/{maxHp}）`
- **敌人受伤**：`{receiver} 受到 {damage} 点{damageType}伤害（剩余 {currentHp}/{maxHp}）`

## 占位符说明

消息模板支持以下占位符：

| 占位符 | 说明 | 示例 |
|-------|------|------|
| `{attacker}` | 攻击者名称 | "勇者" |
| `{target}` | 目标名称 | "史莱姆" |
| `{receiver}` | 接收者名称 | "勇者" |
| `{damage}` | 伤害值 | "50" |
| `{damageType}` | 伤害类型（自动翻译） | "物理" |
| `{currentHp}` | 当前血量 | "75" |
| `{maxHp}` | 最大血量 | "100" |

## 使用示例

### 示例1：自定义攻击消息

编辑 `battle-events-config.json`：

```json
{
  "Messages": {
    "AttackStart": {
      "Enabled": true,
      "PlayerAttacksEnemy": "⚔️ {attacker} 冲向 {target}！",
      "EnemyAttacksPlayer": "⚠️ {attacker} 向 {target} 发起攻击！"
    }
  }
}
```

**效果**：
- 玩家攻击：`⚔️ 勇者 冲向 史莱姆！`
- 敌人攻击：`⚠️ 哥布林 向 勇者 发起攻击！`

### 示例2：自定义伤害消息

```json
{
  "Messages": {
    "DamageDealt": {
      "Enabled": true,
      "Normal": "💥 {attacker} 对 {target} 造成了 {damage} 点{damageType}伤害",
      "Critical": "🔥 暴击！{attacker} 对 {target} 造成 {damage} 点{damageType}伤害！"
    }
  }
}
```

**效果**：
- 普通攻击：`💥 勇者 对 史莱姆 造成了 50 点物理伤害`
- 暴击攻击：`🔥 暴击！勇者 对 史莱姆 造成 100 点物理伤害！`

### 示例3：添加表情符号

```json
{
  "Messages": {
    "DamageReceived": {
      "Enabled": true,
      "Player": "🛡️ {receiver} 受到 {attacker} 的 {damage} 点{damageType}伤害（❤️ {currentHp}/{maxHp}）"
    }
  }
}
```

**效果**：
- `🛡️ 勇者 受到 哥布林 的 15 点物理伤害（❤️ 85/100）`

### 示例4：自定义伤害类型名称

```json
{
  "DamageTypeNames": {
    "Physical": "物理",
    "Magic": "魔法",
    "True": "真实",
    "Fire": "火焰",
    "Ice": "冰霜"
  }
}
```

## 启用/禁用事件通知

### 方法1：通过 BattleEvents 配置

编辑 `battle-events-config.json`：

```json
{
  "EnableBattleEventMessages": true,
  "Messages": {
    "AttackStart": {
      "Enabled": false  // 禁用攻击开始消息
    },
    "DamageDealt": {
      "Enabled": true   // 启用伤害造成消息
    },
    "DamageReceived": {
      "Enabled": true   // 启用伤害接收消息
    }
  }
}
```

### 方法2：通过 SignalR 配置

编辑 `signalr-config.json`：

```json
{
  "Notification": {
    "EnableAttackStartNotification": false,
    "EnableDamageDealtNotification": true,
    "EnableDamageReceivedNotification": true
  }
}
```

**注意**：两种方法都需要启用，事件才会被发送。

## 前端集成示例

### 监听战斗事件

```typescript
// 连接到 SignalR Hub
const connection = new HubConnectionBuilder()
    .withUrl("/hubs/battle")
    .build();

// 监听战斗事件
connection.on("BattleEvent", (eventData) => {
    switch (eventData.eventType) {
        case "AttackStart":
            handleAttackStart(eventData);
            break;
        case "DamageDealt":
            handleDamageDealt(eventData);
            break;
        case "DamageReceived":
            handleDamageReceived(eventData);
            break;
    }
});

function handleAttackStart(event) {
    console.log(`${event.attackerName} 开始攻击 ${event.targetName}`);
    showBattleMessage(`${event.attackerName} 开始攻击 ${event.targetName}`);
}

function handleDamageDealt(event) {
    const critTag = event.isCrit ? "暴击！" : "";
    const message = `${critTag}${event.attackerName} 对 ${event.targetName} 造成 ${event.damage} 点伤害`;
    showBattleMessage(message);
}

function handleDamageReceived(event) {
    const message = `${event.receiverName} 受到 ${event.damage} 点伤害（剩余 ${event.currentHp}/${event.maxHp}）`;
    showBattleMessage(message, "danger");
}
```

### 显示战斗日志

```typescript
function showBattleMessage(message, type = "info") {
    const logElement = document.createElement("div");
    logElement.className = `battle-log-entry ${type}`;
    logElement.textContent = message;
    
    const logContainer = document.getElementById("battle-log");
    logContainer.appendChild(logElement);
    
    // 自动滚动到底部
    logContainer.scrollTop = logContainer.scrollHeight;
    
    // 限制日志条数
    while (logContainer.children.length > 100) {
        logContainer.removeChild(logContainer.firstChild);
    }
}
```

## 常见问题

### Q1: 为什么收不到战斗事件通知？

**检查清单**：
1. 确认 SignalR 连接已建立
2. 检查 `signalr-config.json` 中对应的 `Enable*Notification` 选项是否为 `true`
3. 检查 `battle-events-config.json` 中对应的 `Enabled` 选项是否为 `true`
4. 确认前端已正确订阅 `BattleEvent` 事件

### Q2: 如何完全禁用战斗事件消息？

在 `battle-events-config.json` 中设置：

```json
{
  "EnableBattleEventMessages": false
}
```

或在 `signalr-config.json` 中全部设置为 `false`：

```json
{
  "Notification": {
    "EnableAttackStartNotification": false,
    "EnableDamageDealtNotification": false,
    "EnableDamageReceivedNotification": false
  }
}
```

### Q3: 消息模板修改后需要重启服务器吗？

是的，当前实现需要重启服务器才能加载新的配置。如果需要运行时重载配置，可以使用 `IOptionsMonitor<BattleEventsOptions>` 替代 `IOptions<BattleEventsOptions>`。

### Q4: 可以添加自定义占位符吗？

可以。需要：
1. 在对应的 DTO 中添加新字段
2. 在 `BattleEventMessageFormatter` 中添加对应的 `Replace` 调用
3. 在配置文件的模板中使用新占位符

示例：
```csharp
// 在 DamageDealtEventDto 中添加
public string WeaponName { get; set; }

// 在格式化器中添加
.Replace("{weapon}", evt.WeaponName)

// 在配置文件中使用
"Normal": "{attacker} 使用 {weapon} 对 {target} 造成 {damage} 点伤害"
```

## 性能优化建议

1. **高频事件过滤**：对于高频率的事件（如每秒多次的攻击），考虑在前端实现节流或防抖
2. **消息缓冲**：前端可以缓冲多个消息，批量显示
3. **日志限制**：限制前端日志显示的条数，避免内存占用过大
4. **按需启用**：仅启用需要的事件类型，减少网络流量

## 扩展阅读

- [战斗事件通知系统实施报告](./战斗事件通知系统实施报告.md) - 详细的技术实现说明
- [SignalR 集成优化方案](./SignalR集成优化方案.md) - SignalR 架构设计
- [SignalR 轻量事件优化指南](./SignalR轻量事件优化指南.md) - 性能优化指南

## 反馈与支持

如有问题或建议，请通过以下方式联系：
- 提交 GitHub Issue
- 查看项目文档
- 参考单元测试示例
