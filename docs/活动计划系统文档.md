# 活动计划系统（Activity Plan System）文档

## 概述

活动计划系统是 BlazorIdle 游戏的核心功能之一，它为战斗、采集、制作等游戏活动提供了统一的计划和调度框架。该系统允许玩家创建、启动和管理多个活动计划，每个计划可以设置不同的限制条件（如时间限制、无限制等）。

## 设计原则

1. **最小化修改**：在现有战斗系统基础上添加计划层，不破坏原有逻辑
2. **代码风格一致**：遵循项目现有的代码组织和命名规范
3. **可扩展性**：为未来的采集、制作等活动类型预留扩展点
4. **状态管理**：清晰的状态机设计，确保计划状态的正确转换

## 核心概念

### 活动类型（ActivityType）

当前支持的活动类型：
- **Combat（持续战斗）**：对指定敌人进行持续战斗，敌人被击败后自动刷新
- **Dungeon（地下城）**：挑战地下城，支持单次或循环模式

未来扩展（预留）：
- Gather（采集）
- Craft（制作）

### 限制类型（LimitType）

- **Duration（时长限制）**：按指定秒数执行，达到时长后自动完成
- **Infinite（无限制）**：一直执行直到手动停止

### 活动状态（ActivityState）

状态机流程：`Pending → Running → Completed/Cancelled`

- **Pending（待执行）**：计划已创建但未开始
- **Running（执行中）**：计划正在执行
- **Completed（已完成）**：计划正常结束（达到限制条件或手动停止）
- **Cancelled（已取消）**：计划被用户取消

## 数据模型

### ActivityPlan 实体

```csharp
public class ActivityPlan
{
    public Guid Id { get; set; }                  // 计划唯一标识
    public Guid CharacterId { get; set; }         // 所属角色ID
    public int SlotIndex { get; set; }            // 所属槽位索引（0-4）
    public ActivityType Type { get; set; }        // 活动类型
    public LimitType LimitType { get; set; }      // 限制类型
    public double? LimitValue { get; set; }       // 限制值（秒）
    public ActivityState State { get; set; }      // 活动状态
    public DateTime CreatedAt { get; set; }       // 创建时间
    public DateTime? StartedAt { get; set; }      // 开始时间
    public DateTime? CompletedAt { get; set; }    // 完成时间
    public string PayloadJson { get; set; }       // 活动配置（JSON）
    public Guid? BattleId { get; set; }          // 关联的战斗ID
    public double ExecutedSeconds { get; set; }   // 已执行时长
}
```

### CombatActivityPayload 配置

战斗活动的配置参数：

```csharp
public class CombatActivityPayload
{
    public string? EnemyId { get; set; }          // 敌人ID
    public int EnemyCount { get; set; }           // 敌人数量
    public double? RespawnDelay { get; set; }     // 重生延迟（秒）
    public ulong? Seed { get; set; }              // 随机种子
}
```

### DungeonActivityPayload 配置

地下城活动的配置参数：

```csharp
public class DungeonActivityPayload
{
    public string DungeonId { get; set; }         // 地下城ID
    public bool Loop { get; set; }                // 是否循环
    public double? WaveDelay { get; set; }        // 波次延迟（秒）
    public double? RunDelay { get; set; }         // 轮次延迟（秒）
    public ulong? Seed { get; set; }              // 随机种子
}
```

## API 接口

### 1. 创建战斗计划

**接口**：`POST /api/activity-plans/combat`

**参数**：
- `characterId` (Guid, 必需)：角色ID
- `slotIndex` (int, 默认0)：槽位索引（0-4）
- `limitType` (string, 默认"duration")：限制类型（"duration" 或 "infinite"）
- `limitValue` (double?, 可选)：限制值（秒，duration类型必需）
- `enemyId` (string?, 可选)：敌人ID
- `enemyCount` (int, 默认1)：敌人数量
- `respawnDelay` (double?, 可选)：重生延迟（秒）
- `seed` (ulong?, 可选)：随机种子

**示例**：
```bash
# 创建一个1小时的战斗计划
POST /api/activity-plans/combat?characterId=xxx&limitType=duration&limitValue=3600&enemyId=goblin

# 创建一个无限时长的战斗计划
POST /api/activity-plans/combat?characterId=xxx&limitType=infinite&enemyId=orc
```

**响应**：
```json
{
  "id": "uuid",
  "characterId": "uuid",
  "type": 1,
  "state": 0,
  "limitType": 1,
  "limitValue": 3600,
  "payloadJson": "{\"EnemyId\":\"goblin\",\"EnemyCount\":1}",
  ...
}
```

### 2. 创建地下城计划

**接口**：`POST /api/activity-plans/dungeon`

**参数**：
- `characterId` (Guid, 必需)：角色ID
- `slotIndex` (int, 默认0)：槽位索引（0-4）
- `limitType` (string, 默认"duration")：限制类型
- `limitValue` (double?, 可选)：限制值（秒）
- `dungeonId` (string, 默认"intro_cave")：地下城ID
- `loop` (bool, 默认false)：是否循环
- `waveDelay` (double?, 可选)：波次延迟
- `runDelay` (double?, 可选)：轮次延迟
- `seed` (ulong?, 可选)：随机种子

**示例**：
```bash
# 创建一个2小时的地下城循环计划
POST /api/activity-plans/dungeon?characterId=xxx&limitType=duration&limitValue=7200&dungeonId=intro_cave&loop=true
```

### 3. 启动计划

**接口**：`POST /api/activity-plans/{id}/start`

**响应**：
```json
{
  "planId": "uuid",
  "battleId": "uuid"
}
```

### 4. 停止计划

**接口**：`POST /api/activity-plans/{id}/stop`

**响应**：
```json
{
  "planId": "uuid",
  "stopped": true
}
```

### 5. 取消计划

**接口**：`POST /api/activity-plans/{id}/cancel`

**响应**：
```json
{
  "planId": "uuid",
  "cancelled": true
}
```

### 6. 获取角色所有计划

**接口**：`GET /api/activity-plans/character/{characterId}`

**响应**：计划列表数组

### 7. 获取指定槽位的计划

**接口**：`GET /api/activity-plans/character/{characterId}/slot/{slotIndex}`

**响应**：指定槽位的计划列表数组

### 8. 获取单个计划

**接口**：`GET /api/activity-plans/{id}`

**响应**：单个计划对象

### 9. 删除计划

**接口**：`DELETE /api/activity-plans/{id}`

**注意**：只能删除未启动或已完成的计划，运行中的计划需要先停止。

## 使用流程

### 典型使用场景：创建并执行一个战斗计划

1. **创建计划**：
```bash
POST /api/activity-plans/combat?characterId=xxx&limitType=duration&limitValue=3600&enemyId=dummy
# 返回 { "id": "plan-uuid", ... }
```

2. **启动计划**：
```bash
POST /api/activity-plans/plan-uuid/start
# 返回 { "planId": "plan-uuid", "battleId": "battle-uuid" }
```

3. **查询战斗状态**（使用现有战斗API）：
```bash
GET /api/battles/step/battle-uuid/status
```

4. **手动停止计划**（可选）：
```bash
POST /api/activity-plans/plan-uuid/stop
```

5. **查看计划结果**：
```bash
GET /api/activity-plans/plan-uuid
# 查看 state、executedSeconds、completedAt 等字段
```

### 无限时长计划的使用

```bash
# 1. 创建无限计划
POST /api/activity-plans/combat?characterId=xxx&limitType=infinite&enemyId=orc

# 2. 启动计划
POST /api/activity-plans/plan-uuid/start

# 3. 战斗会一直持续，直到手动停止
POST /api/activity-plans/plan-uuid/stop
```

## 架构设计

### 领域层（Domain）

- **Domain/Activities/**：活动计划领域模型
  - `ActivityPlan.cs`：活动计划实体
  - `ActivityType.cs`：活动类型枚举
  - `ActivityState.cs`：活动状态枚举
  - `LimitType.cs`：限制类型枚举
  - `CombatActivityPayload.cs`：战斗配置
  - `DungeonActivityPayload.cs`：地下城配置

### 应用层（Application）

- **Application/Activities/**：活动计划服务
  - `ActivityPlanService.cs`：核心业务逻辑
    - 创建计划
    - 启动计划（集成 StepBattleCoordinator）
    - 停止计划
    - 取消计划
    - 更新进度

- **Application/Abstractions/**：仓储接口
  - `IActivityPlanRepository.cs`：活动计划仓储接口

### 基础设施层（Infrastructure）

- **Infrastructure/Persistence/Repositories/**：数据访问
  - `ActivityPlanRepository.cs`：活动计划仓储实现

- **Infrastructure/Persistence/Migrations/**：数据库迁移
  - `20251007033423_AddActivityPlanTable.cs`：创建 ActivityPlans 表

### API层（Api）

- **Api/ActivityPlansController.cs**：RESTful API控制器
  - 提供创建、查询、启动、停止、取消等端点

## 与现有系统的集成

### 战斗系统集成

活动计划系统通过 `StepBattleCoordinator` 与现有战斗系统集成：

1. 创建计划时，将活动配置存储在 `PayloadJson` 字段
2. 启动计划时，解析配置并调用 `StepBattleCoordinator.Start()` 启动战斗
3. 停止计划时，调用 `StepBattleCoordinator.StopAndFinalizeAsync()` 停止战斗
4. 战斗 ID 存储在 `ActivityPlan.BattleId` 字段中，便于关联查询

### 数据持久化

- 使用 Entity Framework Core 进行数据持久化
- `ActivityPlans` 表存储所有活动计划
- 通过外键 `CharacterId` 关联到 `Characters` 表
- 通过 `BattleId` 关联到战斗记录

## 未来扩展

### 多槽位支持

当前设计中已包含 `SlotIndex` 字段（0-4），为未来的多槽位并行执行预留：

```csharp
public int SlotIndex { get; set; }  // 0-4，共5个槽位
```

未来可以实现：
- 每个角色最多同时运行 5 个不同槽位的计划
- 不同槽位可以执行不同类型的活动
- 槽位之间通过互斥标签（exclusion tags）避免冲突

### 采集活动（Gather）

```csharp
public enum ActivityType
{
    Combat = 1,
    Dungeon = 2,
    Gather = 3,  // 未来实现
}

public class GatherActivityPayload
{
    public string ResourceId { get; set; }
    public string RegionId { get; set; }
    // ... 其他采集参数
}
```

### 制作活动（Craft）

```csharp
public enum ActivityType
{
    Combat = 1,
    Dungeon = 2,
    Gather = 3,
    Craft = 4,  // 未来实现
}

public class CraftActivityPayload
{
    public string RecipeId { get; set; }
    public int Quantity { get; set; }
    // ... 其他制作参数
}
```

### 数量限制（Count Limit）

```csharp
public enum LimitType
{
    Duration = 1,
    Infinite = 2,
    Count = 3,  // 未来实现：按击杀数量或采集数量限制
}
```

### 队列自动衔接

未来可以实现计划队列功能：
- 同一槽位可以添加多个待执行计划
- 当前计划完成后，自动启动下一个计划
- 支持计划的重排序和优先级调整

## 测试

测试文件位置：`tests/BlazorIdle.Tests/ActivityPlanTests.cs`

测试覆盖：
- ✅ 无限时长计划的限制检查
- ✅ 时长限制的达成判断
- ✅ 状态转换的有效性
- ✅ 活动类型的支持

运行测试：
```bash
dotnet test --filter "FullyQualifiedName~ActivityPlanTests"
```

## 性能考虑

1. **数据库索引**：`CharacterId` 和 `SlotIndex` 字段应创建索引，提高查询性能
2. **状态更新频率**：避免频繁更新 `ExecutedSeconds` 字段，可以采用批量更新策略
3. **内存管理**：活动计划的状态主要在数据库中，运行时状态由 `StepBattleCoordinator` 管理

## 常见问题（FAQ）

### Q: 可以同时运行多个计划吗？
A: 当前版本每个角色只能同时运行一个计划（由 `GetRunningPlanAsync` 检查限制）。未来版本将支持多槽位并行。

### Q: 无限时长的计划什么时候会停止？
A: 无限时长计划需要手动调用 `/stop` 接口停止，或者在角色离线时由后台服务自动停止。

### Q: 计划完成后会自动获得奖励吗？
A: 是的，战斗奖励由现有的边打边发系统处理，计划完成后可以通过战斗API查询奖励。

### Q: 如何查看计划的执行进度？
A: 可以通过 `GET /api/activity-plans/{id}` 查看 `ExecutedSeconds` 字段，或者通过战斗API查看战斗详情。

### Q: 可以修改已创建的计划吗？
A: 当前版本不支持修改计划。如需修改，请删除旧计划并创建新计划。

## 总结

活动计划系统为 BlazorIdle 提供了灵活的活动管理框架，支持时间限制和无限时长两种模式，与现有战斗系统无缝集成，并为未来的采集、制作等功能预留了扩展点。系统设计遵循领域驱动设计（DDD）原则，代码结构清晰，易于维护和扩展。
