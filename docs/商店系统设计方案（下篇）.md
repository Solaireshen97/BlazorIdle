# BlazorIdle 商店系统设计方案（下篇）
## 集成测试、性能优化与运维

**项目**: BlazorIdle  
**文档类型**: 设计方案 - 下篇  
**创建日期**: 2025-10-12  
**版本**: 1.0  
**状态**: 设计阶段  
**作者**: 系统架构团队

---

## 📋 目录

1. [Phase 5: 集成测试](#1-phase-5-集成测试)
2. [Phase 6: 性能优化](#2-phase-6-性能优化)
3. [监控与日志](#3-监控与日志)
4. [安全性加固](#4-安全性加固)
5. [运维与配置管理](#5-运维与配置管理)
6. [扩展功能设计](#6-扩展功能设计)
7. [交付清单](#7-交付清单)

---

## 1. Phase 5: 集成测试

### 1.1 测试策略

| 测试类型 | 覆盖范围 | 工具 | 目标覆盖率 |
|---------|---------|------|-----------|
| 单元测试 | 领域模型、服务类 | xUnit | 80%+ |
| 集成测试 | API端点、数据库交互 | xUnit + TestServer | 70%+ |
| 性能测试 | 并发购买、大量商品加载 | BenchmarkDotNet | N/A |
| 端到端测试 | 完整购买流程 | Playwright/Selenium | 关键路径 |

### 1.2 单元测试清单

#### 1.2.1 领域模型测试

**文件**: `BlazorIdle.Server.Tests/Domain/Shop/ShopAggregateTests.cs`

```csharp
using BlazorIdle.Server.Domain.Shop.Models;
using Xunit;

namespace BlazorIdle.Server.Tests.Domain.Shop;

public class ShopAggregateTests
{
    [Fact]
    public void ShopInstance_ShouldInitializeCorrectly()
    {
        // Arrange & Act
        var shop = new ShopInstance("shop_test");
        
        // Assert
        Assert.NotEqual(Guid.Empty, shop.Id);
        Assert.Equal("shop_test", shop.ShopDefinitionId);
        Assert.Equal(0, shop.RefreshCount);
        Assert.NotNull(shop.ItemStocks);
        Assert.Empty(shop.ItemStocks);
    }
    
    [Fact]
    public void ShopInstance_Refresh_ShouldUpdateState()
    {
        // Arrange
        var shop = new ShopInstance("shop_test");
        var stocks = new List<ShopItemStock>
        {
            new ShopItemStock(shop.Id, "item1", 10, 10),
            new ShopItemStock(shop.Id, "item2", 5, 5)
        };
        var refreshTime = DateTime.UtcNow;
        
        // Act
        shop.Refresh(refreshTime, stocks);
        
        // Assert
        Assert.Equal(refreshTime, shop.LastRefreshTime);
        Assert.Equal(1, shop.RefreshCount);
        Assert.Equal(2, shop.ItemStocks.Count);
        Assert.Single(shop.DomainEvents); // ShopRefreshedEvent
    }
    
    [Fact]
    public void ShopInstance_TryDeductStock_ShouldSucceedWhenStockAvailable()
    {
        // Arrange
        var shop = new ShopInstance("shop_test");
        var stocks = new List<ShopItemStock>
        {
            new ShopItemStock(shop.Id, "item1", 10, 10)
        };
        shop.Refresh(DateTime.UtcNow, stocks);
        
        // Act
        var result = shop.TryDeductStock("item1", 3);
        
        // Assert
        Assert.True(result);
        Assert.Equal(7, shop.ItemStocks[0].CurrentStock);
    }
    
    [Fact]
    public void ShopInstance_TryDeductStock_ShouldFailWhenStockInsufficient()
    {
        // Arrange
        var shop = new ShopInstance("shop_test");
        var stocks = new List<ShopItemStock>
        {
            new ShopItemStock(shop.Id, "item1", 10, 5)
        };
        shop.Refresh(DateTime.UtcNow, stocks);
        
        // Act
        var result = shop.TryDeductStock("item1", 10);
        
        // Assert
        Assert.False(result);
        Assert.Equal(5, shop.ItemStocks[0].CurrentStock); // 未扣减
    }
}
```

#### 1.2.2 库存管理测试

**文件**: `BlazorIdle.Server.Tests/Domain/Shop/ShopItemStockTests.cs`

```csharp
public class ShopItemStockTests
{
    [Fact]
    public void TryDeduct_ShouldSucceed_WhenStockIsInfinite()
    {
        // Arrange
        var stock = new ShopItemStock(Guid.NewGuid(), "item1", null, null);
        
        // Act
        var result = stock.TryDeduct(100);
        
        // Assert
        Assert.True(result);
        Assert.Null(stock.CurrentStock); // 仍然是无限
    }
    
    [Theory]
    [InlineData(10, 5, true, 5)]   // 库存10，扣5，成功，剩5
    [InlineData(10, 10, true, 0)]  // 库存10，扣10，成功，剩0
    [InlineData(10, 11, false, 10)] // 库存10，扣11，失败，剩10
    [InlineData(0, 1, false, 0)]   // 库存0，扣1，失败，剩0
    public void TryDeduct_ShouldWorkCorrectly(
        int initialStock, 
        int deductAmount, 
        bool expectedResult, 
        int expectedRemaining)
    {
        // Arrange
        var stock = new ShopItemStock(Guid.NewGuid(), "item1", 100, initialStock);
        
        // Act
        var result = stock.TryDeduct(deductAmount);
        
        // Assert
        Assert.Equal(expectedResult, result);
        Assert.Equal(expectedRemaining, stock.CurrentStock);
    }
    
    [Fact]
    public void RestockToMax_ShouldResetToMaxStock()
    {
        // Arrange
        var stock = new ShopItemStock(Guid.NewGuid(), "item1", 20, 5);
        
        // Act
        stock.RestockToMax();
        
        // Assert
        Assert.Equal(20, stock.CurrentStock);
    }
}
```

#### 1.2.3 价格计算测试

```csharp
public class CurrencyCostTests
{
    [Theory]
    [InlineData(100, 1.0, 100)]   // 无折扣
    [InlineData(100, 0.8, 80)]    // 8折
    [InlineData(100, 0.5, 50)]    // 5折
    [InlineData(100, 0.0, 0)]     // 全免费
    public void CalculateActualCost_ShouldApplyDiscount(
        long baseAmount, 
        double discount, 
        long expected)
    {
        // Arrange
        var cost = new CurrencyCost
        {
            CurrencyType = CurrencyType.Gold,
            Amount = baseAmount,
            DiscountFactor = discount
        };
        
        // Act
        var actual = cost.CalculateActualCost();
        
        // Assert
        Assert.Equal(expected, actual);
    }
}
```

### 1.3 集成测试清单

#### 1.3.1 购买流程集成测试

**文件**: `BlazorIdle.Server.Tests/Integration/PurchaseIntegrationTests.cs`

```csharp
using Microsoft.AspNetCore.Mvc.Testing;
using Xunit;

namespace BlazorIdle.Server.Tests.Integration;

public class PurchaseIntegrationTests : IClassFixture<WebApplicationFactory<Program>>
{
    private readonly WebApplicationFactory<Program> _factory;
    private readonly HttpClient _client;
    
    public PurchaseIntegrationTests(WebApplicationFactory<Program> factory)
    {
        _factory = factory;
        _client = factory.CreateClient();
    }
    
    [Fact]
    public async Task Purchase_ShouldSucceed_WhenAllConditionsMet()
    {
        // Arrange
        var characterId = await CreateTestCharacter(gold: 1000);
        await SeedTestShop();
        
        var request = new PurchaseRequest
        {
            CharacterId = characterId,
            ShopItemId = "test_item_bread",
            Quantity = 5,
            TransactionId = Guid.NewGuid().ToString()
        };
        
        // Act
        var response = await _client.PostAsJsonAsync("/api/shops/purchase", request);
        
        // Assert
        response.EnsureSuccessStatusCode();
        var result = await response.Content.ReadFromJsonAsync<PurchaseResult>();
        Assert.True(result.Success);
        Assert.Equal(5, result.ItemsGranted.First().Quantity);
        
        // 验证金币扣除
        var character = await GetCharacter(characterId);
        Assert.Equal(975, character.Gold); // 1000 - (5 * 5)
    }
    
    [Fact]
    public async Task Purchase_ShouldFail_WhenInsufficientGold()
    {
        // Arrange
        var characterId = await CreateTestCharacter(gold: 10); // 只有10金币
        await SeedTestShop();
        
        var request = new PurchaseRequest
        {
            CharacterId = characterId,
            ShopItemId = "test_item_bread",
            Quantity = 100, // 需要500金币
            TransactionId = Guid.NewGuid().ToString()
        };
        
        // Act
        var response = await _client.PostAsJsonAsync("/api/shops/purchase", request);
        
        // Assert
        var result = await response.Content.ReadFromJsonAsync<PurchaseResult>();
        Assert.False(result.Success);
        Assert.Contains("货币不足", result.Message);
    }
    
    [Fact]
    public async Task Purchase_ShouldBeIdempotent()
    {
        // Arrange
        var characterId = await CreateTestCharacter(gold: 1000);
        await SeedTestShop();
        
        var transactionId = Guid.NewGuid().ToString();
        var request = new PurchaseRequest
        {
            CharacterId = characterId,
            ShopItemId = "test_item_bread",
            Quantity = 5,
            TransactionId = transactionId
        };
        
        // Act - 第一次购买
        var response1 = await _client.PostAsJsonAsync("/api/shops/purchase", request);
        var result1 = await response1.Content.ReadFromJsonAsync<PurchaseResult>();
        
        // Act - 第二次购买（相同TransactionId）
        var response2 = await _client.PostAsJsonAsync("/api/shops/purchase", request);
        var result2 = await response2.Content.ReadFromJsonAsync<PurchaseResult>();
        
        // Assert
        Assert.True(result1.Success);
        Assert.True(result2.Success); // 幂等，不报错
        
        // 验证只扣了一次钱
        var character = await GetCharacter(characterId);
        Assert.Equal(975, character.Gold);
    }
    
    [Fact]
    public async Task Purchase_ShouldDeductStock_WhenStockLimited()
    {
        // Arrange
        var characterId = await CreateTestCharacter(gold: 10000);
        await SeedTestShopWithLimitedStock(itemStock: 10);
        
        // Act - 购买5个
        await PurchaseItem(characterId, quantity: 5);
        
        // Assert - 验证库存剩余5个
        var shop = await GetShopDetail("test_shop");
        var item = shop.Items.First(i => i.ShopItemId == "limited_item");
        Assert.Equal(5, item.CurrentStock);
    }
    
    [Fact]
    public async Task Purchase_ShouldEnforcePurchaseLimit()
    {
        // Arrange
        var characterId = await CreateTestCharacter(gold: 10000);
        await SeedTestShopWithDailyLimit(maxPerDay: 3);
        
        // Act - 第一次购买3个（达到上限）
        var result1 = await PurchaseItem(characterId, quantity: 3);
        Assert.True(result1.Success);
        
        // Act - 第二次尝试购买1个（超限）
        var result2 = await PurchaseItem(characterId, quantity: 1);
        
        // Assert
        Assert.False(result2.Success);
        Assert.Contains("限购", result2.Message);
    }
    
    // 辅助方法
    private async Task<Guid> CreateTestCharacter(long gold) { /* ... */ }
    private async Task SeedTestShop() { /* ... */ }
    private async Task<Character> GetCharacter(Guid id) { /* ... */ }
    private async Task<ShopDetailDto> GetShopDetail(string shopId) { /* ... */ }
}
```

#### 1.3.2 商店刷新测试

```csharp
public class ShopRefreshIntegrationTests
{
    [Fact]
    public async Task RefreshShop_ShouldRestockItems()
    {
        // Arrange
        var shopId = "test_shop_daily";
        await SeedTestShop(shopId, RefreshInterval.Daily);
        var shopInstance = await GetShopInstance(shopId);
        
        // 模拟购买耗尽库存
        await DepleteSomeStock(shopInstance.Id);
        
        // Act
        await _refreshService.RefreshShopAsync(shopId);
        
        // Assert
        var refreshedShop = await GetShopInstance(shopId);
        Assert.True(refreshedShop.RefreshCount > shopInstance.RefreshCount);
        
        var stock = refreshedShop.ItemStocks.First();
        Assert.Equal(stock.MaxStock, stock.CurrentStock); // 补满
    }
    
    [Fact]
    public async Task RefreshShop_ShouldSkip_WhenNotTimeYet()
    {
        // Arrange
        var shopId = "test_shop_daily";
        await SeedTestShop(shopId, RefreshInterval.Daily);
        
        // 刚刚刷新过
        await _refreshService.RefreshShopAsync(shopId);
        var refreshCount1 = (await GetShopInstance(shopId)).RefreshCount;
        
        // Act - 立即再次刷新
        var result = await _refreshService.RefreshShopAsync(shopId);
        var refreshCount2 = (await GetShopInstance(shopId)).RefreshCount;
        
        // Assert
        Assert.Equal("商店尚未到刷新时间", result.Message);
        Assert.Equal(refreshCount1, refreshCount2); // 未刷新
    }
}
```

### 1.4 性能测试

#### 1.4.1 并发购买测试

**文件**: `BlazorIdle.Server.Tests/Performance/ConcurrentPurchaseTests.cs`

```csharp
using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

namespace BlazorIdle.Server.Tests.Performance;

[MemoryDiagnoser]
[SimpleJob(iterationCount: 100)]
public class ConcurrentPurchaseBenchmark
{
    private IPurchaseService _purchaseService;
    private Guid _characterId;
    private string _shopItemId;
    
    [GlobalSetup]
    public void Setup()
    {
        // 初始化测试环境
        _characterId = Guid.NewGuid();
        _shopItemId = "test_item";
    }
    
    [Benchmark]
    public async Task Sequential_10Purchases()
    {
        for (int i = 0; i < 10; i++)
        {
            await _purchaseService.PurchaseAsync(new PurchaseRequest
            {
                CharacterId = _characterId,
                ShopItemId = _shopItemId,
                Quantity = 1,
                TransactionId = Guid.NewGuid().ToString()
            });
        }
    }
    
    [Benchmark]
    public async Task Concurrent_10Purchases()
    {
        var tasks = Enumerable.Range(0, 10).Select(i =>
            _purchaseService.PurchaseAsync(new PurchaseRequest
            {
                CharacterId = _characterId,
                ShopItemId = _shopItemId,
                Quantity = 1,
                TransactionId = Guid.NewGuid().ToString()
            })
        );
        
        await Task.WhenAll(tasks);
    }
}

// 运行: dotnet run -c Release --project BlazorIdle.Server.Tests
// BenchmarkRunner.Run<ConcurrentPurchaseBenchmark>();
```

#### 1.4.2 大量商品加载测试

```csharp
[MemoryDiagnoser]
public class ShopLoadBenchmark
{
    [Params(10, 50, 100, 500)]
    public int ItemCount;
    
    [Benchmark]
    public async Task LoadShopWithItems()
    {
        var shopId = $"test_shop_{ItemCount}items";
        await _shopService.GetShopDetailAsync(shopId);
    }
}
```

### 1.5 测试覆盖率目标

| 模块 | 目标覆盖率 | 当前覆盖率 | 状态 |
|-----|----------|-----------|------|
| Domain/Shop/Models | 85% | - | 待实施 |
| Domain/Shop/Services | 80% | - | 待实施 |
| Application/Shop | 75% | - | 待实施 |
| Controllers | 70% | - | 待实施 |

---

## 2. Phase 6: 性能优化

### 2.1 数据库查询优化

#### 2.1.1 索引策略

```sql
-- ShopDefinitions表
CREATE INDEX IX_ShopDefinitions_ShopType ON ShopDefinitions(ShopType);
CREATE INDEX IX_ShopDefinitions_IsActive ON ShopDefinitions(IsActive);
CREATE INDEX IX_ShopDefinitions_SortOrder ON ShopDefinitions(SortOrder);

-- ShopItemDefinitions表
CREATE INDEX IX_ShopItemDefinitions_ShopDefinitionId ON ShopItemDefinitions(ShopDefinitionId);
CREATE INDEX IX_ShopItemDefinitions_ItemType ON ShopItemDefinitions(ItemType);
CREATE INDEX IX_ShopItemDefinitions_IsActive ON ShopItemDefinitions(IsActive);
CREATE INDEX IX_ShopItemDefinitions_DisplayOrder ON ShopItemDefinitions(DisplayOrder);

-- ShopInstance表
CREATE INDEX IX_ShopInstance_ShopDefinitionId ON ShopInstance(ShopDefinitionId);
CREATE INDEX IX_ShopInstance_NextRefreshTime ON ShopInstance(NextRefreshTime)
    WHERE NextRefreshTime IS NOT NULL;

-- ShopItemStock表
CREATE INDEX IX_ShopItemStock_ShopInstanceId ON ShopItemStock(ShopInstanceId);
CREATE INDEX IX_ShopItemStock_ShopItemId ON ShopItemStock(ShopItemId);

-- PurchaseRecord表
CREATE INDEX IX_PurchaseRecord_CharacterId_PurchaseTime 
    ON PurchaseRecord(CharacterId, PurchaseTime DESC);
CREATE INDEX IX_PurchaseRecord_ShopItemId ON PurchaseRecord(ShopItemId);

-- CharacterPurchaseRecord表
CREATE INDEX IX_CharacterPurchaseRecord_CharacterId_ShopItemId 
    ON CharacterPurchaseRecord(CharacterId, ShopItemId);
```

#### 2.1.2 查询优化策略

```csharp
// 使用 AsNoTracking 减少内存占用
public async Task<List<ShopDefinition>> GetAllActiveShopDefinitionsAsync(
    CancellationToken ct = default)
{
    return await _dbContext.ShopDefinitions
        .AsNoTracking()
        .Where(s => s.IsActive)
        .OrderBy(s => s.SortOrder)
        .Include(s => s.ItemDefinitions.Where(i => i.IsActive))
        .ToListAsync(ct);
}

// 分页查询购买历史
public async Task<List<PurchaseRecord>> GetCharacterPurchaseHistoryAsync(
    Guid characterId,
    DateTime? startDate,
    DateTime? endDate,
    int page = 1,
    int pageSize = 50,
    CancellationToken ct = default)
{
    var query = _dbContext.PurchaseRecords
        .AsNoTracking()
        .Where(p => p.CharacterId == characterId);
    
    if (startDate.HasValue)
        query = query.Where(p => p.PurchaseTime >= startDate.Value);
        
    if (endDate.HasValue)
        query = query.Where(p => p.PurchaseTime <= endDate.Value);
    
    return await query
        .OrderByDescending(p => p.PurchaseTime)
        .Skip((page - 1) * pageSize)
        .Take(pageSize)
        .ToListAsync(ct);
}

// 批量查询限购记录
public async Task<Dictionary<string, CharacterPurchaseRecord>> GetCharacterPurchaseRecordsAsync(
    Guid characterId,
    List<string> shopItemIds,
    CancellationToken ct = default)
{
    var records = await _dbContext.CharacterPurchaseRecords
        .AsNoTracking()
        .Where(r => r.CharacterId == characterId && shopItemIds.Contains(r.ShopItemId))
        .ToListAsync(ct);
    
    return records.ToDictionary(r => r.ShopItemId);
}
```

### 2.2 缓存策略

#### 2.2.1 内存缓存（IMemoryCache）

```csharp
using Microsoft.Extensions.Caching.Memory;

public class CachedShopRepository : IShopRepository
{
    private readonly IShopRepository _innerRepository;
    private readonly IMemoryCache _cache;
    private readonly ILogger<CachedShopRepository> _logger;
    
    private const string SHOP_DEF_KEY_PREFIX = "shop_def:";
    private const int CACHE_DURATION_MINUTES = 30;
    
    public async Task<ShopDefinition?> GetShopDefinitionAsync(
        string shopId,
        CancellationToken ct = default)
    {
        var cacheKey = $"{SHOP_DEF_KEY_PREFIX}{shopId}";
        
        if (_cache.TryGetValue(cacheKey, out ShopDefinition? cached))
        {
            _logger.LogDebug("Cache hit: {CacheKey}", cacheKey);
            return cached;
        }
        
        var definition = await _innerRepository.GetShopDefinitionAsync(shopId, ct);
        
        if (definition != null)
        {
            _cache.Set(cacheKey, definition, TimeSpan.FromMinutes(CACHE_DURATION_MINUTES));
            _logger.LogDebug("Cache set: {CacheKey}", cacheKey);
        }
        
        return definition;
    }
    
    public void InvalidateShopCache(string shopId)
    {
        var cacheKey = $"{SHOP_DEF_KEY_PREFIX}{shopId}";
        _cache.Remove(cacheKey);
        _logger.LogInformation("Cache invalidated: {CacheKey}", cacheKey);
    }
}
```

#### 2.2.2 分布式缓存（Redis - 可选）

```csharp
using Microsoft.Extensions.Caching.Distributed;
using System.Text.Json;

public class DistributedCachedShopRepository : IShopRepository
{
    private readonly IShopRepository _innerRepository;
    private readonly IDistributedCache _cache;
    
    public async Task<ShopDefinition?> GetShopDefinitionAsync(
        string shopId,
        CancellationToken ct = default)
    {
        var cacheKey = $"shop_def:{shopId}";
        var cached = await _cache.GetStringAsync(cacheKey, ct);
        
        if (cached != null)
        {
            return JsonSerializer.Deserialize<ShopDefinition>(cached);
        }
        
        var definition = await _innerRepository.GetShopDefinitionAsync(shopId, ct);
        
        if (definition != null)
        {
            var serialized = JsonSerializer.Serialize(definition);
            await _cache.SetStringAsync(
                cacheKey, 
                serialized, 
                new DistributedCacheEntryOptions
                {
                    AbsoluteExpirationRelativeToNow = TimeSpan.FromMinutes(30)
                },
                ct);
        }
        
        return definition;
    }
}
```

### 2.3 并发控制

#### 2.3.1 乐观锁

```csharp
// ShopInstance实体添加Version字段
public class ShopInstance
{
    public int Version { get; private set; }
    
    public void Refresh(...)
    {
        Version++; // 更新版本号
        // ...
    }
}

// EF Core配置
builder.Property(s => s.Version)
    .IsConcurrencyToken();

// 保存时处理并发冲突
public async Task<ShopInstance> SaveShopInstanceAsync(
    ShopInstance instance,
    CancellationToken ct = default)
{
    try
    {
        _dbContext.Update(instance);
        await _dbContext.SaveChangesAsync(ct);
        return instance;
    }
    catch (DbUpdateConcurrencyException ex)
    {
        _logger.LogWarning(ex, "Concurrency conflict when saving shop instance {Id}", instance.Id);
        
        // 重试策略
        await _dbContext.Entry(instance).ReloadAsync(ct);
        throw new ConcurrencyException("商店数据已被其他操作修改，请重试");
    }
}
```

#### 2.3.2 分布式锁（有限库存商品）

```csharp
using StackExchange.Redis;

public class DistributedLockService
{
    private readonly IConnectionMultiplexer _redis;
    
    public async Task<bool> AcquireLockAsync(
        string resourceKey,
        string lockId,
        TimeSpan expiry)
    {
        var db = _redis.GetDatabase();
        return await db.StringSetAsync(
            $"lock:{resourceKey}",
            lockId,
            expiry,
            When.NotExists);
    }
    
    public async Task ReleaseLockAsync(string resourceKey, string lockId)
    {
        var db = _redis.GetDatabase();
        var script = @"
            if redis.call('get', KEYS[1]) == ARGV[1] then
                return redis.call('del', KEYS[1])
            else
                return 0
            end";
        
        await db.ScriptEvaluateAsync(script, new RedisKey[] { $"lock:{resourceKey}" }, new RedisValue[] { lockId });
    }
}

// 在购买服务中使用
public async Task<PurchaseResult> PurchaseAsync(
    PurchaseRequest request,
    CancellationToken ct = default)
{
    var lockId = Guid.NewGuid().ToString();
    var lockKey = $"shop_item:{request.ShopItemId}";
    
    if (!await _lockService.AcquireLockAsync(lockKey, lockId, TimeSpan.FromSeconds(30)))
    {
        return PurchaseResult.Fail("商品正在被其他玩家购买，请稍后重试");
    }
    
    try
    {
        // 执行购买逻辑
        return await ExecutePurchaseAsync(request, ct);
    }
    finally
    {
        await _lockService.ReleaseLockAsync(lockKey, lockId);
    }
}
```

---

## 3. 监控与日志

### 3.1 关键指标监控

#### 3.1.1 业务指标

| 指标 | 描述 | 采集方式 | 告警阈值 |
|-----|------|---------|---------|
| **购买成功率** | (成功购买数/总购买请求) * 100% | Counter | < 95% |
| **购买响应时间** | P50/P95/P99延迟 | Histogram | P95 > 500ms |
| **库存耗尽次数** | 商品库存为0的次数 | Counter | > 10/小时 |
| **刷新失败率** | 商店刷新失败比例 | Counter | > 1% |
| **货币流通量** | 每日金币进出总量 | Gauge | 异常波动 |
| **热销商品Top10** | 购买次数最多的商品 | TopK | N/A |

#### 3.1.2 技术指标

| 指标 | 描述 | 告警阈值 |
|-----|------|---------|
| **并发购买冲突** | 乐观锁冲突次数 | > 100/分钟 |
| **数据库连接池** | 活跃/空闲连接数 | 活跃 > 80% |
| **缓存命中率** | 商店定义缓存命中率 | < 90% |
| **API错误率** | 4xx/5xx响应比例 | > 1% |

#### 3.1.3 监控实现（Prometheus + Grafana）

**文件**: `BlazorIdle.Server/Infrastructure/Monitoring/ShopMetrics.cs`

```csharp
using Prometheus;

public class ShopMetrics
{
    // 购买计数器
    private static readonly Counter PurchaseTotal = Metrics
        .CreateCounter(
            "shop_purchase_total",
            "Total number of purchase requests",
            new CounterConfiguration
            {
                LabelNames = new[] { "shop_id", "item_type", "result" }
            });
    
    // 购买延迟
    private static readonly Histogram PurchaseDuration = Metrics
        .CreateHistogram(
            "shop_purchase_duration_seconds",
            "Purchase request duration in seconds",
            new HistogramConfiguration
            {
                LabelNames = new[] { "shop_id" },
                Buckets = Histogram.ExponentialBuckets(0.01, 2, 10)
            });
    
    // 库存耗尽
    private static readonly Counter StockDepleted = Metrics
        .CreateCounter(
            "shop_stock_depleted_total",
            "Number of times items went out of stock",
            new CounterConfiguration
            {
                LabelNames = new[] { "shop_id", "item_id" }
            });
    
    // 货币流通
    private static readonly Counter CurrencyFlow = Metrics
        .CreateCounter(
            "shop_currency_flow_total",
            "Total currency exchanged",
            new CounterConfiguration
            {
                LabelNames = new[] { "currency_type", "direction" } // in/out
            });
    
    // 缓存命中率
    private static readonly Counter CacheHits = Metrics
        .CreateCounter(
            "shop_cache_hits_total",
            "Total cache hits",
            new CounterConfiguration
            {
                LabelNames = new[] { "cache_type" }
            });
    
    // 辅助方法
    public static void RecordPurchase(string shopId, string itemType, bool success)
    {
        PurchaseTotal.WithLabels(shopId, itemType, success ? "success" : "failure").Inc();
    }
    
    public static IDisposable MeasurePurchase(string shopId)
    {
        return PurchaseDuration.WithLabels(shopId).NewTimer();
    }
    
    public static void RecordStockDepletion(string shopId, string itemId)
    {
        StockDepleted.WithLabels(shopId, itemId).Inc();
    }
    
    public static void RecordCurrencyFlow(CurrencyType type, long amount, string direction)
    {
        CurrencyFlow.WithLabels(type.ToString(), direction).Inc(amount);
    }
}

// 在PurchaseService中使用
public async Task<PurchaseResult> PurchaseAsync(
    PurchaseRequest request,
    CancellationToken ct = default)
{
    using (ShopMetrics.MeasurePurchase(request.ShopId))
    {
        try
        {
            var result = await ExecutePurchaseAsync(request, ct);
            ShopMetrics.RecordPurchase(request.ShopId, itemType, result.Success);
            return result;
        }
        catch (Exception ex)
        {
            ShopMetrics.RecordPurchase(request.ShopId, itemType, false);
            throw;
        }
    }
}
```

### 3.2 结构化日志

#### 3.2.1 日志规范

```csharp
public class PurchaseService
{
    private readonly ILogger<PurchaseService> _logger;
    
    public async Task<PurchaseResult> PurchaseAsync(...)
    {
        _logger.LogInformation(
            "Purchase started: CharacterId={CharacterId}, ShopItemId={ShopItemId}, Quantity={Quantity}, TxId={TransactionId}",
            request.CharacterId,
            request.ShopItemId,
            request.Quantity,
            request.TransactionId);
        
        try
        {
            // 执行购买
            var result = await ExecutePurchaseAsync(request, ct);
            
            _logger.LogInformation(
                "Purchase completed: CharacterId={CharacterId}, ShopItemId={ShopItemId}, Success={Success}, RemainingGold={Gold}",
                request.CharacterId,
                request.ShopItemId,
                result.Success,
                result.RemainingCurrency.GetValueOrDefault(CurrencyType.Gold));
            
            return result;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex,
                "Purchase failed: CharacterId={CharacterId}, ShopItemId={ShopItemId}, Error={Error}",
                request.CharacterId,
                request.ShopItemId,
                ex.Message);
            
            throw;
        }
    }
}
```

#### 3.2.2 日志级别使用

| 级别 | 用途 | 示例 |
|-----|------|------|
| **Trace** | 详细调试信息 | 条件评估步骤 |
| **Debug** | 开发调试 | 缓存命中/未命中 |
| **Information** | 正常业务流程 | 购买成功、商店刷新 |
| **Warning** | 潜在问题 | 库存低、并发冲突 |
| **Error** | 错误情况 | 购买失败、数据库异常 |
| **Critical** | 严重错误 | 数据不一致、服务不可用 |

---

## 4. 安全性加固

### 4.1 防刷机制

#### 4.1.1 购买限频

```csharp
using Microsoft.AspNetCore.RateLimiting;

// Startup.cs 配置
builder.Services.AddRateLimiter(options =>
{
    options.AddFixedWindowLimiter("purchase", opt =>
    {
        opt.Window = TimeSpan.FromMinutes(1);
        opt.PermitLimit = 20; // 每分钟最多20次购买请求
        opt.QueueLimit = 0;
    });
});

// Controller应用限频
[HttpPost("purchase")]
[EnableRateLimiting("purchase")]
public async Task<IActionResult> Purchase([FromBody] PurchaseRequest request)
{
    // ...
}
```

#### 4.1.2 价格验证

```csharp
public class PurchaseValidator
{
    public async Task<ValidationResult> ValidateAsync(PurchaseRequest request, ...)
    {
        // ... 其他验证
        
        // 价格验证：客户端不传价格，服务端查询
        var itemDef = await _shopRepo.GetShopItemDefinitionAsync(request.ShopItemId, ct);
        var expectedPrices = itemDef.GetPrices();
        
        // 如果客户端传了价格（可选），验证是否一致
        if (request.ExpectedPrice != null)
        {
            var actualTotalCost = expectedPrices
                .Where(p => p.CurrencyType == CurrencyType.Gold)
                .Sum(p => p.Amount * request.Quantity);
                
            if (request.ExpectedPrice != actualTotalCost)
            {
                _logger.LogWarning(
                    "Price mismatch: CharacterId={CharacterId}, Expected={Expected}, Actual={Actual}",
                    request.CharacterId,
                    request.ExpectedPrice,
                    actualTotalCost);
                    
                return ValidationResult.Fail("价格已变更，请刷新后重试");
            }
        }
        
        return ValidationResult.Success();
    }
}
```

#### 4.1.3 异常行为检测

```csharp
public class AnomalyDetectionService
{
    /// <summary>
    /// 检测异常购买行为
    /// </summary>
    public async Task<bool> IsAnomalousBehavior(
        Guid characterId,
        string shopItemId,
        int quantity,
        CancellationToken ct)
    {
        // 1. 检查短时间内大量购买同一商品
        var recentPurchases = await _purchaseHistoryRepo.GetCharacterPurchaseHistoryAsync(
            characterId,
            startDate: DateTime.UtcNow.AddMinutes(-5),
            ct: ct);
        
        var sameItemCount = recentPurchases
            .Where(p => p.ShopItemId == shopItemId)
            .Sum(p => p.Quantity);
        
        if (sameItemCount > 100) // 5分钟内购买同一商品超过100个
        {
            _logger.LogWarning(
                "Anomaly: Rapid purchase detected. CharacterId={CharacterId}, ItemId={ItemId}, Count={Count}",
                characterId, shopItemId, sameItemCount);
            return true;
        }
        
        // 2. 检查账号创建后立即大额消费
        var character = await _characterRepo.GetByIdAsync(characterId, ct);
        var accountAge = DateTime.UtcNow - character.CreatedAt;
        
        if (accountAge < TimeSpan.FromHours(1) && quantity * GetItemPrice(shopItemId) > 10000)
        {
            _logger.LogWarning(
                "Anomaly: New account high-value purchase. CharacterId={CharacterId}, AccountAge={Age}",
                characterId, accountAge);
            return true;
        }
        
        return false;
    }
}
```

### 4.2 SQL注入防护

```csharp
// ✅ 推荐：使用参数化查询（EF Core自动处理）
public async Task<ShopDefinition?> GetShopDefinitionAsync(string shopId, ...)
{
    return await _dbContext.ShopDefinitions
        .FirstOrDefaultAsync(s => s.Id == shopId, ct); // 参数化
}

// ❌ 避免：字符串拼接SQL（容易注入）
// var sql = $"SELECT * FROM ShopDefinitions WHERE Id = '{shopId}'"; // 危险！
```

### 4.3 数据加密

```csharp
// 敏感数据加密（如代币余额）
public class EncryptionService
{
    private readonly byte[] _key;
    private readonly byte[] _iv;
    
    public string Encrypt(string plainText)
    {
        using var aes = Aes.Create();
        aes.Key = _key;
        aes.IV = _iv;
        
        var encryptor = aes.CreateEncryptor();
        var plainBytes = Encoding.UTF8.GetBytes(plainText);
        var encryptedBytes = encryptor.TransformFinalBlock(plainBytes, 0, plainBytes.Length);
        
        return Convert.ToBase64String(encryptedBytes);
    }
    
    public string Decrypt(string cipherText)
    {
        // 解密实现...
    }
}
```

---

## 5. 运维与配置管理

### 5.1 配置文件结构

#### 5.1.1 appsettings.json

```json
{
  "ShopSystem": {
    "EnablePurchaseLimit": true,
    "DefaultCacheMinutes": 30,
    "MaxPurchaseQuantity": 999,
    "RefreshIntervals": {
      "Daily": "00:00:00",
      "Weekly": "Monday 00:00:00",
      "Hourly": "HH:00:00"
    },
    "RateLimiting": {
      "PurchasePerMinute": 20,
      "RefreshPerHour": 10
    },
    "Monitoring": {
      "EnableMetrics": true,
      "EnableDetailedLogs": false
    }
  },
  
  "ConnectionStrings": {
    "GameDatabase": "Data Source=game.db",
    "RedisCache": "localhost:6379"
  }
}
```

#### 5.1.2 商店配置（JSON文件或数据库）

**文件**: `BlazorIdle.Server/Configuration/Shops/shops_config.json`

```json
{
  "version": "1.0",
  "shops": [
    {
      "id": "shop_general_town",
      "name": "城镇杂货铺",
      "shopType": "General",
      "refreshInterval": "Never",
      "items": [
        {
          "shopItemId": "item_bread",
          "itemType": "Consumable",
          "itemId": "consumable_bread",
          "prices": [
            { "currencyType": "Gold", "amount": 5 }
          ],
          "stockPolicy": "Infinite"
        }
      ]
    }
  ]
}
```

### 5.2 配置热更新

```csharp
public class ShopConfigReloadService : BackgroundService
{
    private readonly IOptionsMonitor<ShopSystemOptions> _options;
    private readonly IShopRepository _shopRepo;
    private readonly ILogger<ShopConfigReloadService> _logger;
    
    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        _options.OnChange(async (options, name) =>
        {
            _logger.LogInformation("Shop configuration changed, reloading...");
            await ReloadConfigurationAsync(options);
        });
        
        while (!stoppingToken.IsCancellationRequested)
        {
            await Task.Delay(TimeSpan.FromMinutes(5), stoppingToken);
        }
    }
    
    private async Task ReloadConfigurationAsync(ShopSystemOptions options)
    {
        // 重新加载商店配置
        var configPath = options.ConfigFilePath;
        var json = await File.ReadAllTextAsync(configPath);
        var config = JsonSerializer.Deserialize<ShopConfiguration>(json);
        
        // 更新到数据库
        foreach (var shopDef in config.Shops)
        {
            await _shopRepo.SaveShopDefinitionAsync(shopDef);
        }
        
        // 清除缓存
        // _cache.Clear();
        
        _logger.LogInformation("Shop configuration reloaded successfully");
    }
}
```

### 5.3 数据库备份

```bash
#!/bin/bash
# backup_shop_data.sh

DB_FILE="/app/data/game.db"
BACKUP_DIR="/app/backups"
DATE=$(date +%Y%m%d_%H%M%S)
BACKUP_FILE="$BACKUP_DIR/game_$DATE.db"

# 创建备份
sqlite3 $DB_FILE ".backup $BACKUP_FILE"

# 压缩
gzip $BACKUP_FILE

# 保留最近7天的备份
find $BACKUP_DIR -name "game_*.db.gz" -mtime +7 -delete

echo "Backup completed: $BACKUP_FILE.gz"
```

### 5.4 定时任务（商店刷新）

```csharp
using Quartz;

public class ShopRefreshJob : IJob
{
    private readonly IShopRefreshService _refreshService;
    private readonly ILogger<ShopRefreshJob> _logger;
    
    public async Task Execute(IJobExecutionContext context)
    {
        _logger.LogInformation("Starting scheduled shop refresh...");
        
        // 获取需要刷新的商店列表
        var shopsToRefresh = await GetShopsNeedingRefresh();
        
        foreach (var shopId in shopsToRefresh)
        {
            try
            {
                var result = await _refreshService.RefreshShopAsync(shopId);
                _logger.LogInformation("Shop refreshed: {ShopId}, Result={Result}", shopId, result.Message);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to refresh shop: {ShopId}", shopId);
            }
        }
        
        _logger.LogInformation("Scheduled shop refresh completed");
    }
}

// Startup.cs 配置
builder.Services.AddQuartz(q =>
{
    q.UseMicrosoftDependencyInjectionJobFactory();
    
    // 每日0点刷新
    var jobKey = new JobKey("ShopRefreshJob");
    q.AddJob<ShopRefreshJob>(opts => opts.WithIdentity(jobKey));
    q.AddTrigger(opts => opts
        .ForJob(jobKey)
        .WithIdentity("ShopRefreshTrigger")
        .WithCronSchedule("0 0 0 * * ?")); // 每天0点
});

builder.Services.AddQuartzHostedService(q => q.WaitForJobsToComplete = true);
```

---

## 6. 扩展功能设计

### 6.1 拍卖行系统（未来）

#### 6.1.1 数据模型草案

```csharp
/// <summary>
/// 拍卖物品
/// </summary>
public class AuctionItem
{
    public Guid Id { get; set; }
    public Guid SellerId { get; set; }
    public string ItemType { get; set; } // Equipment/Material/Consumable
    public string ItemId { get; set; }
    
    public long StartingBid { get; set; }
    public long BuyoutPrice { get; set; }
    public long CurrentBid { get; set; }
    public Guid? CurrentBidder { get; set; }
    
    public DateTime ListedAt { get; set; }
    public DateTime ExpiresAt { get; set; }
    public AuctionStatus Status { get; set; }
}

public enum AuctionStatus
{
    Active,
    Sold,
    Expired,
    Cancelled
}
```

#### 6.1.2 核心功能

- 上架物品（设置起拍价、一口价）
- 竞价系统（最高出价者获得）
- 自动结算（到期后自动处理）
- 搜索筛选（按类型、价格、时间）
- 手续费机制（上架费、成交费）

### 6.2 玩家间交易（未来）

#### 6.2.1 安全交易流程

```
交易流程
├── 1. 玩家A发起交易请求 → 玩家B
├── 2. 玩家B接受请求
├── 3. 双方放入物品/金币
├── 4. 双方确认
├── 5. 服务端验证
│   ├── 检查物品所有权
│   ├── 检查背包空间
│   ├── 检查交易限制（绑定物品）
│   └── 防作弊检测
├── 6. 执行交易（事务）
│   ├── 扣除物品/金币
│   ├── 发放物品/金币
│   └── 记录交易日志
└── 7. 通知双方结果
```

#### 6.2.2 防刷机制

- 交易冷却时间（每次交易后10分钟）
- 交易限额（每日最多10笔）
- 新账号限制（创建后24小时内不能交易）
- 大额交易审核（单笔>10万金币需审核）

### 6.3 黑市系统（未来）

#### 6.3.1 特性

- 随机刷新时间（2-6小时）
- 稀有物品（高价值、限量）
- 特殊货币（黑市代币）
- 风险机制（购买可能被"执法者"罚款）

---

## 7. 交付清单

### 7.1 代码交付

| 类别 | 文件/目录 | 说明 |
|-----|----------|------|
| **领域模型** | `Domain/Shop/Models/` | ShopDefinition, ShopInstance, ShopItemDefinition等 |
| **仓储接口** | `Domain/Shop/Repositories/` | IShopRepository, IPurchaseHistoryRepository |
| **应用服务** | `Application/Shop/Services/` | PurchaseService, ShopRefreshService |
| **验证器** | `Application/Shop/Validators/` | PurchaseValidator |
| **API控制器** | `Controllers/ShopController.cs` | REST API端点 |
| **前端页面** | `BlazorIdle/Pages/Shop*.razor` | ShopList, ShopDetail |
| **前端组件** | `BlazorIdle/Components/Shop*.razor` | ShopItemCard, PurchaseModal |
| **数据迁移** | `Infrastructure/Persistence/Migrations/` | EF Core迁移脚本 |
| **配置文件** | `Configuration/Shops/` | 商店JSON配置 |
| **单元测试** | `Tests/Domain/Shop/` | 领域模型测试 |
| **集成测试** | `Tests/Integration/` | API集成测试 |

### 7.2 文档交付

| 文档 | 文件名 | 说明 |
|-----|--------|------|
| **设计方案（上篇）** | `商店系统设计方案（上篇）.md` | 架构设计与核心功能 |
| **设计方案（中篇）** | `商店系统设计方案（中篇）.md` | 详细实施步骤 |
| **设计方案（下篇）** | `商店系统设计方案（下篇）.md` | 集成测试、性能优化、运维 |
| **API文档** | `API/商店系统API文档.md` | RESTful API接口说明 |
| **数据库设计** | `Database/商店系统数据库设计.md` | ER图、表结构、索引 |
| **用户手册** | `UserGuide/商店系统用户手册.md` | 玩家使用指南 |
| **运维手册** | `Operations/商店系统运维手册.md` | 部署、配置、监控 |
| **测试报告** | `Testing/商店系统测试报告.md` | 测试结果、覆盖率 |

### 7.3 配置交付

| 配置 | 文件 | 说明 |
|-----|------|------|
| **商店配置** | `shops_config.json` | 商店定义、商品配置 |
| **应用配置** | `appsettings.json` | 系统参数、连接字符串 |
| **监控配置** | `prometheus.yml` | Prometheus采集配置 |
| **日志配置** | `nlog.config` | 日志级别、输出目标 |

### 7.4 验收标准

#### 7.4.1 功能验收

- [ ] 商店列表加载正常，显示已解锁商店
- [ ] 商店详情页显示商品列表、价格、库存
- [ ] 购买功能正常，扣除货币并发放物品
- [ ] 限购机制生效（日限购、周限购）
- [ ] 库存扣减正确（有限库存商品）
- [ ] 商店刷新功能正常（定时刷新、手动刷新）
- [ ] 条件解锁生效（商店解锁、商品解锁）
- [ ] 多货币支持（金币、声望、荣誉）

#### 7.4.2 性能验收

- [ ] 商店列表加载时间 < 500ms
- [ ] 购买响应时间 < 200ms（P95）
- [ ] 支持100并发购买请求
- [ ] 缓存命中率 > 90%

#### 7.4.3 质量验收

- [ ] 单元测试覆盖率 > 80%
- [ ] 集成测试通过率 100%
- [ ] 无内存泄漏
- [ ] 无SQL注入漏洞
- [ ] 代码审查通过

---

## 8. 风险与应对

### 8.1 已识别风险

| 风险 | 概率 | 影响 | 应对措施 |
|-----|------|------|---------|
| **条件DSL实现复杂** | 中 | 高 | 先实现简单条件，复杂条件延后 |
| **并发购买冲突** | 高 | 中 | 使用乐观锁 + 重试 + 分布式锁 |
| **性能瓶颈** | 中 | 中 | 缓存 + 索引优化 + 分页加载 |
| **数据不一致** | 低 | 高 | 事务保证 + 幂等性设计 |
| **玩家刷金币** | 中 | 高 | 限频 + 异常检测 + 日志审计 |

### 8.2 未来挑战

- **经济通胀控制**：长期运营后货币贬值
- **拍卖行性能**：海量商品搜索优化
- **跨服交易**：分布式事务处理
- **作弊对抗**：外挂、脚本检测

---

## 9. 总结

本设计方案涵盖了商店系统从架构设计到实施落地的完整方案，包括：

### 9.1 核心成果

1. **完整的领域模型**：ShopAggregate、ShopItem、PurchaseLimit等
2. **灵活的价格系统**：支持多货币、折扣、动态定价
3. **强大的条件解锁**：DSL表达式、缓存优化
4. **健壮的并发控制**：乐观锁、分布式锁、幂等性保证
5. **全面的监控体系**：Prometheus指标、结构化日志
6. **安全的防刷机制**：限频、价格验证、异常检测

### 9.2 设计亮点

- ✅ **数据驱动**：商店配置化，易于扩展
- ✅ **服务端权威**：所有交易服务端验证
- ✅ **性能优化**：缓存、索引、分页
- ✅ **可监控可运维**：指标、日志、告警
- ✅ **为未来预留接口**：拍卖行、交易行、黑市

### 9.3 后续工作

- Phase 1-4实施（约4-5周）
- 集成测试与优化（1周）
- 部署上线与监控（3天）
- 迭代优化与扩展功能开发

---

**文档完成 - 商店系统设计方案全套（上中下三篇）已交付** 🎉

---

## 附录：快速参考

### A. 关键API端点

| 端点 | 方法 | 说明 |
|-----|------|------|
| `/api/shops` | GET | 获取商店列表 |
| `/api/shops/{shopId}` | GET | 获取商店详情 |
| `/api/shops/purchase` | POST | 购买商品 |
| `/api/shops/{shopId}/refresh` | POST | 手动刷新商店 |
| `/api/purchase-history` | GET | 购买历史 |

### B. 数据库表清单

- ShopDefinitions
- ShopItemDefinitions
- ShopInstance
- ShopItemStock
- PurchaseRecord
- CharacterPurchaseRecord
- ReputationRecord (新增)
- CharacterWallet (新增)
- TokenBalance (新增)

### C. 配置参数

- `ShopSystem:EnablePurchaseLimit` - 是否启用限购
- `ShopSystem:DefaultCacheMinutes` - 缓存时长
- `ShopSystem:MaxPurchaseQuantity` - 单次最大购买数量

### D. 监控指标

- `shop_purchase_total` - 购买总数
- `shop_purchase_duration_seconds` - 购买延迟
- `shop_stock_depleted_total` - 库存耗尽次数
- `shop_currency_flow_total` - 货币流通量

---

**END**
