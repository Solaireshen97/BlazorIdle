# 离线暂停/恢复功能快速参考

## 核心概念

### 三种计划状态

```csharp
// 1. 活跃状态（正在执行）
State == Running && BattleId != null

// 2. 暂停状态（已保存状态，等待恢复）
State == Running && BattleId == null && BattleStateJson != null

// 3. 完成状态（任务结束）
State == Completed && BattleStateJson == null
```

## API 使用

### 暂停任务（离线检测使用）

```csharp
// 用于离线检测，保留状态以便恢复
await _planService.PausePlanAsync(planId, ct);
```

### 恢复任务（心跳更新使用）

```csharp
// 从保存的状态恢复任务
await _planService.ResumePlanAsync(planId, ct);
```

### 停止任务（正常完成使用）

```csharp
// 正常停止任务，标记为完成
await _planService.StopPlanAsync(planId, ct);
```

## 何时使用哪个方法？

| 场景 | 方法 | 原因 |
|------|------|------|
| 离线检测 | PausePlanAsync | 需要恢复 |
| 玩家手动停止 | StopPlanAsync | 任务结束 |
| 任务达到限制 | StopPlanAsync | 任务完成 |
| 心跳恢复 | ResumePlanAsync | 继续执行 |

## 检查暂停状态

```csharp
// 查找暂停的计划
var pausedPlan = await _db.ActivityPlans
    .FirstOrDefaultAsync(p => 
        p.CharacterId == characterId 
        && p.State == ActivityState.Running
        && !p.BattleId.HasValue
        && !string.IsNullOrWhiteSpace(p.BattleStateJson));
```

## 常见模式

### 模式 1: 离线检测与暂停

```csharp
if (offlineSeconds >= threshold)
{
    // 暂停而非停止
    await _planService.PausePlanAsync(plan.Id, ct);
}
```

### 模式 2: 心跳更新与恢复

```csharp
// 更新心跳
character.LastSeenAtUtc = DateTime.UtcNow;
await _db.SaveChangesAsync(ct);

// 检查并恢复暂停的计划
var pausedPlan = await FindPausedPlan(characterId);
if (pausedPlan != null)
{
    await _planService.ResumePlanAsync(pausedPlan.Id, ct);
}
```

### 模式 3: 检查活跃计划

```csharp
var runningPlan = await _plans.GetRunningPlanAsync(characterId, ct);

// 检查是否有活跃的计划（不包括暂停的）
if (runningPlan != null && runningPlan.BattleId.HasValue)
{
    throw new InvalidOperationException("Another plan is already running");
}
```

## 配置项

```json
{
  "Offline": {
    "OfflineDetectionSeconds": 60,
    "AutoApplyRewards": true
  }
}
```

## 注意事项

### ⚠️ 不要混用

```csharp
// ❌ 错误：离线检测使用 Stop
await _planService.StopPlanAsync(plan.Id, ct);  // 任务会被标记为完成！

// ✅ 正确：离线检测使用 Pause
await _planService.PausePlanAsync(plan.Id, ct);  // 任务可以恢复
```

### ⚠️ 状态检查要完整

```csharp
// ❌ 不完整：只检查 State
if (plan.State == ActivityState.Running) { ... }

// ✅ 完整：同时检查 BattleId
if (plan.State == ActivityState.Running && plan.BattleId.HasValue) { ... }
```

## 工作流程图

```
玩家在线战斗
    ↓
检测到离线 (60秒)
    ↓
PausePlanAsync
    ├─ 保存 BattleStateJson
    ├─ 清空 BattleId
    └─ 保持 State = Running
    ↓
暂停状态（内存释放）
    ↓
玩家上线（发送心跳）
    ↓
ResumePlanAsync
    ├─ 加载 BattleStateJson
    ├─ 创建新战斗实例
    └─ 设置新 BattleId
    ↓
恢复执行（无缝衔接）
```

## 相关文件

- `ActivityPlanService.cs` - PausePlanAsync, ResumePlanAsync
- `OfflineDetectionService.cs` - 离线检测逻辑
- `CharactersController.cs` - 心跳端点，自动恢复
- `OfflinePauseResumeTests.cs` - 测试用例

## 更多信息

详见完整文档：
- [离线暂停恢复机制.md](./离线暂停恢复机制.md)
- [离线暂停问题修复总结.md](./离线暂停问题修复总结.md)
