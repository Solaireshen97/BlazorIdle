# 活动计划自动完成功能说明

## 问题描述

在之前的实现中，活动计划功能存在以下问题：

1. **任务无法自动结束**：当任务时间到达后，需要用户手动停止当前任务才能开始下一个任务
2. **任务时间无法实时显示**：前端只能在停止任务后才能获取到当前的任务执行时间

这与设计理念不符 - 停止任务应该是在服务端满足条件后自动执行的。

## 解决方案

### 1. 服务端自动检查和停止任务

通过修改 `StepBattleHostedService`，在现有的战斗推进循环中增加了活动计划进度检查：

```csharp
// 每 1 秒检查一次所有运行中的活动计划
if ((DateTime.UtcNow - lastPlanCheckAt).TotalMilliseconds >= 1000)
{
    lastPlanCheckAt = DateTime.UtcNow;
    await CheckAndUpdateActivityPlansAsync(stoppingToken);
}
```

`CheckAndUpdateActivityPlansAsync` 方法会：
- 获取所有状态为 `Running` 的活动计划
- 对每个计划调用 `UpdatePlanProgressAsync()`
- 从关联的战斗状态中更新 `ExecutedSeconds`
- 检查是否达到限制条件 `IsLimitReached()`
- 如果达到限制，自动调用 `StopPlanAsync()` 停止任务
- 自动启动下一个待执行的任务

### 2. 前端实时更新任务时间

修改 `Characters.razor` 的 `StartPlanPollingAsync` 方法：

```csharp
// 在轮询战斗状态的同时，也刷新计划列表
if (lastCreated is not null)
{
    characterPlans = await Api.GetCharacterPlansAsync(lastCreated.Id);
}
```

这样每 2 秒刷新一次计划列表，用户可以看到任务的 `ExecutedSeconds` 实时更新。

## 工作流程

```
用户创建任务 (duration=300秒)
    ↓
服务端自动启动任务
    ↓
StepBattleHostedService 每秒检查
    ↓
从战斗状态更新 ExecutedSeconds
    ↓
检查 ExecutedSeconds >= LimitValue (300)
    ↓ 是
自动停止任务
    ↓
自动启动下一个待执行任务
```

## 代码修改总结

### 服务端

1. **StepBattleHostedService.cs**
   - 添加 `IServiceScopeFactory` 依赖注入
   - 添加 `CheckAndUpdateActivityPlansAsync()` 方法
   - 在主循环中每秒调用一次该方法

2. **IActivityPlanRepository.cs & ActivityPlanRepository.cs**
   - 添加 `GetAllRunningPlansAsync()` 方法

### 前端

3. **Characters.razor**
   - 修改 `StartPlanPollingAsync()` 在轮询时同时刷新计划列表

## 测试结果

- ✅ 所有 27 个活动计划相关测试通过
- ✅ 构建成功，无新增警告
- ✅ 任务现在可以自动在达到时间限制后停止
- ✅ 前端可以实时显示任务执行时间
- ✅ 下一个任务会自动启动

## 使用示例

### 场景：创建一个 5 分钟的战斗任务

1. 用户在前端创建一个 300 秒（5 分钟）的战斗计划
2. 如果没有其他运行中的任务，该计划自动启动
3. 前端每 2 秒刷新，显示当前执行时间（如：150/300 秒）
4. 服务端每秒检查，当 ExecutedSeconds >= 300 时
5. 自动停止任务，标记为 Completed
6. 如果队列中有其他待执行任务，自动启动

### 场景：多个任务排队

1. 创建任务 A（300 秒，槽位 0）→ 自动启动
2. 创建任务 B（600 秒，槽位 1）→ 进入队列
3. 创建任务 C（180 秒，槽位 0）→ 进入队列
4. 5 分钟后，任务 A 自动完成
5. 任务 C 自动启动（槽位 0 优先级高）
6. 任务 C 完成后，任务 B 自动启动

## 技术细节

### 性能考虑

- 后台服务每秒只查询一次数据库（获取运行中的计划）
- 只更新确实在运行的计划，不会影响其他状态的计划
- 前端轮询间隔为 2 秒，不会造成服务器压力

### 错误处理

- 所有异常都被捕获并记录日志，不会影响其他任务的执行
- 如果计划更新失败，下一次检查会重试
- 前端刷新失败不会中断轮询

### 幂等性

- `UpdatePlanProgressAsync` 是幂等的，多次调用不会产生副作用
- `StopPlanAsync` 也是幂等的，只有在状态为 Running 时才会执行

## 未来扩展

可以考虑以下优化：

1. **可配置的检查间隔**：允许在配置文件中设置检查频率
2. **批量更新**：如果有大量运行中的计划，可以批量更新以提高性能
3. **推送通知**：当任务自动完成时，向前端推送通知
4. **任务完成事件**：触发域事件，供其他模块订阅（如成就系统）

## 总结

通过这次优化，活动计划系统现在能够：

- ✅ 自动检查任务完成条件
- ✅ 自动停止达到限制的任务
- ✅ 自动启动队列中的下一个任务
- ✅ 实时显示任务执行时间
- ✅ 符合"服务端权威"的设计理念

用户体验得到显著提升，无需手动管理任务生命周期。
