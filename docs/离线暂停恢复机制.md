# 离线暂停恢复机制文档

## 概述

本文档描述了离线玩家检测、任务暂停和恢复的完整机制。当玩家离线超过阈值时，系统会暂停任务并保存状态，而不是直接结束任务。玩家上线后，任务会自动恢复执行。

## 核心问题

### 之前的问题

在之前的实现中，`CheckAndPauseOfflinePlayers` 检测到玩家离线超过阈值时，会调用 `StopPlanAsync`，这会导致：

1. 任务状态被标记为 `Completed`
2. 战斗状态 (`BattleStateJson`) 被清空
3. 玩家上线后无法恢复任务
4. 离线结算后任务已经被设定为完成，无法正常重新开启

### 解决方案

引入新的暂停/恢复机制：

1. **暂停 (Pause)**：保存战斗状态，停止内存中的战斗，但保持计划在 `Running` 状态
2. **恢复 (Resume)**：从保存的战斗状态恢复任务执行

## 技术实现

### 1. PausePlanAsync - 暂停任务

**位置**: `BlazorIdle.Server/Application/Activities/ActivityPlanService.cs`

```csharp
/// <summary>
/// 暂停活动计划（用于离线检测，保留状态以便恢复）
/// </summary>
public async Task<bool> PausePlanAsync(Guid planId, CancellationToken ct = default)
```

**功能**：
- 保存当前战斗状态到 `BattleStateJson`
- 更新已执行时长 (`ExecutedSeconds`)
- 停止内存中的战斗实例
- 清空 `BattleId` 和 `StartedAt`（表示内存已清空）
- **保持计划状态为 `Running`**（关键！）
- **保留 `BattleStateJson`**（用于恢复）

### 2. ResumePlanAsync - 恢复任务

**位置**: `BlazorIdle.Server/Application/Activities/ActivityPlanService.cs`

```csharp
/// <summary>
/// 恢复暂停的活动计划
/// </summary>
public async Task<Guid> ResumePlanAsync(Guid planId, CancellationToken ct = default)
```

**功能**：
- 从 `BattleStateJson` 加载战斗状态
- 创建新的战斗实例并恢复状态
- 设置 `BattleId` 和 `StartedAt`
- 继续执行任务

### 3. 离线检测服务更新

**位置**: `BlazorIdle.Server/Services/OfflineDetectionService.cs`

**修改**：
```csharp
// 之前：
await planService.StopPlanAsync(plan.Id, ct);

// 现在：
await planService.PausePlanAsync(plan.Id, ct);
```

### 4. 心跳端点增强

**位置**: `BlazorIdle.Server/Api/CharactersController.cs`

**新增功能**：
- 更新心跳时自动检测暂停的计划
- 自动恢复暂停的计划

```csharp
// 检查是否有暂停的计划需要恢复
var runningPlan = await _db.ActivityPlans
    .FirstOrDefaultAsync(p => p.CharacterId == id 
        && p.State == ActivityState.Running
        && !p.BattleId.HasValue
        && !string.IsNullOrWhiteSpace(p.BattleStateJson));

if (runningPlan != null)
{
    await _planService.ResumePlanAsync(runningPlan.Id);
}
```

## 状态识别

### 暂停状态的计划特征

一个计划处于暂停状态，当且仅当：

1. `State == ActivityState.Running`（仍然是运行状态）
2. `BattleId == null`（内存已清空）
3. `BattleStateJson != null`（状态已保存）
4. `StartedAt == null`（标记为暂停）

### 活跃状态的计划特征

1. `State == ActivityState.Running`
2. `BattleId != null`（内存中有战斗实例）
3. `StartedAt != null`

### 完成状态的计划特征

1. `State == ActivityState.Completed`
2. `BattleStateJson == null`（状态已清空）
3. `CompletedAt != null`

## 工作流程

### 离线暂停流程

```
1. OfflineDetectionService 定期检查
   ↓
2. 发现玩家离线超过阈值 (默认60秒)
   ↓
3. 调用 PausePlanAsync
   ↓
4. 保存战斗状态到 BattleStateJson
   ↓
5. 停止内存中的战斗
   ↓
6. 清空 BattleId 和 StartedAt
   ↓
7. 保持 State = Running
```

### 上线恢复流程

```
1. 玩家发送心跳请求
   ↓
2. 更新 LastSeenAtUtc
   ↓
3. 检查是否有暂停的计划
   ↓
4. 调用 ResumePlanAsync
   ↓
5. 从 BattleStateJson 恢复战斗状态
   ↓
6. 创建新的战斗实例
   ↓
7. 设置 BattleId 和 StartedAt
   ↓
8. 继续执行任务
```

### 离线结算流程

```
1. 玩家上线发送心跳
   ↓
2. 检测离线时间超过阈值
   ↓
3. 调用 CheckAndSettleAsync
   ↓
4. 使用 OfflineFastForwardEngine 快进模拟
   ↓
5. 计算收益并更新计划状态
   ↓
6. 如果计划完成，标记为 Completed
   ↓
7. 如果未完成，保持 Running 状态
   ↓
8. 尝试启动下一个待执行任务（如果计划完成）
```

## API 端点

### 更新心跳

```http
POST /api/characters/{id}/heartbeat
```

**响应**：
```json
{
  "message": "心跳更新成功",
  "timestamp": "2024-01-01T12:00:00Z",
  "offlineSettlement": {
    "hasOfflineTime": true,
    "offlineSeconds": 120,
    "hasRunningPlan": true,
    "settlement": { ... }
  },
  "planResumed": true
}
```

## 配置选项

### appsettings.json

```json
{
  "Offline": {
    "OfflineDetectionSeconds": 60,
    "AutoApplyRewards": true
  }
}
```

- `OfflineDetectionSeconds`: 离线检测阈值（秒）
- `AutoApplyRewards`: 是否自动应用离线收益

## 与 StopPlanAsync 的区别

| 特性 | PausePlanAsync | StopPlanAsync |
|------|---------------|---------------|
| 计划状态 | 保持 `Running` | 标记为 `Completed` |
| BattleStateJson | 保留 | 清空 |
| BattleId | 清空 | 清空 |
| StartedAt | 清空 | 保留 |
| CompletedAt | 不设置 | 设置为当前时间 |
| 可恢复 | ✅ 是 | ❌ 否 |
| 自动启动下一个任务 | ❌ 否 | ✅ 是 |

## 测试验证

### 测试用例

参见 `tests/BlazorIdle.Tests/OfflinePauseResumeTests.cs`：

1. `PausedPlan_ShouldKeepRunningState` - 验证暂停后保持运行状态
2. `PausedPlan_ShouldNotBeCompleted` - 验证暂停后不标记为完成
3. `ResumedPlan_ShouldHaveBattleIdAndStartedAt` - 验证恢复后设置正确
4. `OfflineDetection_ShouldPauseNotStop` - 验证离线检测使用暂停而非停止
5. `PausedPlan_IdentifiedByStateAndBattleId` - 验证暂停状态识别

## 注意事项

1. **暂停不等于停止**：暂停保留所有状态，停止则完成任务
2. **自动恢复**：玩家上线后任务自动恢复，无需手动操作
3. **状态完整性**：必须同时检查 `State`、`BattleId` 和 `BattleStateJson` 来判断计划状态
4. **离线结算优先**：如果玩家离线期间任务完成，会执行离线结算而不是恢复

## 检查其他离线问题

### 已检查的方面

1. ✅ **离线检测服务**：已更新为使用 `PausePlanAsync` 而非 `StopPlanAsync`
2. ✅ **心跳端点**：已添加自动恢复逻辑
3. ✅ **离线结算**：`CheckAndSettleAsync` 正确处理暂停计划
4. ✅ **计划状态管理**：正确区分活跃、暂停和完成状态
5. ✅ **Repository 方法**：`GetRunningPlanAsync` 包含暂停计划（符合预期）
6. ✅ **启动检查**：`StartPlanAsync` 和 `ResumePlanAsync` 正确检查是否有活跃计划

### 潜在改进点

虽然当前实现已经修复了主要问题，但以下是一些可能的改进方向：

1. **添加恢复失败重试机制**：如果恢复失败，可以考虑添加重试逻辑
2. **暂停时间记录**：可以记录计划暂停的时间，用于监控和统计
3. **暂停原因标记**：可以添加字段标记暂停原因（离线检测、手动暂停等）
4. **恢复通知**：可以在恢复时发送通知给前端

## 相关文档

- [活动计划自动执行功能](./activity-plan-auto-execution.md)
- [离线战斗系统实施总结](./离线战斗系统实施总结.md)
- [OfflineFastForwardEngine实施文档](./OfflineFastForwardEngine实施文档.md)

## 更新历史

- 2024-01-XX: 初始版本，修复离线检测问题
  - 添加 PausePlanAsync 和 ResumePlanAsync 方法
  - 更新离线检测服务使用暂停机制
  - 心跳端点添加自动恢复功能
  - 完善测试覆盖率
