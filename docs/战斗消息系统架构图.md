# 战斗消息系统架构图

**版本**: 1.0  
**日期**: 2025-10-14  
**状态**: ✅ 已完成

---

## 📐 系统架构概览

```
┌─────────────────────────────────────────────────────────────────┐
│                        战斗消息系统                              │
└─────────────────────────────────────────────────────────────────┘

┌──────────────────┐      ┌──────────────────┐      ┌──────────────────┐
│  配置文件层      │      │   服务层         │      │   战斗逻辑层     │
│                  │      │                  │      │                  │
│  appsettings     │─────▶│ BattleMessage    │◀─────│  BattleEngine    │
│  .json           │      │ Formatter        │      │                  │
│                  │      │                  │      │  AttackTickEvent │
│  BattleMessages  │      │                  │      │  DamageCalculator│
│  {                      │                  │      │  EnemyAttackEvent│
│   templates...   │      │                  │      │                  │
│  }               │      │                  │      │                  │
└──────────────────┘      └──────────────────┘      └──────────────────┘
                                   │                          │
                                   │                          │
                                   ▼                          ▼
                          ┌──────────────────┐      ┌──────────────────┐
                          │  事件DTO层       │      │  SignalR通知层   │
                          │                  │      │                  │
                          │ AttackStarted    │      │ BattleNotification│
                          │ DamageApplied    │─────▶│ Service          │
                          │ DamageReceived   │      │                  │
                          │                  │      │                  │
                          └──────────────────┘      └──────────────────┘
                                                              │
                                                              │
                                                              ▼
                                                     ┌──────────────────┐
                                                     │   前端(Blazor)   │
                                                     │                  │
                                                     │  战斗日志显示    │
                                                     │  血量条更新      │
                                                     │  动画触发        │
                                                     │                  │
                                                     └──────────────────┘
```

---

## 🔄 消息流程图

### 玩家攻击敌人流程

```
1. 玩家发起攻击
   │
   ▼
2. AttackTickEvent 触发
   │
   ├─▶ BattleMessageFormatter.FormatAttackStarted()
   │   │
   │   ▼
   │   AttackStartedEventDto {
   │     AttackerName: "玩家"
   │     TargetName: "史莱姆"
   │     Message: "玩家 开始攻击 史莱姆"
   │   }
   │   │
   │   ▼
   └─▶ NotificationService.NotifyEventAsync()
       │
       ▼
3. SignalR Hub 广播
   │
   ▼
4. 前端接收并显示
   "玩家 开始攻击 史莱姆"
```

### 造成伤害流程

```
1. 伤害计算
   │
   ▼
2. DamageCalculator.ApplyDamage()
   │
   ├─▶ BattleMessageFormatter.FormatDamageDealt()
   │   │
   │   ▼
   │   DamageAppliedEventDto {
   │     AttackerName: "玩家"
   │     TargetName: "哥布林"
   │     Damage: 150
   │     IsCrit: true
   │     Message: "玩家 对 哥布林 造成 150 点伤害（暴击）"
   │   }
   │   │
   │   ▼
   └─▶ NotificationService.NotifyEventAsync()
       │
       ▼
3. SignalR Hub 广播
   │
   ▼
4. 前端接收并显示
   "玩家 对 哥布林 造成 150 点伤害（暴击）"
```

---

## 📦 核心组件说明

### 1. 配置层 (Configuration Layer)

**文件**: `appsettings.json`

```json
{
  "BattleMessages": {
    "AttackStartedTemplate": "{attacker} 开始攻击 {target}",
    "DamageDealtTemplate": "{attacker} 对 {target} 造成 {damage} 点伤害{critSuffix}",
    "CritSuffix": "（暴击）",
    "DamageReceivedTemplate": "{target} 受到来自 {attacker} 的 {damage} 点伤害",
    "EnemyAttackStartedTemplate": "{attacker} 开始攻击 {target}",
    "EnableAttackStartedEvent": true,
    "EnableDamageDealtEvent": true,
    "EnableDamageReceivedEvent": true,
    "EnableEnemyAttackStartedEvent": true,
    "PlayerName": "玩家",
    "MaxMessageHistory": 100
  }
}
```

**职责**:
- 存储所有消息模板
- 控制事件开关
- 支持运行时配置更新

---

### 2. 配置模型 (Configuration Model)

**文件**: `BattleMessageOptions.cs`

```csharp
public sealed class BattleMessageOptions
{
    public const string SectionName = "BattleMessages";
    
    public string AttackStartedTemplate { get; set; }
    public string DamageDealtTemplate { get; set; }
    public string CritSuffix { get; set; }
    public string DamageReceivedTemplate { get; set; }
    public string EnemyAttackStartedTemplate { get; set; }
    
    public bool EnableAttackStartedEvent { get; set; }
    public bool EnableDamageDealtEvent { get; set; }
    public bool EnableDamageReceivedEvent { get; set; }
    public bool EnableEnemyAttackStartedEvent { get; set; }
    
    public string PlayerName { get; set; }
    public int MaxMessageHistory { get; set; }
}
```

**职责**:
- 强类型配置模型
- 提供默认值
- 支持依赖注入

---

### 3. 消息格式化器 (Message Formatter)

**文件**: `BattleMessageFormatter.cs`

```csharp
public sealed class BattleMessageFormatter
{
    private readonly BattleMessageOptions _options;
    
    public string FormatAttackStarted(string attacker, string target)
    {
        return _options.AttackStartedTemplate
            .Replace("{attacker}", attacker)
            .Replace("{target}", target);
    }
    
    public string FormatDamageDealt(string attacker, string target, 
                                   int damage, bool isCrit)
    {
        var critSuffix = isCrit ? _options.CritSuffix : "";
        return _options.DamageDealtTemplate
            .Replace("{attacker}", attacker)
            .Replace("{target}", target)
            .Replace("{damage}", damage.ToString())
            .Replace("{critSuffix}", critSuffix);
    }
    
    // ... 其他格式化方法
}
```

**职责**:
- 根据模板生成消息
- 替换占位符
- 检查事件开关状态

---

### 4. 事件DTO (Event Data Transfer Objects)

**文件**: `BattleNotifications.cs`

```csharp
// 攻击开始事件
public sealed class AttackStartedEventDto : BattleEventDto
{
    public string AttackerName { get; set; }
    public string TargetName { get; set; }
    public string Message { get; set; }
}

// 造成伤害事件
public sealed class DamageAppliedEventDto : BattleEventDto
{
    public string Source { get; set; }
    public int Damage { get; set; }
    public bool IsCrit { get; set; }
    public int TargetCurrentHp { get; set; }
    public int TargetMaxHp { get; set; }
    public string AttackerName { get; set; }
    public string TargetName { get; set; }
    public string Message { get; set; }
}

// 受到伤害事件
public sealed class DamageReceivedEventDto : BattleEventDto
{
    public string AttackerName { get; set; }
    public string TargetName { get; set; }
    public int Damage { get; set; }
    public int TargetCurrentHp { get; set; }
    public int TargetMaxHp { get; set; }
    public string Message { get; set; }
}
```

**职责**:
- 传输事件数据
- 包含格式化的消息
- 支持序列化到SignalR

---

### 5. 战斗逻辑集成点

#### AttackTickEvent.cs

```csharp
if (formatter?.IsAttackStartedEnabled == true)
{
    var message = formatter.FormatAttackStarted(
        attacker.Name, 
        enemy.Name
    );
    
    await notificationService.NotifyEventAsync(
        ctx.BattleId,
        new AttackStartedEventDto
        {
            BattleId = ctx.BattleId,
            EventTime = ctx.Clock.Now,
            EventType = "AttackStarted",
            AttackerName = attacker.Name,
            TargetName = enemy.Name,
            Message = message
        }
    );
}
```

#### DamageCalculator.cs

```csharp
if (formatter?.IsDamageDealtEnabled == true)
{
    var message = formatter.FormatDamageDealt(
        attackerName,
        targetName,
        finalDamage,
        result.IsCrit
    );
    
    await notificationService.NotifyEventAsync(
        battleId,
        new DamageAppliedEventDto
        {
            BattleId = battleId,
            EventTime = currentTime,
            EventType = "DamageApplied",
            Source = source,
            Damage = finalDamage,
            IsCrit = result.IsCrit,
            TargetCurrentHp = target.CurrentHp,
            TargetMaxHp = target.MaxHp,
            AttackerName = attackerName,
            TargetName = targetName,
            Message = message
        }
    );
}
```

---

## 🔧 依赖注入配置

**文件**: `Program.cs`

```csharp
// 注册配置
builder.Services.Configure<BattleMessageOptions>(
    builder.Configuration.GetSection(BattleMessageOptions.SectionName)
);

// 注册服务
builder.Services.AddSingleton<BattleMessageFormatter>();
```

---

## 🎯 前端集成示例

```csharp
@inject BattleSignalRService SignalRService

protected override async Task OnInitializedAsync()
{
    SignalRService.OnBattleEvent((battleId, eventData) =>
    {
        if (eventData is AttackStartedEventDto attack)
        {
            AddBattleLog(attack.Message);
        }
        else if (eventData is DamageAppliedEventDto damage)
        {
            AddBattleLog(damage.Message);
            UpdateEnemyHealth(damage.TargetCurrentHp, damage.TargetMaxHp);
        }
        else if (eventData is DamageReceivedEventDto received)
        {
            AddBattleLog(received.Message);
            UpdatePlayerHealth(received.TargetCurrentHp, received.TargetMaxHp);
        }
    });
}

private void AddBattleLog(string message)
{
    _battleLog.Add($"[{DateTime.Now:HH:mm:ss}] {message}");
    if (_battleLog.Count > 50)
    {
        _battleLog.RemoveAt(0);
    }
    StateHasChanged();
}
```

---

## 📊 数据流图

```
┌─────────────┐
│ 战斗事件    │
│ (游戏逻辑)  │
└──────┬──────┘
       │
       ▼
┌─────────────────────┐
│ MessageFormatter    │
│ - 读取配置          │
│ - 检查开关          │
│ - 生成消息          │
└──────┬──────────────┘
       │
       ▼
┌─────────────────────┐
│ EventDto            │
│ - 结构化数据        │
│ - 包含消息          │
└──────┬──────────────┘
       │
       ▼
┌─────────────────────┐
│ NotificationService │
│ - 序列化            │
│ - SignalR发送       │
└──────┬──────────────┘
       │
       ▼
┌─────────────────────┐
│ SignalR Hub         │
│ - 广播到连接        │
└──────┬──────────────┘
       │
       ▼
┌─────────────────────┐
│ 前端接收器          │
│ - 反序列化          │
│ - 显示消息          │
│ - 更新UI            │
└─────────────────────┘
```

---

## 🧪 测试架构

### 单元测试层

```
BattleMessageTests.cs
├─ FormatAttackStarted_ReplacesPlaceholders
├─ FormatDamageDealt_WithoutCrit_ReplacesPlaceholders
├─ FormatDamageDealt_WithCrit_IncludesCritSuffix
├─ FormatDamageReceived_ReplacesPlaceholders
├─ IsAttackStartedEnabled_ReturnsConfigValue
├─ GetPlayerName_ReturnsConfigValue
├─ AttackStartedEventDto_HasRequiredProperties
├─ DamageAppliedEventDto_HasExtendedProperties
└─ DamageReceivedEventDto_HasRequiredProperties
```

### 集成测试层

```
BattleMessageIntegrationTests.cs
├─ BattleEngine_WithMessageFormatter_SendsAttackStartedEvent
├─ BattleEngine_WithMessageFormatter_SendsDamageAppliedEvent
├─ BattleEngine_WithEnemyAttack_SendsDamageReceivedEvent
└─ BattleEngine_WithDisabledEvents_DoesNotSendMessages
```

---

## 🚀 扩展流程

### 添加新事件类型的步骤

```
1. 配置层
   └─ BattleMessageOptions.cs
      └─ 添加新模板属性和开关

2. 服务层
   └─ BattleMessageFormatter.cs
      └─ 添加新的格式化方法

3. DTO层
   └─ BattleNotifications.cs
      └─ 创建新的EventDto类

4. 战斗逻辑层
   └─ 相关战斗事件文件
      └─ 触发新事件通知

5. 配置文件
   └─ appsettings.json
      └─ 添加新配置项

6. 测试层
   ├─ BattleMessageTests.cs (单元测试)
   └─ BattleMessageIntegrationTests.cs (集成测试)
```

---

## 📈 性能考虑

### 异步处理

```csharp
// 事件通知是异步的，不阻塞战斗逻辑
await notificationService.NotifyEventAsync(battleId, eventDto);
```

### 可选节流

```json
{
  "SignalR": {
    "Performance": {
      "EnableThrottling": true,
      "ThrottleWindowMs": 1000
    }
  }
}
```

### 条件触发

```csharp
// 只有配置启用时才触发
if (formatter?.IsAttackStartedEnabled == true)
{
    // 发送事件
}
```

---

## 📝 总结

战斗消息系统通过以下架构实现了需求：

1. **配置化** - 所有消息模板在配置文件中
2. **解耦** - 消息生成与战斗逻辑分离
3. **可扩展** - 易于添加新事件类型
4. **可测试** - 完整的测试覆盖
5. **高性能** - 异步通知，可选节流
6. **类型安全** - 强类型DTO和配置模型

系统已准备好投入生产使用！✅
