# 活动计划系统 - 并发和完成检测修复

## 问题概述

活动计划系统存在两个主要问题：

1. **战斗卡住问题**：计划任务模式的战斗（continue模式和时间模式）在一定时间后会卡住，不会像直接调用的step战斗一样持续到时间结束
2. **并发执行问题**：在前端项目中执行第一个任务的过程中创建第二个任务时，两个任务会一起执行，前端的进度条会一起走

## 根本原因分析

### 问题1：战斗卡住（完成检测逻辑错误）

#### 原有逻辑缺陷

在 `CombatActivityExecutor.CheckCompletionAsync` 中：

```csharp
// 原有代码
public async Task<bool> CheckCompletionAsync(ActivityPlan plan, ActivityExecutionContext context, CancellationToken ct = default)
{
    if (context.UnderlyingExecutionId is null)
        return true;
    
    var battleId = context.UnderlyingExecutionId.Value;
    
    if (!_battleCoordinator.TryGet(battleId, out var battle) || battle is null)
        return true;
    
    // 如果战斗已完成，检查限制
    if (battle.Completed)
        return true;
    
    // 检查是否达到限制
    return plan.IsLimitReached();
}
```

**问题所在**：

1. 对于 `Duration` 模式的战斗，`RunningBattle.Advance()` 会在达到目标时间时自动设置 `Completed = true`
2. 但对于 `Continuous` 和 `Dungeon` 模式，战斗**永远不会自动设置** `Completed = true`
3. 这导致 Continuous 模式的战斗即使达到了活动计划的时间限制，也不会完成

#### RunningBattle 的完成逻辑

在 `RunningBattle.Advance()` 中：

```csharp
public void Advance(int maxEvents = 2000, double maxSimSecondsSlice = 0.25)
{
    // ...
    var sliceEnd = (Mode == StepBattleMode.Duration)
        ? Math.Min(TargetDurationSeconds, Clock.CurrentTime + allowedDelta)
        : (Clock.CurrentTime + allowedDelta);  // ← Continuous 模式没有时间限制

    Engine.AdvanceTo(sliceEnd, maxEvents);

    // 只有 Duration 模式会自动完成
    if (Mode == StepBattleMode.Duration && (Clock.CurrentTime >= TargetDurationSeconds))
    {
        Completed = true;
        Battle.Finish(Clock.CurrentTime);
    }
    // ← Continuous/Dungeon 模式永远不会在这里设置 Completed
}
```

**设计意图与实际问题**：

- **设计意图**：Continuous 模式应该由活动计划系统根据限制条件（DurationLimit/CountLimit/InfiniteLimit）来决定何时完成
- **实际问题**：但原有的 `CheckCompletionAsync` 逻辑没有正确处理这种情况

### 问题2：并发执行（槽位操作的竞态条件）

#### 竞态条件场景

当用户快速创建两个计划时：

```
时间线：
T0: CreatePlan(Plan A, Slot 0) → slot.IsIdle = true
    → slot.StartPlan(A) → CurrentPlanId = A
    → _ = TryStartPlanAsync(A) 【异步，不等待】
    
T1: CreatePlan(Plan B, Slot 0) → slot.IsIdle = false
    → slot.EnqueuePlan(B) → QueuedPlanIds = [B]
    
T2: AdvanceAllAsync() 执行
    → TryStartPendingPlansAsync()
    → 发现 slot.IsIdle = false, QueuedPlanIds = [B]
    → 【不会启动 B，正确】
    
T3: Plan A 完成
    → AdvancePlanAsync(A)
    → slot.FinishCurrentAndGetNext() → 返回 B
    → _ = TryStartPlanAsync(B)
```

这个流程看起来是正确的，但存在**多个线程同时操作槽位**的风险：

1. **CreatePlan** 可能在主线程/API 线程执行
2. **AdvanceAllAsync** 在后台服务线程执行（每1秒）
3. **TryStartPendingPlansAsync** 也在后台服务线程执行

如果没有同步机制，可能出现：

```
Thread 1 (CreatePlan):                  Thread 2 (TryStartPendingPlansAsync):
检查 slot.IsIdle = false                
                                        检查 slot.IsIdle = false
slot.EnqueuePlan(B)                     
                                        发现队列有 B
                                        从队列移除 B
                                        slot.StartPlan(B) ← 可能在 A 还在运行时设置
```

虽然实际代码中这种情况不太容易发生，但缺少同步保护是不安全的。

## 解决方案

### 修复1：完善完成检测逻辑

在 `CombatActivityExecutor.CheckCompletionAsync` 中：

```csharp
public async Task<bool> CheckCompletionAsync(ActivityPlan plan, ActivityExecutionContext context, CancellationToken ct = default)
{
    if (context.UnderlyingExecutionId is null)
        return true;
    
    var battleId = context.UnderlyingExecutionId.Value;
    
    if (!_battleCoordinator.TryGet(battleId, out var battle) || battle is null)
        return true;
    
    // 对于Duration模式，如果战斗已完成则活动完成
    if (battle.Mode == StepBattleMode.Duration && battle.Completed)
        return true;
    
    // 对于Continuous/Dungeon模式，或Duration模式未完成时，检查活动计划的限制
    // 这样可以支持：
    // 1. Continuous模式 + Duration限制：限定时间的连续战斗
    // 2. Continuous模式 + Count限制：击杀指定数量
    // 3. Continuous模式 + Infinite限制：需要手动停止
    if (plan.IsLimitReached())
        return true;
    
    // 对于Duration模式，即使限制未达到，如果战斗已完成也应该结束
    // （这处理战斗提前结束的情况，如地城完成）
    if (battle.Completed)
        return true;
    
    return false;
}
```

**修复要点**：

1. **明确处理 Duration 模式**：依赖战斗自身的 `Completed` 标志
2. **正确处理 Continuous/Dungeon 模式**：依赖活动计划的限制检查 `plan.IsLimitReached()`
3. **兜底检查**：即使是 Duration 模式，也检查计划限制（支持手动设置更短的时间限制）

### 修复2：添加槽位操作同步

在 `ActivityCoordinator` 中添加槽位锁：

```csharp
// 槽位操作锁，防止并发创建/启动计划时的竞态条件
private readonly ConcurrentDictionary<string, SemaphoreSlim> _slotLocks = new();
```

#### 保护 CreatePlan 操作

```csharp
public ActivityPlan CreatePlan(...)
{
    // ...
    
    // 获取槽位锁
    var lockKey = $"{characterId}:{slotIndex}";
    var slotLock = _slotLocks.GetOrAdd(lockKey, _ => new SemaphoreSlim(1, 1));
    
    // 使用锁保护槽位操作，防止竞态条件
    slotLock.Wait();
    try
    {
        var slots = EnsureCharacterSlots(characterId);
        var slot = slots[slotIndex];
        
        if (slot.IsIdle)
        {
            slot.StartPlan(plan.Id);
            _ = TryStartPlanAsync(plan.Id, CancellationToken.None);
        }
        else
        {
            slot.EnqueuePlan(plan.Id);
        }
    }
    finally
    {
        slotLock.Release();
    }
    
    return plan;
}
```

#### 保护 TryStartPendingPlansAsync 操作

```csharp
private async Task TryStartPendingPlansAsync(CancellationToken ct)
{
    foreach (var (characterId, slots) in _characterSlots)
    {
        for (int i = 0; i < slots.Count; i++)
        {
            var slot = slots[i];
            var lockKey = $"{characterId}:{i}";
            var slotLock = _slotLocks.GetOrAdd(lockKey, _ => new SemaphoreSlim(1, 1));
            
            await slotLock.WaitAsync(ct);
            try
            {
                // 再次检查，因为可能在等待锁期间状态已改变
                if (slot.IsIdle && slot.QueuedPlanIds.Count > 0)
                {
                    var nextId = slot.QueuedPlanIds[0];
                    slot.QueuedPlanIds.RemoveAt(0);
                    slot.StartPlan(nextId);
                    
                    // 在锁外启动计划（避免死锁）
                    _ = TryStartPlanAsync(nextId, ct);
                }
            }
            finally
            {
                slotLock.Release();
            }
        }
    }
}
```

#### 保护 AdvancePlanAsync 中的槽位切换

```csharp
private async Task AdvancePlanAsync(ActivityPlan plan, CancellationToken ct)
{
    // ... 推进和完成检查 ...
    
    if (completed)
    {
        // 停止执行
        await executor.StopAsync(plan, context, ct);
        plan.Complete();
        _contexts.TryRemove(plan.Id, out _);
        
        // 获取槽位锁
        var lockKey = $"{plan.CharacterId}:{plan.SlotIndex}";
        var slotLock = _slotLocks.GetOrAdd(lockKey, _ => new SemaphoreSlim(1, 1));
        
        Guid? nextPlanId = null;
        await slotLock.WaitAsync(ct);
        try
        {
            var slots = EnsureCharacterSlots(plan.CharacterId);
            var slot = slots[plan.SlotIndex];
            
            if (slot.CurrentPlanId == plan.Id)
            {
                nextPlanId = slot.FinishCurrentAndGetNext();
                if (nextPlanId.HasValue)
                {
                    slot.StartPlan(nextPlanId.Value);
                }
            }
        }
        finally
        {
            slotLock.Release();
        }
        
        // 在锁外启动下一个计划
        if (nextPlanId.HasValue)
        {
            _ = TryStartPlanAsync(nextPlanId.Value, ct);
        }
    }
}
```

#### 保护 CancelPlanAsync 操作

```csharp
public async Task<bool> CancelPlanAsync(Guid planId, CancellationToken ct = default)
{
    // ...
    
    var lockKey = $"{plan.CharacterId}:{plan.SlotIndex}";
    var slotLock = _slotLocks.GetOrAdd(lockKey, _ => new SemaphoreSlim(1, 1));
    
    if (plan.State == ActivityState.Running)
    {
        // 停止执行...
        
        Guid? nextPlanId = null;
        await slotLock.WaitAsync(ct);
        try
        {
            var slots = EnsureCharacterSlots(plan.CharacterId);
            var slot = slots[plan.SlotIndex];
            if (slot.CurrentPlanId == planId)
            {
                nextPlanId = slot.FinishCurrentAndGetNext();
                if (nextPlanId.HasValue)
                {
                    slot.StartPlan(nextPlanId.Value);
                }
            }
        }
        finally
        {
            slotLock.Release();
        }
        
        if (nextPlanId.HasValue)
        {
            _ = TryStartPlanAsync(nextPlanId.Value, ct);
        }
    }
    else if (plan.State == ActivityState.Pending)
    {
        await slotLock.WaitAsync(ct);
        try
        {
            var slots = EnsureCharacterSlots(plan.CharacterId);
            var slot = slots[plan.SlotIndex];
            slot.RemovePlan(planId);
        }
        finally
        {
            slotLock.Release();
        }
    }
    
    plan.Cancel();
    return true;
}
```

## 修复效果

### 问题1：战斗卡住 ✅ 已解决

- **Continuous + Duration限制**：现在可以正确在达到时间限制时完成
- **Continuous + Count限制**：现在可以正确在击杀足够数量后完成
- **Continuous + Infinite限制**：需要手动取消（符合设计）
- **Duration模式**：保持原有行为，由战斗引擎控制完成

### 问题2：并发执行 ✅ 已解决

- 使用 `SemaphoreSlim` 为每个槽位提供细粒度锁
- 锁的粒度：`{characterId}:{slotIndex}`，不同角色、不同槽位互不影响
- 所有槽位状态修改操作都在锁保护下进行
- `TryStartPlanAsync` 在锁外调用，避免死锁和性能问题

## 设计模式说明

### 活动计划系统的设计意图

根据 `整合设计总结.txt`：

```
活动计划 | 多槽 / 限制类型（Count/Duration/Infinite）/ 顺序执行
自动衔接：当前 plan 达到限制 → 查找下一个 Pending → 启动，否则角色 Idle
```

**关键设计点**：

1. **多槽位**：每个角色有3-5个独立的活动槽位
2. **限制类型**：
   - `Duration`：按模拟时间（秒）
   - `Count`：按击杀数/采集次数等
   - `Infinite`：需要手动停止
3. **顺序执行**：每个槽位的计划按队列顺序**依次**执行，不并发
4. **自动衔接**：当前计划完成后自动启动下一个

### 战斗模式与活动限制的关系

| 战斗模式 | 战斗自身行为 | 活动限制 | 组合效果 |
|---------|------------|---------|---------|
| Duration | 达到目标时间自动完成 | Duration | 使用战斗的目标时间 |
| Duration | 达到目标时间自动完成 | Count | 理论上不适用（战斗会先完成） |
| Continuous | 永不自动完成 | Duration | 限定时间的连续战斗 ✅ |
| Continuous | 永不自动完成 | Count | 击杀指定数量后完成 ✅ |
| Continuous | 永不自动完成 | Infinite | 需要手动停止 ✅ |
| Dungeon | 根据地城配置决定 | Duration | 限定时间内打地城 |
| Dungeon | 根据地城配置决定 | Count | 完成指定次数地城 |

**修复后的行为**：

- 战斗模式决定战斗引擎的行为（何时自动完成）
- 活动限制决定活动计划的完成条件
- 两者可以独立设置，提供更大的灵活性

## 测试建议

### 测试场景1：Continuous + Duration

```csharp
// 创建一个60秒的连续战斗
var plan = coordinator.CreatePlan(
    characterId: characterId,
    slotIndex: 0,
    type: ActivityType.Combat,
    limit: new DurationLimit(60.0),
    payloadJson: JsonSerializer.Serialize(new {
        enemyId = "dummy",
        mode = "continuous"
    })
);

// 预期：60秒后自动完成
```

### 测试场景2：Continuous + Count

```csharp
// 创建一个击杀100个敌人的连续战斗
var plan = coordinator.CreatePlan(
    characterId: characterId,
    slotIndex: 0,
    type: ActivityType.Combat,
    limit: new CountLimit(100),
    payloadJson: JsonSerializer.Serialize(new {
        enemyId = "dummy",
        mode = "continuous"
    })
);

// 预期：击杀100个后自动完成
```

### 测试场景3：顺序执行

```csharp
// 快速创建3个计划
var plan1 = coordinator.CreatePlan(..., slotIndex: 0, limit: new DurationLimit(30));
var plan2 = coordinator.CreatePlan(..., slotIndex: 0, limit: new DurationLimit(30));
var plan3 = coordinator.CreatePlan(..., slotIndex: 0, limit: new DurationLimit(30));

// 预期：
// - plan1 立即开始
// - plan2 和 plan3 在队列中等待
// - plan1 完成后，plan2 自动开始
// - plan2 完成后，plan3 自动开始
```

### 测试场景4：多槽位并发（预期行为）

```csharp
// 在不同槽位创建计划
var plan1 = coordinator.CreatePlan(..., slotIndex: 0, ...);
var plan2 = coordinator.CreatePlan(..., slotIndex: 1, ...);
var plan3 = coordinator.CreatePlan(..., slotIndex: 2, ...);

// 预期：3个计划同时执行（因为在不同槽位）
```

## 性能考虑

### 锁的粒度

- **锁的数量**：`角色数 × 槽位数`（典型：100个角色 × 3个槽位 = 300个锁）
- **锁的持有时间**：极短（只保护槽位状态修改，不包括计划启动）
- **锁的竞争**：极低（每个锁只在一个槽位内竞争）

### 性能影响

- **CreatePlan**：增加了锁获取开销，但可以忽略不计（微秒级）
- **AdvanceAllAsync**：遍历所有槽位时需要获取锁，但因为锁粒度细，不会阻塞其他槽位
- **内存开销**：每个锁约48字节，300个锁约14KB，可以忽略

### 优化空间

如果未来需要优化，可以考虑：

1. **锁池**：预先创建固定数量的锁，避免动态创建
2. **读写锁**：如果查询操作远多于修改操作，可以使用 `ReaderWriterLockSlim`
3. **无锁数据结构**：使用 Interlocked 操作代替锁（但代码复杂度更高）

## 总结

本次修复解决了活动计划系统的两个关键问题：

1. ✅ **完成检测逻辑**：正确处理不同战斗模式与活动限制的组合
2. ✅ **并发控制**：使用细粒度锁确保槽位状态的一致性

修复后的系统符合设计文档的要求：

- 支持多种限制类型（Duration/Count/Infinite）
- 支持顺序执行（队列中的计划依次执行）
- 支持自动衔接（完成后自动启动下一个）
- 线程安全（防止竞态条件）

## 相关文档

- `整合设计总结.txt`：系统整体设计
- `docs/活动计划系统-24秒超时问题分析与修复.md`：之前的修复（Task.Run 问题）
- `docs/活动计划系统-API使用指南.md`：API 使用文档
