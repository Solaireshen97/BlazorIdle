# BlazorIdle 开发规范

**文档版本**: 1.0  
**创建日期**: 2025-10-15  
**维护者**: 开发团队  
**状态**: Phase 9 开发文档

---

## 📋 目录

1. [代码风格](#代码风格)
2. [命名约定](#命名约定)
3. [注释规范](#注释规范)
4. [项目结构规范](#项目结构规范)
5. [配置化规范](#配置化规范)
6. [测试规范](#测试规范)
7. [Git 提交规范](#git-提交规范)
8. [Code Review 清单](#code-review-清单)

---

## 代码风格

### C# 代码风格

遵循 [C# 编码约定](https://docs.microsoft.com/zh-cn/dotnet/csharp/fundamentals/coding-style/coding-conventions)。

#### 基本规则

- **缩进**: 4 个空格（不使用 Tab）
- **大括号**: 始终使用大括号，即使只有一行代码
- **行宽**: 建议不超过 120 字符
- **文件编码**: UTF-8 with BOM
- **换行符**: LF (Unix 风格)

#### 示例

```csharp
// ✅ 推荐
public class CharacterService
{
    private readonly ICharacterRepository _repository;
    
    public CharacterService(ICharacterRepository repository)
    {
        _repository = repository ?? throw new ArgumentNullException(nameof(repository));
    }
    
    public async Task<Character> GetCharacterAsync(Guid characterId)
    {
        if (characterId == Guid.Empty)
        {
            throw new ArgumentException("角色ID不能为空", nameof(characterId));
        }
        
        return await _repository.GetByIdAsync(characterId);
    }
}

// ❌ 避免
public class CharacterService{
private ICharacterRepository _repo;
public CharacterService(ICharacterRepository repo){_repo=repo;}
public async Task<Character> GetCharacter(Guid id){return await _repo.GetByIdAsync(id);}
}
```

### 空格和空行

#### 空格使用

```csharp
// ✅ 推荐
if (condition) { }
for (int i = 0; i < count; i++) { }
var result = Calculate(a, b, c);
var value = array[index];

// ❌ 避免
if(condition){}
for(int i=0;i<count;i++){}
var result = Calculate(a,b,c);
var value = array[ index ];
```

#### 空行使用

```csharp
// ✅ 推荐
public class Example
{
    // 字段之间无空行
    private readonly IService _service;
    private readonly ILogger _logger;
    
    // 构造函数前有空行
    public Example(IService service, ILogger logger)
    {
        _service = service;
        _logger = logger;
    }
    
    // 方法之间有空行
    public void Method1()
    {
        // 逻辑分组之间有空行
        var data = PrepareData();
        
        ProcessData(data);
        
        SaveData(data);
    }
    
    public void Method2()
    {
        // ...
    }
}
```

---

## 命名约定

### 通用规则

| 类型 | 命名规则 | 示例 |
|-----|---------|------|
| 命名空间 | PascalCase | `BlazorIdle.Domain.Combat` |
| 类 | PascalCase | `CharacterService` |
| 接口 | I + PascalCase | `ICharacterRepository` |
| 方法 | PascalCase | `GetCharacterAsync` |
| 属性 | PascalCase | `CharacterId` |
| 字段（私有） | _camelCase | `_repository` |
| 字段（常量） | PascalCase | `MaxRetryCount` |
| 参数 | camelCase | `characterId` |
| 局部变量 | camelCase | `character` |
| 异步方法 | 后缀Async | `SaveCharacterAsync` |

### 详细规范

#### 1. 类命名

```csharp
// ✅ 推荐 - 名词或名词短语
public class Character { }
public class BattleEngine { }
public class DamageCalculator { }
public class CharacterService { }

// ❌ 避免 - 动词或模糊名称
public class ProcessData { }
public class Helper { }
public class Manager { }
public class Utils { }
```

#### 2. 接口命名

```csharp
// ✅ 推荐 - I 前缀 + 能力描述
public interface ICharacterRepository { }
public interface IDamageCalculator { }
public interface IEventScheduler { }

// ❌ 避免
public interface CharacterRepo { }  // 缺少 I 前缀
public interface IHelper { }        // 名称太模糊
```

#### 3. 方法命名

```csharp
// ✅ 推荐 - 动词或动词短语
public void SaveCharacter() { }
public Character GetCharacter() { }
public bool ValidateEquipment() { }
public async Task<Character> LoadCharacterAsync() { }

// ❌ 避免
public void Character() { }          // 名词
public void DoIt() { }               // 不明确
public void get_character() { }      // 错误的命名风格
public async Task<Character> LoadCharacter() { }  // 异步方法缺少 Async 后缀
```

#### 4. 属性命名

```csharp
// ✅ 推荐
public Guid CharacterId { get; set; }
public string Name { get; set; }
public int MaxHealth { get; set; }
public bool IsAlive { get; set; }
public bool CanAttack { get; set; }

// ❌ 避免
public Guid characterId { get; set; }     // 应该是 PascalCase
public string name_ { get; set; }          // 不使用下划线后缀
public int m_maxHealth { get; set; }       // 不使用匈牙利命名法
```

#### 5. 字段命名

```csharp
// ✅ 推荐
private readonly ICharacterRepository _repository;
private readonly ILogger<CharacterService> _logger;
private int _retryCount;

private const int MaxRetryCount = 3;
private static readonly TimeSpan DefaultTimeout = TimeSpan.FromSeconds(30);

// ❌ 避免
private ICharacterRepository repository;           // 私有字段应有下划线前缀
private ILogger<CharacterService> m_logger;       // 不使用匈牙利命名法
private int RetryCount;                           // 私有字段不应该 PascalCase
```

#### 6. 配置类命名

```csharp
// ✅ 推荐 - Options 后缀
public class CombatEngineOptions { }
public class ShopOptions { }
public class EquipmentSystemOptions { }

// ❌ 避免
public class CombatEngineConfig { }    // 使用 Options 而非 Config
public class CombatEngineSettings { }  // 使用 Options 而非 Settings
```

**规范**: 根据 Phase 8 确立的约定，配置类统一使用 `Options` 后缀。

---

## 注释规范

### XML 文档注释

所有公共 API 必须有 XML 文档注释。

#### 类注释

```csharp
/// <summary>
/// 战斗引擎 - 核心战斗循环处理器
/// </summary>
/// <remarks>
/// 职责：
/// 1. 驱动事件调度器推进战斗时间
/// 2. 处理攻击、技能、Buff等战斗事件
/// 3. 管理敌人生成和波次切换
/// </remarks>
public sealed class BattleEngine
{
    // ...
}
```

#### 方法注释

```csharp
/// <summary>
/// 推进战斗到指定时间点
/// </summary>
/// <param name="targetTime">目标时间（秒）</param>
/// <returns>是否战斗结束</returns>
/// <exception cref="InvalidOperationException">当战斗已结束时抛出</exception>
public bool AdvanceTo(double targetTime)
{
    // ...
}
```

#### 属性注释

```csharp
/// <summary>
/// 远未来时间戳，用于标记未激活的事件
/// </summary>
public double FarFutureTimestamp { get; set; } = 1e10;

/// <summary>
/// 技能检查间隔（秒），控制敌人技能触发检查频率
/// </summary>
public double SkillCheckIntervalSeconds { get; set; } = 0.5;
```

### 代码内注释

#### 算法注释

```csharp
public double CalculateArmorReduction(double armor, int attackerLevel)
{
    // 护甲减伤公式: Armor / (Armor + C + K * Level)
    // C = 常量 (默认 400)
    // K = 系数 (默认 50)
    // 该公式确保护甲收益递减，防止无限堆叠
    
    var denominator = armor + _options.DamageReduction.ConstantC + 
                     _options.DamageReduction.CoefficientK * attackerLevel;
    
    var reduction = armor / denominator;
    
    // 限制最大减伤率为 75%
    return Math.Min(reduction, _options.ArmorCalculation.MaxArmorReduction);
}
```

#### 步骤注释

```csharp
public async Task ProcessBattleAsync(Guid characterId)
{
    // 1. 验证参数
    if (characterId == Guid.Empty)
        throw new ArgumentException("角色ID不能为空", nameof(characterId));
    
    // 2. 加载角色数据
    var character = await _repository.GetByIdAsync(characterId);
    if (character == null)
        throw new InvalidOperationException("角色不存在");
    
    // 3. 初始化战斗引擎
    var battle = _battleFactory.CreateBattle(character);
    
    // 4. 执行战斗循环
    while (!battle.IsCompleted)
    {
        battle.AdvanceTo(battle.CurrentTime + 1.0);
    }
    
    // 5. 发放奖励
    await _rewardService.GrantRewardsAsync(characterId, battle.Rewards);
}
```

#### TODO 注释

```csharp
// TODO: 实现装备套装效果计算
// TODO: 优化大规模战斗的性能 - 预计 Phase 11
// FIXME: 修复暴击率计算精度问题
// NOTE: 此处逻辑与客户端同步，修改时需同步更新
```

### 注释原则

✅ **应该注释**:
- 复杂的业务逻辑
- 特殊的算法实现
- 非显而易见的设计决策
- 临时解决方案和待优化项
- 与其他模块的交互说明

❌ **不应注释**:
- 显而易见的代码（如 `// 创建对象`）
- 重复代码的内容（如方法名已说明的内容）
- 过时的注释（修改代码时务必更新注释）

---

## 项目结构规范

### 目录组织

```
BlazorIdle.Server/
├── Api/                          # API 控制器
│   └── [Name]Controller.cs
├── Application/                  # 应用层服务
│   ├── [Feature]/
│   │   ├── [Name]Service.cs
│   │   └── I[Name]Service.cs
│   └── Abstractions/
├── Domain/                       # 领域层
│   ├── [Aggregate]/
│   │   ├── [Entity].cs
│   │   ├── [ValueObject].cs
│   │   └── Services/
│   │       └── [DomainService].cs
├── Infrastructure/               # 基础设施层
│   ├── Configuration/            # 配置选项类
│   │   └── [Feature]Options.cs
│   ├── DependencyInjection/
│   │   └── DependencyInjection.cs
│   ├── Persistence/
│   │   ├── Configurations/
│   │   │   └── [Entity]Configuration.cs
│   │   └── Repositories/
│   │       └── [Entity]Repository.cs
│   └── Startup/
├── Hubs/                         # SignalR Hubs
│   └── [Name]Hub.cs
└── Config/                       # 配置文件目录
    └── [Feature]/
        └── [ConfigFile].json
```

### 文件组织规则

1. **一个文件一个类**: 每个文件只包含一个主要类
2. **文件名与类名一致**: `CharacterService.cs` → `class CharacterService`
3. **相关文件放在同一目录**: 如 `Character.cs` 和 `CharacterConfiguration.cs`
4. **使用命名空间对应目录结构**: `BlazorIdle.Domain.Combat` → `Domain/Combat/`

---

## 配置化规范

### Phase 8 确立的配置化原则

基于 Phase 8 的成功实践，制定以下配置化规范：

#### 1. 配置类命名

```csharp
// ✅ 推荐 - Options 后缀
public class CombatEngineOptions { }
public class EquipmentSystemOptions { }

// ❌ 避免
public class CombatEngineConfig { }
public class CombatEngineSettings { }
```

#### 2. 配置类结构

```csharp
/// <summary>
/// 战斗引擎配置选项
/// </summary>
public class CombatEngineOptions
{
    /// <summary>
    /// 远未来时间戳，用于标记未激活的事件
    /// </summary>
    public double FarFutureTimestamp { get; set; } = 1e10;
    
    /// <summary>
    /// 技能检查间隔（秒）
    /// </summary>
    public double SkillCheckIntervalSeconds { get; set; } = 0.5;
    
    /// <summary>
    /// 伤害减免参数
    /// </summary>
    public DamageReductionOptions DamageReduction { get; set; } = new();
}

/// <summary>
/// 伤害减免配置选项
/// </summary>
public class DamageReductionOptions
{
    /// <summary>
    /// 伤害减免系数K
    /// </summary>
    public double CoefficientK { get; set; } = 50.0;
    
    /// <summary>
    /// 伤害减免常量C
    /// </summary>
    public double ConstantC { get; set; } = 400.0;
}
```

**规范要点**:
- 所有属性都有 XML 注释
- 提供合理的默认值
- 使用驼峰命名法（PascalCase）
- 嵌套配置使用独立的 Options 类

#### 3. 配置注册

```csharp
// Infrastructure/DependencyInjection/DependencyInjection.cs
public static IServiceCollection AddCombatEngine(
    this IServiceCollection services,
    IConfiguration configuration)
{
    // 注册配置
    services.Configure<CombatEngineOptions>(
        configuration.GetSection("CombatEngine"));
    
    // 注册服务
    services.AddScoped<IBattleEngine, BattleEngine>();
    
    return services;
}
```

#### 4. 配置使用

```csharp
public class BattleEngine
{
    private readonly CombatEngineOptions _options;
    
    public BattleEngine(IOptions<CombatEngineOptions> options)
    {
        _options = options.Value;
    }
    
    public void Initialize()
    {
        // 使用配置值
        var farFuture = _options.FarFutureTimestamp;
        var interval = _options.SkillCheckIntervalSeconds;
    }
}
```

#### 5. 配置文件

```json
{
  "CombatEngine": {
    "FarFutureTimestamp": 1e10,
    "SkillCheckIntervalSeconds": 0.5,
    "BuffTickIntervalSeconds": 1.0,
    "BaseAttackDamage": 10,
    "DefaultAttackerLevel": 50,
    "DamageReduction": {
      "CoefficientK": 50.0,
      "ConstantC": 400.0
    }
  }
}
```

**配置文件规范**:
- 使用驼峰命名（PascalCase）
- 保持结构清晰，适当嵌套
- 添加注释说明（开发环境）
- 敏感信息使用环境变量

#### 6. 避免硬编码

```csharp
// ❌ 避免 - 硬编码
private const double FAR_FUTURE = 1e10;
private const double SKILL_CHECK_INTERVAL = 0.5;

// ✅ 推荐 - 使用配置
private readonly CombatEngineOptions _options;

public void Method()
{
    var farFuture = _options.FarFutureTimestamp;
    var interval = _options.SkillCheckIntervalSeconds;
}
```

**Phase 8 成果**: 16个硬编码常量已全部迁移到配置文件 ✅

### 何时需要配置化

需要配置化的参数：
- ✅ 数值平衡参数（伤害系数、冷却时间等）
- ✅ 系统行为开关（启用/禁用某功能）
- ✅ 性能调优参数（缓存时长、批处理大小等）
- ✅ 环境相关参数（数据库连接、API 端点等）
- ✅ 业务规则参数（购买限制、刷新间隔等）

不需要配置化的参数：
- ❌ 常量定义（如枚举值、固定字符串）
- ❌ 算法内部临时变量
- ❌ 框架要求的魔法值

---

## 测试规范

### 测试命名

```csharp
// ✅ 推荐 - [MethodName]_[Scenario]_[ExpectedBehavior]
[Fact]
public void CalculateDamage_WithHighArmor_ReducesDamageCorrectly()
{
    // Arrange
    var calculator = new DamageCalculator(_options);
    var armor = 1000;
    
    // Act
    var reduction = calculator.CalculateArmorReduction(armor, 50);
    
    // Assert
    Assert.InRange(reduction, 0.0, 0.75);
}

[Fact]
public void GetCharacter_WithInvalidId_ThrowsArgumentException()
{
    // Arrange
    var service = new CharacterService(_repository);
    
    // Act & Assert
    Assert.ThrowsAsync<ArgumentException>(() => 
        service.GetCharacterAsync(Guid.Empty));
}
```

### 测试结构

使用 **AAA 模式** (Arrange-Act-Assert):

```csharp
[Fact]
public void ExampleTest()
{
    // Arrange - 准备测试数据和对象
    var service = new CharacterService(_repository);
    var characterId = Guid.NewGuid();
    
    // Act - 执行被测试的方法
    var result = service.GetCharacter(characterId);
    
    // Assert - 验证结果
    Assert.NotNull(result);
    Assert.Equal(characterId, result.Id);
}
```

### 测试覆盖

- **单元测试**: 覆盖核心业务逻辑
- **集成测试**: 覆盖模块间交互
- **回归测试**: 防止已修复的bug再次出现

**目标**: 保持 330+ 测试全部通过 ✅

---

## Git 提交规范

### 提交消息格式

```
<type>(<scope>): <subject>

<body>

<footer>
```

### Type 类型

| 类型 | 说明 |
|-----|------|
| feat | 新功能 |
| fix | Bug修复 |
| docs | 文档更新 |
| style | 代码格式（不影响功能） |
| refactor | 重构（不改变功能） |
| test | 测试相关 |
| chore | 构建/工具链更新 |
| perf | 性能优化 |

### 示例

```
feat(combat): 添加战斗引擎配置化支持

- 创建 CombatEngineOptions 配置类
- 迁移 7 个硬编码常量到配置文件
- 更新 BattleEngine 使用配置注入
- 添加配置验证和默认值

Phase 8 - 战斗引擎配置化
```

```
fix(equipment): 修复护甲减伤计算精度问题

护甲减伤公式在极端值时出现精度问题，调整为使用
double 类型并限制最大减伤率。

Fixes #123
```

```
docs(phase9): 添加开发文档 - 架构概览和配置指南

Phase 9 开发文档编写
```

### 提交原则

- ✅ 每次提交专注于一个问题
- ✅ 提交消息清晰描述变更内容
- ✅ 包含相关的 Issue 编号
- ✅ 大功能分多次小提交
- ❌ 避免"WIP"、"fix"等模糊消息
- ❌ 避免一次提交包含多个不相关的变更

---

## Code Review 清单

### 功能性

- [ ] 代码实现了需求的功能
- [ ] 边界条件和错误情况都已处理
- [ ] 没有引入新的 Bug
- [ ] 已有测试全部通过
- [ ] 新增功能有对应的测试

### 代码质量

- [ ] 代码清晰易读
- [ ] 命名符合规范
- [ ] 没有重复代码
- [ ] 没有过长的方法（建议 < 50 行）
- [ ] 没有过深的嵌套（建议 < 4 层）
- [ ] 合理使用设计模式

### 注释和文档

- [ ] 公共 API 有 XML 文档注释
- [ ] 复杂逻辑有必要的代码注释
- [ ] 注释准确且最新
- [ ] 相关文档已更新

### 配置化 (Phase 8+)

- [ ] 没有新的硬编码常量
- [ ] 配置类使用 Options 后缀
- [ ] 配置有合理的默认值
- [ ] 配置在 appsettings.json 中定义
- [ ] 配置参数有文档说明

### 性能

- [ ] 没有明显的性能问题
- [ ] 数据库查询已优化
- [ ] 避免不必要的计算和分配
- [ ] 异步方法正确使用

### 安全性

- [ ] 输入验证充分
- [ ] 没有 SQL 注入风险
- [ ] 敏感信息没有硬编码
- [ ] 权限检查正确

### 可维护性

- [ ] 代码符合项目风格
- [ ] 依赖注入使用正确
- [ ] 错误处理适当
- [ ] 日志记录充分

---

## 最佳实践总结

### 核心原则

1. **零功能改动** - 代码优化不改变业务逻辑
2. **维持代码风格** - 遵循现有命名和组织规范
3. **渐进式推进** - 小步快跑，分阶段验收
4. **完善文档** - 代码即文档，文档保持更新
5. **测试优先** - 修改前测试通过，修改后测试通过
6. **配置化优先** - 避免硬编码，使用配置文件

### Phase 8 经验总结

✅ **成功实践**:
- Options 后缀命名统一且清晰
- 配置类提供默认值，向后兼容
- 驼峰命名法（PascalCase）易于理解
- Infrastructure/Configuration 目录组织清晰
- 每阶段测试，确保功能不变

✅ **可复用模式**:
- 配置类 + Options 模式
- 依赖注入 + IOptions\<T>
- 嵌套配置结构
- XML 文档注释
- 单元测试覆盖

---

## 相关文档

- [01-架构概览.md](./01-架构概览.md) - 系统架构设计
- [07-配置指南.md](./07-配置指南.md) - 配置参数说明
- `docs/服务端代码优化方案.md` - 整体优化方案
- `服务端代码优化Phase8完成总结.md` - Phase 8 最佳实践

---

**文档维护**:  
本文档作为 Phase 9 开发文档的一部分，应随项目演进持续更新。团队成员应遵循本规范，并在实践中不断完善。
