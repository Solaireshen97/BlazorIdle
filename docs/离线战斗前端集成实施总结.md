# 离线战斗前端集成实施总结

## 📋 概述

本文档总结离线战斗功能的前端集成实施（Step 4），基于已完成的后端实现（Steps 1-3）。

### 实施目标
- ✅ 实现离线战斗的前端展示和交互
- ✅ 集成心跳机制到现有的计划轮询循环
- ✅ 实现无感的离线继承效果
- ✅ 保持代码风格一致，最小化修改

---

## 🔧 实施内容

### 1. API 客户端扩展

**文件**: `BlazorIdle/Services/ApiClient.cs`

新增三个 API 方法：

```csharp
/// <summary>检查离线收益（不发放）</summary>
public Task<OfflineCheckResult?> CheckOfflineAsync(Guid characterId, CancellationToken ct = default)

/// <summary>应用离线结算，实际发放收益</summary>
public async Task ApplyOfflineSettlementAsync(Guid characterId, OfflineFastForwardResult settlement, CancellationToken ct = default)

/// <summary>更新心跳时间（记录玩家在线）</summary>
public async Task UpdateHeartbeatAsync(Guid characterId, CancellationToken ct = default)
```

**调用的后端 API**：
- `GET /api/offline/check?characterId={id}` - 检查离线收益
- `POST /api/offline/apply` - 应用离线结算
- `POST /api/characters/{id}/heartbeat` - 更新心跳

---

### 2. 前端数据模型

**文件**: `BlazorIdle/Services/ApiModels.cs`

新增三个 DTO 类型：

```csharp
/// <summary>离线快进结果</summary>
public sealed class OfflineFastForwardResult
{
    public Guid CharacterId { get; init; }
    public Guid PlanId { get; init; }
    public double SimulatedSeconds { get; init; }      // 实际模拟时长
    public bool PlanCompleted { get; init; }           // 计划是否完成
    public long TotalDamage { get; init; }
    public int TotalKills { get; init; }
    public long Gold { get; init; }                    // 金币收益
    public long Exp { get; init; }                     // 经验收益
    public Dictionary<string, double> LootExpected { get; init; }
    public Dictionary<string, int> LootSampled { get; init; }
    public double UpdatedExecutedSeconds { get; init; } // 更新后的已执行时长
    public string DropMode { get; init; } = "expected";
}

/// <summary>离线检查结果（用于登录时自动检测）</summary>
public sealed class OfflineCheckResult
{
    public bool HasOfflineTime { get; init; }
    public double OfflineSeconds { get; init; }
    public bool HasRunningPlan { get; init; }
    public OfflineFastForwardResult? Settlement { get; init; }
    public bool PlanCompleted { get; init; }
    public bool NextPlanStarted { get; init; }
    public Guid? NextPlanId { get; init; }
}

/// <summary>应用离线结算请求</summary>
public sealed class ApplySettlementRequest
{
    public Guid CharacterId { get; set; }
    public OfflineFastForwardResult Settlement { get; set; }
}
```

---

### 3. Characters 页面集成

**文件**: `BlazorIdle/Pages/Characters.razor`

#### 3.1 状态管理

新增状态变量：
```csharp
private bool showOfflineDialog = false;
private OfflineCheckResult? offlineCheckResult;
```

#### 3.2 登录时检查离线收益

在 `LoadUserDataAsync` 方法中添加：
```csharp
// 检查离线收益
await CheckOfflineRewardsAsync(selectedCharacter.Id);
```

#### 3.3 离线检查方法

```csharp
async Task CheckOfflineRewardsAsync(Guid characterId)
{
    try
    {
        var result = await Api.CheckOfflineAsync(characterId);
        if (result is not null && result.HasOfflineTime && result.HasRunningPlan)
        {
            offlineCheckResult = result;
            showOfflineDialog = true;
            await RefreshPlansAsync();
        }
    }
    catch (Exception ex)
    {
        userMessage = $"检查离线收益失败: {ex.Message}";
    }
}
```

#### 3.4 应用离线结算

```csharp
async Task ApplyOfflineSettlement()
{
    if (offlineCheckResult?.Settlement is null || lastCreated is null)
        return;

    try
    {
        isBusy = true;
        await Api.ApplyOfflineSettlementAsync(lastCreated.Id, offlineCheckResult.Settlement);
        
        // 刷新角色数据和计划列表
        await LoadUserDataAsync();
        await RefreshPlansAsync();
        
        // 关闭弹窗
        showOfflineDialog = false;
        offlineCheckResult = null;
        
        userMessage = "离线收益已领取！";
    }
    catch (Exception ex)
    {
        planError = $"领取离线收益失败: {ex.Message}";
    }
    finally
    {
        isBusy = false;
    }
}
```

#### 3.5 心跳集成到计划轮询

在 `StartPlanPollingAsync` 方法中添加心跳更新：
```csharp
// 同时刷新计划列表以获取最新的ExecutedSeconds并更新心跳
if (lastCreated is not null)
{
    characterPlans = await Api.GetCharacterPlansAsync(lastCreated.Id);
    
    // 更新心跳（每次刷新计划时更新，实现无感心跳）
    try
    {
        await Api.UpdateHeartbeatAsync(lastCreated.Id, _planPollCts.Token);
    }
    catch (Exception) { /* 心跳更新失败不影响主流程 */ }
}
```

**设计说明**：
- 心跳更新集成在现有的 2 秒轮询循环中
- 避免添加额外的定时器，保持代码简洁
- 心跳失败不影响主流程

#### 3.6 离线结算弹窗 UI

```razor
@if (showOfflineDialog && offlineCheckResult is not null)
{
    <div class="modal" style="display: block; background: rgba(0,0,0,0.5);">
        <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">🎉 欢迎回来！离线收益结算</h5>
                    <button type="button" class="btn-close" @onclick="CloseOfflineDialog"></button>
                </div>
                <div class="modal-body">
                    <!-- 离线时长显示 -->
                    <div class="alert alert-info">
                        <strong>离线时长：</strong> X 小时 Y 分钟
                    </div>
                    
                    <!-- 收益统计 -->
                    <div class="card">
                        <h6>收益统计</h6>
                        <div>💰 金币: +XXX</div>
                        <div>⭐ 经验: +XXX</div>
                        <div>⚔️ 总伤害: XXX</div>
                        <div>💀 击杀数: XXX</div>
                    </div>

                    <!-- 掉落物品（如果有）-->
                    
                    <!-- 计划状态提示 -->
                </div>
                <div class="modal-footer">
                    <button class="btn btn-secondary" @onclick="CloseOfflineDialog">稍后</button>
                    <button class="btn btn-primary" @onclick="ApplyOfflineSettlement">确认领取</button>
                </div>
            </div>
        </div>
    </div>
}
```

**UI 特点**：
- 使用 Bootstrap Modal 样式
- 显示离线时长、收益统计、掉落物品
- 显示计划完成状态和自动衔接提示
- 用户可以选择"稍后"或"确认领取"

---

## 🧪 单元测试

**文件**: `tests/BlazorIdle.Tests/OfflineFrontendIntegrationTests.cs`

创建了 7 个单元测试用例，全部通过：

### 测试覆盖

1. **OfflineCheck_WithNoOfflineTime_ShouldReturnNoRewards**
   - 测试刚上线（无离线时间）的场景
   - 验证离线时长 < 1 秒

2. **OfflineCheck_WithRunningPlan_ShouldReturnSettlement**
   - 测试有运行计划且离线 1 小时的场景
   - 验证返回结算数据，ExecutedSeconds 正确更新

3. **OfflineCheck_PlanCompletedDuringOffline_ShouldMarkAsCompleted**
   - 测试计划在离线期间完成的场景
   - 验证计划状态变为 Completed

4. **OfflineCheck_SeamlessInheritance_ShouldContinueFromMidBattle**
   - **关键测试**：验证无感继承效果
   - 计划打到一半（15分钟）进入离线
   - 离线30分钟后上线
   - 验证从15分钟的进度继续计算，总共45分钟

5. **OfflineCheck_MaxCapSeconds_ShouldLimitTo12Hours**
   - 测试 12 小时离线时长上限
   - 离线24小时，但只计算12小时

6. **HeartbeatUpdate_ShouldUpdateLastSeenTime**
   - 测试心跳更新功能
   - 验证 LastSeenAtUtc 正确更新

7. **OfflineSettlement_WithRewards_ShouldHavePositiveValues**
   - 测试离线收益非负
   - 验证金币、经验、伤害数值合理

### 测试结果

```
✅ Passed!  - Failed: 0, Passed: 7, Skipped: 0, Total: 7
```

---

## 🎯 关键设计决策

### 1. 无感继承实现

**后端保证**：
- `OfflineFastForwardEngine.FastForward()` 从 `plan.ExecutedSeconds` 继续计算
- 不会重新开始，而是基于当前进度快进

**前端配合**：
- 直接调用 API，信任后端的无感继承逻辑
- 不需要额外的状态保存或恢复

### 2. 心跳更新策略

**集成到现有轮询**：
- 利用 `StartPlanPollingAsync` 每 2 秒的刷新循环
- 在刷新计划列表时同步更新心跳
- 避免创建新的定时器

**容错设计**：
- 心跳更新失败不影响主流程
- 使用 try-catch 捕获异常

### 3. 用户体验设计

**弹窗展示**：
- 登录时自动检查，有离线收益则弹窗
- 用户可以选择"稍后"或"确认领取"
- 确认后才发放收益，避免误操作

**信息展示**：
- 清晰显示离线时长（小时+分钟）
- 展示收益明细（金币、经验、伤害、击杀）
- 提示计划状态（完成、继续中、自动衔接）

### 4. 代码风格一致性

**遵循现有模式**：
- 命名风格与现有代码一致
- 使用相同的错误处理方式
- 复用现有的 UI 组件和样式

**最小化修改**：
- 只修改必要的文件
- 不改变现有功能的行为
- 保持代码结构清晰

---

## 📊 实施效果

### 功能完整性

✅ **核心功能**：
- 离线检查自动触发
- 收益展示清晰完整
- 心跳更新无感集成
- 无感继承效果正确

✅ **边界条件**：
- 无离线时间不弹窗
- 12小时上限正确限制
- 计划完成自动衔接
- 错误处理健壮

### 代码质量

✅ **编译状态**：
- 无编译错误
- 仅 3 个已存在的警告（非本次修改引入）

✅ **测试覆盖**：
- 7 个单元测试全部通过
- 覆盖核心场景和边界情况
- 验证无感继承效果

✅ **代码风格**：
- 与现有代码一致
- 注释清晰完整
- 命名规范统一

### 性能影响

✅ **最小性能开销**：
- 心跳更新集成到现有轮询，无额外定时器
- API 调用仅在必要时触发
- 离线检查仅在登录时执行一次

---

## 🔄 完整流程示例

### 场景：用户离线 1 小时，计划未完成

#### 1. 初始状态
- 角色在线，运行一个 3 小时战斗计划
- 已执行 30 分钟 (ExecutedSeconds = 1800)
- LastSeenAtUtc = 2025-01-08 10:00:00

#### 2. 用户下线
- 关闭浏览器
- LastSeenAtUtc 保持不变

#### 3. 1 小时后用户上线
- 浏览器加载 Characters 页面
- `LoadUserDataAsync` 调用 `CheckOfflineRewardsAsync`
- 前端调用 `GET /api/offline/check?characterId=xxx`

#### 4. 后端处理
```
1. 计算离线时长 = Now(11:00) - LastSeen(10:00) = 3600秒
2. 查找运行计划
3. 快进模拟 3600 秒（从 1800 秒的进度继续）
4. 更新 ExecutedSeconds = 1800 + 3600 = 5400 秒
5. 判断：5400 < 10800（3小时），未完成
6. 计算收益
7. 返回 OfflineCheckResult
```

#### 5. 前端展示
```
弹窗显示:
  离线时长: 1小时0分钟
  💰 金币: +2000
  ⭐ 经验: +3000
  ⚔️ 总伤害: 150000
  💀 击杀数: 60
  
  ⏳ 活动计划继续进行中...
  
  [稍后] [确认领取]
```

#### 6. 用户点击"确认领取"
- 前端调用 `POST /api/offline/apply`
- 后端更新 Character.Gold += 2000
- 后端更新 Character.Experience += 3000
- 刷新角色数据和计划列表
- 战斗计划继续运行（剩余 1.5 小时）

#### 7. 计划轮询（每2秒）
- 刷新战斗状态
- 刷新计划列表（看到 ExecutedSeconds 实时更新）
- 更新心跳（LastSeenAtUtc = Now）

---

## 📝 后续工作

### 可选改进

1. **UI/UX 优化**
   - 添加动画效果
   - 改进离线收益的视觉展示
   - 添加音效提示

2. **功能扩展**
   - 离线历史记录查询
   - 离线收益统计报表
   - 多角色离线收益汇总

3. **性能优化**
   - 心跳批量更新（如果有多个角色）
   - 离线检查结果缓存

### 已完成验证

- ✅ 单元测试全部通过
- ✅ 无感继承效果验证
- ✅ 心跳更新机制验证
- ✅ 代码风格一致性检查

### 待验证

- [ ] 浏览器端完整流程测试
- [ ] 多角色切换场景测试
- [ ] 长时间离线（接近12小时）测试
- [ ] 网络异常时的容错测试

---

## 🎓 技术要点总结

1. **最小化修改原则**
   - 仅修改 3 个核心文件
   - 复用现有架构和组件
   - 不破坏现有功能

2. **无感继承设计**
   - 后端从 ExecutedSeconds 继续计算
   - 前端无需特殊处理
   - 用户体验流畅自然

3. **心跳集成策略**
   - 利用现有轮询循环
   - 避免额外定时器
   - 容错性好

4. **测试驱动开发**
   - 先写测试再实现
   - 7 个测试全部通过
   - 覆盖核心场景

5. **代码质量保证**
   - 风格一致
   - 注释完整
   - 易于维护

---

## 📚 相关文档

- [离线战斗系统实施总结](./离线战斗系统实施总结.md) - 完整系统设计
- [OfflineFastForwardEngine实施文档](./OfflineFastForwardEngine实施文档.md) - 快进引擎实现
- [活动计划自动完成功能说明](../活动计划自动完成功能说明.md) - 计划系统说明
- [整合设计总结](../整合设计总结.txt) - 项目整体设计

---

**文档结束**

*最后更新: 2025-01-08*
*作者: GitHub Copilot with Solaireshen97*
