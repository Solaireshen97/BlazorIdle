# 活动计划系统 - 快速开始指南

## 简介

本指南将帮助你快速了解和使用活动计划系统。

## ✨ 新特性：自动执行

**活动计划现在支持自动执行！**

- 创建计划时，如果角色没有运行中的任务，会**自动启动**
- 任务完成后，会**自动启动**下一个队列中的任务
- 你只需要创建计划，系统会自动处理任务的执行和队列管理

详细了解请查看 [自动执行文档](./activity-plan-auto-execution.md)

## 5分钟快速上手

### 步骤 1：创建一个战斗计划

使用 Postman、curl 或其他 HTTP 客户端：

```bash
POST http://localhost:5000/api/activity-plans/combat?characterId=你的角色ID&limitType=duration&limitValue=600&enemyId=dummy
```

参数说明：
- `characterId`: 你的角色ID（从角色创建或查询接口获取）
- `limitType=duration`: 使用时长限制模式
- `limitValue=600`: 战斗持续10分钟（600秒）
- `enemyId=dummy`: 对抗dummy敌人

返回结果示例：
```json
{
  "id": "abc123...",
  "characterId": "xyz789...",
  "type": 1,
  "state": 1,
  "limitType": 1,
  "limitValue": 600,
  "slotIndex": 0,
  "executedSeconds": 0,
  "createdAt": "2024-10-07T12:00:00Z",
  "payloadJson": "{\"EnemyId\":\"dummy\",\"EnemyCount\":1}",
  "battleId": "def456..."
}
```

**🎉 新特性：自动执行！** 
如果你的角色当前没有运行中的任务，新创建的计划会**自动启动**（`state=1` 表示 Running）！你不再需要手动调用 `/start` 接口。

记住返回的 `id` 和 `battleId` 值。

### 步骤 2：查看战斗状态

```bash
GET http://localhost:5000/api/battles/step/def456.../status
```

返回结果包含：
- 模拟时长
- 造成的总伤害
- DPS（每秒伤害）
- 击杀次数
- 获得的金币和经验

### 步骤 3：停止计划（可选）

如果你想在计划自动完成前停止它：

```bash
POST http://localhost:5000/api/activity-plans/abc123.../stop
```

**💡 提示：** 当一个计划停止后，如果队列中还有待执行的计划，系统会**自动启动**下一个计划！

### 步骤 4：查看计划结果

```bash
GET http://localhost:5000/api/activity-plans/abc123...
```

查看 `state`、`executedSeconds`、`completedAt` 等字段了解计划执行情况。

## 常用场景

### 场景 1：无限时长的挂机战斗

想要一直战斗直到手动停止？

```bash
# 创建无限计划（自动启动）
POST http://localhost:5000/api/activity-plans/combat?characterId=xxx&limitType=infinite&enemyId=orc

# ... 战斗会立即开始并一直持续 ...

# 想停止时调用
POST http://localhost:5000/api/activity-plans/{planId}/stop
```

### 场景 2：挑战地下城

```bash
# 创建地下城计划（2小时，循环模式，自动启动）
POST http://localhost:5000/api/activity-plans/dungeon?characterId=xxx&limitType=duration&limitValue=7200&dungeonId=intro_cave&loop=true

# 战斗会立即开始，2小时后自动完成
```

### 场景 3：任务队列 - 连续执行多个任务

```bash
# 创建第一个任务（自动启动）
POST http://localhost:5000/api/activity-plans/combat?characterId=xxx&limitType=duration&limitValue=600&enemyId=goblin

# 创建第二个任务（进入队列）
POST http://localhost:5000/api/activity-plans/combat?characterId=xxx&limitType=duration&limitValue=600&enemyId=orc

# 创建第三个任务（进入队列）
POST http://localhost:5000/api/activity-plans/dungeon?characterId=xxx&limitType=duration&limitValue=1200&dungeonId=intro_cave

# 任务会按顺序自动执行：goblin → orc → intro_cave
```

### 场景 4：查看角色的所有计划

```bash
GET http://localhost:5000/api/activity-plans/character/{characterId}
```

返回该角色的所有计划列表（包括待执行、运行中、已完成的）。

## 使用 .NET SDK 调用示例

如果你在 C# 代码中使用：

```csharp
using System.Net.Http;
using System.Text.Json;

// 创建 HTTP 客户端
var client = new HttpClient { BaseAddress = new Uri("http://localhost:5000") };

// 创建战斗计划（自动启动）
var createUrl = $"/api/activity-plans/combat?characterId={characterId}&limitType=duration&limitValue=600&enemyId=dummy";
var createResponse = await client.PostAsync(createUrl, null);
var plan = await JsonSerializer.DeserializeAsync<ActivityPlan>(
    await createResponse.Content.ReadAsStreamAsync());

// 计划已自动启动！检查 battleId
Console.WriteLine($"Battle auto-started with ID: {plan.BattleId}");

// 查询战斗状态
var statusUrl = $"/api/battles/step/{plan.BattleId}/status";
var statusResponse = await client.GetAsync(statusUrl);
var status = await JsonSerializer.DeserializeAsync<BattleStatus>(
    await statusResponse.Content.ReadAsStreamAsync());

Console.WriteLine($"DPS: {status.Dps}, Gold: {status.Gold}");
```

## 使用 JavaScript/TypeScript 调用示例

在前端代码中：

```javascript
// 创建战斗计划（自动启动）
const createResponse = await fetch(
  `/api/activity-plans/combat?characterId=${characterId}&limitType=duration&limitValue=600&enemyId=dummy`,
  { method: 'POST' }
);
const plan = await createResponse.json();

// 计划已自动启动！检查 battleId
console.log(`Battle auto-started with ID: ${plan.battleId}`);

// 定期查询战斗状态
setInterval(async () => {
  const statusResponse = await fetch(
    `/api/battles/step/${plan.battleId}/status`
  );
  const status = await statusResponse.json();
  
  console.log(`Progress: ${status.simulatedSeconds}/${status.targetSeconds}s`);
  console.log(`DPS: ${status.dps}, Gold: ${status.gold}`);
}, 5000); // 每5秒更新一次
```

## 参数说明

### 战斗计划参数

| 参数 | 类型 | 必需 | 默认值 | 说明 |
|------|------|------|--------|------|
| characterId | Guid | 是 | - | 角色ID |
| slotIndex | int | 否 | 0 | 槽位索引（0-4） |
| limitType | string | 否 | "duration" | "duration" 或 "infinite" |
| limitValue | double? | 视情况 | - | 秒数（duration时必需） |
| enemyId | string? | 否 | null | 敌人ID |
| enemyCount | int | 否 | 1 | 敌人数量 |
| respawnDelay | double? | 否 | null | 重生延迟（秒） |
| seed | ulong? | 否 | null | 随机种子 |

### 地下城计划参数

| 参数 | 类型 | 必需 | 默认值 | 说明 |
|------|------|------|--------|------|
| characterId | Guid | 是 | - | 角色ID |
| slotIndex | int | 否 | 0 | 槽位索引（0-4） |
| limitType | string | 否 | "duration" | "duration" 或 "infinite" |
| limitValue | double? | 视情况 | - | 秒数（duration时必需） |
| dungeonId | string | 否 | "intro_cave" | 地下城ID |
| loop | bool | 否 | false | 是否循环 |
| waveDelay | double? | 否 | null | 波次延迟（秒） |
| runDelay | double? | 否 | null | 轮次延迟（秒） |
| seed | ulong? | 否 | null | 随机种子 |

## 故障排除

### 问题：创建计划时返回 "Character not found"

**解决方案**：确保提供的 `characterId` 是有效的。先调用角色查询接口确认角色存在。

### 问题：创建计划时角色已有运行中的任务

**现象**：新创建的计划 `state=0` (Pending)，而不是自动启动。

**原因**：每个角色只能同时运行一个计划。如果已有运行中的计划，新计划会进入队列等待。

**解决方案**：
1. 等待当前任务自动完成，新任务会自动启动
2. 或手动停止当前任务：

查询正在运行的计划：
```bash
GET /api/activity-plans/character/{characterId}
# 查找 state=1 的计划
```

停止正在运行的计划（会自动启动下一个）：
```bash
POST /api/activity-plans/{runningPlanId}/stop
```

### 问题：删除计划时返回 "Cannot delete a running plan"

**解决方案**：必须先停止正在运行的计划，才能删除它：

```bash
# 先停止
POST /api/activity-plans/{planId}/stop

# 再删除
DELETE /api/activity-plans/{planId}
```

## 下一步

- 阅读[完整文档](./活动计划系统文档.md)了解更多细节
- 查看[API参考](./活动计划系统文档.md#api-接口)了解所有可用端点
- 了解[架构设计](./活动计划系统文档.md#架构设计)深入理解系统实现

## 获取帮助

如果遇到问题或有疑问：
1. 检查本指南的故障排除部分
2. 阅读完整文档
3. 在项目 Issues 中提问
