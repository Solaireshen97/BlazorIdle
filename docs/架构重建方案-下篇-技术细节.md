# BlazorIdle 架构重建方案（下篇）- 技术细节

**文档版本**: 1.0  
**创建日期**: 2025-10-20  
**前置文档**: 架构重建方案（上篇）、（中篇）  
**文档类型**: 技术实现细节与最佳实践

---

## 一、Phase 4: 业务服务层整理（Week 9-11）

### 1.1 目标
建立清晰的服务边界、统一的接口规范、合理的依赖关系

### 1.2 服务划分矩阵

#### 核心领域服务

| 服务名称 | 职责范围 | 依赖服务 | 对外接口数 |
|---------|---------|---------|-----------|
| **CharacterService** | 角色创建、查询、更新、删除 | AuthService | 8-10 |
| **CombatService** | 战斗创建、执行、结算 | CharacterService, EquipmentService | 10-12 |
| **EquipmentService** | 装备穿戴、卸下、查询 | CharacterService | 8-10 |
| **SkillService** | 技能使用、冷却管理 | CharacterService | 6-8 |
| **ActivityService** | 活动计划管理、执行 | CharacterService | 10-12 |
| **ShopService** | 商店购买、刷新 | CharacterService, EquipmentService | 6-8 |
| **QuestService** | 任务接取、完成、奖励 | CharacterService | 8-10 |

#### 支撑服务

| 服务名称 | 职责范围 | 对外接口数 |
|---------|---------|-----------|
| **AuthService** | 用户认证、授权、Token 管理 | 5-6 |
| **NotificationService** | 实时通知推送 | 3-4 |
| **ConfigService** | 配置数据加载、缓存 | 4-5 |
| **MonitoringService** | 性能指标、日志聚合 | 3-4 |

### 1.3 服务接口规范

#### 统一命名规范

```csharp
// 查询操作
Task<T?> GetAsync(Guid id, CancellationToken ct = default);
Task<List<T>> GetAllAsync(CancellationToken ct = default);
Task<List<T>> FindAsync(Expression<Func<T, bool>> predicate, CancellationToken ct = default);

// 创建操作
Task<T> CreateAsync(CreateTRequest request, CancellationToken ct = default);

// 更新操作
Task UpdateAsync(UpdateTRequest request, CancellationToken ct = default);

// 删除操作
Task DeleteAsync(Guid id, CancellationToken ct = default);

// 业务操作（动词开头）
Task StartBattleAsync(...);
Task CompleteBattleAsync(...);
Task EquipGearAsync(...);
Task UnequipGearAsync(...);
```

#### 统一返回类型

```csharp
// 操作结果
public record Result<T>
{
    public bool Success { get; init; }
    public T? Data { get; init; }
    public string? Error { get; init; }
    public string? ErrorCode { get; init; }
    
    public static Result<T> Ok(T data) => new() { Success = true, Data = data };
    public static Result<T> Fail(string error, string? errorCode = null) 
        => new() { Success = false, Error = error, ErrorCode = errorCode };
}

// 分页结果
public record PagedResult<T>
{
    public List<T> Items { get; init; } = new();
    public int TotalCount { get; init; }
    public int PageNumber { get; init; }
    public int PageSize { get; init; }
    public int TotalPages => (int)Math.Ceiling((double)TotalCount / PageSize);
}
```

### 1.4 依赖注入最佳实践

#### 服务生命周期

```csharp
// 单例服务 - 无状态、全局共享
builder.Services.AddSingleton<IEventBus, InMemoryEventBus>();
builder.Services.AddSingleton<IConfigService, ConfigService>();
builder.Services.AddSingleton<INotificationService, NotificationService>();

// 作用域服务 - 每个请求一个实例
builder.Services.AddScoped<ICharacterService, CharacterService>();
builder.Services.AddScoped<ICombatService, CombatService>();
builder.Services.AddScoped<IEquipmentService, EquipmentService>();

// 瞬态服务 - 每次注入一个新实例（尽量少用）
builder.Services.AddTransient<IEmailSender, EmailSender>();
```

#### 避免循环依赖

```csharp
// ❌ 错误示例 - 循环依赖
public class CharacterService
{
    private readonly ICombatService _combatService; // 依赖 CombatService
}

public class CombatService
{
    private readonly ICharacterService _characterService; // 依赖 CharacterService
}

// ✅ 正确示例 - 使用事件解耦
public class CharacterService
{
    private readonly IEventBus _eventBus;
    
    public async Task LevelUpAsync(Guid characterId)
    {
        // ... 升级逻辑
        await _eventBus.PublishAsync(new CharacterLevelUpEvent(characterId, newLevel));
    }
}

public class CombatService
{
    private readonly IEventBus _eventBus;
    
    public CombatService(IEventBus eventBus)
    {
        _eventBus = eventBus;
        _eventBus.Subscribe<CharacterLevelUpEvent>(OnCharacterLevelUp);
    }
    
    private async Task OnCharacterLevelUp(CharacterLevelUpEvent @event, CancellationToken ct)
    {
        // 响应升级事件
    }
}
```

### 1.5 错误处理策略

#### 异常分层

```csharp
// 基础异常
public class DomainException : Exception
{
    public string ErrorCode { get; }
    
    public DomainException(string message, string errorCode) : base(message)
    {
        ErrorCode = errorCode;
    }
}

// 具体异常
public class CharacterNotFoundException : DomainException
{
    public CharacterNotFoundException(Guid characterId) 
        : base($"Character {characterId} not found", "CHARACTER_NOT_FOUND")
    {
    }
}

public class InsufficientGoldException : DomainException
{
    public InsufficientGoldException(int required, int available)
        : base($"Insufficient gold. Required: {required}, Available: {available}", "INSUFFICIENT_GOLD")
    {
    }
}
```

#### 全局异常处理

```csharp
public class GlobalExceptionHandler : IExceptionHandler
{
    private readonly ILogger<GlobalExceptionHandler> _logger;
    
    public async ValueTask<bool> TryHandleAsync(
        HttpContext httpContext, 
        Exception exception, 
        CancellationToken cancellationToken)
    {
        _logger.LogError(exception, "Unhandled exception occurred");
        
        var (statusCode, errorCode) = exception switch
        {
            DomainException de => (StatusCodes.Status400BadRequest, de.ErrorCode),
            UnauthorizedAccessException => (StatusCodes.Status401Unauthorized, "UNAUTHORIZED"),
            _ => (StatusCodes.Status500InternalServerError, "INTERNAL_ERROR")
        };
        
        httpContext.Response.StatusCode = statusCode;
        await httpContext.Response.WriteAsJsonAsync(new
        {
            error = exception.Message,
            errorCode = errorCode
        }, cancellationToken);
        
        return true;
    }
}
```

### 1.6 实施任务清单

#### Task 4.1: 绘制服务依赖图（1 天）
- 使用工具（如 PlantUML）绘制当前服务依赖
- 识别循环依赖
- 设计目标依赖关系

#### Task 4.2: 定义服务接口（2 天）
- 为每个服务定义清晰的接口
- 统一命名规范
- 文档化接口契约

#### Task 4.3: 重构服务实现（5 天）
- 按优先级逐个重构服务
- 消除循环依赖
- 统一错误处理

#### Task 4.4: 补充单元测试（3 天）
- 每个服务至少 80% 覆盖率
- 模拟依赖服务
- 测试边界条件

#### Task 4.5: 集成测试（2 天）
- 端到端场景测试
- 性能测试
- 压力测试

---

## 二、Phase 5: 核心功能迁移（Week 12-16+）

### 2.1 迁移策略

#### 渐进式迁移模式

```
旧系统 ────────────┐
  ↓                ↓
  ↓           Feature Flag
  ↓                ↓
  ↓         ┌─────┴─────┐
  ↓         ↓           ↓
  ↓      使用旧实现   使用新实现
  ↓         ↓           ↓
  └─────────┴───────────┘
                ↓
           客户端响应
```

#### Feature Flag 实现

```csharp
public class FeatureFlags
{
    public const string UseNewCharacterService = "UseNewCharacterService";
    public const string UseNewCombatService = "UseNewCombatService";
    public const string UseNewEquipmentService = "UseNewEquipmentService";
}

// appsettings.json
{
  "FeatureManagement": {
    "UseNewCharacterService": true,
    "UseNewCombatService": false,  // 灰度中
    "UseNewEquipmentService": false  // 未启用
  }
}

// 使用
public class CharacterController : ControllerBase
{
    private readonly IFeatureManager _featureManager;
    private readonly ICharacterService _newCharacterService;
    private readonly LegacyCharacterService _legacyCharacterService;
    
    public async Task<IActionResult> GetCharacter(Guid id)
    {
        if (await _featureManager.IsEnabledAsync(FeatureFlags.UseNewCharacterService))
        {
            var result = await _newCharacterService.GetAsync(id);
            return Ok(result);
        }
        else
        {
            var result = await _legacyCharacterService.GetCharacter(id);
            return Ok(result);
        }
    }
}
```

### 2.2 功能迁移详细计划

#### P0 功能迁移（Week 12-13）

##### 功能 1: 用户认证与角色管理（2 天）

**现有实现分析**:
- JWT 认证已完成，无需大改
- 角色 CRUD 需要迁移到新 Repository

**迁移步骤**:
1. 创建 `IAuthService` 接口
2. 实现 `AuthService`（使用新 Repository）
3. 编写单元测试
4. 创建 Feature Flag
5. 灰度测试（10% 用户）
6. 全量切换
7. 清理旧代码

**验收标准**:
- ✅ 登录、注册功能正常
- ✅ Token 刷新正常
- ✅ 角色 CRUD 正常
- ✅ 性能不低于旧实现

---

##### 功能 2: 战斗核心循环（5 天）

**现有实现分析**:
- 战斗引擎逻辑复杂
- 涉及多个子系统（装备、技能、Buff）
- 需要仔细测试

**迁移步骤**:
1. 分析现有战斗逻辑
2. 设计新的战斗服务接口
3. 实现核心战斗循环
   - 伤害计算
   - 技能使用
   - Buff 应用
   - 掉落计算
4. 集成事件发布（战斗开始、进度、结束）
5. 编写大量单元测试
6. 集成测试
7. 性能对比测试
8. 灰度发布

**关键代码结构**:
```csharp
public class CombatService : ICombatService
{
    private readonly IRepository<BattleRecord> _battleRepo;
    private readonly ICharacterService _characterService;
    private readonly IEquipmentService _equipmentService;
    private readonly ISkillService _skillService;
    private readonly IEventBus _eventBus;
    private readonly ILogger<CombatService> _logger;
    
    public async Task<Result<BattleRecord>> StartBattleAsync(StartBattleRequest request, CancellationToken ct = default)
    {
        // 1. 验证角色存在
        var character = await _characterService.GetAsync(request.CharacterId, ct);
        if (character == null)
            return Result<BattleRecord>.Fail("Character not found", "CHARACTER_NOT_FOUND");
        
        // 2. 获取角色装备和技能
        var equipment = await _equipmentService.GetEquippedGearAsync(request.CharacterId, ct);
        var skills = await _skillService.GetActiveSkillsAsync(request.CharacterId, ct);
        
        // 3. 创建战斗记录
        var battle = new BattleRecord
        {
            Id = Guid.NewGuid(),
            CharacterId = request.CharacterId,
            MonsterId = request.MonsterId,
            Status = BattleStatus.InProgress,
            StartTime = DateTime.UtcNow
        };
        
        await _battleRepo.AddAsync(battle, ct);
        
        // 4. 发布战斗开始事件
        await _eventBus.PublishAsync(new BattleStartedEvent(battle.Id, request.CharacterId), ct);
        
        // 5. 启动战斗循环（异步）
        _ = Task.Run(() => RunBattleLoopAsync(battle.Id), ct);
        
        return Result<BattleRecord>.Ok(battle);
    }
    
    private async Task RunBattleLoopAsync(Guid battleId)
    {
        while (true)
        {
            // 加载战斗状态
            var battle = await _battleRepo.GetByIdAsync(battleId);
            if (battle == null || battle.Status != BattleStatus.InProgress)
                break;
            
            // 处理一个战斗 Tick
            await ProcessBattleTickAsync(battle);
            
            // 检查战斗是否结束
            if (IsBattleCompleted(battle))
            {
                await CompleteBattleAsync(battle);
                break;
            }
            
            // 等待下一个 Tick
            await Task.Delay(TimeSpan.FromMilliseconds(500));
        }
    }
    
    private async Task ProcessBattleTickAsync(BattleRecord battle)
    {
        // 1. 计算角色伤害
        var characterDamage = await CalculateCharacterDamageAsync(battle);
        battle.MonsterHp -= characterDamage;
        
        // 2. 计算怪物伤害
        var monsterDamage = await CalculateMonsterDamageAsync(battle);
        battle.CharacterHp -= monsterDamage;
        
        // 3. 处理技能冷却
        await ProcessSkillCooldownsAsync(battle);
        
        // 4. 处理 Buff
        await ProcessBuffsAsync(battle);
        
        // 5. 更新战斗记录
        await _battleRepo.UpdateAsync(battle);
        
        // 6. 发布进度事件
        await _eventBus.PublishAsync(new BattleProgressEvent(
            battle.Id, 
            battle.MonsterHp, 
            battle.MonsterMaxHp
        ));
    }
    
    private async Task CompleteBattleAsync(BattleRecord battle)
    {
        battle.Status = battle.CharacterHp > 0 ? BattleStatus.Victory : BattleStatus.Defeat;
        battle.EndTime = DateTime.UtcNow;
        
        // 计算奖励
        var rewards = CalculateRewards(battle);
        
        // 应用奖励
        await ApplyRewardsAsync(battle.CharacterId, rewards);
        
        // 更新战斗记录
        await _battleRepo.UpdateAsync(battle);
        
        // 发布战斗完成事件
        await _eventBus.PublishAsync(new BattleCompletedEvent(
            battle.Id,
            battle.Status == BattleStatus.Victory,
            rewards.Exp,
            rewards.Gold
        ));
    }
    
    // ... 其他辅助方法
}
```

**验收标准**:
- ✅ 战斗能正常开始、执行、结束
- ✅ 伤害计算准确
- ✅ 技能使用正常
- ✅ 掉落正常
- ✅ 经验和金币正确增加
- ✅ 性能不低于旧实现

---

##### 功能 3: 装备系统基础（3 天）

**迁移步骤**:
1. 迁移装备穿戴/卸下逻辑
2. 迁移属性计算
3. 迁移装备查询
4. 测试与验证

**关键接口**:
```csharp
public interface IEquipmentService
{
    // 基础操作
    Task<Result<Unit>> EquipAsync(Guid characterId, Guid gearId, CancellationToken ct = default);
    Task<Result<Unit>> UnequipAsync(Guid characterId, string slotName, CancellationToken ct = default);
    Task<List<GearInstance>> GetEquippedGearAsync(Guid characterId, CancellationToken ct = default);
    
    // 属性计算
    Task<CharacterStats> CalculateStatsAsync(Guid characterId, CancellationToken ct = default);
}
```

---

##### 功能 4: 技能使用与冷却（2 天）

**迁移步骤**:
1. 迁移技能使用逻辑
2. 迁移冷却管理
3. 集成到战斗系统
4. 测试与验证

---

#### P1 功能迁移（Week 14-15）

##### 功能 5: 活动计划系统（3 天）

**关键功能**:
- 创建活动计划
- 执行活动
- 取消活动
- 查询活动状态

**迁移重点**:
- 统一活动类型枚举
- 简化状态机
- 清晰的错误处理

---

##### 功能 6: 离线战斗与收益（4 天）

**离线战斗策略**:
```csharp
public class OfflineBattleService : IOfflineBattleService
{
    public async Task<OfflineResult> ProcessOfflineTimeAsync(Guid characterId, CancellationToken ct = default)
    {
        // 1. 计算离线时长
        var character = await _characterService.GetAsync(characterId, ct);
        var offlineDuration = DateTime.UtcNow - character.LastOnlineAt;
        
        // 2. 限制最大离线时长（如 12 小时）
        var maxOfflineDuration = TimeSpan.FromHours(12);
        var effectiveDuration = offlineDuration > maxOfflineDuration 
            ? maxOfflineDuration 
            : offlineDuration;
        
        // 3. 模拟战斗
        var battles = CalculateOfflineBattles(effectiveDuration);
        
        // 4. 计算奖励
        var totalRewards = new Rewards();
        foreach (var battle in battles)
        {
            var battleRewards = await SimulateBattleAsync(character, battle, ct);
            totalRewards.Add(battleRewards);
        }
        
        // 5. 应用奖励
        await ApplyRewardsAsync(characterId, totalRewards, ct);
        
        // 6. 返回结果
        return new OfflineResult
        {
            Duration = effectiveDuration,
            BattleCount = battles.Count,
            Rewards = totalRewards
        };
    }
    
    private async Task<Rewards> SimulateBattleAsync(Character character, OfflineBattle battle, CancellationToken ct)
    {
        // 简化的战斗模拟
        // 不需要像在线战斗那样逐 Tick 处理
        // 直接计算结果
        
        var characterPower = await CalculateCharacterPowerAsync(character);
        var monsterPower = GetMonsterPower(battle.MonsterId);
        
        var victoryProbability = characterPower / (characterPower + monsterPower);
        var isVictory = _random.NextDouble() < victoryProbability;
        
        if (isVictory)
        {
            return CalculateRewards(battle);
        }
        else
        {
            return new Rewards(); // 失败无奖励
        }
    }
}
```

**验收标准**:
- ✅ 离线时长计算准确
- ✅ 最大离线时长限制生效
- ✅ 奖励计算合理
- ✅ 不会导致经济失衡

---

##### 功能 7-8: 商店系统、装备分解与重铸（4 天）

**迁移重点**:
- 统一交易逻辑
- 货币检查
- 库存管理
- 事务一致性

---

#### P2 功能迁移（Week 16）

##### 功能 9-11: 任务、声望、多角色（5 天）

**迁移策略**:
- 这些功能相对独立
- 可以并行迁移
- 优先保证核心功能稳定

---

### 2.3 数据迁移方案

#### 无需数据迁移场景
- 如果新旧系统使用相同的数据库 Schema
- 只是访问方式不同
- 无需数据迁移

#### 需要数据迁移场景
- 如果调整了 Schema
- 需要编写迁移脚本

```csharp
// 示例：添加新字段的迁移
public class AddLastOnlineAtToCharacter : Migration
{
    protected override void Up(MigrationBuilder migrationBuilder)
    {
        migrationBuilder.AddColumn<DateTime>(
            name: "LastOnlineAt",
            table: "Characters",
            type: "TEXT",
            nullable: false,
            defaultValue: DateTime.UtcNow);
    }
    
    protected override void Down(MigrationBuilder migrationBuilder)
    {
        migrationBuilder.DropColumn(
            name: "LastOnlineAt",
            table: "Characters");
    }
}
```

### 2.4 灰度发布策略

#### 按用户百分比灰度

```csharp
public class GradualRolloutFeatureFilter : IFeatureFilter
{
    public Task<bool> EvaluateAsync(FeatureFilterEvaluationContext context)
    {
        var userId = context.Parameters.Get<string>("UserId");
        var percentage = context.Parameters.Get<int>("Percentage");
        
        // 使用用户 ID 的哈希值决定是否启用
        var hash = userId.GetHashCode();
        var bucket = Math.Abs(hash % 100);
        
        return Task.FromResult(bucket < percentage);
    }
}

// appsettings.json
{
  "FeatureManagement": {
    "UseNewCombatService": {
      "EnabledFor": [
        {
          "Name": "GradualRollout",
          "Parameters": {
            "Percentage": 10  // 10% 用户
          }
        }
      ]
    }
  }
}
```

#### 按用户白名单灰度

```csharp
// appsettings.json
{
  "FeatureManagement": {
    "UseNewCombatService": {
      "EnabledFor": [
        {
          "Name": "Whitelist",
          "Parameters": {
            "Users": ["user1@example.com", "user2@example.com"]
          }
        }
      ]
    }
  }
}
```

---

## 三、性能优化指南

### 3.1 数据库优化

#### 索引优化

```csharp
// 在 DbContext 配置中添加索引
protected override void OnModelCreating(ModelBuilder modelBuilder)
{
    modelBuilder.Entity<Character>()
        .HasIndex(c => c.UserId);  // 频繁查询
    
    modelBuilder.Entity<BattleRecord>()
        .HasIndex(b => new { b.CharacterId, b.Status });  // 复合索引
    
    modelBuilder.Entity<GearInstance>()
        .HasIndex(g => g.CharacterId)
        .HasFilter("IsEquipped = 1");  // 过滤索引
}
```

#### 查询优化

```csharp
// ❌ N+1 查询问题
public async Task<List<CharacterDto>> GetCharactersAsync()
{
    var characters = await _context.Characters.ToListAsync();
    
    foreach (var character in characters)
    {
        // 每个角色都会执行一次查询！
        character.Equipment = await _context.GearInstances
            .Where(g => g.CharacterId == character.Id)
            .ToListAsync();
    }
    
    return characters;
}

// ✅ 使用 Include 预加载
public async Task<List<CharacterDto>> GetCharactersAsync()
{
    var characters = await _context.Characters
        .Include(c => c.Equipment)  // 一次查询获取所有数据
        .ToListAsync();
    
    return characters;
}

// ✅ 使用 AsNoTracking（只读查询）
public async Task<List<CharacterDto>> GetCharactersAsync()
{
    var characters = await _context.Characters
        .AsNoTracking()  // 不跟踪实体变化，性能更好
        .Include(c => c.Equipment)
        .ToListAsync();
    
    return characters;
}

// ✅ 使用投影（只选择需要的字段）
public async Task<List<CharacterSummaryDto>> GetCharacterSummariesAsync()
{
    var summaries = await _context.Characters
        .Select(c => new CharacterSummaryDto
        {
            Id = c.Id,
            Name = c.Name,
            Level = c.Level
            // 只选择需要的字段
        })
        .ToListAsync();
    
    return summaries;
}
```

### 3.2 缓存优化

#### 缓存键设计

```csharp
public static class CacheKeys
{
    // 使用常量定义缓存键模板
    public const string CharacterPrefix = "character";
    public const string EquipmentPrefix = "equipment";
    public const string ConfigPrefix = "config";
    
    // 生成缓存键的方法
    public static string Character(Guid id) => $"{CharacterPrefix}:{id}";
    public static string CharacterEquipment(Guid characterId) => $"{EquipmentPrefix}:{characterId}";
    public static string SkillDefinition(string skillId) => $"{ConfigPrefix}:skill:{skillId}";
}
```

#### 缓存穿透防护

```csharp
public async Task<Character?> GetCharacterAsync(Guid id)
{
    var cacheKey = CacheKeys.Character(id);
    
    // 尝试从缓存获取
    var cached = await _cache.GetAsync(cacheKey);
    if (cached != null)
        return cached;
    
    // 从数据库加载
    var character = await _repository.GetByIdAsync(id);
    
    // 即使结果为 null，也缓存一段时间（防止穿透）
    if (character != null)
    {
        await _cache.SetAsync(cacheKey, character, TimeSpan.FromMinutes(5));
    }
    else
    {
        // 缓存 null 结果，但使用较短的 TTL
        await _cache.SetAsync(cacheKey, null, TimeSpan.FromMinutes(1));
    }
    
    return character;
}
```

### 3.3 SignalR 优化

#### 消息批量发送

```csharp
public class MessageAggregator
{
    private readonly ConcurrentDictionary<Guid, List<BattleProgressEvent>> _buffer = new();
    private readonly IHubContext<BattleNotificationHub> _hubContext;
    private readonly Timer _flushTimer;
    
    public MessageAggregator(IHubContext<BattleNotificationHub> hubContext)
    {
        _hubContext = hubContext;
        _flushTimer = new Timer(FlushMessages, null, 
            TimeSpan.FromMilliseconds(500), 
            TimeSpan.FromMilliseconds(500));
    }
    
    public void AddMessage(Guid battleId, BattleProgressEvent @event)
    {
        _buffer.AddOrUpdate(
            battleId,
            _ => new List<BattleProgressEvent> { @event },
            (_, list) => { list.Add(@event); return list; }
        );
    }
    
    private async void FlushMessages(object? state)
    {
        // 获取并清空缓冲区
        var batches = new Dictionary<Guid, List<BattleProgressEvent>>();
        foreach (var kvp in _buffer)
        {
            if (_buffer.TryRemove(kvp.Key, out var events))
            {
                batches[kvp.Key] = events;
            }
        }
        
        // 批量发送
        foreach (var batch in batches)
        {
            var battleId = batch.Key;
            var events = batch.Value;
            
            // 聚合多个事件为一个消息
            var aggregated = new
            {
                BattleId = battleId,
                EventCount = events.Count,
                LastMonsterHp = events.Last().MonsterHp,
                LastMonsterMaxHp = events.Last().MonsterMaxHp
            };
            
            await _hubContext.Clients
                .Group($"battle_{battleId}")
                .SendAsync("BattleProgressBatch", aggregated);
        }
    }
}
```

---

## 四、测试策略

### 4.1 单元测试

#### 测试覆盖率目标
- 核心业务逻辑: 90%+
- 服务层: 80%+
- Repository: 70%+
- 控制器: 60%+

#### 测试示例

```csharp
public class CharacterServiceTests
{
    private readonly Mock<IRepository<Character>> _mockRepo;
    private readonly Mock<ICache<Character>> _mockCache;
    private readonly Mock<IEventBus> _mockEventBus;
    private readonly CharacterService _service;
    
    public CharacterServiceTests()
    {
        _mockRepo = new Mock<IRepository<Character>>();
        _mockCache = new Mock<ICache<Character>>();
        _mockEventBus = new Mock<IEventBus>();
        
        _service = new CharacterService(
            _mockRepo.Object,
            _mockCache.Object,
            _mockEventBus.Object,
            Mock.Of<ILogger<CharacterService>>()
        );
    }
    
    [Fact]
    public async Task GetCharacterAsync_WhenCached_ShouldReturnFromCache()
    {
        // Arrange
        var characterId = Guid.NewGuid();
        var expectedCharacter = new Character { Id = characterId, Name = "Test" };
        
        _mockCache
            .Setup(c => c.GetAsync(It.IsAny<string>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(expectedCharacter);
        
        // Act
        var result = await _service.GetAsync(characterId);
        
        // Assert
        Assert.NotNull(result);
        Assert.Equal(expectedCharacter.Id, result.Id);
        
        // 验证没有访问数据库
        _mockRepo.Verify(r => r.GetByIdAsync(It.IsAny<Guid>(), It.IsAny<CancellationToken>()), Times.Never);
    }
    
    [Fact]
    public async Task CreateCharacterAsync_ShouldPublishEvent()
    {
        // Arrange
        var request = new CreateCharacterRequest { Name = "New Character" };
        
        _mockRepo
            .Setup(r => r.AddAsync(It.IsAny<Character>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync((Character c, CancellationToken ct) => c);
        
        // Act
        await _service.CreateAsync(request);
        
        // Assert
        _mockEventBus.Verify(
            e => e.PublishAsync(It.IsAny<CharacterCreatedEvent>(), It.IsAny<CancellationToken>()),
            Times.Once
        );
    }
}
```

### 4.2 集成测试

#### 测试基础设施

```csharp
public class IntegrationTestBase : IAsyncLifetime
{
    protected WebApplicationFactory<Program> Factory { get; private set; } = null!;
    protected HttpClient Client { get; private set; } = null!;
    protected GameDbContext DbContext { get; private set; } = null!;
    
    public async Task InitializeAsync()
    {
        Factory = new WebApplicationFactory<Program>()
            .WithWebHostBuilder(builder =>
            {
                builder.ConfigureServices(services =>
                {
                    // 替换为测试数据库
                    services.RemoveAll<GameDbContext>();
                    services.AddDbContext<GameDbContext>(options =>
                        options.UseInMemoryDatabase("TestDb"));
                });
            });
        
        Client = Factory.CreateClient();
        
        var scope = Factory.Services.CreateScope();
        DbContext = scope.ServiceProvider.GetRequiredService<GameDbContext>();
        
        // 初始化测试数据
        await SeedTestDataAsync();
    }
    
    public async Task DisposeAsync()
    {
        await DbContext.Database.EnsureDeletedAsync();
        Client.Dispose();
        await Factory.DisposeAsync();
    }
    
    protected async Task SeedTestDataAsync()
    {
        // 添加测试数据
    }
}

public class CharacterApiTests : IntegrationTestBase
{
    [Fact]
    public async Task GetCharacter_ShouldReturnCharacter()
    {
        // Arrange
        var character = new Character { Id = Guid.NewGuid(), Name = "Test" };
        DbContext.Characters.Add(character);
        await DbContext.SaveChangesAsync();
        
        // Act
        var response = await Client.GetAsync($"/api/characters/{character.Id}");
        
        // Assert
        response.EnsureSuccessStatusCode();
        var result = await response.Content.ReadFromJsonAsync<Character>();
        Assert.NotNull(result);
        Assert.Equal(character.Name, result.Name);
    }
}
```

### 4.3 性能测试

#### 使用 K6 进行负载测试

```javascript
// k6-load-test.js
import http from 'k6/http';
import { check, sleep } from 'k6';

export const options = {
  stages: [
    { duration: '2m', target: 100 },  // 2分钟内达到100个虚拟用户
    { duration: '5m', target: 100 },  // 保持100个用户5分钟
    { duration: '2m', target: 0 },    // 2分钟内降到0
  ],
  thresholds: {
    http_req_duration: ['p(95)<500'],  // 95%的请求响应时间 < 500ms
    http_req_failed: ['rate<0.01'],    // 失败率 < 1%
  },
};

export default function () {
  // 测试获取角色
  const res = http.get('http://localhost:5000/api/characters/123');
  check(res, {
    'status is 200': (r) => r.status === 200,
    'response time < 500ms': (r) => r.timings.duration < 500,
  });
  
  sleep(1);
}
```

---

## 五、监控与告警

### 5.1 关键指标

#### 应用性能指标
- 请求响应时间（P50, P95, P99）
- 请求吞吐量（RPS）
- 错误率
- 并发用户数

#### 数据库指标
- 查询响应时间
- 慢查询数量
- 连接池使用率
- 死锁次数

#### 缓存指标
- 缓存命中率
- 缓存驱逐率
- 缓存大小

#### SignalR 指标
- 连接数
- 消息发送速率
- 消息延迟

### 5.2 告警规则

```yaml
# 示例告警配置（Prometheus）
groups:
  - name: blazoridle_alerts
    rules:
      - alert: HighResponseTime
        expr: http_request_duration_seconds{quantile="0.95"} > 1
        for: 5m
        annotations:
          summary: "API响应时间过高"
          description: "P95响应时间超过1秒，持续5分钟"
      
      - alert: HighErrorRate
        expr: rate(http_requests_total{status=~"5.."}[5m]) > 0.05
        for: 2m
        annotations:
          summary: "错误率过高"
          description: "5xx错误率超过5%，持续2分钟"
      
      - alert: LowCacheHitRate
        expr: cache_hit_rate < 0.7
        for: 10m
        annotations:
          summary: "缓存命中率过低"
          description: "缓存命中率低于70%，持续10分钟"
```

---

## 六、总结

本文档详细描述了 Phase 4-5 的技术实现细节，包括：

1. **业务服务层整理**: 服务划分、接口规范、依赖管理、错误处理
2. **核心功能迁移**: 详细的迁移计划、代码示例、验收标准
3. **性能优化**: 数据库、缓存、SignalR 等方面的优化策略
4. **测试策略**: 单元测试、集成测试、性能测试的完整方案
5. **监控告警**: 关键指标和告警规则

通过这三篇文档（上、中、下），我们建立了一个完整的架构重建方案：
- **上篇**: 战略规划（为什么做、做什么）
- **中篇**: 实施路径（怎么做、分几步）
- **下篇**: 技术细节（具体怎么实现）

这个方案的核心特点：
✅ **渐进式**: 不做大爆炸式重写
✅ **可回滚**: 每个阶段都可以回退
✅ **有验证**: 充分的测试保证质量
✅ **可度量**: 清晰的指标和目标

---

**文档状态**: ✅ 三篇文档全部完成  
**建议**: 团队评审后开始 Phase 0 准备工作  
**相关文档**: 
- 架构重建方案（上篇）- 战略规划
- 架构重建方案（中篇）- 实施路径
