# 战斗循环优化需求分析报告

## 文档信息
- **版本**: 1.0
- **日期**: 2025-10-14
- **作者**: 战斗系统优化团队
- **状态**: 需求分析完成

---

## 目录
1. [需求背景](#需求背景)
2. [当前系统分析](#当前系统分析)
3. [问题识别](#问题识别)
4. [优化目标](#优化目标)
5. [技术分析](#技术分析)
6. [影响范围评估](#影响范围评估)
7. [风险评估](#风险评估)

---

## 需求背景

### 用户需求原文
```
我打算修改当前的战斗循环，现在我们的战斗创建了之后就会触发攻击，我想要让玩家的攻击更符合直观的感受，
当怪物出现的时候玩家的攻击事件应该才开始读秒攻击速度的时间然后触发伤害事件，攻击和触发的技能虽然是
随机判断的，但是应该为同一个，而不是攻击和技能各打一个目标，如果怪物死亡后没有新的怪物，进入刷新阶段了，
那么就应该类似于玩家死亡一样把攻击暂停，直到怪物出现才重新开始计算进度。

特殊进度可以根据需要，比如不同职业的特性来配置是否怪物死亡后停止触发，还是只要在战斗中就一直触发。

玩家死亡的时候攻击和特殊进度都应该停止，特殊进度应该和攻击进度一样开始战斗的时候从0开始算进度。

攻击的进度的重置需要推送到前端，让前端能够实时反应。
```

### 核心诉求提炼

1. **玩家攻击时机优化**
   - 战斗开始时不应立即攻击
   - 应等待完整的攻击间隔后才触发第一次攻击
   - 怪物出现后才开始攻击倒计时

2. **目标选择一致性**
   - 攻击和技能应该攻击同一个目标
   - 避免攻击和技能分别选择不同目标的情况

3. **刷新阶段行为优化**
   - 怪物全部死亡进入刷新等待时，应暂停玩家攻击
   - 暂停行为类似于玩家死亡
   - 新怪物出现时重新开始攻击倒计时

4. **特殊轨道灵活配置**
   - 不同职业可配置特殊轨道在无怪物时的行为
   - 支持两种模式：
     - 跟随攻击轨道暂停（怪物死亡后停止）
     - 持续触发（只要在战斗中就一直触发）

5. **玩家死亡行为统一**
   - 玩家死亡时攻击和特殊轨道都应停止
   - 复活后两者都从0开始计算进度

6. **前端实时反馈**
   - 攻击进度重置需要推送到前端
   - 前端能够实时显示进度变化

---

## 当前系统分析

### 2.1 当前攻击初始化逻辑

**文件**: `BattleEngine.cs` (构造函数)

```csharp
// 当前实现：战斗开始时立即调度第一次攻击
var attackTrack = new TrackState(TrackType.Attack, Battle.AttackIntervalSeconds, 0);
var specialTrack = new TrackState(TrackType.Special, Battle.SpecialIntervalSeconds, Battle.SpecialIntervalSeconds);

Scheduler.Schedule(new AttackTickEvent(attackTrack.NextTriggerAt, attackTrack));  // NextTriggerAt = 0
Scheduler.Schedule(new SpecialPulseEvent(specialTrack.NextTriggerAt, specialTrack));  // NextTriggerAt = specialInterval
```

**问题**:
- 攻击轨道的 `NextTriggerAt` 初始化为 0，导致战斗开始时立即触发攻击
- 特殊轨道初始化为 `specialInterval`，已经延迟了一个周期
- 两者初始化逻辑不一致

### 2.2 当前目标选择逻辑

**文件**: `AttackTickEvent.cs`

```csharp
// 在每次攻击时选择目标
var candidates = context.EncounterGroup.All
    .Select((enc, idx) => new Combatants.EnemyCombatant($"enemy_{idx}", enc))
    .ToList<Combatants.ICombatant>();

target = context.TargetSelector.SelectTarget(candidates);

// 技能施放时也会独立选择目标
context.AutoCaster.TryAutoCast(context, ExecuteAt);
```

**问题**:
- 普通攻击选择目标
- 技能施放可能独立选择不同目标
- 没有目标锁定机制

### 2.3 当前刷新等待逻辑

**文件**: `BattleEngine.cs` (`TryScheduleNextWaveIfCleared`)

```csharp
private void TryScheduleNextWaveIfCleared()
{
    if (!IsWaveCleared()) return;
    
    // ... 安排下一波
    _pendingNextGroup = nextGroup;
    _pendingSpawnAt = Clock.CurrentTime + delay;
    _waitingSpawn = true;
    
    // 已经有重置攻击进度的调用
    ResetAttackProgress();  // 只重置攻击轨道
}
```

**问题**:
- 重置了攻击进度，但没有真正暂停攻击
- 攻击事件会继续被调度和执行
- 特殊轨道没有被处理

### 2.4 当前玩家死亡逻辑

**文件**: `PlayerDeathEvent.cs`

```csharp
// 暂停所有玩家轨道
const double FAR_FUTURE = 1e10;
foreach (var track in context.Tracks)
{
    track.NextTriggerAt = FAR_FUTURE;
}
```

**文件**: `PlayerReviveEvent.cs`

```csharp
// 复活时恢复轨道
foreach (var track in context.Tracks)
{
    track.NextTriggerAt = ExecuteAt + track.CurrentInterval;
    
    if (track.TrackType == TrackType.Attack)
    {
        context.Scheduler.Schedule(new AttackTickEvent(track.NextTriggerAt, track));
    }
    else if (track.TrackType == TrackType.Special)
    {
        context.Scheduler.Schedule(new SpecialPulseEvent(track.NextTriggerAt, track));
    }
}
```

**分析**:
- 玩家死亡时已经正确暂停了所有轨道
- 复活时从 `ExecuteAt + track.CurrentInterval` 开始，符合从0开始计算进度的需求
- 这个机制可以作为刷新等待的参考

### 2.5 当前前端进度显示

**文件**: `战斗攻击进度平滑优化报告.md`

前端已经实现了平滑的进度条显示：
- 通过追踪 `NextAttackAt` 的变化计算攻击间隔
- 使用客户端插值实现平滑动画
- 服务器轮询时自动校正

但是当前没有特定的"进度重置"推送事件，前端依赖于检测 `NextAttackAt` 的跳跃变化。

---

## 问题识别

### 3.1 核心问题列表

| 问题编号 | 问题描述 | 严重程度 | 当前状态 |
|---------|---------|---------|---------|
| P1 | 战斗开始时玩家立即攻击，缺乏准备时间 | 中 | 需要修复 |
| P2 | 攻击和技能可能选择不同目标 | 中 | 需要修复 |
| P3 | 刷新等待时攻击没有真正暂停 | 高 | 需要修复 |
| P4 | 特殊轨道在无怪物时的行为不可配置 | 低 | 需要增强 |
| P5 | 特殊轨道初始延迟不符合需求 | 中 | 需要修复 |
| P6 | 缺少明确的进度重置推送机制 | 低 | 需要增强 |

### 3.2 问题分析

#### P1: 战斗开始时玩家立即攻击

**根本原因**:
```csharp
// 攻击轨道初始化时 nextTriggerAt = 0
var attackTrack = new TrackState(TrackType.Attack, Battle.AttackIntervalSeconds, 0);
```

**影响**:
- 玩家在战斗开始的瞬间就发动攻击
- 不符合"读秒-攻击"的直观体验
- 与特殊轨道的延迟启动不一致

**修复方向**:
- 将初始 `NextTriggerAt` 设置为 `attackInterval` 而不是 0
- 确保第一次攻击在完整间隔后触发

#### P2: 攻击和技能选择不同目标

**根本原因**:
- 攻击事件中选择一次目标
- 技能施放时 `AutoCaster.TryAutoCast` 内部可能再次选择目标
- 没有"当前目标"的概念

**影响**:
- 战斗逻辑不连贯
- 可能导致怪物仇恨混乱（未来多人时）
- 玩家体验不直观

**修复方向**:
- 在攻击事件中选定目标后，将其传递给 `TryAutoCast`
- 或者在 `BattleContext` 中维护"当前目标"

#### P3: 刷新等待时攻击没有真正暂停

**根本原因**:
- `ResetAttackProgress` 只是重置了 `NextTriggerAt`
- 但 `AttackTickEvent` 已经被调度，仍然会执行
- `Execute` 方法中检查目标是否存在，但不检查是否在等待刷新

**影响**:
- 攻击事件会在无怪物时继续执行
- 浪费计算资源
- 可能导致逻辑错误

**修复方向**:
- 类似玩家死亡，将 `NextTriggerAt` 设置为 `FAR_FUTURE`
- 在新怪物出现时重新调度攻击事件

#### P4: 特殊轨道行为不可配置

**根本原因**:
- 特殊轨道的行为硬编码在事件中
- 没有配置选项控制其在无怪物时的行为

**影响**:
- 无法实现职业差异化
- 例如某些职业的特殊机制可能需要持续触发

**修复方向**:
- 在 `IProfessionModule` 或 `TrackState` 中添加配置项
- 例如 `PauseWhenNoEnemies` 标志

#### P5: 特殊轨道初始延迟不符合需求

**根本原因**:
```csharp
// 特殊轨道初始化时就有延迟
var specialTrack = new TrackState(TrackType.Special, Battle.SpecialIntervalSeconds, Battle.SpecialIntervalSeconds);
```

**影响**:
- 用户需求是"从0开始算进度"
- 当前实现第一次触发在 specialInterval 后
- 不符合统一的"从0开始"原则

**修复方向**:
- 根据需求，考虑是否应该从0开始
- 或者保持当前行为，取决于职业设计

#### P6: 缺少明确的进度重置推送

**根本原因**:
- 前端依赖于检测 `NextAttackAt` 的变化
- 没有显式的"进度重置"事件通知

**影响**:
- 前端需要推断何时发生了重置
- 可能存在边缘情况未覆盖

**修复方向**:
- 添加 SignalR 推送事件，明确通知进度重置
- 或者在现有的标签系统中添加 `attack_progress_reset` 标志推送

---

## 优化目标

### 4.1 功能目标

| 目标编号 | 目标描述 | 优先级 | 期望效果 |
|---------|---------|--------|---------|
| G1 | 攻击时机优化 | 高 | 战斗开始后等待完整间隔才发动第一次攻击 |
| G2 | 目标一致性 | 高 | 同一轮攻击中，普通攻击和技能攻击同一目标 |
| G3 | 刷新等待暂停 | 高 | 无怪物时暂停攻击，新怪物出现时恢复 |
| G4 | 特殊轨道配置化 | 中 | 支持职业自定义特殊轨道的暂停行为 |
| G5 | 进度统一起点 | 中 | 所有轨道从0开始计算进度 |
| G6 | 前端实时反馈 | 中 | 进度重置时推送通知到前端 |

### 4.2 非功能目标

- **向后兼容**: 不破坏现有战斗逻辑
- **性能无损**: 不增加明显的计算开销
- **可测试性**: 所有变更可通过单元测试验证
- **可维护性**: 代码清晰，易于理解和扩展

---

## 技术分析

### 5.1 关键修改点

#### 修改点1: BattleEngine 构造函数

**当前代码**:
```csharp
var attackTrack = new TrackState(TrackType.Attack, Battle.AttackIntervalSeconds, 0);
var specialTrack = new TrackState(TrackType.Special, Battle.SpecialIntervalSeconds, Battle.SpecialIntervalSeconds);
```

**建议修改**:
```csharp
var attackTrack = new TrackState(TrackType.Attack, Battle.AttackIntervalSeconds, Battle.AttackIntervalSeconds);
var specialTrack = new TrackState(TrackType.Special, Battle.SpecialIntervalSeconds, Battle.SpecialIntervalSeconds);
// 或者根据需求，特殊轨道也可以从0开始
```

**影响范围**:
- 所有新创建的战斗
- 需要验证离线战斗的兼容性
- 需要更新相关测试用例

#### 修改点2: 目标选择与锁定

**方案A: 在 BattleContext 中维护当前目标**

```csharp
public class BattleContext
{
    // 新增：当前攻击目标
    public ICombatant? CurrentAttackTarget { get; set; }
}
```

**方案B: 在 AttackTickEvent 中传递目标给技能**

```csharp
// 在 AttackTickEvent.Execute 中
target = context.TargetSelector.SelectTarget(candidates);
context.CurrentAttackTarget = target;  // 设置当前目标
context.AutoCaster.TryAutoCast(context, ExecuteAt);  // 技能使用同一目标
```

**推荐**: 方案B，因为更简单，影响范围小

#### 修改点3: 刷新等待时暂停轨道

**建议实现**:
```csharp
private void TryScheduleNextWaveIfCleared()
{
    if (!IsWaveCleared()) return;
    
    // 暂停所有玩家轨道（类似玩家死亡）
    const double FAR_FUTURE = 1e10;
    foreach (var track in Context.Tracks)
    {
        // 根据轨道类型和职业配置决定是否暂停
        if (ShouldPauseTrackDuringSpawn(track))
        {
            track.NextTriggerAt = FAR_FUTURE;
        }
    }
    
    // ... 现有刷新逻辑
}

private bool ShouldPauseTrackDuringSpawn(TrackState track)
{
    if (track.TrackType == TrackType.Attack)
        return true;  // 攻击轨道总是暂停
    
    if (track.TrackType == TrackType.Special)
    {
        // 检查职业配置
        return Context.ProfessionModule.ShouldPauseSpecialDuringSpawn;
    }
    
    return false;
}
```

**恢复时机**: 在 `TryPerformPendingSpawn` 中恢复

```csharp
private void TryPerformPendingSpawn()
{
    // ... 现有刷新逻辑
    
    // 恢复轨道（类似玩家复活）
    double spawnTime = Clock.CurrentTime;
    foreach (var track in Context.Tracks)
    {
        if (track.NextTriggerAt > 1e9)  // 检查是否被暂停
        {
            track.NextTriggerAt = spawnTime + track.CurrentInterval;
            
            // 重新调度事件
            if (track.TrackType == TrackType.Attack)
            {
                Scheduler.Schedule(new AttackTickEvent(track.NextTriggerAt, track));
            }
            else if (track.TrackType == TrackType.Special)
            {
                Scheduler.Schedule(new SpecialPulseEvent(track.NextTriggerAt, track));
            }
        }
    }
    
    // 推送进度重置通知到前端
    Collector.OnTag("tracks_resumed_after_spawn", 1);
}
```

#### 修改点4: 职业特殊轨道配置

**在 IProfessionModule 中添加配置**:
```csharp
public interface IProfessionModule
{
    // 现有成员...
    
    /// <summary>
    /// 是否在无怪物（等待刷新）时暂停特殊轨道
    /// </summary>
    bool ShouldPauseSpecialDuringSpawn { get; }
}
```

**默认实现**:
```csharp
public abstract class BaseProfessionModule : IProfessionModule
{
    public virtual bool ShouldPauseSpecialDuringSpawn => true;  // 默认暂停
}
```

**职业自定义**:
```csharp
public class WarriorModule : BaseProfessionModule
{
    public override bool ShouldPauseSpecialDuringSpawn => false;  // 战士特殊轨道不暂停
}
```

#### 修改点5: 前端进度重置推送

**方案A: 使用现有的 SegmentCollector 标签**

```csharp
// 在暂停时
Collector.OnTag("attack_progress_paused", 1);

// 在恢复时
Collector.OnTag("attack_progress_resumed", 1);
```

**方案B: 添加专门的 SignalR 事件**

```csharp
// 定义新的事件 DTO
public class TrackResetEventDto
{
    public Guid BattleId { get; set; }
    public string EventType { get; set; } = "TrackReset";
    public double EventTime { get; set; }
    public TrackType TrackType { get; set; }
    public string ResetReason { get; set; }  // "SpawnWait", "PlayerDeath", "TargetSwitch"
}

// 在暂停/恢复时发送
if (context.NotificationService?.IsAvailable == true)
{
    var resetEvent = new TrackResetEventDto
    {
        BattleId = context.Battle.Id,
        EventTime = Clock.CurrentTime,
        TrackType = TrackType.Attack,
        ResetReason = "SpawnWait"
    };
    _ = context.NotificationService.NotifyEventAsync(context.Battle.Id, resetEvent);
}
```

**推荐**: 方案A先行，如果前端需要更详细的信息再实现方案B

### 5.2 边缘情况处理

| 场景 | 当前行为 | 期望行为 | 处理方案 |
|-----|---------|---------|---------|
| 战斗开始时无怪物 | 不会发生 | N/A | 配置校验 |
| 刷新延迟为0 | 立即刷新 | 立即恢复攻击 | 检查 delay=0 的情况 |
| 玩家死亡期间怪物刷新 | 怪物出现但玩家未攻击 | 保持暂停直到复活 | 检查玩家状态 |
| 多波次快速切换 | 可能重复调度事件 | 避免重复 | 检查事件是否已调度 |
| 离线战斗恢复 | 按快照恢复 | 正确计算初始延迟 | 验证离线兼容性 |

---

## 影响范围评估

### 6.1 代码影响

| 文件 | 修改类型 | 影响程度 | 风险等级 |
|-----|---------|---------|---------|
| BattleEngine.cs | 修改构造函数、新增方法 | 高 | 中 |
| AttackTickEvent.cs | 修改目标选择逻辑 | 中 | 低 |
| SpecialPulseEvent.cs | 可能需要修改（取决于需求） | 中 | 低 |
| IProfessionModule.cs | 添加配置属性 | 低 | 低 |
| BattleContext.cs | 可能添加CurrentAttackTarget | 低 | 低 |
| 各职业Module | 实现新配置 | 低 | 低 |
| 前端 Characters.razor | 可能需要处理新事件 | 低 | 低 |

### 6.2 功能影响

**受影响的功能**:
1. ✅ 所有新创建的战斗
2. ✅ 持续模式战斗（刷新机制）
3. ✅ 地城战斗（波次切换）
4. ✅ 离线战斗快进
5. ✅ 战斗状态恢复
6. ✅ 前端进度条显示

**不受影响的功能**:
1. ✅ 伤害计算
2. ✅ Buff 系统
3. ✅ 技能冷却
4. ✅ 掉落系统
5. ✅ 经济系统

### 6.3 性能影响

**预期性能变化**:
- ✅ CPU: 无明显变化（增加的检查可忽略不计）
- ✅ 内存: 可能增加一个 `CurrentAttackTarget` 引用（8字节）
- ✅ 网络: 如果添加新的 SignalR 事件，略微增加
- ✅ 事件队列: 无变化

**优化点**:
- 刷新等待时暂停攻击，减少无效事件执行
- 目标锁定减少目标选择的调用次数

---

## 风险评估

### 7.1 技术风险

| 风险 | 描述 | 概率 | 影响 | 缓解措施 |
|-----|------|-----|-----|---------|
| R1 | 初始延迟导致DPS计算偏差 | 中 | 中 | 更新DPS计算逻辑，考虑初始延迟 |
| R2 | 离线战斗兼容性问题 | 中 | 高 | 详细测试离线快进和状态恢复 |
| R3 | 目标锁定导致怪物切换不及时 | 低 | 中 | 在怪物死亡时立即更新目标 |
| R4 | 刷新暂停导致事件重复调度 | 低 | 中 | 检查 NextTriggerAt 状态 |
| R5 | 前端进度条显示异常 | 低 | 低 | 复用现有的平滑进度逻辑 |

### 7.2 用户体验风险

| 风险 | 描述 | 概率 | 影响 | 缓解措施 |
|-----|------|-----|-----|---------|
| U1 | 战斗开始变慢的感觉 | 高 | 低 | 这是预期行为，符合用户需求 |
| U2 | 刷新等待期间进度条停滞 | 低 | 低 | 前端显示"等待刷新"状态 |
| U3 | 特殊轨道行为不符合职业预期 | 低 | 中 | 提供配置，支持职业自定义 |

### 7.3 兼容性风险

| 风险 | 描述 | 概率 | 影响 | 缓解措施 |
|-----|------|-----|-----|---------|
| C1 | 现有测试用例失败 | 高 | 中 | 更新测试用例以匹配新行为 |
| C2 | 现有战斗快照恢复异常 | 中 | 高 | 添加兼容性检查和迁移逻辑 |
| C3 | API 破坏性变更 | 低 | 高 | 保持 API 向后兼容 |

---

## 总结

本次战斗循环优化旨在改善玩家体验，使攻击时机更加合理，目标选择更加一致，刷新等待更加自然。

**关键改进点**:
1. ✅ 战斗开始时等待完整攻击间隔
2. ✅ 攻击和技能使用一致的目标
3. ✅ 刷新等待时暂停攻击
4. ✅ 特殊轨道行为可配置
5. ✅ 前端实时反馈进度重置

**推荐实施策略**:
- 分阶段实施（上、中、下三部分）
- 每个阶段完成后充分测试
- 保持向后兼容性
- 及时收集用户反馈

下一步：详细的分阶段实施方案。
