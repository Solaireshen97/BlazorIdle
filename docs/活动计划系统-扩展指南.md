# 活动计划系统扩展指南

本文档面向开发者，说明如何扩展活动计划系统以支持新的活动类型和功能。

## 目录

1. [添加新的活动类型](#添加新的活动类型)
2. [自定义限制条件](#自定义限制条件)
3. [添加活动互斥规则](#添加活动互斥规则)
4. [实现持久化](#实现持久化)
5. [集成离线快进](#集成离线快进)
6. [高级功能](#高级功能)

## 添加新的活动类型

以采集（Gather）活动为例，展示如何添加新的活动类型。

### 步骤1：更新 ActivityType 枚举

```csharp
// Domain/Activity/ActivityType.cs
public enum ActivityType
{
    Combat = 0,
    Gather = 1,    // 已预留
    Craft = 2      // 已预留
}
```

### 步骤2：创建领域服务（如果需要）

```csharp
// Domain/Gathering/GatheringService.cs
public sealed class GatheringService
{
    private readonly Dictionary<Guid, GatherSession> _sessions = new();
    
    public Guid StartSession(Guid characterId, string nodeId, double gatherSpeed = 1.0)
    {
        var session = new GatherSession
        {
            Id = Guid.NewGuid(),
            CharacterId = characterId,
            NodeId = nodeId,
            GatherSpeed = gatherSpeed,
            StartTime = DateTime.UtcNow
        };
        
        _sessions[session.Id] = session;
        return session.Id;
    }
    
    public void Advance(Guid sessionId, double deltaSeconds)
    {
        if (!_sessions.TryGetValue(sessionId, out var session))
            return;
        
        session.ElapsedSeconds += deltaSeconds;
        
        // 简化的采集逻辑
        double gatherInterval = 5.0 / session.GatherSpeed; // 5秒采集一次
        while (session.LastGatherTime + gatherInterval <= session.ElapsedSeconds)
        {
            session.GatheredCount++;
            session.LastGatherTime += gatherInterval;
        }
    }
    
    public GatherSession? GetSession(Guid sessionId)
    {
        _sessions.TryGetValue(sessionId, out var session);
        return session;
    }
    
    public void StopSession(Guid sessionId)
    {
        _sessions.TryRemove(sessionId, out _);
    }
}

public sealed class GatherSession
{
    public Guid Id { get; init; }
    public Guid CharacterId { get; init; }
    public string NodeId { get; init; } = "";
    public double GatherSpeed { get; init; } = 1.0;
    public DateTime StartTime { get; init; }
    public double ElapsedSeconds { get; set; }
    public int GatheredCount { get; set; }
    public double LastGatherTime { get; set; }
}
```

### 步骤3：实现 IActivityExecutor

```csharp
// Application/Activities/GatherActivityExecutor.cs
public sealed class GatherActivityExecutor : IActivityExecutor
{
    private readonly GatheringService _gatheringService;
    
    public ActivityType SupportedType => ActivityType.Gather;
    
    public GatherActivityExecutor(GatheringService gatheringService)
    {
        _gatheringService = gatheringService;
    }
    
    public async Task<ActivityExecutionContext> StartAsync(ActivityPlan plan, CancellationToken ct = default)
    {
        if (plan.Type != ActivityType.Gather)
            throw new InvalidOperationException($"GatherActivityExecutor only supports Gather activities");
        
        // 解析采集载荷
        var payload = JsonSerializer.Deserialize<GatherPayload>(plan.PayloadJson) 
            ?? throw new InvalidOperationException("Invalid gather payload");
        
        // 启动采集会话
        var sessionId = _gatheringService.StartSession(
            plan.CharacterId, 
            payload.NodeId, 
            payload.GatherSpeed ?? 1.0
        );
        
        var context = new ActivityExecutionContext
        {
            PlanId = plan.Id,
            UnderlyingExecutionId = sessionId
        };
        
        context.Data["nodeId"] = payload.NodeId;
        return context;
    }
    
    public async Task AdvanceAsync(ActivityPlan plan, ActivityExecutionContext context, CancellationToken ct = default)
    {
        if (context.UnderlyingExecutionId is null)
            return;
        
        var sessionId = context.UnderlyingExecutionId.Value;
        var session = _gatheringService.GetSession(sessionId);
        
        if (session is null)
            return;
        
        // 推进采集
        var deltaSeconds = (DateTime.UtcNow - context.LastUpdatedAtUtc).TotalSeconds;
        _gatheringService.Advance(sessionId, deltaSeconds);
        
        // 更新活动进度
        plan.UpdateProgress(session.ElapsedSeconds, session.GatheredCount);
        context.LastUpdatedAtUtc = DateTime.UtcNow;
        
        await Task.CompletedTask;
    }
    
    public Task StopAsync(ActivityPlan plan, ActivityExecutionContext context, CancellationToken ct = default)
    {
        if (context.UnderlyingExecutionId.HasValue)
        {
            _gatheringService.StopSession(context.UnderlyingExecutionId.Value);
        }
        return Task.CompletedTask;
    }
    
    public async Task<bool> CheckCompletionAsync(ActivityPlan plan, ActivityExecutionContext context, CancellationToken ct = default)
    {
        if (context.UnderlyingExecutionId is null)
            return true;
        
        var sessionId = context.UnderlyingExecutionId.Value;
        var session = _gatheringService.GetSession(sessionId);
        
        if (session is null)
            return true;
        
        // 检查是否达到限制
        return plan.IsLimitReached();
    }
}

public sealed class GatherPayload
{
    public string NodeId { get; set; } = "";
    public double? GatherSpeed { get; set; }
}
```

### 步骤4：注册服务

```csharp
// Application/DependencyInjection.cs
public static IServiceCollection AddApplication(this IServiceCollection services)
{
    // ... 现有注册
    
    // 采集服务
    services.AddSingleton<GatheringService>();
    services.AddSingleton<IActivityExecutor, GatherActivityExecutor>();
    
    return services;
}
```

### 步骤5：使用新活动类型

```csharp
var plan = coordinator.CreatePlan(
    characterId: characterId,
    slotIndex: 1,
    type: ActivityType.Gather,
    limit: new CountLimit(50), // 采集50次
    payloadJson: JsonSerializer.Serialize(new {
        nodeId = "iron_ore",
        gatherSpeed = 1.5
    })
);
```

## 自定义限制条件

### 示例：经验值限制

```csharp
// Domain/Activity/LimitSpec.cs (添加到现有文件)

/// <summary>
/// 经验值限制：达到指定经验值停止
/// </summary>
public sealed class ExperienceLimit : LimitSpec
{
    public long TargetExperience { get; init; }
    
    public ExperienceLimit(long experience)
    {
        TargetExperience = Math.Max(0, experience);
    }
    
    public override bool IsReached(ActivityProgress progress)
    {
        if (progress.CustomData.TryGetValue("experience", out var exp) && exp is long expValue)
        {
            return expValue >= TargetExperience;
        }
        return false;
    }
    
    public override string GetLimitType() => "Experience";
}
```

### 使用自定义限制

```csharp
var plan = coordinator.CreatePlan(
    characterId: characterId,
    slotIndex: 0,
    type: ActivityType.Combat,
    limit: new ExperienceLimit(10000), // 获得10000经验停止
    payloadJson: combatPayload
);

// 在执行器中更新自定义数据
plan.Progress.CustomData["experience"] = currentExperience;
```

### 示例：组合限制

```csharp
/// <summary>
/// 组合限制：满足任一子限制即达到
/// </summary>
public sealed class AnyLimit : LimitSpec
{
    public List<LimitSpec> SubLimits { get; init; } = new();
    
    public AnyLimit(params LimitSpec[] limits)
    {
        SubLimits.AddRange(limits);
    }
    
    public override bool IsReached(ActivityProgress progress)
    {
        return SubLimits.Any(limit => limit.IsReached(progress));
    }
    
    public override string GetLimitType() => "Any";
}

// 使用示例：打1小时或击杀100个，先达到哪个就停止
var limit = new AnyLimit(
    new DurationLimit(3600),
    new CountLimit(100)
);
```

## 添加活动互斥规则

### 扩展 ActivityPlan

```csharp
// Domain/Activity/ActivityPlan.cs (扩展)
public sealed class ActivityPlan
{
    // ... 现有属性
    
    /// <summary>活动类别（用于互斥检查）</summary>
    public string ActivityClass { get; set; } = "default";
    
    /// <summary>互斥标签列表</summary>
    public List<string> ExclusionTags { get; init; } = new();
    
    /// <summary>优先级（数值越大优先级越高）</summary>
    public int Priority { get; set; } = 0;
}
```

### 在 ActivityCoordinator 中实现互斥检查

```csharp
// Application/Activities/ActivityCoordinator.cs (扩展)
public sealed class ActivityCoordinator
{
    // ... 现有代码
    
    /// <summary>
    /// 检查活动是否与当前运行的活动冲突
    /// </summary>
    private bool HasConflict(ActivityPlan newPlan)
    {
        var characterPlans = _plans.Values
            .Where(p => p.CharacterId == newPlan.CharacterId && p.State == ActivityState.Running)
            .ToList();
        
        foreach (var existing in characterPlans)
        {
            // 检查活动类别冲突
            if (newPlan.ActivityClass == existing.ActivityClass)
                return true;
            
            // 检查互斥标签冲突
            if (newPlan.ExclusionTags.Any(tag => existing.ExclusionTags.Contains(tag)))
                return true;
        }
        
        return false;
    }
    
    /// <summary>
    /// 创建活动计划（带冲突检查）
    /// </summary>
    public ActivityPlan CreatePlanWithConflictCheck(
        Guid characterId,
        int slotIndex,
        ActivityType type,
        LimitSpec limit,
        string payloadJson,
        string activityClass = "default",
        List<string>? exclusionTags = null,
        int priority = 0)
    {
        var plan = new ActivityPlan
        {
            CharacterId = characterId,
            SlotIndex = slotIndex,
            Type = type,
            Limit = limit,
            PayloadJson = payloadJson,
            ActivityClass = activityClass,
            Priority = priority
        };
        
        if (exclusionTags != null)
        {
            plan.ExclusionTags.AddRange(exclusionTags);
        }
        
        // 检查冲突
        if (HasConflict(plan))
        {
            throw new InvalidOperationException(
                $"Activity conflicts with existing activities. Class: {activityClass}");
        }
        
        _plans[plan.Id] = plan;
        
        // 根据优先级插入队列
        var slots = EnsureCharacterSlots(characterId);
        var slot = slots[slotIndex];
        
        if (slot.IsIdle)
        {
            slot.StartPlan(plan.Id);
        }
        else
        {
            InsertByPriority(slot, plan.Id);
        }
        
        return plan;
    }
    
    private void InsertByPriority(ActivitySlot slot, Guid planId)
    {
        if (!_plans.TryGetValue(planId, out var newPlan))
        {
            slot.EnqueuePlan(planId);
            return;
        }
        
        // 按优先级插入
        int insertIndex = 0;
        for (int i = 0; i < slot.QueuedPlanIds.Count; i++)
        {
            if (_plans.TryGetValue(slot.QueuedPlanIds[i], out var existing))
            {
                if (newPlan.Priority > existing.Priority)
                {
                    insertIndex = i;
                    break;
                }
            }
            insertIndex = i + 1;
        }
        
        slot.QueuedPlanIds.Insert(insertIndex, planId);
    }
}
```

### 使用互斥规则

```csharp
// 战斗类活动互斥
var combatPlan = coordinator.CreatePlanWithConflictCheck(
    characterId: characterId,
    slotIndex: 0,
    type: ActivityType.Combat,
    limit: new DurationLimit(3600),
    payloadJson: combatPayload,
    activityClass: "combat",
    exclusionTags: new List<string> { "requires_full_attention" }
);

// 采集活动可以并行（不同类别）
var gatherPlan = coordinator.CreatePlanWithConflictCheck(
    characterId: characterId,
    slotIndex: 1,
    type: ActivityType.Gather,
    limit: new CountLimit(50),
    payloadJson: gatherPayload,
    activityClass: "gather"
);

// 高优先级战斗（会插队）
var urgentPlan = coordinator.CreatePlanWithConflictCheck(
    characterId: characterId,
    slotIndex: 0,
    type: ActivityType.Combat,
    limit: new DurationLimit(600),
    payloadJson: urgentPayload,
    activityClass: "combat",
    priority: 100
);
```

## 实现持久化

### 步骤1：创建数据库实体

```csharp
// Infrastructure/Persistence/Records/ActivityPlanRecord.cs
public sealed class ActivityPlanRecord
{
    public Guid Id { get; set; }
    public Guid CharacterId { get; set; }
    public int SlotIndex { get; set; }
    public string Type { get; set; } = ""; // ActivityType as string
    public string State { get; set; } = ""; // ActivityState as string
    public string LimitType { get; set; } = "";
    public string LimitValueJson { get; set; } = "{}";
    public string PayloadJson { get; set; } = "{}";
    public DateTime CreatedAtUtc { get; set; }
    public DateTime? StartedAtUtc { get; set; }
    public DateTime? EndedAtUtc { get; set; }
    
    // 进度
    public double ProgressSimulatedSeconds { get; set; }
    public int ProgressCompletedCount { get; set; }
    public string ProgressCustomDataJson { get; set; } = "{}";
    
    // 运行时上下文
    public Guid? UnderlyingExecutionId { get; set; }
    public string RuntimeContextJson { get; set; } = "{}";
}
```

### 步骤2：创建仓储接口

```csharp
// Application/Abstractions/IActivityRepository.cs
public interface IActivityRepository
{
    Task<ActivityPlanRecord?> GetAsync(Guid id, CancellationToken ct = default);
    Task<List<ActivityPlanRecord>> GetByCharacterAsync(Guid characterId, CancellationToken ct = default);
    Task AddAsync(ActivityPlanRecord record, CancellationToken ct = default);
    Task UpdateAsync(ActivityPlanRecord record, CancellationToken ct = default);
    Task DeleteAsync(Guid id, CancellationToken ct = default);
}
```

### 步骤3：实现仓储

```csharp
// Infrastructure/Persistence/ActivityRepository.cs
public sealed class ActivityRepository : IActivityRepository
{
    private readonly ApplicationDbContext _db;
    
    public ActivityRepository(ApplicationDbContext db)
    {
        _db = db;
    }
    
    public async Task<ActivityPlanRecord?> GetAsync(Guid id, CancellationToken ct = default)
    {
        return await _db.ActivityPlans.FindAsync(new object[] { id }, ct);
    }
    
    public async Task<List<ActivityPlanRecord>> GetByCharacterAsync(Guid characterId, CancellationToken ct = default)
    {
        return await _db.ActivityPlans
            .Where(p => p.CharacterId == characterId)
            .ToListAsync(ct);
    }
    
    public async Task AddAsync(ActivityPlanRecord record, CancellationToken ct = default)
    {
        _db.ActivityPlans.Add(record);
        await _db.SaveChangesAsync(ct);
    }
    
    public async Task UpdateAsync(ActivityPlanRecord record, CancellationToken ct = default)
    {
        _db.ActivityPlans.Update(record);
        await _db.SaveChangesAsync(ct);
    }
    
    public async Task DeleteAsync(Guid id, CancellationToken ct = default)
    {
        var record = await GetAsync(id, ct);
        if (record != null)
        {
            _db.ActivityPlans.Remove(record);
            await _db.SaveChangesAsync(ct);
        }
    }
}
```

### 步骤4：在 ActivityCoordinator 中集成持久化

```csharp
// Application/Activities/ActivityCoordinator.cs (扩展)
public sealed class ActivityCoordinator
{
    private readonly IActivityRepository? _repository;
    
    public ActivityCoordinator(
        IEnumerable<IActivityExecutor> executors, 
        int slotsPerCharacter = 3,
        IActivityRepository? repository = null)
    {
        // ... 现有初始化
        _repository = repository;
    }
    
    public async Task<ActivityPlan> CreateAndPersistPlanAsync(
        Guid characterId,
        int slotIndex,
        ActivityType type,
        LimitSpec limit,
        string payloadJson,
        CancellationToken ct = default)
    {
        var plan = CreatePlan(characterId, slotIndex, type, limit, payloadJson);
        
        if (_repository != null)
        {
            var record = MapToRecord(plan);
            await _repository.AddAsync(record, ct);
        }
        
        return plan;
    }
    
    public async Task LoadCharacterPlansAsync(Guid characterId, CancellationToken ct = default)
    {
        if (_repository == null)
            return;
        
        var records = await _repository.GetByCharacterAsync(characterId, ct);
        
        foreach (var record in records.Where(r => r.State == "Pending" || r.State == "Running"))
        {
            var plan = MapFromRecord(record);
            _plans[plan.Id] = plan;
            
            // 恢复槽位状态
            var slots = EnsureCharacterSlots(characterId);
            var slot = slots[plan.SlotIndex];
            
            if (record.State == "Running")
            {
                slot.StartPlan(plan.Id);
            }
            else
            {
                slot.EnqueuePlan(plan.Id);
            }
        }
    }
    
    private ActivityPlanRecord MapToRecord(ActivityPlan plan)
    {
        return new ActivityPlanRecord
        {
            Id = plan.Id,
            CharacterId = plan.CharacterId,
            SlotIndex = plan.SlotIndex,
            Type = plan.Type.ToString(),
            State = plan.State.ToString(),
            LimitType = plan.Limit.GetLimitType(),
            LimitValueJson = SerializeLimitValue(plan.Limit),
            PayloadJson = plan.PayloadJson,
            CreatedAtUtc = plan.CreatedAtUtc,
            StartedAtUtc = plan.StartedAtUtc,
            EndedAtUtc = plan.EndedAtUtc,
            ProgressSimulatedSeconds = plan.Progress.SimulatedSeconds,
            ProgressCompletedCount = plan.Progress.CompletedCount,
            ProgressCustomDataJson = JsonSerializer.Serialize(plan.Progress.CustomData)
        };
    }
    
    private ActivityPlan MapFromRecord(ActivityPlanRecord record)
    {
        // 重建 LimitSpec
        var limit = DeserializeLimit(record.LimitType, record.LimitValueJson);
        
        var plan = new ActivityPlan
        {
            CharacterId = record.CharacterId,
            SlotIndex = record.SlotIndex,
            Type = Enum.Parse<ActivityType>(record.Type),
            Limit = limit,
            PayloadJson = record.PayloadJson
        };
        
        // 恢复状态和进度
        typeof(ActivityPlan).GetProperty("State")!
            .SetValue(plan, Enum.Parse<ActivityState>(record.State));
        plan.UpdateProgress(record.ProgressSimulatedSeconds, record.ProgressCompletedCount);
        
        return plan;
    }
}
```

## 集成离线快进

### 步骤1：扩展 ActivityCoordinator

```csharp
// Application/Activities/ActivityCoordinator.cs (扩展)
public sealed class ActivityCoordinator
{
    public async Task ProcessOfflinePeriodAsync(
        Guid characterId,
        DateTime lastOnlineUtc,
        DateTime nowUtc,
        CancellationToken ct = default)
    {
        var offlineSeconds = (nowUtc - lastOnlineUtc).TotalSeconds;
        offlineSeconds = Math.Min(offlineSeconds, 12 * 3600); // 最多12小时
        
        // 加载角色的活动计划
        await LoadCharacterPlansAsync(characterId, ct);
        
        var slots = GetCharacterSlots(characterId);
        
        foreach (var slot in slots)
        {
            if (slot.CurrentPlanId.HasValue && _plans.TryGetValue(slot.CurrentPlanId.Value, out var plan))
            {
                if (plan.State == ActivityState.Running)
                {
                    // 快进执行
                    await FastForwardPlanAsync(plan, offlineSeconds, ct);
                }
            }
        }
    }
    
    private async Task FastForwardPlanAsync(ActivityPlan plan, double seconds, CancellationToken ct)
    {
        if (!_executors.TryGetValue(plan.Type, out var executor))
            return;
        
        // 对于战斗活动，使用现有的 FastForward 机制
        if (plan.Type == ActivityType.Combat && _contexts.TryGetValue(plan.Id, out var context))
        {
            var battleId = context.UnderlyingExecutionId;
            if (battleId.HasValue)
            {
                // 利用 StepBattleCoordinator 的 FastForward 功能
                // 这里需要扩展 StepBattleCoordinator 支持离线快进
            }
        }
        
        // 简化版：直接推进进度
        var targetSeconds = plan.Progress.SimulatedSeconds + seconds;
        while (plan.Progress.SimulatedSeconds < targetSeconds && !plan.IsLimitReached())
        {
            var deltaSeconds = Math.Min(60, targetSeconds - plan.Progress.SimulatedSeconds);
            plan.UpdateProgress(
                plan.Progress.SimulatedSeconds + deltaSeconds,
                plan.Progress.CompletedCount + (int)(deltaSeconds / 10) // 简化计算
            );
            
            if (plan.IsLimitReached())
            {
                plan.Complete();
                break;
            }
        }
    }
}
```

## 高级功能

### 1. 条件触发

```csharp
// Domain/Activity/ActivityTrigger.cs
public abstract class ActivityTrigger
{
    public abstract bool ShouldTrigger(ActivityContext context);
}

public sealed class HealthPercentageTrigger : ActivityTrigger
{
    public double ThresholdPercentage { get; init; }
    
    public override bool ShouldTrigger(ActivityContext context)
    {
        if (context.Data.TryGetValue("healthPercentage", out var hp) && hp is double healthPct)
        {
            return healthPct <= ThresholdPercentage;
        }
        return false;
    }
}

// 使用示例：血量低于30%时自动切换到防御活动
var trigger = new HealthPercentageTrigger { ThresholdPercentage = 0.3 };
```

### 2. 循环队列

```csharp
// Domain/Activity/ActivitySlot.cs (扩展)
public sealed class ActivitySlot
{
    public bool LoopQueue { get; set; } = false;
    
    public Guid? FinishCurrentAndGetNext()
    {
        var completedId = CurrentPlanId;
        CurrentPlanId = null;
        
        if (QueuedPlanIds.Count > 0)
        {
            var nextId = QueuedPlanIds[0];
            QueuedPlanIds.RemoveAt(0);
            
            // 如果开启循环，将完成的计划加回队列
            if (LoopQueue && completedId.HasValue)
            {
                QueuedPlanIds.Add(completedId.Value);
            }
            
            return nextId;
        }
        
        return null;
    }
}
```

### 3. 活动模板

```csharp
// Domain/Activity/ActivityTemplate.cs
public sealed class ActivityTemplate
{
    public Guid Id { get; init; } = Guid.NewGuid();
    public string Name { get; set; } = "";
    public string Description { get; set; } = "";
    public ActivityType Type { get; init; }
    public string LimitType { get; set; } = "";
    public double LimitValue { get; set; }
    public string PayloadJson { get; set; } = "{}";
    
    public ActivityPlan CreatePlan(Guid characterId, int slotIndex)
    {
        var limit = LimitType.ToLowerInvariant() switch
        {
            "duration" => new DurationLimit(LimitValue),
            "count" => new CountLimit((int)LimitValue),
            _ => new InfiniteLimit()
        };
        
        return new ActivityPlan
        {
            CharacterId = characterId,
            SlotIndex = slotIndex,
            Type = Type,
            Limit = limit,
            PayloadJson = PayloadJson
        };
    }
}

// 使用示例
var template = new ActivityTemplate
{
    Name = "夜间挂机",
    Description = "打dummy 8小时",
    Type = ActivityType.Combat,
    LimitType = "duration",
    LimitValue = 28800,
    PayloadJson = "{\"enemyId\":\"dummy\",\"mode\":\"continuous\"}"
};

var plan = template.CreatePlan(characterId, 0);
```

## 总结

通过本指南，你可以：

✅ 添加新的活动类型（采集、制作等）  
✅ 实现自定义限制条件  
✅ 添加活动互斥和优先级规则  
✅ 实现活动计划的持久化  
✅ 集成离线快进机制  
✅ 实现高级功能（条件触发、循环队列、模板）  

活动计划系统的设计充分考虑了扩展性，所有核心功能都通过接口和抽象类暴露扩展点，便于未来添加新功能。
