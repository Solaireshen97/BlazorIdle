# BlazorIdle 重构路线图（上篇）：现状分析与基础架构规划

**文档版本**: 1.0  
**生成日期**: 2025年10月  
**状态**: 规划文档  
**目标**: 建立稳定的底层架构，为功能实现奠定坚实基础

---

## 📋 目录

1. [项目现状评估](#项目现状评估)
2. [核心问题识别](#核心问题识别)
3. [架构失控点分析](#架构失控点分析)
4. [重构目标与原则](#重构目标与原则)
5. [基础架构层规划](#基础架构层规划)
6. [技术选型确认](#技术选型确认)

---

## 项目现状评估

### 整体完成度分析

基于对项目代码和文档的深入分析，当前项目状态如下：

| 模块层级 | 完成度 | 质量评估 | 问题严重度 |
|---------|--------|---------|-----------|
| **核心战斗引擎** | 🟢 75% | 优秀 | 🟢 轻微 |
| **事件调度系统** | 🟢 90% | 优秀 | 🟢 轻微 |
| **资源与Buff系统** | 🟢 85% | 良好 | 🟡 中等 |
| **技能系统** | 🟢 80% | 良好 | 🟡 中等 |
| **SignalR推送** | 🟡 60% | 一般 | 🔴 严重 |
| **数据库层** | 🟡 50% | 一般 | 🔴 严重 |
| **缓存系统** | 🟡 40% | 较差 | 🔴 严重 |
| **装备系统** | 🔴 10% | 未完善 | 🟡 中等 |
| **活动计划** | 🔴 0% | 缺失 | 🔴 严重 |
| **离线收益** | 🔴 0% | 缺失 | 🔴 严重 |

**总体评估**: 
- ✅ **战斗核心**实现质量高，事件调度机制优秀
- ⚠️ **基础设施层**（SignalR、数据库、缓存）混乱，需要重构
- ❌ **核心玩法**（离线、活动、装备）大部分未实现

### 已完成的优质模块

#### 1. 事件调度核心 ⭐⭐⭐⭐⭐
**位置**: `Domain/Combat/EventScheduler.cs`, `GameClock.cs`

**优点**:
```
✅ 基于优先队列的确定性时间推进
✅ 支持事件回放与离线模拟
✅ 性能优异（O(log n)复杂度）
✅ 代码清晰，测试完善
```

**评价**: 这是项目最核心的基础，**无需重构，保持原样**。

---

#### 2. 双轨战斗系统 ⭐⭐⭐⭐⭐
**位置**: `Domain/Combat/TrackState.cs`, 战斗事件类

**优点**:
```
✅ Attack Track + Special Track 独立节奏
✅ 急速系数动态调整机制完善
✅ 与资源系统、技能系统集成良好
```

**评价**: 设计优秀，**保留并作为核心机制继续发展**。

---

#### 3. 资源桶系统 ⭐⭐⭐⭐
**位置**: `Domain/Combat/Resources/ResourceBucket.cs`

**优点**:
```
✅ 溢出策略（Clamp/Convert/Ignore）设计灵活
✅ 支持资源转换（如怒气→战意Buff）
✅ 统计反馈完善
```

**评价**: 核心机制完整，**仅需补充监控与统计输出**。

---

#### 4. 技能与Buff系统 ⭐⭐⭐⭐
**位置**: `Domain/Combat/Skills/`, `Domain/Combat/Buffs/`

**优点**:
```
✅ 多充能机制实现完善
✅ Buff叠加策略清晰
✅ 自动施放引擎可扩展
```

**评价**: 基础扎实，**待优化配置化与数据驱动**。

---

## 核心问题识别

### 🔴 严重问题：基础设施层混乱

#### 问题1: SignalR架构不清晰

**现象**:
```
❌ Hub职责过重，包含业务逻辑
❌ 连接管理与推送逻辑耦合
❌ 缺少统一的消息分发机制
❌ 前端订阅关系混乱
❌ 无连接恢复与重连策略
```

**影响**:
```
⚠️ 难以维护和扩展
⚠️ 推送逻辑散落各处
⚠️ 前端状态同步不可靠
⚠️ 性能问题难以定位
```

**根因**: SignalR从战术工具变成战略基础设施，但未系统性设计。

---

#### 问题2: 数据库访问混乱

**现象**:
```
❌ DbContext直接在业务层使用
❌ 查询逻辑散落各处
❌ 缺少统一的Repository抽象
❌ 事务边界不清晰
❌ 读写未分离
❌ 批量操作性能差
```

**影响**:
```
⚠️ N+1查询问题频发
⚠️ 数据库压力大
⚠️ 难以优化性能
⚠️ 单元测试困难
```

**根因**: 缺少持久化层抽象，领域层与数据访问层耦合。

---

#### 问题3: 缓存系统不完善

**现象**:
```
❌ 多层缓存（MemoryCache、分布式缓存）未统一
❌ 缓存失效策略不清晰
❌ 缓存穿透、雪崩风险
❌ 缓存与数据库一致性问题
❌ 缓存监控缺失
```

**影响**:
```
⚠️ 缓存命中率低
⚠️ 数据一致性问题
⚠️ 性能提升不明显
⚠️ 故障难以排查
```

**根因**: 缓存作为事后补充，未从架构层面规划。

---

### 🟡 中等问题：配置与数据管理

#### 问题4: 配置管理混乱

**现象**:
```
⚠️ 技能、装备、敌人定义硬编码
⚠️ 无版本管理机制
⚠️ 配置变更需要重新编译
⚠️ 无法热更新
```

**影响**: 内容更新成本高，无法快速迭代。

---

#### 问题5: 事件溯源不完整

**现象**:
```
⚠️ 仅有BattleRecord，无完整事件流
⚠️ 缺少CharacterSnapshot机制
⚠️ 离线补算无基础数据
```

**影响**: 无法实现离线收益，无法审计玩家行为。

---

## 架构失控点分析

### 失控原因溯源

#### 1. 增量开发的技术债累积

```
初期阶段: 快速验证战斗机制 ✅
  ↓
中期阶段: 添加SignalR推送 ⚠️ (未抽象)
  ↓
扩展阶段: 添加缓存优化 ⚠️ (缺少规划)
  ↓
当前状态: 基础设施混乱 ❌ (失去掌控)
```

**教训**: 基础设施需要前瞻性设计，不能事后补充。

---

#### 2. 横向扩展时缺少抽象层

```
数据库访问:
  初期: DbContext直接使用 (简单快速)
    ↓
  扩展: 多个Service直接查询 (开始重复)
    ↓
  现在: 查询逻辑散落各处 (维护困难)
```

**教训**: 及早引入Repository/UnitOfWork模式。

---

#### 3. 推送机制缺少统一规划

```
SignalR使用:
  初期: Hub简单推送战斗结果
    ↓
  扩展: 多个业务模块都用SignalR
    ↓
  现在: Hub职责混乱，推送逻辑重复
```

**教训**: 需要消息总线抽象，统一推送管道。

---

## 重构目标与原则

### 重构目标

#### 短期目标（1-2个月）
```
🎯 建立清晰的基础设施层
🎯 统一SignalR推送机制
🎯 重构数据库访问层
🎯 完善缓存系统
🎯 建立配置管理框架
```

#### 中期目标（3-6个月）
```
🎯 实现离线收益系统
🎯 实现活动计划系统
🎯 完善装备系统
🎯 建立经济循环
```

#### 长期目标（6-12个月）
```
🎯 地图与区域系统
🎯 任务与声望系统
🎯 多角色管理
🎯 监控与诊断面板
```

---

### 重构原则

#### 原则1: 保留优质核心 ✅

```
✅ 保留: 事件调度器
✅ 保留: 双轨战斗系统
✅ 保留: 资源桶机制
✅ 保留: 技能与Buff系统
```

**理由**: 这些模块实现质量高，是项目的核心竞争力。

---

#### 原则2: 重构基础设施 🔧

```
🔧 重构: SignalR抽象层
🔧 重构: 数据库访问层
🔧 重构: 缓存系统
🔧 重构: 配置管理
```

**理由**: 基础设施混乱影响长期发展。

---

#### 原则3: 渐进式推进 📈

```
📈 Phase 0: 建立基础设施
📈 Phase 1: 迁移现有功能
📈 Phase 2: 实现新功能
📈 Phase 3: 优化与完善
```

**理由**: 避免Big Bang式重构风险。

---

#### 原则4: 最小化修改 🎯

```
🎯 仅修改基础设施层
🎯 业务逻辑层保持稳定
🎯 领域模型最小改动
🎯 API兼容性优先
```

**理由**: 降低重构风险，保持开发连续性。

---

## 基础架构层规划

### 架构分层重新定义

#### 新架构模型

```
┌─────────────────────────────────────────────────┐
│            Presentation Layer (前端)             │
│         Blazor WASM + SignalR Client            │
└────────────────────┬────────────────────────────┘
                     │
┌────────────────────▼────────────────────────────┐
│           Application Layer (应用层)             │
│     - API Controllers                           │
│     - SignalR Hubs (仅消息转发)                  │
│     - Application Services                      │
└────────────────────┬────────────────────────────┘
                     │
┌────────────────────▼────────────────────────────┐
│            Domain Layer (领域层)                 │
│     - Battle Engine                             │
│     - Event Scheduler                           │
│     - Skills & Buffs                            │
│     - Resources                                 │
└────────────────────┬────────────────────────────┘
                     │
┌────────────────────▼────────────────────────────┐
│        Infrastructure Layer (基础设施层)         │
│  ┌──────────────────────────────────────────┐  │
│  │    Messaging (消息总线)                    │  │
│  │  - IEventBus                              │  │
│  │  - SignalRMessageDispatcher               │  │
│  └──────────────────────────────────────────┘  │
│  ┌──────────────────────────────────────────┐  │
│  │    Persistence (持久化层)                  │  │
│  │  - IRepository<T>                         │  │
│  │  - IUnitOfWork                            │  │
│  │  - GameDbContext                          │  │
│  └──────────────────────────────────────────┘  │
│  ┌──────────────────────────────────────────┐  │
│  │    Caching (缓存层)                        │  │
│  │  - IMultiTierCache                        │  │
│  │  - CacheInvalidationCoordinator           │  │
│  └──────────────────────────────────────────┘  │
│  ┌──────────────────────────────────────────┐  │
│  │    Configuration (配置层)                  │  │
│  │  - IConfigProvider                        │  │
│  │  - ConfigVersionManager                   │  │
│  └──────────────────────────────────────────┘  │
└─────────────────────────────────────────────────┘
```

---

### 核心基础设施组件

#### 1. 消息总线 (Event Bus)

**职责**:
```
✅ 领域事件发布
✅ 事件订阅管理
✅ SignalR推送协调
✅ 事件持久化（可选）
```

**接口设计**:
```csharp
public interface IEventBus
{
    // 发布领域事件
    Task PublishAsync<TEvent>(TEvent @event) 
        where TEvent : IDomainEvent;
    
    // 订阅事件
    void Subscribe<TEvent>(Func<TEvent, Task> handler) 
        where TEvent : IDomainEvent;
    
    // 批量发布
    Task PublishBatchAsync<TEvent>(IEnumerable<TEvent> events) 
        where TEvent : IDomainEvent;
}
```

**实现要点**:
```
🔹 内存队列 + 异步处理
🔹 支持多订阅者
🔹 异常隔离（一个订阅者失败不影响其他）
🔹 支持事件持久化（用于审计）
```

---

#### 2. SignalR消息分发器

**职责**:
```
✅ 统一SignalR推送入口
✅ 连接管理与分组
✅ 推送策略（单播/组播/广播）
✅ 消息队列与批量发送
```

**接口设计**:
```csharp
public interface ISignalRDispatcher
{
    // 推送给特定用户
    Task SendToUserAsync(Guid userId, string method, object data);
    
    // 推送给组
    Task SendToGroupAsync(string groupName, string method, object data);
    
    // 批量推送
    Task SendBatchAsync(IEnumerable<SignalRMessage> messages);
    
    // 连接管理
    Task AddToGroupAsync(string connectionId, string groupName);
    Task RemoveFromGroupAsync(string connectionId, string groupName);
}
```

**实现要点**:
```
🔹 基于IHubContext<T>封装
🔹 消息队列避免阻塞
🔹 重试机制
🔹 推送统计与监控
```

---

#### 3. 持久化层抽象

**职责**:
```
✅ 统一数据访问入口
✅ 事务管理
✅ 查询优化
✅ 批量操作支持
```

**接口设计**:
```csharp
public interface IRepository<T> where T : class
{
    // 基础CRUD
    Task<T?> GetByIdAsync(Guid id);
    Task<IEnumerable<T>> GetAllAsync();
    Task AddAsync(T entity);
    Task UpdateAsync(T entity);
    Task DeleteAsync(Guid id);
    
    // 批量操作
    Task AddRangeAsync(IEnumerable<T> entities);
    Task UpdateRangeAsync(IEnumerable<T> entities);
    
    // 查询
    Task<IEnumerable<T>> FindAsync(Expression<Func<T, bool>> predicate);
}

public interface IUnitOfWork : IDisposable
{
    IRepository<T> Repository<T>() where T : class;
    Task<int> SaveChangesAsync();
    Task BeginTransactionAsync();
    Task CommitTransactionAsync();
    Task RollbackTransactionAsync();
}
```

**实现要点**:
```
🔹 基于EF Core实现
🔹 延迟加载与预加载策略
🔹 读写分离支持
🔹 批量操作优化（避免N+1查询）
```

---

#### 4. 多层缓存系统

**职责**:
```
✅ L1缓存（内存）
✅ L2缓存（分布式，可选）
✅ 缓存失效策略
✅ 缓存预热
✅ 缓存统计
```

**接口设计**:
```csharp
public interface IMultiTierCache
{
    // 基础操作
    Task<T?> GetAsync<T>(string key);
    Task SetAsync<T>(string key, T value, TimeSpan? expiration = null);
    Task RemoveAsync(string key);
    
    // 批量操作
    Task<IDictionary<string, T>> GetManyAsync<T>(IEnumerable<string> keys);
    Task SetManyAsync<T>(IDictionary<string, T> items, TimeSpan? expiration = null);
    
    // 失效策略
    Task InvalidateByPatternAsync(string pattern);
    Task InvalidateByTagAsync(string tag);
    
    // 统计
    CacheStatistics GetStatistics();
}
```

**实现要点**:
```
🔹 L1: IMemoryCache（进程内）
🔹 L2: Redis/Memcached（可选，未来）
🔹 自动降级（L2不可用时使用L1）
🔹 缓存预热策略
🔹 命中率监控
```

---

#### 5. 配置管理系统

**职责**:
```
✅ 配置数据加载
✅ 版本管理
✅ 热更新支持
✅ 配置验证
```

**接口设计**:
```csharp
public interface IConfigProvider
{
    // 获取配置
    T Get<T>(string key) where T : class;
    IEnumerable<T> GetAll<T>() where T : class;
    
    // 版本管理
    string GetCurrentVersion();
    Task<bool> LoadVersionAsync(string version);
    
    // 热更新
    Task ReloadAsync();
    event EventHandler<ConfigChangedEventArgs> OnConfigChanged;
}
```

**实现要点**:
```
🔹 JSON文件存储（初期）
🔹 数据库存储（未来）
🔹 配置预加载与缓存
🔹 配置校验机制
🔹 版本比对与Diff
```

---

## 技术选型确认

### 核心技术栈

| 层级 | 技术选型 | 理由 | 状态 |
|------|---------|------|------|
| **前端** | Blazor WebAssembly | ✅ 已选定，无需变更 | 保持 |
| **后端** | ASP.NET Core 6+ | ✅ 已选定，无需变更 | 保持 |
| **实时通信** | SignalR | ✅ 已选定，需要架构优化 | 优化 |
| **数据库** | SQLite (开发)<br>PostgreSQL (生产) | ✅ SQLite轻量，PostgreSQL稳定 | 保持/扩展 |
| **ORM** | Entity Framework Core | ✅ 已使用，需要抽象层 | 优化 |
| **缓存** | IMemoryCache<br>Redis (未来) | ✅ 内存缓存优先，分布式可选 | 扩展 |
| **配置** | JSON Files<br>Database (未来) | ✅ 初期文件，后期数据库 | 渐进 |
| **日志** | ILogger (内置) | ✅ 简单够用 | 保持 |
| **测试** | xUnit + Moq | ✅ 标准选择 | 保持 |

---

### 新增依赖包

#### 推荐引入

```xml
<!-- 消息总线 -->
<PackageReference Include="MediatR" Version="12.0.1" />

<!-- 内存缓存增强 -->
<PackageReference Include="Microsoft.Extensions.Caching.Memory" Version="8.0.0" />

<!-- 配置增强 -->
<PackageReference Include="Microsoft.Extensions.Configuration.Json" Version="8.0.0" />

<!-- 未来：分布式缓存 (可选) -->
<!-- <PackageReference Include="StackExchange.Redis" Version="2.7.0" /> -->

<!-- 未来：消息队列 (可选) -->
<!-- <PackageReference Include="RabbitMQ.Client" Version="6.8.1" /> -->
```

---

### 不建议引入

```
❌ 微服务框架（如Dapr） - 过度设计
❌ 复杂消息队列（如Kafka） - 初期不需要
❌ 多种ORM混用 - 增加复杂度
❌ GraphQL - 当前REST API足够
```

---

## 下一步行动

### 立即开始（本文档完成后）

```
📝 创建中篇文档：基础设施实施方案
   - SignalR重构详细方案
   - 数据库访问层重构方案
   - 缓存系统实施方案
   - 配置管理实施方案
```

### 准备工作

```
🔍 代码审计：标记需要重构的文件
📦 依赖整理：确认引入的新包
🗂️ 文件结构规划：新的目录组织
```

---

## 附录：术语表

| 术语 | 定义 |
|-----|------|
| **Event Bus** | 领域事件总线，用于模块间解耦通信 |
| **SignalR Dispatcher** | SignalR消息分发器，统一推送入口 |
| **Repository** | 仓储模式，封装数据访问逻辑 |
| **Unit of Work** | 工作单元模式，管理事务边界 |
| **Multi-Tier Cache** | 多层缓存，L1内存+L2分布式 |
| **Config Provider** | 配置提供者，管理游戏数据配置 |
| **Domain Event** | 领域事件，表示业务状态变化 |
| **Infrastructure Layer** | 基础设施层，提供技术支撑能力 |

---

**文档状态**: ✅ 完成  
**下一步**: 创建《重构路线图-中篇-基础设施实施方案》  
**预计完成时间**: 阅读本文档后立即开始

---

**重要提示**: 
- 本文档仅规划方向，不包含具体代码实现
- 重构遵循"渐进式"原则，避免大规模破坏性变更
- 保留优质核心模块（事件调度、战斗系统），重构基础设施层
- 所有变更需要经过代码审查和测试验证
