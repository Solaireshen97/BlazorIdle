# 数据库优化 - 生产环境监控指南

**文档版本**: 1.0  
**创建日期**: 2025-10-18  
**状态**: 生产环境监控指南  
**适用范围**: Phase 2 完成后的生产环境监控

---

## 📋 目录

1. [执行摘要](#执行摘要)
2. [关键监控指标](#关键监控指标)
3. [监控方法](#监控方法)
4. [预期性能基线](#预期性能基线)
5. [异常检测](#异常检测)
6. [故障排查](#故障排查)
7. [性能调优](#性能调优)

---

## 执行摘要

### 当前状态
✅ **Phase 1 & 2 已完成**  
✅ **内存缓冲已启用** (`EnableMemoryBuffering: true`)  
✅ **所有测试通过** (14/14)  

### 监控目标
- 验证97.9%的数据库写入减少是否实现
- 确认系统稳定性和性能改善
- 识别并解决任何异常情况
- 收集数据用于进一步优化

---

## 关键监控指标

### 1. 数据库写入频率

**重要性**: ⭐⭐⭐⭐⭐ 最关键指标

**监控方法**:
```bash
# 方法 1: 监控 WAL 文件大小变化
watch -n 5 'ls -lh /path/to/gamedata.db-wal'

# 方法 2: 使用 SQLite 内置工具
sqlite3 gamedata.db "PRAGMA wal_checkpoint(PASSIVE);"
```

**预期值**:
- 优化前: WAL 文件每分钟增长 ~30-50KB
- 优化后: WAL 文件每分钟增长 <2KB
- **改善: 95%+**

**告警阈值**:
- ⚠️ WARNING: WAL 增长速度 >10KB/min
- 🚨 CRITICAL: WAL 增长速度 >20KB/min

---

### 2. 内存使用情况

**重要性**: ⭐⭐⭐⭐

**监控方法**:
```bash
# 监控进程内存使用
watch -n 10 'ps aux | grep BlazorIdle.Server | grep -v grep'

# 或使用 dotnet-counters
dotnet-counters monitor --process-id <pid> System.Runtime
```

**预期值**:
- 优化前: ~200-300MB
- 优化后: ~250-400MB
- **增长: +50-150MB (可接受)**

**告警阈值**:
- ⚠️ WARNING: 内存使用 >500MB
- 🚨 CRITICAL: 内存使用 >800MB 或持续增长

**关键子指标**:
- GC Heap Size: 应保持稳定
- GC Frequency: 不应显著增加
- Gen 2 Collections: 应保持低频

---

### 3. API 响应时间

**重要性**: ⭐⭐⭐⭐

**监控端点**:
1. **心跳接口**: `POST /api/characters/{id}/heartbeat`
2. **战斗状态**: `GET /api/battles/step/{id}`
3. **活动计划**: `GET /api/activities/plans`

**预期值**:

| 端点 | 优化前 P95 | 优化后 P95 | 改善 |
|------|-----------|-----------|------|
| Heartbeat | ~150-300ms | <100ms | 40-60% |
| Battle Status | ~100-200ms | <80ms | 30-40% |
| Activity Plans | ~80-150ms | <60ms | 25-40% |

**监控方法**:
```bash
# 使用 Apache Bench 进行简单测试
ab -n 100 -c 10 http://localhost:5000/api/characters/{id}/heartbeat

# 或使用自定义脚本记录响应时间
```

**告警阈值**:
- ⚠️ WARNING: P95 响应时间回升到优化前水平
- 🚨 CRITICAL: P95 响应时间超过优化前水平 20%

---

### 4. 持久化协调器统计

**重要性**: ⭐⭐⭐⭐⭐

**监控方法**:
查看应用日志中的 PersistenceCoordinator 输出：

```bash
# 实时查看保存统计
tail -f /path/to/logs/app.log | grep "PersistenceCoordinator"
```

**预期日志输出**:
```
[INFO] 持久化协调器已启动，保存间隔：30000ms
[INFO] 开始批量保存：Characters(5), BattleSnapshots(3), ActivityPlans(2)
[INFO] 批量保存完成，耗时：45ms，成功：10，失败：0
[INFO] 统计信息：
  - 总dirty实体：10
  - Characters: 5 个 (保存间隔：300000ms)
  - BattleSnapshots: 3 个 (保存间隔：60000ms)
  - ActivityPlans: 2 个 (保存间隔：30000ms)
```

**关键指标**:
- 批量保存频率: 每30-60秒一次
- 每批实体数: 通常 5-20 个
- 保存耗时: <100ms
- 失败率: 0%

**告警阈值**:
- ⚠️ WARNING: 保存耗时 >200ms
- ⚠️ WARNING: 单批实体数 >100 (可能有内存泄漏)
- 🚨 CRITICAL: 保存失败率 >1%
- 🚨 CRITICAL: 保存耗时 >500ms

---

### 5. Dirty 实体计数

**重要性**: ⭐⭐⭐

**监控方法**:
通过日志或自定义健康检查端点：

```csharp
// 可选：添加健康检查端点
[HttpGet("health/memory-state")]
public IActionResult GetMemoryState()
{
    var characterManager = _serviceProvider.GetService<IMemoryStateManager<Character>>();
    var snapshotManager = _serviceProvider.GetService<IMemoryStateManager<RunningBattleSnapshotRecord>>();
    var planManager = _serviceProvider.GetService<IMemoryStateManager<ActivityPlan>>();
    
    return Ok(new {
        characters = new { total = characterManager?.Count, dirty = characterManager?.DirtyCount },
        snapshots = new { total = snapshotManager?.Count, dirty = snapshotManager?.DirtyCount },
        plans = new { total = planManager?.Count, dirty = planManager?.DirtyCount }
    });
}
```

**预期值**:
- Characters Dirty: 通常 5-20 (活跃玩家数)
- BattleSnapshots Dirty: 通常 5-15 (并发战斗数)
- ActivityPlans Dirty: 通常 2-10

**告警阈值**:
- ⚠️ WARNING: 任一类型 Dirty 实体 >100
- 🚨 CRITICAL: 任一类型 Dirty 实体 >500 或持续增长

---

### 6. 服务器关闭行为

**重要性**: ⭐⭐⭐⭐⭐

**验证方法**:
定期执行优雅关闭测试（每周一次）：

```bash
# 1. 启动服务器并模拟用户活动
dotnet run --project BlazorIdle.Server

# 2. 发送 SIGTERM 信号（优雅关闭）
kill -TERM <pid>

# 3. 观察日志输出
```

**预期日志**:
```
[INFO] 收到关闭信号...
[INFO] EnhancedShutdownManager 开始执行...
[INFO] 持久化协调器触发最终保存...
[INFO] 批量保存：Characters(12), BattleSnapshots(5), ActivityPlans(3)
[INFO] 批量保存完成，耗时：78ms
[INFO] 已将 12 个在线角色设置为离线
[INFO] 强制执行 WAL 检查点...
[INFO] WAL 检查点完成
[INFO] 优雅关闭完成，总耗时：2.3秒
```

**验证点**:
- ✅ 所有 Dirty 实体已保存
- ✅ 所有在线角色 `IsOnline = false`
- ✅ WAL 检查点已执行
- ✅ 总耗时 <30秒

**告警**:
- 🚨 CRITICAL: 关闭超时（>30秒）
- 🚨 CRITICAL: 有角色仍显示在线
- 🚨 CRITICAL: 有数据未保存

---

## 监控方法

### 方法 1: 日志监控（推荐）

**配置日志级别**:
```json
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "BlazorIdle.Server.Infrastructure.DatabaseOptimization": "Information",
      "Microsoft.EntityFrameworkCore": "Warning"
    }
  }
}
```

**实时监控命令**:
```bash
# 监控所有数据库优化相关日志
tail -f logs/app.log | grep -E "MemoryStateManager|PersistenceCoordinator|EnhancedShutdownManager"

# 监控批量保存事件
tail -f logs/app.log | grep "批量保存"

# 监控错误和警告
tail -f logs/app.log | grep -E "WARNING|ERROR|CRITICAL"
```

---

### 方法 2: SQLite 查询监控

**数据库写入频率**:
```sql
-- 查看最近更新时间
SELECT 
    'Characters' as Table,
    COUNT(*) as TotalRows,
    MAX(LastSeenAtUtc) as LastUpdate
FROM Characters
UNION ALL
SELECT 
    'RunningBattleSnapshots',
    COUNT(*),
    MAX(UpdatedAtUtc)
FROM RunningBattleSnapshots
UNION ALL
SELECT 
    'ActivityPlans',
    COUNT(*),
    MAX(UpdatedAt)
FROM ActivityPlans;
```

**检查离线状态**:
```sql
-- 验证关闭后所有角色离线
SELECT Id, Name, IsOnline, LastSeenAtUtc
FROM Characters
WHERE IsOnline = 1;
-- 应返回 0 行（关闭后）
```

---

### 方法 3: 性能计数器（高级）

如果需要更详细的监控，可以添加自定义性能计数器：

```csharp
// 在 PersistenceCoordinator 中添加
private static readonly Counter SaveOperationsCounter = 
    Metrics.CreateCounter("db_save_operations_total", "Total database save operations");
    
private static readonly Histogram SaveDurationHistogram = 
    Metrics.CreateHistogram("db_save_duration_seconds", "Database save operation duration");

private static readonly Gauge DirtyEntitiesGauge = 
    Metrics.CreateGauge("memory_dirty_entities", "Number of dirty entities in memory");
```

然后使用 Prometheus + Grafana 进行可视化监控。

---

## 预期性能基线

### 典型负载场景

**场景 1: 低负载（10-20在线玩家）**
- 数据库写入: ~200-400次/小时
- 内存使用: ~250-300MB
- API P95延迟: <50ms
- 批量保存频率: 每30-60秒

**场景 2: 中负载（50-100在线玩家）**
- 数据库写入: ~800-1,500次/小时
- 内存使用: ~300-400MB
- API P95延迟: <80ms
- 批量保存频率: 每30秒

**场景 3: 高负载（100-200在线玩家）**
- 数据库写入: ~1,500-3,000次/小时
- 内存使用: ~400-500MB
- API P95延迟: <100ms
- 批量保存频率: 每30秒

---

## 异常检测

### 异常类型 1: 内存持续增长

**症状**:
- 内存使用持续上升，不回落
- GC 频率增加但内存不释放

**可能原因**:
1. 缓存实体过多，未正常清理
2. LRU 清理策略未生效
3. 事件订阅未取消导致内存泄漏

**排查步骤**:
```bash
# 1. 检查缓存实体数量
curl http://localhost:5000/health/memory-state

# 2. 查看日志中的 LRU 清理事件
grep "LRU清理" logs/app.log | tail -20

# 3. 检查 MaxCachedEntities 配置
grep -A 3 "MemoryCache" appsettings.json
```

**解决方案**:
- 降低 `MaxCachedEntities` 值
- 检查是否有异常大量的实体缓存
- 重启服务器释放内存

---

### 异常类型 2: 保存失败

**症状**:
- 日志中出现"保存失败"错误
- Dirty 实体数持续增加

**可能原因**:
1. 数据库锁定
2. 磁盘空间不足
3. 数据验证失败

**排查步骤**:
```bash
# 1. 查看错误日志
grep -A 10 "保存失败\|SaveChangesAsync failed" logs/app.log | tail -50

# 2. 检查磁盘空间
df -h

# 3. 检查数据库文件权限
ls -l gamedata.db*

# 4. 尝试手动执行 WAL 检查点
sqlite3 gamedata.db "PRAGMA wal_checkpoint(FULL);"
```

**解决方案**:
- 释放磁盘空间
- 修复数据库权限
- 如果是数据验证失败，查看具体错误并修复数据

---

### 异常类型 3: API 响应变慢

**症状**:
- API 响应时间回升到优化前水平
- 用户反馈操作延迟

**可能原因**:
1. 数据库查询未命中缓存
2. Dirty 实体过多导致保存耗时
3. 其他系统瓶颈（CPU、磁盘 I/O）

**排查步骤**:
```bash
# 1. 检查 Dirty 实体数
curl http://localhost:5000/health/memory-state

# 2. 查看批量保存耗时
grep "批量保存完成" logs/app.log | tail -20

# 3. 检查系统资源
top
iostat -x 1 10

# 4. 分析慢查询
sqlite3 gamedata.db "PRAGMA query_only = ON; EXPLAIN QUERY PLAN SELECT * FROM Characters WHERE Id = '...';"
```

**解决方案**:
- 如果 Dirty 实体过多，考虑缩短保存间隔
- 检查数据库索引是否完整
- 优化其他系统瓶颈

---

## 故障排查

### 问题 1: 启用内存缓冲后功能异常

**快速诊断**:
```bash
# 检查配置是否正确
grep -A 30 "Persistence" appsettings.json

# 检查服务是否正常注册
grep "MemoryStateManager\|PersistenceCoordinator" logs/app.log | head -10
```

**紧急回滚**:
```json
{
  "Persistence": {
    "EnableMemoryBuffering": false  // 立即禁用
  }
}
```

重启服务器后，系统恢复到立即保存模式。

---

### 问题 2: 数据丢失

**症状**:
- 用户报告最近的进度丢失
- 最后一次心跳时间异常旧

**可能原因**:
1. 服务器意外崩溃（未执行优雅关闭）
2. 保存间隔过长
3. 保存失败未被发现

**排查步骤**:
```bash
# 1. 检查服务器崩溃日志
grep -i "crash\|exception\|error" logs/app.log | tail -50

# 2. 检查最后一次保存时间
sqlite3 gamedata.db "SELECT MAX(LastSeenAtUtc) FROM Characters;"

# 3. 检查是否有未保存的实体
curl http://localhost:5000/health/memory-state
```

**预防措施**:
- 确保使用 systemd 或类似工具管理服务（自动优雅关闭）
- 定期备份数据库
- 考虑缩短关键数据的保存间隔

---

## 性能调优

### 调优参数 1: SaveIntervalMs

**当前配置**:
```json
{
  "EntitySaveStrategies": {
    "BattleSnapshot": { "SaveIntervalMs": 60000 },
    "CharacterHeartbeat": { "SaveIntervalMs": 300000 },
    "ActivityPlan": { "SaveIntervalMs": 30000 }
  }
}
```

**调优建议**:

| 场景 | 调整方向 | 新值推荐 | 理由 |
|------|---------|---------|------|
| 数据安全性要求高 | 缩短间隔 | 30s / 180s / 15s | 减少潜在数据丢失窗口 |
| 性能优先 | 延长间隔 | 120s / 600s / 60s | 进一步减少数据库写入 |
| 内存压力大 | 缩短间隔 | 30s / 180s / 15s | 更快清理 Dirty 实体 |

**调整方法**:
1. 修改 `appsettings.json`
2. 重启服务器（配置热重载未实现）
3. 监控24小时观察效果

---

### 调优参数 2: MaxCachedEntities

**当前配置**:
```json
{
  "MemoryCache": {
    "MaxCachedEntities": 100000
  }
}
```

**调优建议**:

| 场景 | 新值 | 理由 |
|------|------|------|
| 小型服务器（<50玩家） | 10,000 | 节省内存 |
| 中型服务器（50-200玩家） | 50,000 | 平衡内存和性能 |
| 大型服务器（>200玩家） | 100,000+ | 确保缓存命中率 |

---

### 调优参数 3: MaxBatchSize

**当前配置**:
```json
{
  "Persistence": {
    "MaxBatchSize": 1000
  }
}
```

**调优建议**:
- 如果批量保存耗时过长（>200ms），降低到 500
- 如果保存频率过高，提高到 2000
- 通常不需要调整

---

## 总结

### 监控清单

**每日检查** ✅
- [ ] 查看错误日志（任何 ERROR/CRITICAL 级别）
- [ ] 验证 API 响应时间正常
- [ ] 检查内存使用趋势

**每周检查** ✅
- [ ] 执行优雅关闭测试
- [ ] 分析数据库写入频率趋势
- [ ] 查看批量保存统计（成功率、耗时）
- [ ] 检查 Dirty 实体数量分布

**每月检查** ✅
- [ ] 性能基准测试（对比优化前后）
- [ ] 审查配置参数是否需要调优
- [ ] 数据库完整性检查
- [ ] 文档更新（记录观察到的模式）

---

**文档状态**: ✅ 完成  
**最后更新**: 2025-10-18  
**下次审查**: 收集1周生产数据后
