# BlazorIdle é‡æ„è·¯çº¿å›¾ï¼ˆä¸‹ç¯‡ï¼‰ï¼šåŠŸèƒ½é›†æˆä¸æµ‹è¯•éªŒè¯

**æ–‡æ¡£ç‰ˆæœ¬**: 1.0  
**ç”Ÿæˆæ—¥æœŸ**: 2025å¹´10æœˆ  
**çŠ¶æ€**: å®æ–½è§„åˆ’  
**ç›®æ ‡**: åœ¨ç¨³å®šåŸºç¡€è®¾æ–½ä¸Šå®ç°æ ¸å¿ƒåŠŸèƒ½ï¼Œå®Œæˆæµ‹è¯•éªŒè¯

---

## ğŸ“‹ ç›®å½•

1. [åŠŸèƒ½å®ç°æ€»è§ˆ](#åŠŸèƒ½å®ç°æ€»è§ˆ)
2. [Phase 6: ç¦»çº¿æ”¶ç›Šç³»ç»Ÿ](#phase-6-ç¦»çº¿æ”¶ç›Šç³»ç»Ÿ)
3. [Phase 7: æ´»åŠ¨è®¡åˆ’ç³»ç»Ÿ](#phase-7-æ´»åŠ¨è®¡åˆ’ç³»ç»Ÿ)
4. [Phase 8: è£…å¤‡ç³»ç»Ÿå®Œå–„](#phase-8-è£…å¤‡ç³»ç»Ÿå®Œå–„)
5. [Phase 9: ç»æµå¾ªç¯å»ºç«‹](#phase-9-ç»æµå¾ªç¯å»ºç«‹)
6. [Phase 10: é›†æˆæµ‹è¯•](#phase-10-é›†æˆæµ‹è¯•)
7. [Phase 11: æ€§èƒ½ä¼˜åŒ–](#phase-11-æ€§èƒ½ä¼˜åŒ–)
8. [Phase 12: ç›‘æ§ä¸è¯Šæ–­](#phase-12-ç›‘æ§ä¸è¯Šæ–­)
9. [éªŒæ”¶ä¸äº¤ä»˜](#éªŒæ”¶ä¸äº¤ä»˜)

---

## åŠŸèƒ½å®ç°æ€»è§ˆ

### å®æ–½ç­–ç•¥

åŸºäºå‰ä¸¤ç¯‡æ–‡æ¡£å»ºç«‹çš„ç¨³å®šåŸºç¡€è®¾æ–½ï¼Œæœ¬ç¯‡èšç„¦äºï¼š

```
âœ… æ ¸å¿ƒç©æ³•åŠŸèƒ½å®ç°
âœ… åŠŸèƒ½é›†æˆä¸è”è°ƒ
âœ… å…¨é¢æµ‹è¯•éªŒè¯
âœ… æ€§èƒ½ä¼˜åŒ–ä¸ç›‘æ§
âœ… æ–‡æ¡£å®Œå–„ä¸äº¤ä»˜
```

---

### åŠŸèƒ½å®ç°é¡ºåº

#### ä¸ºä»€ä¹ˆè¿™æ ·æ’åºï¼Ÿ

```
1. ç¦»çº¿æ”¶ç›Š (Phase 6)
   â†“ ç†ç”±ï¼šåŸºäºäº‹ä»¶æº¯æºï¼ˆPhase 5ï¼‰ï¼Œä¸ºæ´»åŠ¨ç³»ç»Ÿæä¾›åŸºç¡€
   
2. æ´»åŠ¨è®¡åˆ’ (Phase 7)
   â†“ ç†ç”±ï¼šç»Ÿä¸€è°ƒåº¦å…¥å£ï¼Œè£…å¤‡è·å–åœºæ™¯ä¾èµ–æ­¤ç³»ç»Ÿ
   
3. è£…å¤‡ç³»ç»Ÿ (Phase 8)
   â†“ ç†ç”±ï¼šæ„ç­‘æ·±åº¦æ ¸å¿ƒï¼Œéœ€è¦æ´»åŠ¨ç³»ç»Ÿæä¾›æ‰è½åœºæ™¯
   
4. ç»æµå¾ªç¯ (Phase 9)
   â†“ ç†ç”±ï¼šè£…å¤‡ç³»ç»Ÿæä¾›æ¶ˆè€—ç«¯ï¼Œé—­åˆç»æµå¾ªç¯
   
5. é›†æˆæµ‹è¯• (Phase 10)
   â†“ ç†ç”±ï¼šæ‰€æœ‰åŠŸèƒ½å®Œæˆåï¼ŒéªŒè¯æ•´ä½“åè°ƒæ€§
   
6. æ€§èƒ½ä¼˜åŒ– (Phase 11)
   â†“ ç†ç”±ï¼šåŸºäºæµ‹è¯•ç»“æœï¼Œå®šå‘ä¼˜åŒ–ç“¶é¢ˆ
   
7. ç›‘æ§è¯Šæ–­ (Phase 12)
   â†“ ç†ç”±ï¼šå»ºç«‹é•¿æœŸè¿ç»´èƒ½åŠ›
```

---

### æ—¶é—´è§„åˆ’

```
Phase 6: ç¦»çº¿æ”¶ç›Š      [3å‘¨]   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘
Phase 7: æ´»åŠ¨è®¡åˆ’      [4å‘¨]   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘
Phase 8: è£…å¤‡ç³»ç»Ÿ      [6å‘¨]   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
Phase 9: ç»æµå¾ªç¯      [3å‘¨]   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
Phase 10: é›†æˆæµ‹è¯•     [2å‘¨]   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
Phase 11: æ€§èƒ½ä¼˜åŒ–     [2å‘¨]   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
Phase 12: ç›‘æ§è¯Šæ–­     [2å‘¨]   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ

æ€»è®¡ï¼š22å‘¨ï¼ˆçº¦5.5ä¸ªæœˆï¼‰
```

**ç»“åˆå‰ä¸¤ç¯‡**:
```
ä¸Šç¯‡+ä¸­ç¯‡: 9-11å‘¨ï¼ˆåŸºç¡€è®¾æ–½ï¼‰
ä¸‹ç¯‡: 22å‘¨ï¼ˆåŠŸèƒ½å®ç°ï¼‰
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
æ€»è®¡: 31-33å‘¨ï¼ˆçº¦7-8ä¸ªæœˆï¼‰
```

---

## Phase 6: ç¦»çº¿æ”¶ç›Šç³»ç»Ÿ

**ç›®æ ‡**: å®ç°ç¦»çº¿æ—¶é—´è¡¥ç®—ï¼Œæä¾›ä¸€è‡´çš„ç¦»çº¿æ”¶ç›Š  
**æ—¶é—´**: 3å‘¨  
**ä¼˜å…ˆçº§**: ğŸ”´ æœ€é«˜  
**ä¾èµ–**: Phase 5ï¼ˆäº‹ä»¶æº¯æºï¼‰

---

### æ­¥éª¤6.1: è®¾è®¡ç¦»çº¿æ”¶ç›Šå¼•æ“

**æ ¸å¿ƒæ¶æ„**:

```csharp
// Domain/Offline/OfflineFastForwardEngine.cs
public class OfflineFastForwardEngine
{
    private readonly IEventStore _eventStore;
    private readonly ISnapshotStore _snapshotStore;
    private readonly IConfigProvider _configProvider;
    private readonly ILogger<OfflineFastForwardEngine> _logger;

    public async Task<OfflineResult> SimulateAsync(
        Guid characterId,
        DateTime lastOnlineTime,
        DateTime currentTime,
        CancellationToken ct = default)
    {
        // 1. è®¡ç®—ç¦»çº¿æ—¶é•¿ï¼ˆä¸Šé™12å°æ—¶ï¼‰
        var offlineDuration = currentTime - lastOnlineTime;
        var cappedDuration = TimeSpan.FromHours(
            Math.Min(offlineDuration.TotalHours, 12));

        _logger.LogInformation(
            "å¼€å§‹ç¦»çº¿è¡¥ç®—: è§’è‰²={CharacterId}, æ—¶é•¿={Duration}å°æ—¶", 
            characterId, cappedDuration.TotalHours);

        // 2. åŠ è½½æœ€æ–°å¿«ç…§
        var (snapshot, version) = await _snapshotStore
            .GetLatestSnapshotAsync<CharacterSnapshot>(characterId, ct);

        if (snapshot == null)
        {
            throw new InvalidOperationException(
                $"æœªæ‰¾åˆ°è§’è‰²å¿«ç…§: {characterId}");
        }

        // 3. é‡æ”¾äº‹ä»¶ï¼ˆå¦‚æœæœ‰æ–°äº‹ä»¶ï¼‰
        var events = await _eventStore
            .GetEventsSinceAsync(characterId, version, ct);
        
        var currentState = ApplyEvents(snapshot, events);

        // 4. æ‰§è¡Œç¦»çº¿æ¨¡æ‹Ÿ
        var result = await SimulateOfflineActivitiesAsync(
            currentState, cappedDuration, ct);

        // 5. ç”Ÿæˆæ–°å¿«ç…§
        await _snapshotStore.SaveSnapshotAsync(
            characterId, result.FinalState, version + 1, ct);

        // 6. æŒä¹…åŒ–äº‹ä»¶
        await _eventStore.AppendBatchAsync(result.Events, ct);

        return result;
    }

    private async Task<OfflineResult> SimulateOfflineActivitiesAsync(
        CharacterState state,
        TimeSpan duration,
        CancellationToken ct)
    {
        var result = new OfflineResult
        {
            StartState = state.Clone(),
            Events = new List<IDomainEvent>()
        };

        // è·å–æœ€åçš„æ´»åŠ¨è®¡åˆ’
        var lastPlan = state.CurrentActivityPlan;
        
        if (lastPlan == null || lastPlan.Type == ActivityType.Idle)
        {
            _logger.LogWarning("è§’è‰²ç¦»çº¿æ—¶æ— æ´»åŠ¨ï¼Œè·³è¿‡æ¨¡æ‹Ÿ");
            result.FinalState = state;
            return result;
        }

        // æ ¹æ®æ´»åŠ¨ç±»å‹æ¨¡æ‹Ÿ
        switch (lastPlan.Type)
        {
            case ActivityType.Combat:
                await SimulateCombatAsync(state, duration, result, ct);
                break;
                
            case ActivityType.Gather:
                await SimulateGatherAsync(state, duration, result, ct);
                break;
                
            case ActivityType.Craft:
                await SimulateCraftAsync(state, duration, result, ct);
                break;
        }

        result.FinalState = state;
        return result;
    }

    private async Task SimulateCombatAsync(
        CharacterState state,
        TimeSpan duration,
        OfflineResult result,
        CancellationToken ct)
    {
        // ä½¿ç”¨ä¸åœ¨çº¿æˆ˜æ–—ç›¸åŒçš„å¼•æ“
        var battleEngine = new BattleEngine(
            state, 
            _configProvider, 
            isOffline: true);

        var segments = await battleEngine.RunForDurationAsync(
            duration, ct);

        // èšåˆç»“æœ
        foreach (var segment in segments)
        {
            result.GoldEarned += segment.GoldReward;
            result.ExperienceGained += segment.ExperienceReward;
            result.ItemsDropped.AddRange(segment.Drops);
            
            result.Events.Add(new BattleSegmentCompletedEvent(
                Guid.NewGuid(),
                state.CharacterId,
                segment));
        }

        _logger.LogInformation(
            "ç¦»çº¿æˆ˜æ–—æ¨¡æ‹Ÿå®Œæˆ: æ®µæ•°={SegmentCount}, é‡‘å¸={Gold}, ç»éªŒ={Exp}",
            segments.Count, result.GoldEarned, result.ExperienceGained);
    }
}
```

---

### æ­¥éª¤6.2: å®ç°åˆ†æ®µæ¨¡æ‹Ÿ

**é˜²æ­¢é•¿æ—¶é—´æ¨¡æ‹Ÿå¡é¡¿**:

```csharp
// Domain/Offline/SegmentedOfflineSimulator.cs
public class SegmentedOfflineSimulator
{
    private const int MAX_SEGMENT_MINUTES = 30;

    public async Task<OfflineResult> SimulateInSegmentsAsync(
        CharacterState state,
        TimeSpan totalDuration,
        CancellationToken ct)
    {
        var result = new OfflineResult();
        var remaining = totalDuration;
        var currentState = state;

        while (remaining > TimeSpan.Zero)
        {
            var segmentDuration = TimeSpan.FromMinutes(
                Math.Min(remaining.TotalMinutes, MAX_SEGMENT_MINUTES));

            _logger.LogDebug(
                "æ¨¡æ‹Ÿæ®µè½: æ—¶é•¿={Duration}åˆ†é’Ÿ", 
                segmentDuration.TotalMinutes);

            var segmentResult = await SimulateSegmentAsync(
                currentState, segmentDuration, ct);

            // åˆå¹¶ç»“æœ
            result.Merge(segmentResult);
            currentState = segmentResult.FinalState;
            remaining -= segmentDuration;

            // å…è®¸å–æ¶ˆ
            ct.ThrowIfCancellationRequested();
        }

        return result;
    }
}
```

---

### æ­¥éª¤6.3: åˆ›å»ºç¦»çº¿æ”¶ç›ŠAPI

```csharp
// Api/OfflineController.cs
[ApiController]
[Route("api/offline")]
public class OfflineController : ControllerBase
{
    private readonly OfflineFastForwardEngine _offlineEngine;
    private readonly IUnitOfWork _unitOfWork;

    [HttpPost("settle/{characterId}")]
    public async Task<IActionResult> SettleOfflineRewards(
        Guid characterId,
        CancellationToken ct)
    {
        // 1. è·å–è§’è‰²ä¿¡æ¯
        var characterRepo = _unitOfWork.Repository<Character>();
        var character = await characterRepo.GetByIdAsync(characterId, ct);

        if (character == null)
        {
            return NotFound();
        }

        // 2. æ£€æŸ¥æ˜¯å¦éœ€è¦ç»“ç®—
        var now = DateTime.UtcNow;
        var lastOnline = character.LastOnlineAt;
        var offlineDuration = now - lastOnline;

        if (offlineDuration < TimeSpan.FromMinutes(5))
        {
            return Ok(new OfflineRewardResponse
            {
                HasRewards = false,
                Message = "ç¦»çº¿æ—¶é—´è¿‡çŸ­ï¼Œæ— æ”¶ç›Š"
            });
        }

        // 3. æ‰§è¡Œç¦»çº¿æ¨¡æ‹Ÿ
        var result = await _offlineEngine.SimulateAsync(
            characterId, lastOnline, now, ct);

        // 4. åº”ç”¨æ”¶ç›Š
        character.Gold += result.GoldEarned;
        character.Experience += result.ExperienceGained;
        character.LastOnlineAt = now;

        await characterRepo.UpdateAsync(character, ct);
        await _unitOfWork.SaveChangesAsync(ct);

        // 5. è¿”å›ç»“æœ
        return Ok(new OfflineRewardResponse
        {
            HasRewards = true,
            GoldEarned = result.GoldEarned,
            ExperienceGained = result.ExperienceGained,
            ItemsDropped = result.ItemsDropped,
            BattleSegments = result.Events.Count,
            OfflineDuration = offlineDuration
        });
    }
}
```

---

### æ­¥éª¤6.4: å‰ç«¯é›†æˆ

**å‰ç«¯è‡ªåŠ¨æ£€æµ‹ç¦»çº¿æ”¶ç›Š**:

```csharp
// Blazor WASM: Services/OfflineRewardService.cs
public class OfflineRewardService
{
    private readonly ApiClient _apiClient;
    private readonly ILogger<OfflineRewardService> _logger;

    public async Task CheckAndSettleOfflineRewardsAsync(Guid characterId)
    {
        try
        {
            var response = await _apiClient.PostAsync<OfflineRewardResponse>(
                $"offline/settle/{characterId}");

            if (response.HasRewards)
            {
                _logger.LogInformation(
                    "ç¦»çº¿æ”¶ç›Šç»“ç®—: é‡‘å¸+{Gold}, ç»éªŒ+{Exp}, ç‰©å“Ã—{Items}",
                    response.GoldEarned,
                    response.ExperienceGained,
                    response.ItemsDropped.Count);

                // è§¦å‘UIæ˜¾ç¤ºç¦»çº¿æ”¶ç›Šå¼¹çª—
                await ShowOfflineRewardDialogAsync(response);
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "ç¦»çº¿æ”¶ç›Šç»“ç®—å¤±è´¥");
        }
    }

    private async Task ShowOfflineRewardDialogAsync(
        OfflineRewardResponse rewards)
    {
        // æ˜¾ç¤ºæ¨¡æ€å¯¹è¯æ¡†å±•ç¤ºæ”¶ç›Š
        // å®ç°çœç•¥...
    }
}
```

---

## Phase 7: æ´»åŠ¨è®¡åˆ’ç³»ç»Ÿ

**ç›®æ ‡**: å®ç°å¤šæ§½ä½æ´»åŠ¨è°ƒåº¦ï¼Œç»Ÿä¸€ç®¡ç†å„ç±»æ´»åŠ¨  
**æ—¶é—´**: 4å‘¨  
**ä¼˜å…ˆçº§**: ğŸ”´ æœ€é«˜  
**ä¾èµ–**: Phase 6ï¼ˆç¦»çº¿ç³»ç»Ÿéœ€è¦æ´»åŠ¨è®¡åˆ’ï¼‰

---

### æ­¥éª¤7.1: å®šä¹‰æ´»åŠ¨è®¡åˆ’æ•°æ®ç»“æ„

```csharp
// Domain/Activities/ActivityPlan.cs
public class ActivityPlan
{
    public Guid Id { get; init; }
    public ActivityType Type { get; init; }
    public PlanState State { get; set; }
    public LimitSpec Limit { get; init; }
    public Dictionary<string, object> Payload { get; init; }
    public DateTime? StartedAt { get; set; }
    public DateTime? CompletedAt { get; set; }
    public int ProgressCount { get; set; }
    public double ProgressDuration { get; set; }

    public bool IsComplete()
    {
        return Limit.Type switch
        {
            LimitType.Count => ProgressCount >= Limit.TargetValue,
            LimitType.Duration => ProgressDuration >= Limit.TargetValue,
            LimitType.Infinite => false,
            _ => false
        };
    }

    public void UpdateProgress(int countDelta, double durationDelta)
    {
        ProgressCount += countDelta;
        ProgressDuration += durationDelta;

        if (IsComplete())
        {
            State = PlanState.Completed;
            CompletedAt = DateTime.UtcNow;
        }
    }
}

// Domain/Activities/ActivitySlot.cs
public class ActivitySlot
{
    public int SlotIndex { get; init; }
    public Guid CharacterId { get; init; }
    public Guid? CurrentPlanId { get; set; }
    public List<Guid> QueuedPlanIds { get; init; } = new();

    public bool IsActive => CurrentPlanId.HasValue;
    public bool HasQueue => QueuedPlanIds.Any();
}
```

---

### æ­¥éª¤7.2: å®ç°æ´»åŠ¨åè°ƒå™¨

```csharp
// Application/Activities/ActivityCoordinator.cs
public class ActivityCoordinator
{
    private readonly IUnitOfWork _unitOfWork;
    private readonly IEventBus _eventBus;
    private readonly ILogger<ActivityCoordinator> _logger;

    public async Task<ActivityPlan> StartActivityAsync(
        Guid characterId,
        int slotIndex,
        ActivityPlan plan,
        CancellationToken ct)
    {
        // 1. éªŒè¯æ§½ä½
        var slotRepo = _unitOfWork.Repository<ActivitySlot>();
        var slot = await slotRepo.GetByIdAsync(
            GetSlotId(characterId, slotIndex), ct);

        if (slot == null)
        {
            throw new InvalidOperationException(
                $"æ´»åŠ¨æ§½ä½ä¸å­˜åœ¨: è§’è‰²={characterId}, æ§½ä½={slotIndex}");
        }

        if (slot.IsActive)
        {
            throw new InvalidOperationException(
                "æ§½ä½å·²æœ‰æ´»åŠ¨è¿è¡Œä¸­");
        }

        // 2. åˆå§‹åŒ–æ´»åŠ¨
        plan.State = PlanState.Running;
        plan.StartedAt = DateTime.UtcNow;

        var planRepo = _unitOfWork.Repository<ActivityPlan>();
        await planRepo.AddAsync(plan, ct);

        // 3. æ›´æ–°æ§½ä½
        slot.CurrentPlanId = plan.Id;
        await slotRepo.UpdateAsync(slot, ct);

        await _unitOfWork.SaveChangesAsync(ct);

        // 4. å‘å¸ƒäº‹ä»¶
        await _eventBus.PublishAsync(new ActivityStartedEvent(
            characterId, slotIndex, plan));

        _logger.LogInformation(
            "æ´»åŠ¨å¼€å§‹: è§’è‰²={CharacterId}, æ§½ä½={Slot}, ç±»å‹={Type}",
            characterId, slotIndex, plan.Type);

        return plan;
    }

    public async Task<ActivityPlan> CompleteActivityAsync(
        Guid planId,
        CancellationToken ct)
    {
        var planRepo = _unitOfWork.Repository<ActivityPlan>();
        var plan = await planRepo.GetByIdAsync(planId, ct);

        if (plan == null)
        {
            throw new KeyNotFoundException($"æ´»åŠ¨è®¡åˆ’ä¸å­˜åœ¨: {planId}");
        }

        // æ ‡è®°å®Œæˆ
        plan.State = PlanState.Completed;
        plan.CompletedAt = DateTime.UtcNow;
        await planRepo.UpdateAsync(plan, ct);

        // æŸ¥æ‰¾æ§½ä½
        var slotRepo = _unitOfWork.Repository<ActivitySlot>();
        var slot = await slotRepo
            .FindAsync(s => s.CurrentPlanId == planId, ct)
            .FirstOrDefaultAsync();

        if (slot != null)
        {
            slot.CurrentPlanId = null;

            // è‡ªåŠ¨å¯åŠ¨ä¸‹ä¸€ä¸ªæ’é˜Ÿæ´»åŠ¨
            if (slot.HasQueue)
            {
                var nextPlanId = slot.QueuedPlanIds.First();
                slot.QueuedPlanIds.RemoveAt(0);
                
                var nextPlan = await planRepo.GetByIdAsync(nextPlanId, ct);
                if (nextPlan != null)
                {
                    await StartActivityAsync(
                        slot.CharacterId, 
                        slot.SlotIndex, 
                        nextPlan, 
                        ct);
                }
            }

            await slotRepo.UpdateAsync(slot, ct);
        }

        await _unitOfWork.SaveChangesAsync(ct);

        // å‘å¸ƒäº‹ä»¶
        await _eventBus.PublishAsync(new ActivityCompletedEvent(
            plan.Payload.GetValueOrDefault("CharacterId", Guid.Empty),
            slot?.SlotIndex ?? 0,
            plan));

        return plan;
    }
}
```

---

### æ­¥éª¤7.3: é›†æˆæˆ˜æ–—æ´»åŠ¨

```csharp
// Application/Activities/CombatActivityHandler.cs
public class CombatActivityHandler
{
    private readonly ActivityCoordinator _coordinator;
    private readonly BattleEngine _battleEngine;
    private readonly IEventBus _eventBus;

    public async Task<ActivityPlan> StartCombatActivityAsync(
        Guid characterId,
        int slotIndex,
        string enemyId,
        int targetKills,
        CancellationToken ct)
    {
        var plan = new ActivityPlan
        {
            Id = Guid.NewGuid(),
            Type = ActivityType.Combat,
            Limit = new LimitSpec
            {
                Type = LimitType.Count,
                TargetValue = targetKills
            },
            Payload = new Dictionary<string, object>
            {
                ["CharacterId"] = characterId,
                ["EnemyId"] = enemyId,
                ["TargetKills"] = targetKills
            }
        };

        // å¯åŠ¨æ´»åŠ¨
        await _coordinator.StartActivityAsync(
            characterId, slotIndex, plan, ct);

        // è®¢é˜…æˆ˜æ–—å®Œæˆäº‹ä»¶ï¼Œæ›´æ–°è¿›åº¦
        _eventBus.Subscribe<BattleCompletedEvent>(async @event =>
        {
            if (@event.CharacterId == characterId)
            {
                await UpdateCombatProgressAsync(plan.Id, 1, ct);
            }
        });

        return plan;
    }

    private async Task UpdateCombatProgressAsync(
        Guid planId,
        int killCount,
        CancellationToken ct)
    {
        var planRepo = _unitOfWork.Repository<ActivityPlan>();
        var plan = await planRepo.GetByIdAsync(planId, ct);

        if (plan != null)
        {
            plan.UpdateProgress(killCount, 0);
            await planRepo.UpdateAsync(plan, ct);
            await _unitOfWork.SaveChangesAsync(ct);

            if (plan.IsComplete())
            {
                await _coordinator.CompleteActivityAsync(planId, ct);
            }
        }
    }
}
```

---

## Phase 8: è£…å¤‡ç³»ç»Ÿå®Œå–„

**ç›®æ ‡**: å®ç°è£…å¤‡Tierã€Affixã€åˆ†è§£ã€é‡é“¸  
**æ—¶é—´**: 6å‘¨  
**ä¼˜å…ˆçº§**: ğŸ”´ é«˜  
**ä¾èµ–**: Phase 7ï¼ˆæ´»åŠ¨ç³»ç»Ÿæä¾›è£…å¤‡æ‰è½åœºæ™¯ï¼‰

---

### æ­¥éª¤8.1: å®šä¹‰è£…å¤‡æ•°æ®ç»“æ„

```csharp
// Domain/Equipment/GearDefinition.cs
public class GearDefinition
{
    public string Id { get; init; }
    public string Name { get; init; }
    public GearSlot Slot { get; init; }
    public GearRarity Rarity { get; init; }
    public int RequiredLevel { get; init; }
    public Dictionary<string, (int Min, int Max)> BaseStats { get; init; }
    public List<string> AllowedAffixPool { get; init; }
    public string? SetId { get; init; }
}

// Domain/Equipment/GearInstance.cs
public class GearInstance
{
    public Guid Id { get; init; }
    public string DefinitionId { get; init; }
    public GearTier Tier { get; set; }
    public List<Affix> Affixes { get; set; }
    public int QualityScore { get; set; }
    public DateTime CreatedAt { get; init; }
    public int RerollCount { get; set; }

    public Dictionary<string, int> GetTotalStats()
    {
        var stats = new Dictionary<string, int>();
        
        // åŸºç¡€å±æ€§ Ã— Tierç³»æ•°
        var definition = ConfigProvider.Get<GearDefinition>(DefinitionId);
        var tierMultiplier = Tier switch
        {
            GearTier.T1 => 0.8,
            GearTier.T2 => 1.0,
            GearTier.T3 => 1.2,
            _ => 1.0
        };

        foreach (var (stat, (min, max)) in definition.BaseStats)
        {
            var avgValue = (min + max) / 2.0;
            stats[stat] = (int)(avgValue * tierMultiplier);
        }

        // è¯æ¡åŠ æˆ
        foreach (var affix in Affixes)
        {
            foreach (var (stat, value) in affix.Stats)
            {
                if (stats.ContainsKey(stat))
                    stats[stat] += value;
                else
                    stats[stat] = value;
            }
        }

        return stats;
    }
}

// Domain/Equipment/Affix.cs
public class Affix
{
    public string Id { get; init; }
    public string Name { get; init; }
    public AffixType Type { get; init; }
    public Dictionary<string, int> Stats { get; init; }
    public AffixRarity Rarity { get; init; }
}
```

---

### æ­¥éª¤8.2: å®ç°è£…å¤‡ç”Ÿæˆå™¨

```csharp
// Domain/Equipment/GearGenerator.cs
public class GearGenerator
{
    private readonly IConfigProvider _configProvider;
    private readonly Random _random;

    public GearInstance GenerateGear(
        string definitionId,
        GearTier tier,
        int affixCount)
    {
        var definition = _configProvider.Get<GearDefinition>(definitionId);
        
        var gear = new GearInstance
        {
            Id = Guid.NewGuid(),
            DefinitionId = definitionId,
            Tier = tier,
            Affixes = new List<Affix>(),
            CreatedAt = DateTime.UtcNow,
            RerollCount = 0
        };

        // ç”Ÿæˆè¯æ¡
        var affixPool = _configProvider.GetAll<AffixDefinition>()
            .Where(a => definition.AllowedAffixPool.Contains(a.Id))
            .ToList();

        for (int i = 0; i < affixCount; i++)
        {
            var affixDef = SelectRandomAffix(affixPool);
            var affix = RollAffix(affixDef);
            gear.Affixes.Add(affix);
        }

        // è®¡ç®—å“è´¨åˆ†æ•°
        gear.QualityScore = CalculateQualityScore(gear);

        return gear;
    }

    private Affix RollAffix(AffixDefinition definition)
    {
        var stats = new Dictionary<string, int>();
        
        foreach (var (stat, (min, max)) in definition.StatRanges)
        {
            var value = _random.Next(min, max + 1);
            stats[stat] = value;
        }

        return new Affix
        {
            Id = definition.Id,
            Name = definition.Name,
            Type = definition.Type,
            Stats = stats,
            Rarity = definition.Rarity
        };
    }

    private int CalculateQualityScore(GearInstance gear)
    {
        // åŸºç¡€åˆ†ï¼šTier
        int score = gear.Tier switch
        {
            GearTier.T1 => 50,
            GearTier.T2 => 75,
            GearTier.T3 => 100,
            _ => 0
        };

        // è¯æ¡åˆ†ï¼šæ•°é‡ + ç¨€æœ‰åº¦
        score += gear.Affixes.Count * 10;
        score += gear.Affixes.Sum(a => (int)a.Rarity * 5);

        return score;
    }
}
```

---

### æ­¥éª¤8.3: å®ç°åˆ†è§£ç³»ç»Ÿ

```csharp
// Application/Equipment/DisenchantService.cs
public class DisenchantService
{
    private readonly IUnitOfWork _unitOfWork;
    private readonly IConfigProvider _configProvider;

    public async Task<DisenchantResult> DisenchantGearAsync(
        Guid gearId,
        Guid characterId,
        CancellationToken ct)
    {
        // 1. è·å–è£…å¤‡
        var gearRepo = _unitOfWork.Repository<GearInstance>();
        var gear = await gearRepo.GetByIdAsync(gearId, ct);

        if (gear == null)
        {
            throw new KeyNotFoundException($"è£…å¤‡ä¸å­˜åœ¨: {gearId}");
        }

        // 2. è®¡ç®—åˆ†è§£äº§å‡º
        var materials = CalculateMaterials(gear);
        var gold = CalculateGold(gear);

        // 3. åˆ é™¤è£…å¤‡
        await gearRepo.DeleteAsync(gearId, ct);

        // 4. æ·»åŠ ææ–™
        var inventoryRepo = _unitOfWork.Repository<Inventory>();
        var inventory = await inventoryRepo
            .FindAsync(i => i.CharacterId == characterId, ct)
            .FirstOrDefaultAsync();

        foreach (var (materialId, quantity) in materials)
        {
            inventory.AddItem(materialId, quantity);
        }

        inventory.Gold += gold;

        await inventoryRepo.UpdateAsync(inventory, ct);
        await _unitOfWork.SaveChangesAsync(ct);

        return new DisenchantResult
        {
            Materials = materials,
            GoldGained = gold
        };
    }

    private Dictionary<string, int> CalculateMaterials(GearInstance gear)
    {
        var materials = new Dictionary<string, int>();
        
        // åŸºç¡€ææ–™ï¼ˆæ ¹æ®Tierï¼‰
        var baseMaterial = gear.Tier switch
        {
            GearTier.T1 => "material_basic",
            GearTier.T2 => "material_intermediate",
            GearTier.T3 => "material_advanced",
            _ => "material_basic"
        };
        
        materials[baseMaterial] = 5;

        // ç¨€æœ‰ææ–™ï¼ˆæ ¹æ®ç¨€æœ‰åº¦ï¼‰
        var definition = _configProvider.Get<GearDefinition>(gear.DefinitionId);
        if (definition.Rarity >= GearRarity.Rare)
        {
            materials["material_rare_essence"] = (int)definition.Rarity;
        }

        return materials;
    }

    private int CalculateGold(GearInstance gear)
    {
        // æ ¹æ®å“è´¨åˆ†æ•°è®¡ç®—é‡‘å¸
        return gear.QualityScore * 10;
    }
}
```

---

### æ­¥éª¤8.4: å®ç°é‡é“¸ç³»ç»Ÿ

```csharp
// Application/Equipment/ReforgeService.cs
public class ReforgeService
{
    private readonly IUnitOfWork _unitOfWork;
    private readonly GearGenerator _gearGenerator;

    // Tierå‡çº§
    public async Task<GearInstance> ReforgeTierAsync(
        Guid gearId,
        Guid characterId,
        CancellationToken ct)
    {
        var gearRepo = _unitOfWork.Repository<GearInstance>();
        var gear = await gearRepo.GetByIdAsync(gearId, ct);

        if (gear == null)
        {
            throw new KeyNotFoundException($"è£…å¤‡ä¸å­˜åœ¨: {gearId}");
        }

        // éªŒè¯æ˜¯å¦å¯å‡çº§
        if (gear.Tier == GearTier.T3)
        {
            throw new InvalidOperationException("è£…å¤‡å·²è¾¾æœ€é«˜Tier");
        }

        // è®¡ç®—æ¶ˆè€—
        var cost = CalculateReforgeCost(gear);
        
        // æ‰£é™¤ææ–™ä¸é‡‘å¸
        var inventoryRepo = _unitOfWork.Repository<Inventory>();
        var inventory = await inventoryRepo
            .FindAsync(i => i.CharacterId == characterId, ct)
            .FirstOrDefaultAsync();

        if (!inventory.HasMaterials(cost.Materials) || 
            inventory.Gold < cost.GoldCost)
        {
            throw new InvalidOperationException("ææ–™æˆ–é‡‘å¸ä¸è¶³");
        }

        inventory.ConsumeMaterials(cost.Materials);
        inventory.Gold -= cost.GoldCost;
        await inventoryRepo.UpdateAsync(inventory, ct);

        // æå‡Tier
        gear.Tier = gear.Tier switch
        {
            GearTier.T1 => GearTier.T2,
            GearTier.T2 => GearTier.T3,
            _ => gear.Tier
        };

        // é‡æ–°è®¡ç®—å“è´¨
        gear.QualityScore = _gearGenerator.CalculateQualityScore(gear);

        await gearRepo.UpdateAsync(gear, ct);
        await _unitOfWork.SaveChangesAsync(ct);

        return gear;
    }

    // è¯æ¡é‡ç½®
    public async Task<GearInstance> RerollAffixesAsync(
        Guid gearId,
        Guid characterId,
        CancellationToken ct)
    {
        var gearRepo = _unitOfWork.Repository<GearInstance>();
        var gear = await gearRepo.GetByIdAsync(gearId, ct);

        if (gear == null)
        {
            throw new KeyNotFoundException($"è£…å¤‡ä¸å­˜åœ¨: {gearId}");
        }

        // é€’å¢æˆæœ¬ï¼ˆæ¯æ¬¡é‡ç½®æ›´è´µï¼‰
        var cost = CalculateRerollCost(gear.RerollCount);

        // æ‰£é™¤æ¶ˆè€—
        var inventoryRepo = _unitOfWork.Repository<Inventory>();
        var inventory = await inventoryRepo
            .FindAsync(i => i.CharacterId == characterId, ct)
            .FirstOrDefaultAsync();

        if (!inventory.HasMaterials(cost.Materials) || 
            inventory.Gold < cost.GoldCost)
        {
            throw new InvalidOperationException("ææ–™æˆ–é‡‘å¸ä¸è¶³");
        }

        inventory.ConsumeMaterials(cost.Materials);
        inventory.Gold -= cost.GoldCost;
        await inventoryRepo.UpdateAsync(inventory, ct);

        // é‡æ–°ç”Ÿæˆè¯æ¡
        var definition = _configProvider.Get<GearDefinition>(gear.DefinitionId);
        gear.Affixes = _gearGenerator.GenerateAffixes(
            definition, gear.Affixes.Count);
        gear.RerollCount++;
        gear.QualityScore = _gearGenerator.CalculateQualityScore(gear);

        await gearRepo.UpdateAsync(gear, ct);
        await _unitOfWork.SaveChangesAsync(ct);

        return gear;
    }
}
```

---

## Phase 9: ç»æµå¾ªç¯å»ºç«‹

**ç›®æ ‡**: å»ºç«‹ç»æµç›‘æ§ï¼Œå¹³è¡¡äº§å‡ºä¸æ¶ˆè€—  
**æ—¶é—´**: 3å‘¨  
**ä¼˜å…ˆçº§**: ğŸŸ¡ ä¸­  
**ä¾èµ–**: Phase 8ï¼ˆè£…å¤‡ç³»ç»Ÿæä¾›æ¶ˆè€—ç«¯ï¼‰

---

### æ­¥éª¤9.1: å®ç°ç»æµäº‹ä»¶è¿½è¸ª

```csharp
// Domain/Economy/EconomyEvent.cs
public record EconomyEvent(
    Guid CharacterId,
    EconomyEventType Type,
    string Source,
    Dictionary<string, int> Changes,
    DateTime Timestamp
) : IDomainEvent
{
    public Guid EventId { get; } = Guid.NewGuid();
    public DateTime OccurredAt => Timestamp;
    public string EventType => nameof(EconomyEvent);
}

// Application/Economy/EconomyTracker.cs
public class EconomyTracker
{
    private readonly IEventBus _eventBus;
    private readonly IEventStore _eventStore;

    public async Task TrackGainAsync(
        Guid characterId,
        string source,
        int goldGained,
        Dictionary<string, int> itemsGained)
    {
        var changes = new Dictionary<string, int>
        {
            ["gold"] = goldGained
        };

        foreach (var (itemId, qty) in itemsGained)
        {
            changes[itemId] = qty;
        }

        var @event = new EconomyEvent(
            characterId,
            EconomyEventType.Gain,
            source,
            changes,
            DateTime.UtcNow);

        await _eventBus.PublishAsync(@event);
        await _eventStore.AppendAsync(@event);
    }

    public async Task TrackSpendAsync(
        Guid characterId,
        string source,
        int goldSpent,
        Dictionary<string, int> materialsSpent)
    {
        var changes = new Dictionary<string, int>
        {
            ["gold"] = -goldSpent
        };

        foreach (var (materialId, qty) in materialsSpent)
        {
            changes[materialId] = -qty;
        }

        var @event = new EconomyEvent(
            characterId,
            EconomyEventType.Spend,
            source,
            changes,
            DateTime.UtcNow);

        await _eventBus.PublishAsync(@event);
        await _eventStore.AppendAsync(@event);
    }
}
```

---

### æ­¥éª¤9.2: å®ç°ç»æµç»Ÿè®¡

```csharp
// Application/Economy/EconomyStatisticsService.cs
public class EconomyStatisticsService
{
    private readonly IEventStore _eventStore;

    public async Task<EconomyReport> GenerateReportAsync(
        TimeSpan period,
        CancellationToken ct)
    {
        var since = DateTime.UtcNow - period;
        var events = await _eventStore
            .GetEventsSinceAsync(Guid.Empty, 0, ct); // æ‰€æœ‰äº‹ä»¶

        var economyEvents = events
            .OfType<EconomyEvent>()
            .Where(e => e.Timestamp >= since)
            .ToList();

        var report = new EconomyReport
        {
            Period = period,
            GeneratedAt = DateTime.UtcNow
        };

        // é‡‘å¸æµæ°´
        report.GoldIn = economyEvents
            .Where(e => e.Type == EconomyEventType.Gain)
            .Sum(e => e.Changes.GetValueOrDefault("gold", 0));

        report.GoldOut = economyEvents
            .Where(e => e.Type == EconomyEventType.Spend)
            .Sum(e => Math.Abs(e.Changes.GetValueOrDefault("gold", 0)));

        report.GoldNetFlow = report.GoldIn - report.GoldOut;

        // æ¥æºåˆ†æ
        report.GoldSourceBreakdown = economyEvents
            .Where(e => e.Type == EconomyEventType.Gain)
            .GroupBy(e => e.Source)
            .ToDictionary(
                g => g.Key,
                g => g.Sum(e => e.Changes.GetValueOrDefault("gold", 0)));

        // æ¶ˆè€—åˆ†æ
        report.GoldSinkBreakdown = economyEvents
            .Where(e => e.Type == EconomyEventType.Spend)
            .GroupBy(e => e.Source)
            .ToDictionary(
                g => g.Key,
                g => g.Sum(e => Math.Abs(e.Changes.GetValueOrDefault("gold", 0))));

        return report;
    }
}
```

---

## Phase 10: é›†æˆæµ‹è¯•

**ç›®æ ‡**: å…¨é¢æµ‹è¯•åŠŸèƒ½é›†æˆï¼ŒéªŒè¯ç³»ç»Ÿç¨³å®šæ€§  
**æ—¶é—´**: 2å‘¨  
**ä¼˜å…ˆçº§**: ğŸ”´ æœ€é«˜

---

### æ­¥éª¤10.1: ç«¯åˆ°ç«¯æµ‹è¯•åœºæ™¯

```csharp
// Tests/Integration/E2EScenarios/CompleteGameLoopTests.cs
[Fact]
public async Task CompleteGameLoop_FromLoginToOfflineRewards_ShouldWork()
{
    // 1. ç”¨æˆ·æ³¨å†Œä¸ç™»å½•
    var userId = await RegisterUserAsync("testuser", "password");
    var token = await LoginAsync("testuser", "password");

    // 2. åˆ›å»ºè§’è‰²
    var characterId = await CreateCharacterAsync(userId, "TestHero");

    // 3. å¯åŠ¨æˆ˜æ–—æ´»åŠ¨
    var activityId = await StartCombatActivityAsync(
        characterId, slotIndex: 0, enemyId: "goblin", targetKills: 5);

    // 4. æ¨¡æ‹Ÿåœ¨çº¿æˆ˜æ–—
    await Task.Delay(TimeSpan.FromSeconds(30));
    var activityStatus = await GetActivityStatusAsync(activityId);
    
    Assert.Equal(PlanState.Running, activityStatus.State);
    Assert.True(activityStatus.Progress > 0);

    // 5. è·å–è£…å¤‡æ‰è½
    var drops = await GetBattleDropsAsync(characterId);
    Assert.NotEmpty(drops);

    // 6. åˆ†è§£ä¸€ä»¶è£…å¤‡
    var gear = drops.First();
    var disenchantResult = await DisenchantGearAsync(gear.Id, characterId);
    
    Assert.True(disenchantResult.GoldGained > 0);
    Assert.NotEmpty(disenchantResult.Materials);

    // 7. æ¨¡æ‹Ÿç¦»çº¿
    await LogoutAsync(characterId);
    await Task.Delay(TimeSpan.FromMinutes(10)); // å®é™…æµ‹è¯•å¯ç”¨æ›´çŸ­æ—¶é—´

    // 8. é‡æ–°ç™»å½•ï¼Œç»“ç®—ç¦»çº¿æ”¶ç›Š
    await LoginAsync("testuser", "password");
    var offlineRewards = await SettleOfflineRewardsAsync(characterId);

    Assert.True(offlineRewards.HasRewards);
    Assert.True(offlineRewards.GoldEarned > 0);

    // 9. éªŒè¯æ•°æ®ä¸€è‡´æ€§
    var finalCharacter = await GetCharacterAsync(characterId);
    Assert.True(finalCharacter.Gold > 0);
    Assert.True(finalCharacter.Experience > 0);
}
```

---

### æ­¥éª¤10.2: å‹åŠ›æµ‹è¯•

```csharp
// Tests/Integration/StressTests/ConcurrentBattleTests.cs
[Fact]
public async Task Concurrent100Battles_ShouldNotDegrade()
{
    var characterIds = Enumerable.Range(0, 100)
        .Select(_ => Guid.NewGuid())
        .ToList();

    // å¹¶å‘å¯åŠ¨100åœºæˆ˜æ–—
    var tasks = characterIds.Select(id => 
        StartCombatActivityAsync(id, 0, "goblin", 10));

    var stopwatch = Stopwatch.StartNew();
    await Task.WhenAll(tasks);
    stopwatch.Stop();

    // éªŒè¯å“åº”æ—¶é—´
    Assert.True(stopwatch.ElapsedMilliseconds < 5000, 
        "100ä¸ªå¹¶å‘è¯·æ±‚åº”åœ¨5ç§’å†…å®Œæˆ");

    // éªŒè¯æ‰€æœ‰æˆ˜æ–—æ­£å¸¸å¯åŠ¨
    foreach (var id in characterIds)
    {
        var activity = await GetActivityStatusAsync(id);
        Assert.Equal(PlanState.Running, activity.State);
    }
}
```

---

## Phase 11: æ€§èƒ½ä¼˜åŒ–

**ç›®æ ‡**: å®šä½å¹¶ä¼˜åŒ–æ€§èƒ½ç“¶é¢ˆ  
**æ—¶é—´**: 2å‘¨  
**ä¼˜å…ˆçº§**: ğŸŸ¡ ä¸­

---

### æ­¥éª¤11.1: æ•°æ®åº“æŸ¥è¯¢ä¼˜åŒ–

```csharp
// ä¼˜åŒ–å‰ï¼šN+1æŸ¥è¯¢
var characters = await _context.Characters.ToListAsync();
foreach (var character in characters)
{
    var equipment = await _context.Equipment
        .Where(e => e.CharacterId == character.Id)
        .ToListAsync();
}

// â†“â†“â†“ ä¼˜åŒ–å â†“â†“â†“

// é¢„åŠ è½½å…³è”æ•°æ®
var characters = await _context.Characters
    .Include(c => c.Equipment)
    .Include(c => c.Inventory)
    .ToListAsync();
```

---

### æ­¥éª¤11.2: ç¼“å­˜é¢„çƒ­

```csharp
// Infrastructure/Caching/CacheWarmupService.cs
public class CacheWarmupService : IHostedService
{
    private readonly IMultiTierCache _cache;
    private readonly IConfigProvider _configProvider;

    public async Task StartAsync(CancellationToken ct)
    {
        // é¢„çƒ­é…ç½®æ•°æ®
        await WarmupConfigsAsync(ct);
        
        // é¢„çƒ­çƒ­é—¨è£…å¤‡æ•°æ®
        await WarmupPopularGearsAsync(ct);
    }

    private async Task WarmupConfigsAsync(CancellationToken ct)
    {
        var skills = _configProvider.GetAll<SkillDefinition>();
        await _cache.SetAsync("config:skills", skills, 
            TimeSpan.FromHours(1), ct);

        var gears = _configProvider.GetAll<GearDefinition>();
        await _cache.SetAsync("config:gears", gears, 
            TimeSpan.FromHours(1), ct);
    }
}
```

---

## Phase 12: ç›‘æ§ä¸è¯Šæ–­

**ç›®æ ‡**: å»ºç«‹è¿ç»´ç›‘æ§èƒ½åŠ›  
**æ—¶é—´**: 2å‘¨  
**ä¼˜å…ˆçº§**: ğŸŸ¡ ä¸­

---

### æ­¥éª¤12.1: å®ç°Metricsæ”¶é›†

```csharp
// Infrastructure/Monitoring/MetricsCollector.cs
public class MetricsCollector
{
    private readonly ConcurrentDictionary<string, long> _counters = new();
    private readonly ConcurrentDictionary<string, double> _gauges = new();

    public void IncrementCounter(string metric, long value = 1)
    {
        _counters.AddOrUpdate(metric, value, (k, v) => v + value);
    }

    public void SetGauge(string metric, double value)
    {
        _gauges[metric] = value;
    }

    public MetricsSnapshot GetSnapshot()
    {
        return new MetricsSnapshot
        {
            Timestamp = DateTime.UtcNow,
            Counters = new Dictionary<string, long>(_counters),
            Gauges = new Dictionary<string, double>(_gauges)
        };
    }
}
```

---

### æ­¥éª¤12.2: ç›‘æ§é¢æ¿API

```csharp
// Api/MonitoringController.cs
[ApiController]
[Route("api/monitoring")]
public class MonitoringController : ControllerBase
{
    private readonly MetricsCollector _metrics;
    private readonly EconomyStatisticsService _economyStats;

    [HttpGet("metrics")]
    public IActionResult GetMetrics()
    {
        return Ok(_metrics.GetSnapshot());
    }

    [HttpGet("economy-report")]
    public async Task<IActionResult> GetEconomyReport(
        [FromQuery] int hours = 24)
    {
        var report = await _economyStats.GenerateReportAsync(
            TimeSpan.FromHours(hours));
        
        return Ok(report);
    }

    [HttpGet("health")]
    public IActionResult GetHealthStatus()
    {
        return Ok(new
        {
            Status = "Healthy",
            Timestamp = DateTime.UtcNow,
            Version = "1.0.0"
        });
    }
}
```

---

## éªŒæ”¶ä¸äº¤ä»˜

### éªŒæ”¶æ ‡å‡†

#### åŠŸèƒ½å®Œæ•´æ€§

```
âœ… ç¦»çº¿æ”¶ç›Šç³»ç»Ÿå¯ç”¨ï¼Œç»“ç®—å‡†ç¡®
âœ… æ´»åŠ¨è®¡åˆ’æ”¯æŒå¤šæ§½ä½ï¼Œè‡ªåŠ¨è¡”æ¥
âœ… è£…å¤‡ç³»ç»Ÿæ”¯æŒTier/Affix/åˆ†è§£/é‡é“¸
âœ… ç»æµå¾ªç¯è¿è¡Œï¼Œäº§å‡ºæ¶ˆè€—å¹³è¡¡
âœ… SignalRæ¨é€ç¨³å®šï¼Œæ— é—æ¼
âœ… æ•°æ®åº“è®¿é—®é«˜æ•ˆï¼Œæ— N+1æŸ¥è¯¢
âœ… ç¼“å­˜å‘½ä¸­ç‡ > 80%
```

#### æ€§èƒ½æŒ‡æ ‡

```
âœ… APIå“åº”æ—¶é—´ P95 < 500ms
âœ… å¹¶å‘100ç”¨æˆ·æ— æ€§èƒ½é€€åŒ–
âœ… ç¦»çº¿æ¨¡æ‹Ÿ12å°æ—¶ < 5ç§’
âœ… æ•°æ®åº“æŸ¥è¯¢ P95 < 100ms
âœ… å†…å­˜å ç”¨ < 500MBï¼ˆå•å®ä¾‹ï¼‰
```

#### ç¨³å®šæ€§æŒ‡æ ‡

```
âœ… 7Ã—24å°æ—¶æ— å´©æºƒ
âœ… é”™è¯¯ç‡ < 0.1%
âœ… æ•°æ®ä¸€è‡´æ€§100%
âœ… äº‹åŠ¡æˆåŠŸç‡ > 99.9%
```

---

### äº¤ä»˜æ¸…å•

#### æ–‡æ¡£

```
âœ… é‡æ„è·¯çº¿å›¾ï¼ˆä¸Šä¸­ä¸‹ä¸‰ç¯‡ï¼‰
âœ… APIæ–‡æ¡£ï¼ˆSwaggerï¼‰
âœ… æ¶æ„è®¾è®¡æ–‡æ¡£
âœ… æ•°æ®åº“Schemaæ–‡æ¡£
âœ… è¿ç»´æ‰‹å†Œ
âœ… æ•…éšœæ’æŸ¥æŒ‡å—
```

#### ä»£ç 

```
âœ… åŸºç¡€è®¾æ–½å±‚ä»£ç 
âœ… åŠŸèƒ½æ¨¡å—ä»£ç 
âœ… å•å…ƒæµ‹è¯•ï¼ˆè¦†ç›–ç‡ > 80%ï¼‰
âœ… é›†æˆæµ‹è¯•
âœ… æ€§èƒ½æµ‹è¯•è„šæœ¬
```

#### é…ç½®

```
âœ… é…ç½®æ–‡ä»¶æ¨¡æ¿
âœ… ç¯å¢ƒå˜é‡è¯´æ˜
âœ… éƒ¨ç½²è„šæœ¬
âœ… æ•°æ®åº“è¿ç§»è„šæœ¬
```

---

## æ€»ç»“

### å®Œæˆåçš„ç³»ç»ŸçŠ¶æ€

```
ğŸ‰ ç¨³å®šçš„åŸºç¡€è®¾æ–½å±‚
   - SignalRç»Ÿä¸€æ¨é€
   - Repositoryæ•°æ®è®¿é—®
   - å¤šå±‚ç¼“å­˜ç³»ç»Ÿ
   - é…ç½®ç®¡ç†æ¡†æ¶
   - äº‹ä»¶æº¯æºæœºåˆ¶

ğŸ‰ å®Œæ•´çš„æ ¸å¿ƒç©æ³•
   - ç¦»çº¿æ”¶ç›Šç³»ç»Ÿ
   - æ´»åŠ¨è®¡åˆ’ç³»ç»Ÿ
   - è£…å¤‡å¼ºåŒ–ç”Ÿæ€
   - ç»æµå¾ªç¯é—­ç¯

ğŸ‰ å¥å£®çš„è¿ç»´èƒ½åŠ›
   - ç›‘æ§ä¸è¯Šæ–­
   - æ€§èƒ½ä¼˜åŒ–
   - æ•…éšœæ’æŸ¥
```

---

### åç»­è§„åˆ’

å®Œæˆæœ¬è·¯çº¿å›¾åï¼Œé¡¹ç›®å…·å¤‡äº†ä»¥ä¸‹æ‰©å±•èƒ½åŠ›ï¼š

```
ğŸ“ˆ ä¸‹ä¸€æ­¥å¯å®ç°ï¼š
   - åœ°å›¾ä¸åŒºåŸŸç³»ç»Ÿ
   - ä»»åŠ¡ä¸å£°æœ›ç³»ç»Ÿ
   - å¤šè§’è‰²Rosterç®¡ç†
   - ç»„é˜Ÿä¸å‰¯æœ¬ç³»ç»Ÿ
   - PvPç³»ç»Ÿ

ğŸ“ˆ é•¿æœŸç›®æ ‡ï¼š
   - èµ›å­£æœºåˆ¶
   - æ’è¡Œæ¦œ
   - å…¬ä¼šç³»ç»Ÿ
   - ç¤¾äº¤åŠŸèƒ½
```

---

**æ–‡æ¡£çŠ¶æ€**: âœ… å®Œæˆ  
**æ€»å®æ–½æ—¶é—´**: çº¦7-8ä¸ªæœˆ  
**é¡¹ç›®æˆç†Ÿåº¦**: ä»Demoæå‡åˆ°å¯è¿è¥çº§åˆ«

---

**å…³é”®æˆåŠŸå› ç´ **:
1. ä¸¥æ ¼æŒ‰Phaseé¡ºåºæ‰§è¡Œï¼Œä¸è·³è¿‡åŸºç¡€è®¾æ–½å»ºè®¾
2. æ¯ä¸ªPhaseå®Œæˆåå……åˆ†æµ‹è¯•ï¼Œå†è¿›å…¥ä¸‹ä¸€Phase
3. ä¿æŒä¸è®¾è®¡æ–‡æ¡£çš„ä¸€è‡´æ€§
4. æŒç»­é‡æ„ï¼Œä¿æŒä»£ç è´¨é‡
5. åŠæ—¶è®°å½•é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆï¼Œå»ºç«‹çŸ¥è¯†åº“

**é¢„æœŸæˆæœ**:
- ä¸€ä¸ªæ¶æ„æ¸…æ™°ã€æ˜“äºç»´æŠ¤çš„Web RPGæ¸¸æˆ
- ç¨³å®šçš„åŸºç¡€è®¾æ–½æ”¯æ’‘åŠŸèƒ½å¿«é€Ÿè¿­ä»£
- å®Œå–„çš„ç›‘æ§ä¸è¯Šæ–­èƒ½åŠ›ä¿éšœé•¿æœŸè¿è¥
