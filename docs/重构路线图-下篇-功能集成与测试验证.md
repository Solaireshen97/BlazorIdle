# BlazorIdle 重构路线图（下篇）：功能集成与测试验证

**文档版本**: 1.0  
**生成日期**: 2025年10月  
**状态**: 实施规划  
**目标**: 在稳定基础设施上实现核心功能，完成测试验证

---

## 📋 目录

1. [功能实现总览](#功能实现总览)
2. [Phase 6: 离线收益系统](#phase-6-离线收益系统)
3. [Phase 7: 活动计划系统](#phase-7-活动计划系统)
4. [Phase 8: 装备系统完善](#phase-8-装备系统完善)
5. [Phase 9: 经济循环建立](#phase-9-经济循环建立)
6. [Phase 10: 集成测试](#phase-10-集成测试)
7. [Phase 11: 性能优化](#phase-11-性能优化)
8. [Phase 12: 监控与诊断](#phase-12-监控与诊断)
9. [验收与交付](#验收与交付)

---

## 功能实现总览

### 实施策略

基于前两篇文档建立的稳定基础设施，本篇聚焦于：

```
✅ 核心玩法功能实现
✅ 功能集成与联调
✅ 全面测试验证
✅ 性能优化与监控
✅ 文档完善与交付
```

---

### 功能实现顺序

#### 为什么这样排序？

```
1. 离线收益 (Phase 6)
   ↓ 理由：基于事件溯源（Phase 5），为活动系统提供基础
   
2. 活动计划 (Phase 7)
   ↓ 理由：统一调度入口，装备获取场景依赖此系统
   
3. 装备系统 (Phase 8)
   ↓ 理由：构筑深度核心，需要活动系统提供掉落场景
   
4. 经济循环 (Phase 9)
   ↓ 理由：装备系统提供消耗端，闭合经济循环
   
5. 集成测试 (Phase 10)
   ↓ 理由：所有功能完成后，验证整体协调性
   
6. 性能优化 (Phase 11)
   ↓ 理由：基于测试结果，定向优化瓶颈
   
7. 监控诊断 (Phase 12)
   ↓ 理由：建立长期运维能力
```

---

### 时间规划

```
Phase 6: 离线收益      [3周]   ████████░░░░░░░░░░░░
Phase 7: 活动计划      [4周]   ████████████░░░░░░░░
Phase 8: 装备系统      [6周]   ████████████████████
Phase 9: 经济循环      [3周]   ████████████████████████
Phase 10: 集成测试     [2周]   ████████████████████████████
Phase 11: 性能优化     [2周]   ████████████████████████████████
Phase 12: 监控诊断     [2周]   ████████████████████████████████████

总计：22周（约5.5个月）
```

**结合前两篇**:
```
上篇+中篇: 9-11周（基础设施）
下篇: 22周（功能实现）
───────────────────────────
总计: 31-33周（约7-8个月）
```

---

## Phase 6: 离线收益系统

**目标**: 实现离线时间补算，提供一致的离线收益  
**时间**: 3周  
**优先级**: 🔴 最高  
**依赖**: Phase 5（事件溯源）

---

### 步骤6.1: 设计离线收益引擎

**核心架构**:

```csharp
// Domain/Offline/OfflineFastForwardEngine.cs
public class OfflineFastForwardEngine
{
    private readonly IEventStore _eventStore;
    private readonly ISnapshotStore _snapshotStore;
    private readonly IConfigProvider _configProvider;
    private readonly ILogger<OfflineFastForwardEngine> _logger;

    public async Task<OfflineResult> SimulateAsync(
        Guid characterId,
        DateTime lastOnlineTime,
        DateTime currentTime,
        CancellationToken ct = default)
    {
        // 1. 计算离线时长（上限12小时）
        var offlineDuration = currentTime - lastOnlineTime;
        var cappedDuration = TimeSpan.FromHours(
            Math.Min(offlineDuration.TotalHours, 12));

        _logger.LogInformation(
            "开始离线补算: 角色={CharacterId}, 时长={Duration}小时", 
            characterId, cappedDuration.TotalHours);

        // 2. 加载最新快照
        var (snapshot, version) = await _snapshotStore
            .GetLatestSnapshotAsync<CharacterSnapshot>(characterId, ct);

        if (snapshot == null)
        {
            throw new InvalidOperationException(
                $"未找到角色快照: {characterId}");
        }

        // 3. 重放事件（如果有新事件）
        var events = await _eventStore
            .GetEventsSinceAsync(characterId, version, ct);
        
        var currentState = ApplyEvents(snapshot, events);

        // 4. 执行离线模拟
        var result = await SimulateOfflineActivitiesAsync(
            currentState, cappedDuration, ct);

        // 5. 生成新快照
        await _snapshotStore.SaveSnapshotAsync(
            characterId, result.FinalState, version + 1, ct);

        // 6. 持久化事件
        await _eventStore.AppendBatchAsync(result.Events, ct);

        return result;
    }

    private async Task<OfflineResult> SimulateOfflineActivitiesAsync(
        CharacterState state,
        TimeSpan duration,
        CancellationToken ct)
    {
        var result = new OfflineResult
        {
            StartState = state.Clone(),
            Events = new List<IDomainEvent>()
        };

        // 获取最后的活动计划
        var lastPlan = state.CurrentActivityPlan;
        
        if (lastPlan == null || lastPlan.Type == ActivityType.Idle)
        {
            _logger.LogWarning("角色离线时无活动，跳过模拟");
            result.FinalState = state;
            return result;
        }

        // 根据活动类型模拟
        switch (lastPlan.Type)
        {
            case ActivityType.Combat:
                await SimulateCombatAsync(state, duration, result, ct);
                break;
                
            case ActivityType.Gather:
                await SimulateGatherAsync(state, duration, result, ct);
                break;
                
            case ActivityType.Craft:
                await SimulateCraftAsync(state, duration, result, ct);
                break;
        }

        result.FinalState = state;
        return result;
    }

    private async Task SimulateCombatAsync(
        CharacterState state,
        TimeSpan duration,
        OfflineResult result,
        CancellationToken ct)
    {
        // 使用与在线战斗相同的引擎
        var battleEngine = new BattleEngine(
            state, 
            _configProvider, 
            isOffline: true);

        var segments = await battleEngine.RunForDurationAsync(
            duration, ct);

        // 聚合结果
        foreach (var segment in segments)
        {
            result.GoldEarned += segment.GoldReward;
            result.ExperienceGained += segment.ExperienceReward;
            result.ItemsDropped.AddRange(segment.Drops);
            
            result.Events.Add(new BattleSegmentCompletedEvent(
                Guid.NewGuid(),
                state.CharacterId,
                segment));
        }

        _logger.LogInformation(
            "离线战斗模拟完成: 段数={SegmentCount}, 金币={Gold}, 经验={Exp}",
            segments.Count, result.GoldEarned, result.ExperienceGained);
    }
}
```

---

### 步骤6.2: 实现分段模拟

**防止长时间模拟卡顿**:

```csharp
// Domain/Offline/SegmentedOfflineSimulator.cs
public class SegmentedOfflineSimulator
{
    private const int MAX_SEGMENT_MINUTES = 30;

    public async Task<OfflineResult> SimulateInSegmentsAsync(
        CharacterState state,
        TimeSpan totalDuration,
        CancellationToken ct)
    {
        var result = new OfflineResult();
        var remaining = totalDuration;
        var currentState = state;

        while (remaining > TimeSpan.Zero)
        {
            var segmentDuration = TimeSpan.FromMinutes(
                Math.Min(remaining.TotalMinutes, MAX_SEGMENT_MINUTES));

            _logger.LogDebug(
                "模拟段落: 时长={Duration}分钟", 
                segmentDuration.TotalMinutes);

            var segmentResult = await SimulateSegmentAsync(
                currentState, segmentDuration, ct);

            // 合并结果
            result.Merge(segmentResult);
            currentState = segmentResult.FinalState;
            remaining -= segmentDuration;

            // 允许取消
            ct.ThrowIfCancellationRequested();
        }

        return result;
    }
}
```

---

### 步骤6.3: 创建离线收益API

```csharp
// Api/OfflineController.cs
[ApiController]
[Route("api/offline")]
public class OfflineController : ControllerBase
{
    private readonly OfflineFastForwardEngine _offlineEngine;
    private readonly IUnitOfWork _unitOfWork;

    [HttpPost("settle/{characterId}")]
    public async Task<IActionResult> SettleOfflineRewards(
        Guid characterId,
        CancellationToken ct)
    {
        // 1. 获取角色信息
        var characterRepo = _unitOfWork.Repository<Character>();
        var character = await characterRepo.GetByIdAsync(characterId, ct);

        if (character == null)
        {
            return NotFound();
        }

        // 2. 检查是否需要结算
        var now = DateTime.UtcNow;
        var lastOnline = character.LastOnlineAt;
        var offlineDuration = now - lastOnline;

        if (offlineDuration < TimeSpan.FromMinutes(5))
        {
            return Ok(new OfflineRewardResponse
            {
                HasRewards = false,
                Message = "离线时间过短，无收益"
            });
        }

        // 3. 执行离线模拟
        var result = await _offlineEngine.SimulateAsync(
            characterId, lastOnline, now, ct);

        // 4. 应用收益
        character.Gold += result.GoldEarned;
        character.Experience += result.ExperienceGained;
        character.LastOnlineAt = now;

        await characterRepo.UpdateAsync(character, ct);
        await _unitOfWork.SaveChangesAsync(ct);

        // 5. 返回结果
        return Ok(new OfflineRewardResponse
        {
            HasRewards = true,
            GoldEarned = result.GoldEarned,
            ExperienceGained = result.ExperienceGained,
            ItemsDropped = result.ItemsDropped,
            BattleSegments = result.Events.Count,
            OfflineDuration = offlineDuration
        });
    }
}
```

---

### 步骤6.4: 前端集成

**前端自动检测离线收益**:

```csharp
// Blazor WASM: Services/OfflineRewardService.cs
public class OfflineRewardService
{
    private readonly ApiClient _apiClient;
    private readonly ILogger<OfflineRewardService> _logger;

    public async Task CheckAndSettleOfflineRewardsAsync(Guid characterId)
    {
        try
        {
            var response = await _apiClient.PostAsync<OfflineRewardResponse>(
                $"offline/settle/{characterId}");

            if (response.HasRewards)
            {
                _logger.LogInformation(
                    "离线收益结算: 金币+{Gold}, 经验+{Exp}, 物品×{Items}",
                    response.GoldEarned,
                    response.ExperienceGained,
                    response.ItemsDropped.Count);

                // 触发UI显示离线收益弹窗
                await ShowOfflineRewardDialogAsync(response);
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "离线收益结算失败");
        }
    }

    private async Task ShowOfflineRewardDialogAsync(
        OfflineRewardResponse rewards)
    {
        // 显示模态对话框展示收益
        // 实现省略...
    }
}
```

---

## Phase 7: 活动计划系统

**目标**: 实现多槽位活动调度，统一管理各类活动  
**时间**: 4周  
**优先级**: 🔴 最高  
**依赖**: Phase 6（离线系统需要活动计划）

---

### 步骤7.1: 定义活动计划数据结构

```csharp
// Domain/Activities/ActivityPlan.cs
public class ActivityPlan
{
    public Guid Id { get; init; }
    public ActivityType Type { get; init; }
    public PlanState State { get; set; }
    public LimitSpec Limit { get; init; }
    public Dictionary<string, object> Payload { get; init; }
    public DateTime? StartedAt { get; set; }
    public DateTime? CompletedAt { get; set; }
    public int ProgressCount { get; set; }
    public double ProgressDuration { get; set; }

    public bool IsComplete()
    {
        return Limit.Type switch
        {
            LimitType.Count => ProgressCount >= Limit.TargetValue,
            LimitType.Duration => ProgressDuration >= Limit.TargetValue,
            LimitType.Infinite => false,
            _ => false
        };
    }

    public void UpdateProgress(int countDelta, double durationDelta)
    {
        ProgressCount += countDelta;
        ProgressDuration += durationDelta;

        if (IsComplete())
        {
            State = PlanState.Completed;
            CompletedAt = DateTime.UtcNow;
        }
    }
}

// Domain/Activities/ActivitySlot.cs
public class ActivitySlot
{
    public int SlotIndex { get; init; }
    public Guid CharacterId { get; init; }
    public Guid? CurrentPlanId { get; set; }
    public List<Guid> QueuedPlanIds { get; init; } = new();

    public bool IsActive => CurrentPlanId.HasValue;
    public bool HasQueue => QueuedPlanIds.Any();
}
```

---

### 步骤7.2: 实现活动协调器

```csharp
// Application/Activities/ActivityCoordinator.cs
public class ActivityCoordinator
{
    private readonly IUnitOfWork _unitOfWork;
    private readonly IEventBus _eventBus;
    private readonly ILogger<ActivityCoordinator> _logger;

    public async Task<ActivityPlan> StartActivityAsync(
        Guid characterId,
        int slotIndex,
        ActivityPlan plan,
        CancellationToken ct)
    {
        // 1. 验证槽位
        var slotRepo = _unitOfWork.Repository<ActivitySlot>();
        var slot = await slotRepo.GetByIdAsync(
            GetSlotId(characterId, slotIndex), ct);

        if (slot == null)
        {
            throw new InvalidOperationException(
                $"活动槽位不存在: 角色={characterId}, 槽位={slotIndex}");
        }

        if (slot.IsActive)
        {
            throw new InvalidOperationException(
                "槽位已有活动运行中");
        }

        // 2. 初始化活动
        plan.State = PlanState.Running;
        plan.StartedAt = DateTime.UtcNow;

        var planRepo = _unitOfWork.Repository<ActivityPlan>();
        await planRepo.AddAsync(plan, ct);

        // 3. 更新槽位
        slot.CurrentPlanId = plan.Id;
        await slotRepo.UpdateAsync(slot, ct);

        await _unitOfWork.SaveChangesAsync(ct);

        // 4. 发布事件
        await _eventBus.PublishAsync(new ActivityStartedEvent(
            characterId, slotIndex, plan));

        _logger.LogInformation(
            "活动开始: 角色={CharacterId}, 槽位={Slot}, 类型={Type}",
            characterId, slotIndex, plan.Type);

        return plan;
    }

    public async Task<ActivityPlan> CompleteActivityAsync(
        Guid planId,
        CancellationToken ct)
    {
        var planRepo = _unitOfWork.Repository<ActivityPlan>();
        var plan = await planRepo.GetByIdAsync(planId, ct);

        if (plan == null)
        {
            throw new KeyNotFoundException($"活动计划不存在: {planId}");
        }

        // 标记完成
        plan.State = PlanState.Completed;
        plan.CompletedAt = DateTime.UtcNow;
        await planRepo.UpdateAsync(plan, ct);

        // 查找槽位
        var slotRepo = _unitOfWork.Repository<ActivitySlot>();
        var slot = await slotRepo
            .FindAsync(s => s.CurrentPlanId == planId, ct)
            .FirstOrDefaultAsync();

        if (slot != null)
        {
            slot.CurrentPlanId = null;

            // 自动启动下一个排队活动
            if (slot.HasQueue)
            {
                var nextPlanId = slot.QueuedPlanIds.First();
                slot.QueuedPlanIds.RemoveAt(0);
                
                var nextPlan = await planRepo.GetByIdAsync(nextPlanId, ct);
                if (nextPlan != null)
                {
                    await StartActivityAsync(
                        slot.CharacterId, 
                        slot.SlotIndex, 
                        nextPlan, 
                        ct);
                }
            }

            await slotRepo.UpdateAsync(slot, ct);
        }

        await _unitOfWork.SaveChangesAsync(ct);

        // 发布事件
        await _eventBus.PublishAsync(new ActivityCompletedEvent(
            plan.Payload.GetValueOrDefault("CharacterId", Guid.Empty),
            slot?.SlotIndex ?? 0,
            plan));

        return plan;
    }
}
```

---

### 步骤7.3: 集成战斗活动

```csharp
// Application/Activities/CombatActivityHandler.cs
public class CombatActivityHandler
{
    private readonly ActivityCoordinator _coordinator;
    private readonly BattleEngine _battleEngine;
    private readonly IEventBus _eventBus;

    public async Task<ActivityPlan> StartCombatActivityAsync(
        Guid characterId,
        int slotIndex,
        string enemyId,
        int targetKills,
        CancellationToken ct)
    {
        var plan = new ActivityPlan
        {
            Id = Guid.NewGuid(),
            Type = ActivityType.Combat,
            Limit = new LimitSpec
            {
                Type = LimitType.Count,
                TargetValue = targetKills
            },
            Payload = new Dictionary<string, object>
            {
                ["CharacterId"] = characterId,
                ["EnemyId"] = enemyId,
                ["TargetKills"] = targetKills
            }
        };

        // 启动活动
        await _coordinator.StartActivityAsync(
            characterId, slotIndex, plan, ct);

        // 订阅战斗完成事件，更新进度
        _eventBus.Subscribe<BattleCompletedEvent>(async @event =>
        {
            if (@event.CharacterId == characterId)
            {
                await UpdateCombatProgressAsync(plan.Id, 1, ct);
            }
        });

        return plan;
    }

    private async Task UpdateCombatProgressAsync(
        Guid planId,
        int killCount,
        CancellationToken ct)
    {
        var planRepo = _unitOfWork.Repository<ActivityPlan>();
        var plan = await planRepo.GetByIdAsync(planId, ct);

        if (plan != null)
        {
            plan.UpdateProgress(killCount, 0);
            await planRepo.UpdateAsync(plan, ct);
            await _unitOfWork.SaveChangesAsync(ct);

            if (plan.IsComplete())
            {
                await _coordinator.CompleteActivityAsync(planId, ct);
            }
        }
    }
}
```

---

## Phase 8: 装备系统完善

**目标**: 实现装备Tier、Affix、分解、重铸  
**时间**: 6周  
**优先级**: 🔴 高  
**依赖**: Phase 7（活动系统提供装备掉落场景）

---

### 步骤8.1: 定义装备数据结构

```csharp
// Domain/Equipment/GearDefinition.cs
public class GearDefinition
{
    public string Id { get; init; }
    public string Name { get; init; }
    public GearSlot Slot { get; init; }
    public GearRarity Rarity { get; init; }
    public int RequiredLevel { get; init; }
    public Dictionary<string, (int Min, int Max)> BaseStats { get; init; }
    public List<string> AllowedAffixPool { get; init; }
    public string? SetId { get; init; }
}

// Domain/Equipment/GearInstance.cs
public class GearInstance
{
    public Guid Id { get; init; }
    public string DefinitionId { get; init; }
    public GearTier Tier { get; set; }
    public List<Affix> Affixes { get; set; }
    public int QualityScore { get; set; }
    public DateTime CreatedAt { get; init; }
    public int RerollCount { get; set; }

    public Dictionary<string, int> GetTotalStats()
    {
        var stats = new Dictionary<string, int>();
        
        // 基础属性 × Tier系数
        var definition = ConfigProvider.Get<GearDefinition>(DefinitionId);
        var tierMultiplier = Tier switch
        {
            GearTier.T1 => 0.8,
            GearTier.T2 => 1.0,
            GearTier.T3 => 1.2,
            _ => 1.0
        };

        foreach (var (stat, (min, max)) in definition.BaseStats)
        {
            var avgValue = (min + max) / 2.0;
            stats[stat] = (int)(avgValue * tierMultiplier);
        }

        // 词条加成
        foreach (var affix in Affixes)
        {
            foreach (var (stat, value) in affix.Stats)
            {
                if (stats.ContainsKey(stat))
                    stats[stat] += value;
                else
                    stats[stat] = value;
            }
        }

        return stats;
    }
}

// Domain/Equipment/Affix.cs
public class Affix
{
    public string Id { get; init; }
    public string Name { get; init; }
    public AffixType Type { get; init; }
    public Dictionary<string, int> Stats { get; init; }
    public AffixRarity Rarity { get; init; }
}
```

---

### 步骤8.2: 实现装备生成器

```csharp
// Domain/Equipment/GearGenerator.cs
public class GearGenerator
{
    private readonly IConfigProvider _configProvider;
    private readonly Random _random;

    public GearInstance GenerateGear(
        string definitionId,
        GearTier tier,
        int affixCount)
    {
        var definition = _configProvider.Get<GearDefinition>(definitionId);
        
        var gear = new GearInstance
        {
            Id = Guid.NewGuid(),
            DefinitionId = definitionId,
            Tier = tier,
            Affixes = new List<Affix>(),
            CreatedAt = DateTime.UtcNow,
            RerollCount = 0
        };

        // 生成词条
        var affixPool = _configProvider.GetAll<AffixDefinition>()
            .Where(a => definition.AllowedAffixPool.Contains(a.Id))
            .ToList();

        for (int i = 0; i < affixCount; i++)
        {
            var affixDef = SelectRandomAffix(affixPool);
            var affix = RollAffix(affixDef);
            gear.Affixes.Add(affix);
        }

        // 计算品质分数
        gear.QualityScore = CalculateQualityScore(gear);

        return gear;
    }

    private Affix RollAffix(AffixDefinition definition)
    {
        var stats = new Dictionary<string, int>();
        
        foreach (var (stat, (min, max)) in definition.StatRanges)
        {
            var value = _random.Next(min, max + 1);
            stats[stat] = value;
        }

        return new Affix
        {
            Id = definition.Id,
            Name = definition.Name,
            Type = definition.Type,
            Stats = stats,
            Rarity = definition.Rarity
        };
    }

    private int CalculateQualityScore(GearInstance gear)
    {
        // 基础分：Tier
        int score = gear.Tier switch
        {
            GearTier.T1 => 50,
            GearTier.T2 => 75,
            GearTier.T3 => 100,
            _ => 0
        };

        // 词条分：数量 + 稀有度
        score += gear.Affixes.Count * 10;
        score += gear.Affixes.Sum(a => (int)a.Rarity * 5);

        return score;
    }
}
```

---

### 步骤8.3: 实现分解系统

```csharp
// Application/Equipment/DisenchantService.cs
public class DisenchantService
{
    private readonly IUnitOfWork _unitOfWork;
    private readonly IConfigProvider _configProvider;

    public async Task<DisenchantResult> DisenchantGearAsync(
        Guid gearId,
        Guid characterId,
        CancellationToken ct)
    {
        // 1. 获取装备
        var gearRepo = _unitOfWork.Repository<GearInstance>();
        var gear = await gearRepo.GetByIdAsync(gearId, ct);

        if (gear == null)
        {
            throw new KeyNotFoundException($"装备不存在: {gearId}");
        }

        // 2. 计算分解产出
        var materials = CalculateMaterials(gear);
        var gold = CalculateGold(gear);

        // 3. 删除装备
        await gearRepo.DeleteAsync(gearId, ct);

        // 4. 添加材料
        var inventoryRepo = _unitOfWork.Repository<Inventory>();
        var inventory = await inventoryRepo
            .FindAsync(i => i.CharacterId == characterId, ct)
            .FirstOrDefaultAsync();

        foreach (var (materialId, quantity) in materials)
        {
            inventory.AddItem(materialId, quantity);
        }

        inventory.Gold += gold;

        await inventoryRepo.UpdateAsync(inventory, ct);
        await _unitOfWork.SaveChangesAsync(ct);

        return new DisenchantResult
        {
            Materials = materials,
            GoldGained = gold
        };
    }

    private Dictionary<string, int> CalculateMaterials(GearInstance gear)
    {
        var materials = new Dictionary<string, int>();
        
        // 基础材料（根据Tier）
        var baseMaterial = gear.Tier switch
        {
            GearTier.T1 => "material_basic",
            GearTier.T2 => "material_intermediate",
            GearTier.T3 => "material_advanced",
            _ => "material_basic"
        };
        
        materials[baseMaterial] = 5;

        // 稀有材料（根据稀有度）
        var definition = _configProvider.Get<GearDefinition>(gear.DefinitionId);
        if (definition.Rarity >= GearRarity.Rare)
        {
            materials["material_rare_essence"] = (int)definition.Rarity;
        }

        return materials;
    }

    private int CalculateGold(GearInstance gear)
    {
        // 根据品质分数计算金币
        return gear.QualityScore * 10;
    }
}
```

---

### 步骤8.4: 实现重铸系统

```csharp
// Application/Equipment/ReforgeService.cs
public class ReforgeService
{
    private readonly IUnitOfWork _unitOfWork;
    private readonly GearGenerator _gearGenerator;

    // Tier升级
    public async Task<GearInstance> ReforgeTierAsync(
        Guid gearId,
        Guid characterId,
        CancellationToken ct)
    {
        var gearRepo = _unitOfWork.Repository<GearInstance>();
        var gear = await gearRepo.GetByIdAsync(gearId, ct);

        if (gear == null)
        {
            throw new KeyNotFoundException($"装备不存在: {gearId}");
        }

        // 验证是否可升级
        if (gear.Tier == GearTier.T3)
        {
            throw new InvalidOperationException("装备已达最高Tier");
        }

        // 计算消耗
        var cost = CalculateReforgeCost(gear);
        
        // 扣除材料与金币
        var inventoryRepo = _unitOfWork.Repository<Inventory>();
        var inventory = await inventoryRepo
            .FindAsync(i => i.CharacterId == characterId, ct)
            .FirstOrDefaultAsync();

        if (!inventory.HasMaterials(cost.Materials) || 
            inventory.Gold < cost.GoldCost)
        {
            throw new InvalidOperationException("材料或金币不足");
        }

        inventory.ConsumeMaterials(cost.Materials);
        inventory.Gold -= cost.GoldCost;
        await inventoryRepo.UpdateAsync(inventory, ct);

        // 提升Tier
        gear.Tier = gear.Tier switch
        {
            GearTier.T1 => GearTier.T2,
            GearTier.T2 => GearTier.T3,
            _ => gear.Tier
        };

        // 重新计算品质
        gear.QualityScore = _gearGenerator.CalculateQualityScore(gear);

        await gearRepo.UpdateAsync(gear, ct);
        await _unitOfWork.SaveChangesAsync(ct);

        return gear;
    }

    // 词条重置
    public async Task<GearInstance> RerollAffixesAsync(
        Guid gearId,
        Guid characterId,
        CancellationToken ct)
    {
        var gearRepo = _unitOfWork.Repository<GearInstance>();
        var gear = await gearRepo.GetByIdAsync(gearId, ct);

        if (gear == null)
        {
            throw new KeyNotFoundException($"装备不存在: {gearId}");
        }

        // 递增成本（每次重置更贵）
        var cost = CalculateRerollCost(gear.RerollCount);

        // 扣除消耗
        var inventoryRepo = _unitOfWork.Repository<Inventory>();
        var inventory = await inventoryRepo
            .FindAsync(i => i.CharacterId == characterId, ct)
            .FirstOrDefaultAsync();

        if (!inventory.HasMaterials(cost.Materials) || 
            inventory.Gold < cost.GoldCost)
        {
            throw new InvalidOperationException("材料或金币不足");
        }

        inventory.ConsumeMaterials(cost.Materials);
        inventory.Gold -= cost.GoldCost;
        await inventoryRepo.UpdateAsync(inventory, ct);

        // 重新生成词条
        var definition = _configProvider.Get<GearDefinition>(gear.DefinitionId);
        gear.Affixes = _gearGenerator.GenerateAffixes(
            definition, gear.Affixes.Count);
        gear.RerollCount++;
        gear.QualityScore = _gearGenerator.CalculateQualityScore(gear);

        await gearRepo.UpdateAsync(gear, ct);
        await _unitOfWork.SaveChangesAsync(ct);

        return gear;
    }
}
```

---

## Phase 9: 经济循环建立

**目标**: 建立经济监控，平衡产出与消耗  
**时间**: 3周  
**优先级**: 🟡 中  
**依赖**: Phase 8（装备系统提供消耗端）

---

### 步骤9.1: 实现经济事件追踪

```csharp
// Domain/Economy/EconomyEvent.cs
public record EconomyEvent(
    Guid CharacterId,
    EconomyEventType Type,
    string Source,
    Dictionary<string, int> Changes,
    DateTime Timestamp
) : IDomainEvent
{
    public Guid EventId { get; } = Guid.NewGuid();
    public DateTime OccurredAt => Timestamp;
    public string EventType => nameof(EconomyEvent);
}

// Application/Economy/EconomyTracker.cs
public class EconomyTracker
{
    private readonly IEventBus _eventBus;
    private readonly IEventStore _eventStore;

    public async Task TrackGainAsync(
        Guid characterId,
        string source,
        int goldGained,
        Dictionary<string, int> itemsGained)
    {
        var changes = new Dictionary<string, int>
        {
            ["gold"] = goldGained
        };

        foreach (var (itemId, qty) in itemsGained)
        {
            changes[itemId] = qty;
        }

        var @event = new EconomyEvent(
            characterId,
            EconomyEventType.Gain,
            source,
            changes,
            DateTime.UtcNow);

        await _eventBus.PublishAsync(@event);
        await _eventStore.AppendAsync(@event);
    }

    public async Task TrackSpendAsync(
        Guid characterId,
        string source,
        int goldSpent,
        Dictionary<string, int> materialsSpent)
    {
        var changes = new Dictionary<string, int>
        {
            ["gold"] = -goldSpent
        };

        foreach (var (materialId, qty) in materialsSpent)
        {
            changes[materialId] = -qty;
        }

        var @event = new EconomyEvent(
            characterId,
            EconomyEventType.Spend,
            source,
            changes,
            DateTime.UtcNow);

        await _eventBus.PublishAsync(@event);
        await _eventStore.AppendAsync(@event);
    }
}
```

---

### 步骤9.2: 实现经济统计

```csharp
// Application/Economy/EconomyStatisticsService.cs
public class EconomyStatisticsService
{
    private readonly IEventStore _eventStore;

    public async Task<EconomyReport> GenerateReportAsync(
        TimeSpan period,
        CancellationToken ct)
    {
        var since = DateTime.UtcNow - period;
        var events = await _eventStore
            .GetEventsSinceAsync(Guid.Empty, 0, ct); // 所有事件

        var economyEvents = events
            .OfType<EconomyEvent>()
            .Where(e => e.Timestamp >= since)
            .ToList();

        var report = new EconomyReport
        {
            Period = period,
            GeneratedAt = DateTime.UtcNow
        };

        // 金币流水
        report.GoldIn = economyEvents
            .Where(e => e.Type == EconomyEventType.Gain)
            .Sum(e => e.Changes.GetValueOrDefault("gold", 0));

        report.GoldOut = economyEvents
            .Where(e => e.Type == EconomyEventType.Spend)
            .Sum(e => Math.Abs(e.Changes.GetValueOrDefault("gold", 0)));

        report.GoldNetFlow = report.GoldIn - report.GoldOut;

        // 来源分析
        report.GoldSourceBreakdown = economyEvents
            .Where(e => e.Type == EconomyEventType.Gain)
            .GroupBy(e => e.Source)
            .ToDictionary(
                g => g.Key,
                g => g.Sum(e => e.Changes.GetValueOrDefault("gold", 0)));

        // 消耗分析
        report.GoldSinkBreakdown = economyEvents
            .Where(e => e.Type == EconomyEventType.Spend)
            .GroupBy(e => e.Source)
            .ToDictionary(
                g => g.Key,
                g => g.Sum(e => Math.Abs(e.Changes.GetValueOrDefault("gold", 0))));

        return report;
    }
}
```

---

## Phase 10: 集成测试

**目标**: 全面测试功能集成，验证系统稳定性  
**时间**: 2周  
**优先级**: 🔴 最高

---

### 步骤10.1: 端到端测试场景

```csharp
// Tests/Integration/E2EScenarios/CompleteGameLoopTests.cs
[Fact]
public async Task CompleteGameLoop_FromLoginToOfflineRewards_ShouldWork()
{
    // 1. 用户注册与登录
    var userId = await RegisterUserAsync("testuser", "password");
    var token = await LoginAsync("testuser", "password");

    // 2. 创建角色
    var characterId = await CreateCharacterAsync(userId, "TestHero");

    // 3. 启动战斗活动
    var activityId = await StartCombatActivityAsync(
        characterId, slotIndex: 0, enemyId: "goblin", targetKills: 5);

    // 4. 模拟在线战斗
    await Task.Delay(TimeSpan.FromSeconds(30));
    var activityStatus = await GetActivityStatusAsync(activityId);
    
    Assert.Equal(PlanState.Running, activityStatus.State);
    Assert.True(activityStatus.Progress > 0);

    // 5. 获取装备掉落
    var drops = await GetBattleDropsAsync(characterId);
    Assert.NotEmpty(drops);

    // 6. 分解一件装备
    var gear = drops.First();
    var disenchantResult = await DisenchantGearAsync(gear.Id, characterId);
    
    Assert.True(disenchantResult.GoldGained > 0);
    Assert.NotEmpty(disenchantResult.Materials);

    // 7. 模拟离线
    await LogoutAsync(characterId);
    await Task.Delay(TimeSpan.FromMinutes(10)); // 实际测试可用更短时间

    // 8. 重新登录，结算离线收益
    await LoginAsync("testuser", "password");
    var offlineRewards = await SettleOfflineRewardsAsync(characterId);

    Assert.True(offlineRewards.HasRewards);
    Assert.True(offlineRewards.GoldEarned > 0);

    // 9. 验证数据一致性
    var finalCharacter = await GetCharacterAsync(characterId);
    Assert.True(finalCharacter.Gold > 0);
    Assert.True(finalCharacter.Experience > 0);
}
```

---

### 步骤10.2: 压力测试

```csharp
// Tests/Integration/StressTests/ConcurrentBattleTests.cs
[Fact]
public async Task Concurrent100Battles_ShouldNotDegrade()
{
    var characterIds = Enumerable.Range(0, 100)
        .Select(_ => Guid.NewGuid())
        .ToList();

    // 并发启动100场战斗
    var tasks = characterIds.Select(id => 
        StartCombatActivityAsync(id, 0, "goblin", 10));

    var stopwatch = Stopwatch.StartNew();
    await Task.WhenAll(tasks);
    stopwatch.Stop();

    // 验证响应时间
    Assert.True(stopwatch.ElapsedMilliseconds < 5000, 
        "100个并发请求应在5秒内完成");

    // 验证所有战斗正常启动
    foreach (var id in characterIds)
    {
        var activity = await GetActivityStatusAsync(id);
        Assert.Equal(PlanState.Running, activity.State);
    }
}
```

---

## Phase 11: 性能优化

**目标**: 定位并优化性能瓶颈  
**时间**: 2周  
**优先级**: 🟡 中

---

### 步骤11.1: 数据库查询优化

```csharp
// 优化前：N+1查询
var characters = await _context.Characters.ToListAsync();
foreach (var character in characters)
{
    var equipment = await _context.Equipment
        .Where(e => e.CharacterId == character.Id)
        .ToListAsync();
}

// ↓↓↓ 优化后 ↓↓↓

// 预加载关联数据
var characters = await _context.Characters
    .Include(c => c.Equipment)
    .Include(c => c.Inventory)
    .ToListAsync();
```

---

### 步骤11.2: 缓存预热

```csharp
// Infrastructure/Caching/CacheWarmupService.cs
public class CacheWarmupService : IHostedService
{
    private readonly IMultiTierCache _cache;
    private readonly IConfigProvider _configProvider;

    public async Task StartAsync(CancellationToken ct)
    {
        // 预热配置数据
        await WarmupConfigsAsync(ct);
        
        // 预热热门装备数据
        await WarmupPopularGearsAsync(ct);
    }

    private async Task WarmupConfigsAsync(CancellationToken ct)
    {
        var skills = _configProvider.GetAll<SkillDefinition>();
        await _cache.SetAsync("config:skills", skills, 
            TimeSpan.FromHours(1), ct);

        var gears = _configProvider.GetAll<GearDefinition>();
        await _cache.SetAsync("config:gears", gears, 
            TimeSpan.FromHours(1), ct);
    }
}
```

---

## Phase 12: 监控与诊断

**目标**: 建立运维监控能力  
**时间**: 2周  
**优先级**: 🟡 中

---

### 步骤12.1: 实现Metrics收集

```csharp
// Infrastructure/Monitoring/MetricsCollector.cs
public class MetricsCollector
{
    private readonly ConcurrentDictionary<string, long> _counters = new();
    private readonly ConcurrentDictionary<string, double> _gauges = new();

    public void IncrementCounter(string metric, long value = 1)
    {
        _counters.AddOrUpdate(metric, value, (k, v) => v + value);
    }

    public void SetGauge(string metric, double value)
    {
        _gauges[metric] = value;
    }

    public MetricsSnapshot GetSnapshot()
    {
        return new MetricsSnapshot
        {
            Timestamp = DateTime.UtcNow,
            Counters = new Dictionary<string, long>(_counters),
            Gauges = new Dictionary<string, double>(_gauges)
        };
    }
}
```

---

### 步骤12.2: 监控面板API

```csharp
// Api/MonitoringController.cs
[ApiController]
[Route("api/monitoring")]
public class MonitoringController : ControllerBase
{
    private readonly MetricsCollector _metrics;
    private readonly EconomyStatisticsService _economyStats;

    [HttpGet("metrics")]
    public IActionResult GetMetrics()
    {
        return Ok(_metrics.GetSnapshot());
    }

    [HttpGet("economy-report")]
    public async Task<IActionResult> GetEconomyReport(
        [FromQuery] int hours = 24)
    {
        var report = await _economyStats.GenerateReportAsync(
            TimeSpan.FromHours(hours));
        
        return Ok(report);
    }

    [HttpGet("health")]
    public IActionResult GetHealthStatus()
    {
        return Ok(new
        {
            Status = "Healthy",
            Timestamp = DateTime.UtcNow,
            Version = "1.0.0"
        });
    }
}
```

---

## 验收与交付

### 验收标准

#### 功能完整性

```
✅ 离线收益系统可用，结算准确
✅ 活动计划支持多槽位，自动衔接
✅ 装备系统支持Tier/Affix/分解/重铸
✅ 经济循环运行，产出消耗平衡
✅ SignalR推送稳定，无遗漏
✅ 数据库访问高效，无N+1查询
✅ 缓存命中率 > 80%
```

#### 性能指标

```
✅ API响应时间 P95 < 500ms
✅ 并发100用户无性能退化
✅ 离线模拟12小时 < 5秒
✅ 数据库查询 P95 < 100ms
✅ 内存占用 < 500MB（单实例）
```

#### 稳定性指标

```
✅ 7×24小时无崩溃
✅ 错误率 < 0.1%
✅ 数据一致性100%
✅ 事务成功率 > 99.9%
```

---

### 交付清单

#### 文档

```
✅ 重构路线图（上中下三篇）
✅ API文档（Swagger）
✅ 架构设计文档
✅ 数据库Schema文档
✅ 运维手册
✅ 故障排查指南
```

#### 代码

```
✅ 基础设施层代码
✅ 功能模块代码
✅ 单元测试（覆盖率 > 80%）
✅ 集成测试
✅ 性能测试脚本
```

#### 配置

```
✅ 配置文件模板
✅ 环境变量说明
✅ 部署脚本
✅ 数据库迁移脚本
```

---

## 总结

### 完成后的系统状态

```
🎉 稳定的基础设施层
   - SignalR统一推送
   - Repository数据访问
   - 多层缓存系统
   - 配置管理框架
   - 事件溯源机制

🎉 完整的核心玩法
   - 离线收益系统
   - 活动计划系统
   - 装备强化生态
   - 经济循环闭环

🎉 健壮的运维能力
   - 监控与诊断
   - 性能优化
   - 故障排查
```

---

### 后续规划

完成本路线图后，项目具备了以下扩展能力：

```
📈 下一步可实现：
   - 地图与区域系统
   - 任务与声望系统
   - 多角色Roster管理
   - 组队与副本系统
   - PvP系统

📈 长期目标：
   - 赛季机制
   - 排行榜
   - 公会系统
   - 社交功能
```

---

**文档状态**: ✅ 完成  
**总实施时间**: 约7-8个月  
**项目成熟度**: 从Demo提升到可运营级别

---

**关键成功因素**:
1. 严格按Phase顺序执行，不跳过基础设施建设
2. 每个Phase完成后充分测试，再进入下一Phase
3. 保持与设计文档的一致性
4. 持续重构，保持代码质量
5. 及时记录问题与解决方案，建立知识库

**预期成果**:
- 一个架构清晰、易于维护的Web RPG游戏
- 稳定的基础设施支撑功能快速迭代
- 完善的监控与诊断能力保障长期运营
