# 用户系统（User System）文档

## 概述

本文档详细说明用户账号系统的设计、实现和使用方法。用户系统为游戏提供账号管理功能，支持一个用户拥有多个角色（为未来的 Roster 系统奠定基础）。

## 设计目标

1. **账号管理**: 提供用户账号的基本信息存储（用户名、邮箱等）
2. **多角色支持**: 一个用户可以创建和管理多个游戏角色（支持 Roster 系统）
3. **松耦合设计**: UserId 为可空外键，保持向后兼容，不破坏现有无账号角色
4. **可扩展性**: 为未来的认证、授权、社交功能预留接口

## 数据库架构

### 表结构

#### 1. users (用户表)

存储用户账号的基本信息。

| 列名 | 类型 | 约束 | 说明 |
|------|------|------|------|
| Id | GUID | PRIMARY KEY | 用户ID |
| Username | VARCHAR(64) | NOT NULL, UNIQUE | 用户名（唯一） |
| Email | VARCHAR(256) | NOT NULL, UNIQUE | 电子邮箱（唯一） |
| PasswordHash | VARCHAR(256) | NOT NULL | 密码哈希（BCrypt） |
| CreatedAt | DATETIME | NOT NULL | 账号创建时间 |
| UpdatedAt | DATETIME | NOT NULL | 最后更新时间 |
| LastLoginAt | DATETIME | NULL | 最后登录时间（可选） |

**索引**:
- PRIMARY KEY: `Id`
- UNIQUE INDEX: `Username` - 确保用户名唯一
- UNIQUE INDEX: `Email` - 确保邮箱唯一

**设计说明**:
- Username 和 Email 都设为唯一，两者都可用于登录识别
- LastLoginAt 可选字段，用于跟踪用户活跃度
- UpdatedAt 字段为未来的账号信息更新预留

#### 2. Characters (角色表) - 新增字段

在现有角色表中新增用户关联字段：

| 列名 | 类型 | 约束 | 说明 |
|------|------|------|------|
| UserId | GUID | NULL, FOREIGN KEY | 所属用户ID（可空） |

**索引**:
- INDEX: `UserId` - 提升按用户查询角色的性能
- INDEX: `(UserId, RosterOrder)` - 复合索引，优化按顺序查询角色
- FOREIGN KEY: `UserId` → `users(Id)` ON DELETE SET NULL

**设计说明**:
- UserId 设为可空，保持向后兼容（支持未绑定用户的角色）
- RosterOrder 默认为 0，支持角色排序功能（用于 Roster 槽位管理）
- ON DELETE SET NULL：删除用户时不删除角色，仅将 UserId 设为 NULL（保留孤立角色）
- 索引优化：加速 "查询某用户的所有角色" 和 "按顺序显示角色" 场景

### 数据关系图

```
users (用户)
    └── 1:N → Characters (角色)

Characters (角色)
    ├── N:1 → users (用户) [可选]
    ├── 1:N → inventory_items (背包物品)
    └── 1:N → economy_events (经济事件)
```

## 领域模型

### User 类

```csharp
namespace BlazorIdle.Server.Domain.Characters;

/// <summary>
/// 用户账号实体，用于管理用户登录信息和角色关联。
/// 一个用户可以拥有多个角色（支持未来的 Roster 系统）。
/// </summary>
public class User
{
    public Guid Id { get; set; }
    public string Username { get; set; } = "";
    public string Email { get; set; } = "";
    public string PasswordHash { get; set; } = "";  // 密码哈希（BCrypt）
    public DateTime CreatedAt { get; set; } = DateTime.UtcNow;
    public DateTime UpdatedAt { get; set; } = DateTime.UtcNow;
    public DateTime? LastLoginAt { get; set; }
    
    // Navigation property - 一个用户可以拥有多个角色
    public ICollection<Character> Characters { get; set; } = new List<Character>();
}
```

### Character 类变更

在 `Character` 类中新增：

```csharp
/// <summary>
/// 所属用户 ID（外键）
/// </summary>
public Guid? UserId { get; set; }

/// <summary>
/// 角色在用户 Roster 中的显示顺序（用于多角色管理）
/// </summary>
public int RosterOrder { get; set; } = 0;

// Navigation property - 所属用户
public User? User { get; set; }
```

## EF Core 配置

### UserConfiguration

```csharp
public class UserConfiguration : IEntityTypeConfiguration<User>
{
    public void Configure(EntityTypeBuilder<User> builder)
    {
        builder.ToTable("users");
        builder.HasKey(u => u.Id);
        
        // 用户名：必填，唯一，最大长度 64
        builder.Property(u => u.Username)
            .IsRequired()
            .HasMaxLength(64);
        builder.HasIndex(u => u.Username).IsUnique();
        
        // 电子邮箱：必填，唯一，最大长度 256
        builder.Property(u => u.Email)
            .IsRequired()
            .HasMaxLength(256);
        builder.HasIndex(u => u.Email).IsUnique();
        
        // 密码哈希：必填，最大长度 256
        builder.Property(u => u.PasswordHash)
            .IsRequired()
            .HasMaxLength(256);
        
        // 配置与 Character 的一对多关系
        builder.HasMany(u => u.Characters)
            .WithOne(c => c.User)
            .HasForeignKey(c => c.UserId)
            .OnDelete(DeleteBehavior.SetNull);
    }
}
```

### CharacterConfiguration 更新

```csharp
// 在 CharacterConfiguration.Configure 方法中添加：
b.Property(x => x.UserId);
b.HasIndex(x => x.UserId);

// 角色在用户 Roster 中的显示顺序
b.Property(x => x.RosterOrder)
    .HasDefaultValue(0);
b.HasIndex(x => new { x.UserId, x.RosterOrder });
```

## 数据库迁移

### 应用迁移

```bash
# 查看迁移
cd BlazorIdle.Server
dotnet ef migrations list

# 应用迁移到数据库
dotnet ef database update

# 或在开发环境自动迁移（Program.cs 中已配置）
dotnet run
```

### 迁移内容

迁移 `20251007064214_AddUserTable` 包含以下操作：

1. 创建 `users` 表及其索引
2. 在 `Characters` 表中添加 `UserId` 列
3. 创建外键约束 `FK_Characters_users_UserId`
4. 创建索引 `IX_Characters_UserId`

迁移 `20251007073221_AddPasswordAndRosterOrder` 包含以下操作：

1. 在 `users` 表中添加 `PasswordHash` 列（VARCHAR(256), NOT NULL）
2. 在 `Characters` 表中添加 `RosterOrder` 列（INTEGER, NOT NULL, DEFAULT 0）
3. 创建复合索引 `IX_Characters_UserId_RosterOrder`

### 回滚迁移

如需回滚：

```bash
dotnet ef migrations remove
# 或回滚到指定迁移
dotnet ef database update <PreviousMigrationName>
```

## 使用示例

### 1. 创建用户

```csharp
// 注意：实际使用时应使用 BCrypt.Net 等库进行密码哈希
// 示例: using BCrypt.Net;
// string passwordHash = BCrypt.HashPassword("userPassword");

var user = new User
{
    Id = Guid.NewGuid(),
    Username = "player123",
    Email = "player123@example.com",
    PasswordHash = BCrypt.Net.BCrypt.HashPassword("securePassword123"),  // 使用 BCrypt 哈希密码
    CreatedAt = DateTime.UtcNow,
    UpdatedAt = DateTime.UtcNow
};

_db.Users.Add(user);
await _db.SaveChangesAsync();
```

### 2. 创建角色并关联用户

```csharp
var character = new Character
{
    Id = Guid.NewGuid(),
    UserId = user.Id,  // 关联到用户
    RosterOrder = 0,   // 第一个角色，顺序为 0
    Name = "勇者小明",
    Profession = Profession.Warrior,
    Level = 1
};

_db.Characters.Add(character);
await _db.SaveChangesAsync();
```

### 3. 验证用户密码

```csharp
// 用户登录时验证密码
var user = await _db.Users
    .FirstOrDefaultAsync(u => u.Username == username);

if (user != null && BCrypt.Net.BCrypt.Verify(inputPassword, user.PasswordHash))
{
    // 密码正确，更新最后登录时间
    user.LastLoginAt = DateTime.UtcNow;
    await _db.SaveChangesAsync();
    
    // 登录成功逻辑...
}
else
{
    // 密码错误或用户不存在
}
```

### 4. 查询用户的所有角色（按顺序）

```csharp
// 方式 1: 使用 Include 加载导航属性并排序
var user = await _db.Users
    .Include(u => u.Characters.OrderBy(c => c.RosterOrder))
    .FirstOrDefaultAsync(u => u.Id == userId);

var characters = user?.Characters;

// 方式 2: 直接查询角色并按 RosterOrder 排序
var characters = await _db.Characters
    .Where(c => c.UserId == userId)
    .OrderBy(c => c.RosterOrder)
    .ToListAsync();
```

### 5. 查询角色及其所属用户

```csharp
var character = await _db.Characters
    .Include(c => c.User)
    .FirstOrDefaultAsync(c => c.Id == characterId);

var username = character?.User?.Username;
```

### 6. 调整角色顺序

```csharp
// 为用户的角色重新排序
var characters = await _db.Characters
    .Where(c => c.UserId == userId)
    .OrderBy(c => c.RosterOrder)
    .ToListAsync();

// 例如：将第三个角色移动到第一位
if (characters.Count >= 3)
{
    var characterToMove = characters[2];
    
    // 将其他角色向后移
    foreach (var c in characters.Take(2))
    {
        c.RosterOrder++;
    }
    
    // 将目标角色移到最前
    characterToMove.RosterOrder = 0;
    
    await _db.SaveChangesAsync();
}
```

### 7. 处理未绑定用户的角色

```csharp
// 查询所有未绑定用户的角色（孤立角色）
var orphanCharacters = await _db.Characters
    .Where(c => c.UserId == null)
    .ToListAsync();

// 将孤立角色绑定到用户
var character = await _db.Characters.FindAsync(characterId);
if (character != null && character.UserId == null)
{
    character.UserId = userId;
    await _db.SaveChangesAsync();
}
```

## API 端点建议

虽然当前未实现 API，但建议添加以下端点：

### 用户管理

- `POST /api/users` - 创建用户
- `GET /api/users/{id}` - 获取用户信息
- `PUT /api/users/{id}` - 更新用户信息
- `GET /api/users/{id}/characters` - 获取用户的所有角色

### 角色管理（更新）

- `POST /api/characters` - 创建角色（可选 userId 和 rosterOrder 参数）
- `PUT /api/characters/{id}/bind-user` - 将角色绑定到用户
- `PUT /api/characters/{id}/reorder` - 调整角色在 Roster 中的顺序

### 认证端点（建议）

- `POST /api/auth/login` - 用户登录（验证用户名/邮箱和密码）
- `POST /api/auth/register` - 用户注册
- `POST /api/auth/change-password` - 修改密码
- `POST /api/auth/reset-password` - 重置密码（需要邮箱验证）

## 最佳实践

### 数据一致性

1. **向后兼容**: UserId 为可空，不强制要求所有角色必须绑定用户
2. **数据完整性**: 利用数据库索引确保用户名和邮箱唯一性
3. **软删除**: 删除用户时角色不被删除，仅解除关联（SET NULL）
4. **查询优化**: 使用 Include 预加载关联数据，避免 N+1 查询问题
5. **时间戳管理**: 每次更新用户信息时更新 UpdatedAt 字段

### 密码安全最佳实践

1. **使用 BCrypt**: 推荐使用 `BCrypt.Net-Next` NuGet 包
   ```bash
   dotnet add package BCrypt.Net-Next
   ```

2. **密码哈希示例**:
   ```csharp
   // 注册时哈希密码
   string passwordHash = BCrypt.Net.BCrypt.HashPassword(plainPassword);
   
   // 登录时验证密码
   bool isValid = BCrypt.Net.BCrypt.Verify(plainPassword, storedHash);
   ```

3. **密码强度要求**（建议在应用层实现）:
   - 最小长度：8 字符
   - 包含大小写字母、数字和特殊字符
   - 不使用常见密码（如 "password123"）
   
4. **安全存储原则**:
   - ❌ 永远不要存储明文密码
   - ❌ 不使用 MD5 或 SHA1（已被破解）
   - ✅ 使用 BCrypt、Argon2 或 PBKDF2
   - ✅ BCrypt 自动处理盐值，每次哈希结果都不同

### 角色排序最佳实践

1. **RosterOrder 使用**:
   - 新建角色时自动分配下一个可用的顺序号
   - 删除角色时可选择是否重新排序其他角色
   - 查询时始终按 RosterOrder 排序

2. **排序示例**:
   ```csharp
   // 获取用户下一个可用的顺序号
   var nextOrder = await _db.Characters
       .Where(c => c.UserId == userId)
       .MaxAsync(c => (int?)c.RosterOrder) ?? -1;
   
   newCharacter.RosterOrder = nextOrder + 1;
   ```

## 与 Roster 系统的关系

当前实现为未来的 Roster 系统打下基础：

- **User**: 账号级别的实体，管理多个角色
- **Character**: 角色实体，属于某个用户
- **未来扩展**: 
  - Roster 槽位管理（RosterSlot 表）
  - 角色切换逻辑
  - 账号级共享资源（日常限额、声望等）

## 安全考虑

1. **密码存储**: 
   - ✅ 已实现 `PasswordHash` 字段，使用 BCrypt 哈希算法存储密码
   - BCrypt 自动处理盐值（salt），每次哈希生成唯一结果
   - 推荐使用 `BCrypt.Net-Next` NuGet 包
   - 永远不要存储明文密码或可逆加密的密码
   
2. **密码策略**:
   - 建议在应用层添加密码强度验证（最小长度、复杂度要求）
   - 实现密码重置功能时使用时限性令牌
   - 考虑添加登录失败次数限制（防暴力破解）
   
3. **邮箱验证**: 建议添加邮箱验证机制（发送验证链接）

4. **用户名规则**: 建议在应用层添加用户名格式验证（长度、字符限制）

5. **访问控制**: 确保用户只能访问自己的角色数据

6. **角色顺序**: RosterOrder 仅用于显示排序，不应影响功能权限

## 已实现功能

1. ✅ **密码功能**: 
   - PasswordHash 字段使用 BCrypt 安全存储密码
   - 支持密码验证和更新
   
2. ✅ **角色排序**: 
   - RosterOrder 字段支持角色在 Roster 中的显示顺序
   - 复合索引优化查询性能
   - 便于实现角色槽位管理

## 后续增强

1. **认证系统**: 集成 JWT 或 Cookie 认证
2. **密码管理**: 实现密码重置、修改密码功能
3. **用户资料**: 扩展用户信息（头像、简介等）
4. **社交功能**: 好友系统、公会系统
5. **Roster 槽位**: 实现槽位解锁和切换逻辑
6. **账号级资源**: 共享日常限额、声望等
7. **密码策略**: 实现密码强度检查、登录失败限制

## 相关文件

### 领域层
- `BlazorIdle.Server/Domain/Characters/User.cs`
- `BlazorIdle.Server/Domain/Characters/Character.cs`

### 基础设施层
- `BlazorIdle.Server/Infrastructure/Persistence/Configurations/UserConfiguration.cs`
- `BlazorIdle.Server/Infrastructure/Persistence/Configurations/CharacterConfiguration.cs`
- `BlazorIdle.Server/Infrastructure/Persistence/GameDbContext.cs`

### 数据库迁移
- `BlazorIdle.Server/Migrations/20251007064214_AddUserTable.cs`
- `BlazorIdle.Server/Migrations/20251007064214_AddUserTable.Designer.cs`

## 总结

用户系统的实现遵循以下原则：

1. **最小化变更**: 仅在必要的地方添加代码，不修改现有工作逻辑
2. **保持一致**: 遵循项目现有的代码风格和架构模式
3. **向后兼容**: UserId 可空设计，不破坏现有功能
4. **面向未来**: 为 Roster 系统和更多功能预留扩展空间
5. **文档完整**: 提供清晰的文档和使用示例

通过这个设计，游戏现在支持用户账号管理，同时为未来的多角色 Roster 系统打下了坚实的基础。

---

## ✨ 最新更新：JWT 认证系统已实现

**更新时间**: 2024-10-07

用户系统现已实现完整的 JWT 认证功能！

### 已实现功能

✅ **用户注册和登录**: 支持用户名/邮箱 + 密码认证  
✅ **JWT Token 认证**: 标准 JWT Bearer Token  
✅ **密码安全**: BCrypt 哈希算法  
✅ **角色自动绑定**: 已认证用户创建角色时自动绑定  
✅ **用户管理 API**: 完整的用户信息管理  
✅ **角色管理 API**: 绑定、排序等功能  
✅ **Swagger 支持**: Swagger UI 中可测试认证 API  

### 新增 API 端点

#### 认证端点（无需授权）
- `POST /api/auth/register` - 用户注册
- `POST /api/auth/login` - 用户登录
- `POST /api/auth/change-password` - 修改密码

#### 用户管理端点（需要授权）
- `GET /api/users/me` - 获取当前用户信息
- `GET /api/users/{id}` - 获取用户信息
- `GET /api/users/{id}/characters` - 获取用户的所有角色
- `PUT /api/users/{id}` - 更新用户信息

#### 角色管理端点
- `POST /api/characters` - 创建角色（带 Token 自动绑定）
- `PUT /api/characters/{id}/bind-user` - 绑定角色到用户
- `PUT /api/characters/{id}/reorder` - 调整角色顺序

### 快速开始

```bash
# 1. 注册用户
curl -X POST http://localhost:5000/api/auth/register \
  -H "Content-Type: application/json" \
  -d '{"username":"myuser","email":"user@example.com","password":"Pass123"}'

# 2. 获取 Token 后创建角色（自动绑定）
curl -X POST http://localhost:5000/api/characters \
  -H "Authorization: Bearer {token}" \
  -H "Content-Type: application/json" \
  -d '{"name":"MyWarrior","profession":0}'
```

### 详细文档

- 📘 [JWT认证系统文档](./JWT认证系统文档.md) - 完整的认证系统说明
- 📦 [API认证示例](./API认证示例.md) - 实际使用示例和代码
- 🔑 [认证系统快速参考](./认证系统快速参考.md) - 快速查阅手册

### 向后兼容

本实现完全向后兼容，不影响现有功能：
- ✅ 不登录也能创建角色（角色不绑定用户）
- ✅ 现有 API 端点保持不变
- ✅ 已有数据不受影响

