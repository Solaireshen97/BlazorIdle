# BlazorIdle æ•°æ®åº“æ“ä½œä¼˜åŒ–å®æ–½æ–¹æ¡ˆ - ä¸Šç¯‡ï¼šåŸºç¡€è®¾æ–½å»ºè®¾

**é¡¹ç›®**: BlazorIdle æœåŠ¡ç«¯æ•°æ®åº“æ“ä½œä¼˜åŒ–  
**é˜¶æ®µ**: ä¸Šç¯‡ - åŸºç¡€è®¾æ–½å»ºè®¾  
**å·¥ä½œé‡**: 7-9 å·¥ä½œæ—¥  
**ä¼˜å…ˆçº§**: P0ï¼ˆæœ€é«˜ï¼‰  
**æ–‡æ¡£ç‰ˆæœ¬**: 1.0

---

## ğŸ“‹ ç›®å½•

1. [ä¸Šç¯‡æ¦‚è¿°](#ä¸Šç¯‡æ¦‚è¿°)
2. [Phase 1: é…ç½®ç³»ç»Ÿè®¾è®¡ä¸å®ç°](#phase-1-é…ç½®ç³»ç»Ÿè®¾è®¡ä¸å®ç°)
3. [Phase 2: æŒä¹…åŒ–ç®¡ç†å™¨æ ¸å¿ƒå®ç°](#phase-2-æŒä¹…åŒ–ç®¡ç†å™¨æ ¸å¿ƒå®ç°)
4. [Phase 3: æ‰¹é‡åˆ·æ–°åå°æœåŠ¡](#phase-3-æ‰¹é‡åˆ·æ–°åå°æœåŠ¡)
5. [Phase 4: ç›‘æ§ä¸è¯Šæ–­åŸºç¡€](#phase-4-ç›‘æ§ä¸è¯Šæ–­åŸºç¡€)
6. [ä¸Šç¯‡æ€»ç»“ä¸éªŒæ”¶](#ä¸Šç¯‡æ€»ç»“ä¸éªŒæ”¶)

---

## ä¸Šç¯‡æ¦‚è¿°

### ç›®æ ‡

ä¸Šç¯‡èšç„¦äº**åŸºç¡€è®¾æ–½å»ºè®¾**ï¼Œä¸ºæ‰¹é‡æŒä¹…åŒ–æä¾›æ ¸å¿ƒæ¡†æ¶ï¼š

1. âœ… å»ºç«‹é…ç½®ç³»ç»Ÿï¼Œæ”¯æŒæ¨¡å—åŒ–é…ç½®
2. âœ… å®ç°æŒä¹…åŒ–ç®¡ç†å™¨ï¼ˆPersistenceManagerï¼‰
3. âœ… å®ç°æ‰¹é‡åˆ·æ–°åå°æœåŠ¡ï¼ˆBatchFlushHostedServiceï¼‰
4. âœ… å»ºç«‹åŸºç¡€ç›‘æ§å’Œè¯Šæ–­èƒ½åŠ›

### ä¸æ¶‰åŠçš„å†…å®¹

- âŒ å…·ä½“ä¸šåŠ¡æ¨¡å—é›†æˆï¼ˆä¸­ç¯‡ï¼‰
- âŒ ä¼˜é›…å…³é—­å¢å¼ºï¼ˆä¸‹ç¯‡ï¼‰
- âŒ æ€§èƒ½è°ƒä¼˜ï¼ˆä¸‹ç¯‡ï¼‰

### å…³é”®äº§å‡º

- ğŸ“¦ `PersistenceOptions.cs` - é…ç½®æ¨¡å‹
- ğŸ“¦ `IPersistenceManager.cs` - æŒä¹…åŒ–ç®¡ç†å™¨æ¥å£
- ğŸ“¦ `PersistenceManager.cs` - æŒä¹…åŒ–ç®¡ç†å™¨å®ç°
- ğŸ“¦ `BatchFlushHostedService.cs` - æ‰¹é‡åˆ·æ–°åå°æœåŠ¡
- ğŸ“¦ `PersistenceMetrics.cs` - ç›‘æ§æŒ‡æ ‡æ”¶é›†å™¨
- ğŸ“„ ä¸Šç¯‡å®æ–½æ€»ç»“æ–‡æ¡£
- âœ… å•å…ƒæµ‹è¯•ï¼ˆè¦†ç›–ç‡â‰¥95%ï¼‰

---

## Phase 1: é…ç½®ç³»ç»Ÿè®¾è®¡ä¸å®ç°

**å·¥ä½œé‡**: 1.5 å¤©  
**ä¼˜å…ˆçº§**: P0

### 1.1 ç›®æ ‡

å»ºç«‹çµæ´»çš„é…ç½®ç³»ç»Ÿï¼Œæ”¯æŒï¼š
- å…¨å±€é…ç½®å’Œæ¨¡å—åŒ–é…ç½®
- å¼€å‘/ç”Ÿäº§ç¯å¢ƒå·®å¼‚åŒ–é…ç½®
- è¿è¡Œæ—¶é…ç½®éªŒè¯

### 1.2 å®æ–½æ­¥éª¤

#### Step 1.1: åˆ›å»ºé…ç½®æ¨¡å‹ç±»

**æ–‡ä»¶**: `BlazorIdle.Server/Infrastructure/Configuration/PersistenceOptions.cs`

```csharp
namespace BlazorIdle.Server.Infrastructure.Configuration;

/// <summary>
/// æŒä¹…åŒ–é…ç½®é€‰é¡¹
/// æ”¯æŒæ‰¹é‡æŒä¹…åŒ–å’Œæ¨¡å—åŒ–é…ç½®
/// </summary>
public class PersistenceOptions
{
    /// <summary>
    /// é…ç½®èŠ‚åç§°ï¼ˆå¯¹åº” appsettings.jsonï¼‰
    /// </summary>
    public const string SectionName = "Persistence";

    /// <summary>
    /// æ˜¯å¦å¯ç”¨æ‰¹é‡æŒä¹…åŒ–ï¼ˆå…¨å±€å¼€å…³ï¼‰
    /// </summary>
    public bool EnableBatchPersistence { get; set; } = true;

    /// <summary>
    /// å…¨å±€é»˜è®¤åˆ·æ–°é—´éš”ï¼ˆç§’ï¼‰
    /// </summary>
    public double GlobalFlushIntervalSeconds { get; set; } = 10.0;

    /// <summary>
    /// å•æ¬¡æ‰¹é‡ä¿å­˜çš„æœ€å¤§è®°å½•æ•°
    /// </summary>
    public int MaxBatchSize { get; set; } = 1000;

    /// <summary>
    /// ä¿å­˜å¤±è´¥é‡è¯•æ¬¡æ•°
    /// </summary>
    public int MaxRetryAttempts { get; set; } = 3;

    /// <summary>
    /// é‡è¯•å»¶è¿Ÿï¼ˆæ¯«ç§’ï¼‰
    /// </summary>
    public int RetryDelayMilliseconds { get; set; } = 500;

    /// <summary>
    /// æ¨¡å—åŒ–é…ç½®å­—å…¸
    /// </summary>
    public Dictionary<string, CategoryOptions> Categories { get; set; } = new();

    /// <summary>
    /// ä¼˜é›…å…³é—­é…ç½®
    /// </summary>
    public GracefulShutdownOptions GracefulShutdown { get; set; } = new();

    /// <summary>
    /// ç›‘æ§é…ç½®
    /// </summary>
    public MonitoringOptions Monitoring { get; set; } = new();
}

/// <summary>
/// æ¨¡å—ç±»åˆ«é…ç½®
/// </summary>
public class CategoryOptions
{
    /// <summary>
    /// æ˜¯å¦å¯ç”¨æ­¤ç±»åˆ«çš„æ‰¹é‡æŒä¹…åŒ–
    /// </summary>
    public bool Enabled { get; set; } = true;

    /// <summary>
    /// åˆ·æ–°é—´éš”ï¼ˆç§’ï¼‰ï¼Œnull æ—¶ä½¿ç”¨å…¨å±€é»˜è®¤å€¼
    /// </summary>
    public double? FlushIntervalSeconds { get; set; }

    /// <summary>
    /// æœ€å¤§æ‰¹æ¬¡å¤§å°ï¼Œnull æ—¶ä½¿ç”¨å…¨å±€é»˜è®¤å€¼
    /// </summary>
    public int? MaxBatchSize { get; set; }

    /// <summary>
    /// ä¼˜å…ˆçº§ï¼ˆ0 æœ€é«˜ï¼‰
    /// </summary>
    public int Priority { get; set; } = 1;

    /// <summary>
    /// æ˜¯å¦åœ¨ç‰¹å®šæ¡ä»¶ä¸‹ç«‹å³ä¿å­˜
    /// </summary>
    public bool ImmediateOnCondition { get; set; } = false;

    /// <summary>
    /// ç«‹å³ä¿å­˜çš„æ¡ä»¶æ ‡ç­¾åˆ—è¡¨
    /// </summary>
    public List<string> ImmediateConditions { get; set; } = new();
}

/// <summary>
/// ä¼˜é›…å…³é—­é…ç½®
/// </summary>
public class GracefulShutdownOptions
{
    /// <summary>
    /// æ˜¯å¦å¯ç”¨ä¼˜é›…å…³é—­å¢å¼º
    /// </summary>
    public bool Enabled { get; set; } = true;

    /// <summary>
    /// å…³é—­è¶…æ—¶æ—¶é—´ï¼ˆç§’ï¼‰
    /// </summary>
    public int ShutdownTimeoutSeconds { get; set; } = 10;

    /// <summary>
    /// æ˜¯å¦ä¿å­˜æ‰€æœ‰è„æ•°æ®
    /// </summary>
    public bool SaveAllDirtyData { get; set; } = true;

    /// <summary>
    /// æ˜¯å¦å°†æ‰€æœ‰è§’è‰²è®¾ä¸ºç¦»çº¿
    /// </summary>
    public bool SetAllCharactersOffline { get; set; } = true;

    /// <summary>
    /// æ˜¯å¦ç­‰å¾…è¿›è¡Œä¸­çš„æ“ä½œå®Œæˆ
    /// </summary>
    public bool WaitForInProgressOperations { get; set; } = true;

    /// <summary>
    /// è¶…æ—¶æ—¶æ˜¯å¦å¼ºåˆ¶ä¿å­˜
    /// </summary>
    public bool ForceSaveOnTimeout { get; set; } = true;
}

/// <summary>
/// ç›‘æ§é…ç½®
/// </summary>
public class MonitoringOptions
{
    /// <summary>
    /// æ˜¯å¦å¯ç”¨ç›‘æ§æŒ‡æ ‡
    /// </summary>
    public bool EnableMetrics { get; set; } = true;

    /// <summary>
    /// æŒ‡æ ‡æ”¶é›†é—´éš”ï¼ˆç§’ï¼‰
    /// </summary>
    public int MetricsCollectionIntervalSeconds { get; set; } = 60;

    /// <summary>
    /// æ˜¯å¦è®°å½•æ‰¹é‡ä¿å­˜æ“ä½œæ—¥å¿—
    /// </summary>
    public bool LogFlushOperations { get; set; } = true;

    /// <summary>
    /// æ—¥å¿—çº§åˆ«
    /// </summary>
    public string LogLevel { get; set; } = "Information";

    /// <summary>
    /// è„æ•°æ®è¿‡å¤šæ—¶æ˜¯å¦å‘Šè­¦
    /// </summary>
    public bool AlertOnHighDirtyCount { get; set; } = true;

    /// <summary>
    /// å‘Šè­¦é˜ˆå€¼ï¼ˆè„æ•°æ®æ¡æ•°ï¼‰
    /// </summary>
    public int DirtyCountAlertThreshold { get; set; } = 5000;
}
```

#### Step 1.2: æ·»åŠ é…ç½®éªŒè¯

**æ–‡ä»¶**: `BlazorIdle.Server/Infrastructure/Configuration/PersistenceOptionsValidator.cs`

```csharp
namespace BlazorIdle.Server.Infrastructure.Configuration;

/// <summary>
/// æŒä¹…åŒ–é…ç½®éªŒè¯å™¨
/// ç¡®ä¿é…ç½®å‚æ•°åœ¨åˆç†èŒƒå›´å†…
/// </summary>
public static class PersistenceOptionsValidator
{
    /// <summary>
    /// éªŒè¯é…ç½®é€‰é¡¹
    /// </summary>
    public static ValidationResult Validate(PersistenceOptions options)
    {
        var errors = new List<string>();

        // å…¨å±€é…ç½®éªŒè¯
        if (options.GlobalFlushIntervalSeconds < 1.0 || options.GlobalFlushIntervalSeconds > 300.0)
        {
            errors.Add("GlobalFlushIntervalSeconds å¿…é¡»åœ¨ 1-300 ç§’ä¹‹é—´");
        }

        if (options.MaxBatchSize < 10 || options.MaxBatchSize > 10000)
        {
            errors.Add("MaxBatchSize å¿…é¡»åœ¨ 10-10000 ä¹‹é—´");
        }

        if (options.MaxRetryAttempts < 0 || options.MaxRetryAttempts > 10)
        {
            errors.Add("MaxRetryAttempts å¿…é¡»åœ¨ 0-10 ä¹‹é—´");
        }

        // æ¨¡å—é…ç½®éªŒè¯
        foreach (var (category, categoryOptions) in options.Categories)
        {
            if (categoryOptions.FlushIntervalSeconds.HasValue)
            {
                if (categoryOptions.FlushIntervalSeconds.Value < 1.0 || 
                    categoryOptions.FlushIntervalSeconds.Value > 300.0)
                {
                    errors.Add($"ç±»åˆ« '{category}' çš„ FlushIntervalSeconds å¿…é¡»åœ¨ 1-300 ç§’ä¹‹é—´");
                }
            }

            if (categoryOptions.MaxBatchSize.HasValue)
            {
                if (categoryOptions.MaxBatchSize.Value < 10 || 
                    categoryOptions.MaxBatchSize.Value > 10000)
                {
                    errors.Add($"ç±»åˆ« '{category}' çš„ MaxBatchSize å¿…é¡»åœ¨ 10-10000 ä¹‹é—´");
                }
            }
        }

        // ä¼˜é›…å…³é—­é…ç½®éªŒè¯
        if (options.GracefulShutdown.ShutdownTimeoutSeconds < 1 || 
            options.GracefulShutdown.ShutdownTimeoutSeconds > 60)
        {
            errors.Add("ShutdownTimeoutSeconds å¿…é¡»åœ¨ 1-60 ç§’ä¹‹é—´");
        }

        return new ValidationResult
        {
            IsValid = errors.Count == 0,
            Errors = errors
        };
    }

    public class ValidationResult
    {
        public bool IsValid { get; set; }
        public List<string> Errors { get; set; } = new();
    }
}
```

#### Step 1.3: æ›´æ–° appsettings.json

**æ–‡ä»¶**: `BlazorIdle.Server/appsettings.json`

åœ¨ç°æœ‰é…ç½®åŸºç¡€ä¸Šæ·»åŠ æ–°é…ç½®èŠ‚ï¼š

```json
{
  "Persistence": {
    "EnableBatchPersistence": true,
    "GlobalFlushIntervalSeconds": 10.0,
    "MaxBatchSize": 1000,
    "MaxRetryAttempts": 3,
    "RetryDelayMilliseconds": 500,
    
    "Categories": {
      "BattleSnapshot": {
        "Enabled": true,
        "FlushIntervalSeconds": 5.0,
        "MaxBatchSize": 100,
        "Priority": 0,
        "ImmediateOnCondition": true,
        "ImmediateConditions": ["BattleComplete"]
      },
      
      "CharacterStatus": {
        "Enabled": true,
        "FlushIntervalSeconds": 30.0,
        "MaxBatchSize": 500,
        "Priority": 1
      },
      
      "ActivityPlan": {
        "Enabled": true,
        "FlushIntervalSeconds": 10.0,
        "MaxBatchSize": 200,
        "Priority": 1
      },
      
      "Equipment": {
        "Enabled": true,
        "FlushIntervalSeconds": 5.0,
        "MaxBatchSize": 100,
        "Priority": 1,
        "ImmediateOnCondition": true,
        "ImmediateConditions": ["Purchase", "Disenchant"]
      }
    },
    
    "GracefulShutdown": {
      "Enabled": true,
      "ShutdownTimeoutSeconds": 10,
      "SaveAllDirtyData": true,
      "SetAllCharactersOffline": true,
      "WaitForInProgressOperations": true,
      "ForceSaveOnTimeout": true
    },
    
    "Monitoring": {
      "EnableMetrics": true,
      "MetricsCollectionIntervalSeconds": 60,
      "LogFlushOperations": true,
      "LogLevel": "Information",
      "AlertOnHighDirtyCount": true,
      "DirtyCountAlertThreshold": 5000
    }
  }
}
```

#### Step 1.4: æ³¨å†Œé…ç½®åˆ° DI å®¹å™¨

**æ–‡ä»¶**: `BlazorIdle.Server/Program.cs`

åœ¨ç°æœ‰æœåŠ¡æ³¨å†Œéƒ¨åˆ†æ·»åŠ ï¼š

```csharp
// æŒä¹…åŒ–é…ç½®æ³¨å†Œï¼ˆåœ¨ç°æœ‰ builder.Services æ³¨å†Œä¹‹åæ·»åŠ ï¼‰
builder.Services.Configure<PersistenceOptions>(
    builder.Configuration.GetSection(PersistenceOptions.SectionName));

// é…ç½®éªŒè¯ï¼ˆå¯åŠ¨æ—¶éªŒè¯ï¼‰
var persistenceOptions = builder.Configuration
    .GetSection(PersistenceOptions.SectionName)
    .Get<PersistenceOptions>() ?? new PersistenceOptions();

var validation = PersistenceOptionsValidator.Validate(persistenceOptions);
if (!validation.IsValid)
{
    var errors = string.Join(Environment.NewLine, validation.Errors);
    throw new InvalidOperationException(
        $"æŒä¹…åŒ–é…ç½®éªŒè¯å¤±è´¥:{Environment.NewLine}{errors}");
}
```

### 1.3 å•å…ƒæµ‹è¯•

**æ–‡ä»¶**: `tests/BlazorIdle.Tests/Infrastructure/Configuration/PersistenceOptionsTests.cs`

```csharp
public class PersistenceOptionsTests
{
    [Fact]
    public void DefaultOptions_ShouldBeValid()
    {
        // Arrange
        var options = new PersistenceOptions();

        // Act
        var result = PersistenceOptionsValidator.Validate(options);

        // Assert
        Assert.True(result.IsValid);
        Assert.Empty(result.Errors);
    }

    [Theory]
    [InlineData(0.5)]    // å°äºæœ€å°å€¼
    [InlineData(301.0)]  // å¤§äºæœ€å¤§å€¼
    public void GlobalFlushInterval_OutOfRange_ShouldBeInvalid(double interval)
    {
        // Arrange
        var options = new PersistenceOptions
        {
            GlobalFlushIntervalSeconds = interval
        };

        // Act
        var result = PersistenceOptionsValidator.Validate(options);

        // Assert
        Assert.False(result.IsValid);
        Assert.Contains(result.Errors, e => e.Contains("GlobalFlushIntervalSeconds"));
    }

    // æ›´å¤šæµ‹è¯•ç”¨ä¾‹...
}
```

### 1.4 éªŒæ”¶æ ‡å‡†

- [ ] `PersistenceOptions` ç±»æ­£ç¡®å»ºæ¨¡æ‰€æœ‰é…ç½®å‚æ•°
- [ ] é…ç½®éªŒè¯å™¨èƒ½å¤Ÿè¯†åˆ«æ‰€æœ‰æ— æ•ˆé…ç½®
- [ ] appsettings.json åŒ…å«å®Œæ•´çš„é…ç½®ç¤ºä¾‹
- [ ] é…ç½®èƒ½å¤Ÿæ­£ç¡®æ³¨å†Œåˆ° DI å®¹å™¨
- [ ] å•å…ƒæµ‹è¯•è¦†ç›–ç‡â‰¥95%
- [ ] æ‰€æœ‰æµ‹è¯•é€šè¿‡

---

## Phase 2: æŒä¹…åŒ–ç®¡ç†å™¨æ ¸å¿ƒå®ç°

**å·¥ä½œé‡**: 3 å¤©  
**ä¼˜å…ˆçº§**: P0

### 2.1 ç›®æ ‡

å®ç°æŒä¹…åŒ–ç®¡ç†å™¨ï¼ˆPersistenceManagerï¼‰ï¼Œæä¾›ï¼š
- è„æ•°æ®è¿½è¸ª
- æ‰¹é‡ä¿å­˜åè°ƒ
- ç«‹å³ä¿å­˜æ”¯æŒ
- çº¿ç¨‹å®‰å…¨

### 2.2 å®æ–½æ­¥éª¤

#### Step 2.1: å®šä¹‰æ ¸å¿ƒæ¥å£å’Œæ¨¡å‹

**æ–‡ä»¶**: `BlazorIdle.Server/Application/Abstractions/IPersistenceManager.cs`

```csharp
namespace BlazorIdle.Server.Application.Abstractions;

/// <summary>
/// æŒä¹…åŒ–ç®¡ç†å™¨æ¥å£
/// ç»Ÿä¸€ç®¡ç†å†…å­˜æ•°æ®çš„æŒä¹…åŒ–æ“ä½œ
/// </summary>
public interface IPersistenceManager
{
    /// <summary>
    /// æ ‡è®°å®ä½“ä¸ºè„ï¼ˆéœ€è¦ä¿å­˜ï¼‰
    /// </summary>
    /// <param name="entity">å®ä½“å¯¹è±¡</param>
    /// <param name="category">ç±»åˆ«ï¼ˆå¦‚ "BattleSnapshot", "CharacterStatus"ï¼‰</param>
    /// <param name="condition">å¯é€‰æ¡ä»¶æ ‡ç­¾ï¼ˆå¦‚ "BattleComplete"ï¼‰</param>
    void MarkDirty<T>(T entity, string category, string? condition = null) where T : class;

    /// <summary>
    /// æ‰¹é‡æ ‡è®°å®ä½“ä¸ºè„
    /// </summary>
    void MarkDirtyBatch<T>(IEnumerable<T> entities, string category, string? condition = null) where T : class;

    /// <summary>
    /// æ‰¹é‡ä¿å­˜æ‰€æœ‰è„æ•°æ®
    /// </summary>
    /// <param name="ct">å–æ¶ˆä»¤ç‰Œ</param>
    /// <returns>æŒä¹…åŒ–ç»“æœ</returns>
    Task<PersistenceResult> FlushAsync(CancellationToken ct = default);

    /// <summary>
    /// æ‰¹é‡ä¿å­˜æŒ‡å®šç±»åˆ«çš„è„æ•°æ®
    /// </summary>
    /// <param name="category">ç±»åˆ«åç§°</param>
    /// <param name="ct">å–æ¶ˆä»¤ç‰Œ</param>
    /// <returns>æŒä¹…åŒ–ç»“æœ</returns>
    Task<PersistenceResult> FlushCategoryAsync(string category, CancellationToken ct = default);

    /// <summary>
    /// ç«‹å³ä¿å­˜æŒ‡å®šå®ä½“ï¼ˆä¸ç­‰å¾…æ‰¹é‡åˆ·æ–°ï¼‰
    /// </summary>
    Task<PersistenceResult> SaveImmediatelyAsync<T>(T entity, string category, CancellationToken ct = default) where T : class;

    /// <summary>
    /// è·å–è„æ•°æ®ç»Ÿè®¡ä¿¡æ¯
    /// </summary>
    PersistenceStatistics GetStatistics();

    /// <summary>
    /// æ¸…é™¤æ‰€æœ‰è„æ•°æ®æ ‡è®°ï¼ˆä¸ä¿å­˜ï¼‰
    /// </summary>
    void ClearDirty(string? category = null);
}

/// <summary>
/// æŒä¹…åŒ–ç»“æœ
/// </summary>
public class PersistenceResult
{
    /// <summary>
    /// æ˜¯å¦æˆåŠŸ
    /// </summary>
    public bool Success { get; set; }

    /// <summary>
    /// ä¿å­˜çš„è®°å½•æ•°
    /// </summary>
    public int SavedCount { get; set; }

    /// <summary>
    /// å¤±è´¥çš„è®°å½•æ•°
    /// </summary>
    public int FailedCount { get; set; }

    /// <summary>
    /// è€—æ—¶ï¼ˆæ¯«ç§’ï¼‰
    /// </summary>
    public long ElapsedMilliseconds { get; set; }

    /// <summary>
    /// é”™è¯¯æ¶ˆæ¯
    /// </summary>
    public List<string> Errors { get; set; } = new();

    /// <summary>
    /// æŒ‰ç±»åˆ«ç»Ÿè®¡
    /// </summary>
    public Dictionary<string, CategoryResult> CategoryResults { get; set; } = new();
}

/// <summary>
/// ç±»åˆ«æŒä¹…åŒ–ç»“æœ
/// </summary>
public class CategoryResult
{
    public string Category { get; set; } = "";
    public int SavedCount { get; set; }
    public int FailedCount { get; set; }
    public long ElapsedMilliseconds { get; set; }
}

/// <summary>
/// æŒä¹…åŒ–ç»Ÿè®¡ä¿¡æ¯
/// </summary>
public class PersistenceStatistics
{
    /// <summary>
    /// æ€»è„æ•°æ®æ¡æ•°
    /// </summary>
    public int TotalDirtyCount { get; set; }

    /// <summary>
    /// æŒ‰ç±»åˆ«ç»Ÿè®¡
    /// </summary>
    public Dictionary<string, int> DirtyCountByCategory { get; set; } = new();

    /// <summary>
    /// æœ€è¿‘ä¸€æ¬¡åˆ·æ–°æ—¶é—´
    /// </summary>
    public DateTime? LastFlushTime { get; set; }

    /// <summary>
    /// æœ€è¿‘ä¸€æ¬¡åˆ·æ–°è€—æ—¶ï¼ˆæ¯«ç§’ï¼‰
    /// </summary>
    public long? LastFlushElapsedMs { get; set; }

    /// <summary>
    /// ç´¯è®¡åˆ·æ–°æ¬¡æ•°
    /// </summary>
    public long TotalFlushCount { get; set; }

    /// <summary>
    /// ç´¯è®¡ä¿å­˜è®°å½•æ•°
    /// </summary>
    public long TotalSavedCount { get; set; }
}
```

#### Step 2.2: å®ç°è„æ•°æ®è¿½è¸ªå™¨

**æ–‡ä»¶**: `BlazorIdle.Server/Infrastructure/Persistence/DirtyTracker.cs`

```csharp
namespace BlazorIdle.Server.Infrastructure.Persistence;

/// <summary>
/// è„æ•°æ®è¿½è¸ªå™¨
/// çº¿ç¨‹å®‰å…¨çš„è„æ•°æ®ç®¡ç†
/// </summary>
internal class DirtyTracker
{
    // æŒ‰ç±»åˆ«ç»„ç»‡çš„è„æ•°æ®é˜Ÿåˆ—
    private readonly ConcurrentDictionary<string, ConcurrentBag<DirtyEntry>> _dirtyBags = new();
    
    // ç«‹å³ä¿å­˜é˜Ÿåˆ—ï¼ˆé«˜ä¼˜å…ˆçº§ï¼‰
    private readonly ConcurrentBag<DirtyEntry> _immediateBag = new();
    
    // ç»Ÿè®¡ä¿¡æ¯
    private long _totalMarkedCount;
    private DateTime? _lastFlushTime;
    private long? _lastFlushElapsedMs;
    private long _totalFlushCount;
    private long _totalSavedCount;

    /// <summary>
    /// è„æ•°æ®æ¡ç›®
    /// </summary>
    internal class DirtyEntry
    {
        public object Entity { get; set; } = null!;
        public string Category { get; set; } = "";
        public string? Condition { get; set; }
        public DateTime MarkedAt { get; set; } = DateTime.UtcNow;
        public bool IsImmediate { get; set; }
    }

    /// <summary>
    /// æ ‡è®°å®ä½“ä¸ºè„
    /// </summary>
    public void MarkDirty(object entity, string category, string? condition, bool immediate)
    {
        var entry = new DirtyEntry
        {
            Entity = entity,
            Category = category,
            Condition = condition,
            IsImmediate = immediate
        };

        if (immediate)
        {
            _immediateBag.Add(entry);
        }
        else
        {
            var bag = _dirtyBags.GetOrAdd(category, _ => new ConcurrentBag<DirtyEntry>());
            bag.Add(entry);
        }

        Interlocked.Increment(ref _totalMarkedCount);
    }

    /// <summary>
    /// è·å–å¹¶æ¸…ç©ºç«‹å³ä¿å­˜é˜Ÿåˆ—
    /// </summary>
    public List<DirtyEntry> TakeImmediate()
    {
        var entries = new List<DirtyEntry>();
        while (_immediateBag.TryTake(out var entry))
        {
            entries.Add(entry);
        }
        return entries;
    }

    /// <summary>
    /// è·å–å¹¶æ¸…ç©ºæŒ‡å®šç±»åˆ«çš„è„æ•°æ®
    /// </summary>
    public List<DirtyEntry> TakeCategory(string category, int maxCount = int.MaxValue)
    {
        if (!_dirtyBags.TryGetValue(category, out var bag))
        {
            return new List<DirtyEntry>();
        }

        var entries = new List<DirtyEntry>();
        var taken = 0;

        while (taken < maxCount && bag.TryTake(out var entry))
        {
            entries.Add(entry);
            taken++;
        }

        return entries;
    }

    /// <summary>
    /// è·å–å¹¶æ¸…ç©ºæ‰€æœ‰è„æ•°æ®ï¼ˆæŒ‰ä¼˜å…ˆçº§æ’åºï¼‰
    /// </summary>
    public Dictionary<string, List<DirtyEntry>> TakeAll(int maxTotalCount = int.MaxValue)
    {
        var result = new Dictionary<string, List<DirtyEntry>>();
        var totalTaken = 0;

        // æŒ‰ä¼˜å…ˆçº§æ’åºç±»åˆ«
        var sortedCategories = _dirtyBags.Keys.OrderBy(k => k).ToList();

        foreach (var category in sortedCategories)
        {
            if (totalTaken >= maxTotalCount)
                break;

            var remaining = maxTotalCount - totalTaken;
            var entries = TakeCategory(category, remaining);
            
            if (entries.Any())
            {
                result[category] = entries;
                totalTaken += entries.Count;
            }
        }

        return result;
    }

    /// <summary>
    /// è·å–ç»Ÿè®¡ä¿¡æ¯
    /// </summary>
    public PersistenceStatistics GetStatistics()
    {
        var stats = new PersistenceStatistics
        {
            TotalDirtyCount = _immediateBag.Count,
            LastFlushTime = _lastFlushTime,
            LastFlushElapsedMs = _lastFlushElapsedMs,
            TotalFlushCount = _totalFlushCount,
            TotalSavedCount = _totalSavedCount
        };

        foreach (var (category, bag) in _dirtyBags)
        {
            stats.DirtyCountByCategory[category] = bag.Count;
            stats.TotalDirtyCount += bag.Count;
        }

        return stats;
    }

    /// <summary>
    /// æ›´æ–°ç»Ÿè®¡ä¿¡æ¯ï¼ˆåˆ·æ–°å®Œæˆåè°ƒç”¨ï¼‰
    /// </summary>
    public void UpdateStatistics(long savedCount, long elapsedMs)
    {
        _lastFlushTime = DateTime.UtcNow;
        _lastFlushElapsedMs = elapsedMs;
        Interlocked.Increment(ref _totalFlushCount);
        Interlocked.Add(ref _totalSavedCount, savedCount);
    }

    /// <summary>
    /// æ¸…é™¤æ‰€æœ‰è„æ•°æ®ï¼ˆä¸ä¿å­˜ï¼‰
    /// </summary>
    public void Clear(string? category = null)
    {
        if (category == null)
        {
            _dirtyBags.Clear();
            while (_immediateBag.TryTake(out _)) { }
        }
        else if (_dirtyBags.TryGetValue(category, out var bag))
        {
            while (bag.TryTake(out _)) { }
        }
    }
}
```

#### Step 2.3: å®ç°æŒä¹…åŒ–ç®¡ç†å™¨

**æ–‡ä»¶**: `BlazorIdle.Server/Infrastructure/Persistence/PersistenceManager.cs`

```csharp
namespace BlazorIdle.Server.Infrastructure.Persistence;

/// <summary>
/// æŒä¹…åŒ–ç®¡ç†å™¨å®ç°
/// ç»Ÿä¸€ç®¡ç†å†…å­˜æ•°æ®çš„æŒä¹…åŒ–æ“ä½œ
/// </summary>
public class PersistenceManager : IPersistenceManager
{
    private readonly DirtyTracker _dirtyTracker = new();
    private readonly IServiceScopeFactory _scopeFactory;
    private readonly IOptions<PersistenceOptions> _options;
    private readonly ILogger<PersistenceManager> _logger;
    private readonly SemaphoreSlim _flushLock = new(1, 1);

    public PersistenceManager(
        IServiceScopeFactory scopeFactory,
        IOptions<PersistenceOptions> options,
        ILogger<PersistenceManager> logger)
    {
        _scopeFactory = scopeFactory;
        _options = options;
        _logger = logger;
    }

    public void MarkDirty<T>(T entity, string category, string? condition = null) where T : class
    {
        if (!_options.Value.EnableBatchPersistence)
        {
            return; // æ‰¹é‡æŒä¹…åŒ–æœªå¯ç”¨ï¼Œå¿½ç•¥
        }

        var categoryOptions = GetCategoryOptions(category);
        if (!categoryOptions.Enabled)
        {
            return; // æ­¤ç±»åˆ«æœªå¯ç”¨æ‰¹é‡æŒä¹…åŒ–
        }

        // åˆ¤æ–­æ˜¯å¦éœ€è¦ç«‹å³ä¿å­˜
        var immediate = categoryOptions.ImmediateOnCondition && 
                       condition != null && 
                       categoryOptions.ImmediateConditions.Contains(condition);

        _dirtyTracker.MarkDirty(entity, category, condition, immediate);

        // ç›‘æ§å‘Šè­¦
        CheckDirtyCountAlert();
    }

    public void MarkDirtyBatch<T>(IEnumerable<T> entities, string category, string? condition = null) where T : class
    {
        foreach (var entity in entities)
        {
            MarkDirty(entity, category, condition);
        }
    }

    public async Task<PersistenceResult> FlushAsync(CancellationToken ct = default)
    {
        if (!_options.Value.EnableBatchPersistence)
        {
            return new PersistenceResult { Success = true }; // æ‰¹é‡æŒä¹…åŒ–æœªå¯ç”¨
        }

        var sw = Stopwatch.StartNew();
        var result = new PersistenceResult { Success = true };

        // ç¡®ä¿åŒæ—¶åªæœ‰ä¸€ä¸ªåˆ·æ–°æ“ä½œ
        await _flushLock.WaitAsync(ct);
        try
        {
            // 1. å…ˆå¤„ç†ç«‹å³ä¿å­˜é˜Ÿåˆ—
            var immediateEntries = _dirtyTracker.TakeImmediate();
            if (immediateEntries.Any())
            {
                var immediateResult = await SaveEntriesAsync(immediateEntries, ct);
                MergeResults(result, immediateResult);
            }

            // 2. æŒ‰ä¼˜å…ˆçº§å¤„ç†æ™®é€šé˜Ÿåˆ—
            var allEntries = _dirtyTracker.TakeAll(_options.Value.MaxBatchSize);
            if (allEntries.Any())
            {
                var batchResult = await SaveEntriesByCategory Async(allEntries, ct);
                MergeResults(result, batchResult);
            }

            sw.Stop();
            result.ElapsedMilliseconds = sw.ElapsedMilliseconds;

            // æ›´æ–°ç»Ÿè®¡
            _dirtyTracker.UpdateStatistics(result.SavedCount, sw.ElapsedMilliseconds);

            // æ—¥å¿—
            if (_options.Value.Monitoring.LogFlushOperations && result.SavedCount > 0)
            {
                _logger.LogInformation(
                    "æ‰¹é‡ä¿å­˜å®Œæˆ: æˆåŠŸ {SavedCount} æ¡, å¤±è´¥ {FailedCount} æ¡, è€—æ—¶ {ElapsedMs}ms",
                    result.SavedCount, result.FailedCount, result.ElapsedMilliseconds);
            }
        }
        finally
        {
            _flushLock.Release();
        }

        return result;
    }

    public async Task<PersistenceResult> FlushCategoryAsync(string category, CancellationToken ct = default)
    {
        var categoryOptions = GetCategoryOptions(category);
        if (!categoryOptions.Enabled)
        {
            return new PersistenceResult { Success = true };
        }

        var maxBatchSize = categoryOptions.MaxBatchSize ?? _options.Value.MaxBatchSize;
        var entries = _dirtyTracker.TakeCategory(category, maxBatchSize);
        
        if (!entries.Any())
        {
            return new PersistenceResult { Success = true };
        }

        return await SaveEntriesAsync(entries, ct);
    }

    public async Task<PersistenceResult> SaveImmediatelyAsync<T>(T entity, string category, CancellationToken ct = default) where T : class
    {
        var entries = new List<DirtyTracker.DirtyEntry>
        {
            new() { Entity = entity, Category = category, IsImmediate = true }
        };

        return await SaveEntriesAsync(entries, ct);
    }

    public PersistenceStatistics GetStatistics()
    {
        return _dirtyTracker.GetStatistics();
    }

    public void ClearDirty(string? category = null)
    {
        _dirtyTracker.Clear(category);
    }

    // ===== ç§æœ‰è¾…åŠ©æ–¹æ³• =====

    private CategoryOptions GetCategoryOptions(string category)
    {
        if (_options.Value.Categories.TryGetValue(category, out var options))
        {
            return options;
        }

        // è¿”å›é»˜è®¤é…ç½®
        return new CategoryOptions
        {
            Enabled = true,
            FlushIntervalSeconds = _options.Value.GlobalFlushIntervalSeconds,
            MaxBatchSize = _options.Value.MaxBatchSize
        };
    }

    private async Task<PersistenceResult> SaveEntriesAsync(
        List<DirtyTracker.DirtyEntry> entries, 
        CancellationToken ct)
    {
        // æŒ‰ç±»åˆ«åˆ†ç»„
        var byCategory = entries.GroupBy(e => e.Category).ToDictionary(g => g.Key, g => g.ToList());
        return await SaveEntriesByCategoryAsync(byCategory, ct);
    }

    private async Task<PersistenceResult> SaveEntriesByCategoryAsync(
        Dictionary<string, List<DirtyTracker.DirtyEntry>> entriesByCategory,
        CancellationToken ct)
    {
        var result = new PersistenceResult { Success = true };

        foreach (var (category, entries) in entriesByCategory)
        {
            var categoryResult = await SaveCategoryEntriesAsync(category, entries, ct);
            result.CategoryResults[category] = categoryResult;
            result.SavedCount += categoryResult.SavedCount;
            result.FailedCount += categoryResult.FailedCount;
        }

        result.Success = result.FailedCount == 0;
        return result;
    }

    private async Task<CategoryResult> SaveCategoryEntriesAsync(
        string category,
        List<DirtyTracker.DirtyEntry> entries,
        CancellationToken ct)
    {
        var sw = Stopwatch.StartNew();
        var result = new CategoryResult { Category = category };

        try
        {
            using var scope = _scopeFactory.CreateScope();
            var db = scope.ServiceProvider.GetRequiredService<GameDbContext>();

            // å°†å®ä½“é™„åŠ åˆ° DbContext å¹¶æ ‡è®°ä¸º Modified
            foreach (var entry in entries)
            {
                var entityEntry = db.Entry(entry.Entity);
                if (entityEntry.State == EntityState.Detached)
                {
                    db.Attach(entry.Entity);
                    entityEntry.State = EntityState.Modified;
                }
            }

            // æ‰¹é‡ä¿å­˜
            var savedCount = await SaveWithRetryAsync(db, ct);
            result.SavedCount = savedCount;
        }
        catch (Exception ex)
        {
            result.FailedCount = entries.Count;
            _logger.LogError(ex, "ä¿å­˜ç±»åˆ« {Category} çš„æ•°æ®å¤±è´¥", category);
        }

        sw.Stop();
        result.ElapsedMilliseconds = sw.ElapsedMilliseconds;
        return result;
    }

    private async Task<int> SaveWithRetryAsync(GameDbContext db, CancellationToken ct)
    {
        var maxAttempts = _options.Value.MaxRetryAttempts + 1;
        var delayMs = _options.Value.RetryDelayMilliseconds;

        for (int attempt = 1; attempt <= maxAttempts; attempt++)
        {
            try
            {
                return await db.SaveChangesAsync(ct);
            }
            catch (DbUpdateConcurrencyException) when (attempt < maxAttempts)
            {
                _logger.LogWarning("ä¿å­˜æ•°æ®æ—¶å‘ç”Ÿå¹¶å‘å†²çªï¼Œé‡è¯• {Attempt}/{MaxAttempts}", attempt, maxAttempts);
                await Task.Delay(delayMs * attempt, ct); // æŒ‡æ•°é€€é¿
            }
            catch (DbUpdateException) when (attempt < maxAttempts)
            {
                _logger.LogWarning("ä¿å­˜æ•°æ®æ—¶å‘ç”Ÿæ•°æ®åº“é”™è¯¯ï¼Œé‡è¯• {Attempt}/{MaxAttempts}", attempt, maxAttempts);
                await Task.Delay(delayMs * attempt, ct);
            }
        }

        throw new InvalidOperationException($"ä¿å­˜æ•°æ®å¤±è´¥ï¼Œå·²é‡è¯• {maxAttempts} æ¬¡");
    }

    private void MergeResults(PersistenceResult target, PersistenceResult source)
    {
        target.SavedCount += source.SavedCount;
        target.FailedCount += source.FailedCount;
        target.Errors.AddRange(source.Errors);
        
        foreach (var (category, categoryResult) in source.CategoryResults)
        {
            target.CategoryResults[category] = categoryResult;
        }
    }

    private void CheckDirtyCountAlert()
    {
        if (!_options.Value.Monitoring.AlertOnHighDirtyCount)
        {
            return;
        }

        var stats = _dirtyTracker.GetStatistics();
        if (stats.TotalDirtyCount >= _options.Value.Monitoring.DirtyCountAlertThreshold)
        {
            _logger.LogWarning(
                "è„æ•°æ®æ•°é‡è¿‡å¤š: {DirtyCount} (é˜ˆå€¼: {Threshold})ï¼Œå»ºè®®æ£€æŸ¥æ‰¹é‡åˆ·æ–°é—´éš”",
                stats.TotalDirtyCount,
                _options.Value.Monitoring.DirtyCountAlertThreshold);
        }
    }
}
```

### 2.3 å•å…ƒæµ‹è¯•

**æ–‡ä»¶**: `tests/BlazorIdle.Tests/Infrastructure/Persistence/PersistenceManagerTests.cs`

```csharp
public class PersistenceManagerTests
{
    [Fact]
    public void MarkDirty_ShouldTrackEntity()
    {
        // Arrange
        var manager = CreateManager();
        var entity = new TestEntity { Id = Guid.NewGuid() };

        // Act
        manager.MarkDirty(entity, "TestCategory");
        var stats = manager.GetStatistics();

        // Assert
        Assert.Equal(1, stats.TotalDirtyCount);
        Assert.True(stats.DirtyCountByCategory.ContainsKey("TestCategory"));
    }

    [Fact]
    public async Task FlushAsync_ShouldSaveAllDirtyData()
    {
        // Arrange
        var manager = CreateManager();
        var entities = Enumerable.Range(1, 10)
            .Select(_ => new TestEntity { Id = Guid.NewGuid() })
            .ToList();

        foreach (var entity in entities)
        {
            manager.MarkDirty(entity, "TestCategory");
        }

        // Act
        var result = await manager.FlushAsync();

        // Assert
        Assert.True(result.Success);
        Assert.Equal(10, result.SavedCount);
        Assert.Equal(0, result.FailedCount);
    }

    // æ›´å¤šæµ‹è¯•ç”¨ä¾‹...
}
```

### 2.4 éªŒæ”¶æ ‡å‡†

- [ ] `IPersistenceManager` æ¥å£å®šä¹‰å®Œæ•´
- [ ] `DirtyTracker` çº¿ç¨‹å®‰å…¨ï¼Œæ”¯æŒå¹¶å‘æ“ä½œ
- [ ] `PersistenceManager` æ­£ç¡®å®ç°æ‰€æœ‰æ¥å£æ–¹æ³•
- [ ] æ”¯æŒç«‹å³ä¿å­˜å’Œæ‰¹é‡ä¿å­˜ä¸¤ç§æ¨¡å¼
- [ ] é‡è¯•æœºåˆ¶æœ‰æ•ˆå¤„ç†æ•°æ®åº“é”å’Œå¹¶å‘å¼‚å¸¸
- [ ] ç»Ÿè®¡ä¿¡æ¯å‡†ç¡®
- [ ] å•å…ƒæµ‹è¯•è¦†ç›–ç‡â‰¥95%
- [ ] æ‰€æœ‰æµ‹è¯•é€šè¿‡

---

## Phase 3: æ‰¹é‡åˆ·æ–°åå°æœåŠ¡

**å·¥ä½œé‡**: 1.5 å¤©  
**ä¼˜å…ˆçº§**: P0

### 3.1 ç›®æ ‡

å®ç°æ‰¹é‡åˆ·æ–°åå°æœåŠ¡ï¼ˆBatchFlushHostedServiceï¼‰ï¼Œæä¾›ï¼š
- å®šæ—¶æ‰¹é‡åˆ·æ–°
- å¯é…ç½®çš„åˆ·æ–°é—´éš”
- ä¼˜é›…å¯åŠ¨å’Œå…³é—­

### 3.2 å®æ–½æ­¥éª¤

#### Step 3.1: å®ç°åå°æœåŠ¡

**æ–‡ä»¶**: `BlazorIdle.Server/Services/Batch FlushHostedService.cs`

```csharp
namespace BlazorIdle.Server.Services;

/// <summary>
/// æ‰¹é‡åˆ·æ–°åå°æœåŠ¡
/// å®šæœŸè§¦å‘æŒä¹…åŒ–ç®¡ç†å™¨çš„æ‰¹é‡ä¿å­˜æ“ä½œ
/// </summary>
public class BatchFlushHostedService : BackgroundService
{
    private readonly IPersistenceManager _persistenceManager;
    private readonly IOptions<PersistenceOptions> _options;
    private readonly ILogger<BatchFlushHostedService> _logger;

    public BatchFlushHostedService(
        IPersistenceManager persistenceManager,
        IOptions<PersistenceOptions> options,
        ILogger<BatchFlushHostedService> logger)
    {
        _persistenceManager = persistenceManager;
        _options = options;
        _logger = logger;
    }

    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        if (!_options.Value.EnableBatchPersistence)
        {
            _logger.LogInformation("æ‰¹é‡æŒä¹…åŒ–æœªå¯ç”¨ï¼ŒBatchFlushHostedService ä¸æ‰§è¡Œ");
            return;
        }

        _logger.LogInformation(
            "BatchFlushHostedService å¯åŠ¨ï¼Œåˆ·æ–°é—´éš”: {IntervalSeconds}ç§’",
            _options.Value.GlobalFlushIntervalSeconds);

        try
        {
            while (!stoppingToken.IsCancellationRequested)
            {
                // ç­‰å¾…åˆ·æ–°é—´éš”
                var intervalMs = (int)(_options.Value.GlobalFlushIntervalSeconds * 1000);
                await Task.Delay(intervalMs, stoppingToken);

                // æ‰§è¡Œæ‰¹é‡åˆ·æ–°
                try
                {
                    var result = await _persistenceManager.FlushAsync(stoppingToken);
                    
                    if (result.FailedCount > 0)
                    {
                        _logger.LogWarning(
                            "æ‰¹é‡åˆ·æ–°éƒ¨åˆ†å¤±è´¥: æˆåŠŸ {SavedCount}, å¤±è´¥ {FailedCount}",
                            result.SavedCount, result.FailedCount);
                    }
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "æ‰¹é‡åˆ·æ–°æ—¶å‘ç”Ÿå¼‚å¸¸");
                }
            }
        }
        catch (OperationCanceledException)
        {
            _logger.LogInformation("BatchFlushHostedService æ”¶åˆ°åœæ­¢ä¿¡å·");
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "BatchFlushHostedService å‘ç”Ÿæœªå¤„ç†çš„å¼‚å¸¸");
        }

        _logger.LogInformation("BatchFlushHostedService å·²åœæ­¢");
    }

    public override async Task StopAsync(CancellationToken cancellationToken)
    {
        _logger.LogInformation("BatchFlushHostedService æ­£åœ¨å…³é—­ï¼Œæ‰§è¡Œæœ€ç»ˆåˆ·æ–°...");

        try
        {
            // å…³é—­æ—¶æ‰§è¡Œæœ€ç»ˆåˆ·æ–°
            var result = await _persistenceManager.FlushAsync(cancellationToken);
            
            _logger.LogInformation(
                "æœ€ç»ˆåˆ·æ–°å®Œæˆ: æˆåŠŸ {SavedCount}, å¤±è´¥ {FailedCount}, è€—æ—¶ {ElapsedMs}ms",
                result.SavedCount, result.FailedCount, result.ElapsedMilliseconds);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "æœ€ç»ˆåˆ·æ–°æ—¶å‘ç”Ÿå¼‚å¸¸");
        }

        await base.StopAsync(cancellationToken);
    }
}
```

#### Step 3.2: æ³¨å†Œåå°æœåŠ¡

**æ–‡ä»¶**: `BlazorIdle.Server/Program.cs`

åœ¨ç°æœ‰åå°æœåŠ¡æ³¨å†Œéƒ¨åˆ†æ·»åŠ ï¼š

```csharp
// æ³¨å†ŒæŒä¹…åŒ–ç®¡ç†å™¨å’Œæ‰¹é‡åˆ·æ–°æœåŠ¡
builder.Services.AddSingleton<IPersistenceManager, PersistenceManager>();
builder.Services.AddHostedService<BatchFlushHostedService>();
```

### 3.3 é›†æˆæµ‹è¯•

**æ–‡ä»¶**: `tests/BlazorIdle.Tests/Services/BatchFlushHostedServiceTests.cs`

```csharp
public class BatchFlushHostedServiceTests
{
    [Fact]
    public async Task ExecuteAsync_ShouldFlushPeriodically()
    {
        // Arrange
        var persistenceManagerMock = new Mock<IPersistenceManager>();
        var options = Options.Create(new PersistenceOptions
        {
            EnableBatchPersistence = true,
            GlobalFlushIntervalSeconds = 0.5 // æµ‹è¯•ç”¨ï¼Œ0.5ç§’
        });
        var loggerMock = new Mock<ILogger<BatchFlushHostedService>>();

        persistenceManagerMock
            .Setup(m => m.FlushAsync(It.IsAny<CancellationToken>()))
            .ReturnsAsync(new PersistenceResult { Success = true });

        var service = new BatchFlushHostedService(
            persistenceManagerMock.Object,
            options,
            loggerMock.Object);

        var cts = new CancellationTokenSource();

        // Act
        var task = service.StartAsync(cts.Token);
        await Task.Delay(1500); // ç­‰å¾…è¶³å¤Ÿæ—¶é—´è§¦å‘è‡³å°‘2æ¬¡åˆ·æ–°
        cts.Cancel();
        await service.StopAsync(CancellationToken.None);

        // Assert
        persistenceManagerMock.Verify(
            m => m.FlushAsync(It.IsAny<CancellationToken>()),
            Times.AtLeast(2)); // è‡³å°‘è§¦å‘2æ¬¡åˆ·æ–°
    }

    // æ›´å¤šæµ‹è¯•ç”¨ä¾‹...
}
```

### 3.4 éªŒæ”¶æ ‡å‡†

- [ ] `BatchFlushHostedService` èƒ½å¤Ÿå®šæœŸè§¦å‘æ‰¹é‡åˆ·æ–°
- [ ] åˆ·æ–°é—´éš”å¯é…ç½®
- [ ] å…³é—­æ—¶æ‰§è¡Œæœ€ç»ˆåˆ·æ–°
- [ ] å¼‚å¸¸å¤„ç†å¥å£®ï¼Œä¸ä¼šå¯¼è‡´æœåŠ¡åœæ­¢
- [ ] æ—¥å¿—è®°å½•å®Œæ•´
- [ ] é›†æˆæµ‹è¯•éªŒè¯å®šæœŸåˆ·æ–°åŠŸèƒ½
- [ ] æ‰€æœ‰æµ‹è¯•é€šè¿‡

---

## Phase 4: ç›‘æ§ä¸è¯Šæ–­åŸºç¡€

**å·¥ä½œé‡**: 1 å¤©  
**ä¼˜å…ˆçº§**: P1

### 4.1 ç›®æ ‡

å»ºç«‹åŸºç¡€ç›‘æ§å’Œè¯Šæ–­èƒ½åŠ›ï¼š
- æŒä¹…åŒ–æŒ‡æ ‡æ”¶é›†
- è¯Šæ–­API
- æ—¥å¿—å¢å¼º

### 4.2 å®æ–½æ­¥éª¤

#### Step 4.1: å®ç°æŒ‡æ ‡æ”¶é›†å™¨

**æ–‡ä»¶**: `BlazorIdle.Server/Infrastructure/Monitoring/PersistenceMetrics.cs`

```csharp
namespace BlazorIdle.Server.Infrastructure.Monitoring;

/// <summary>
/// æŒä¹…åŒ–æŒ‡æ ‡æ”¶é›†å™¨
/// </summary>
public class PersistenceMetrics
{
    private long _totalFlushCount;
    private long _totalSavedCount;
    private long _totalFailedCount;
    private long _totalFlushTimeMs;
    private readonly ConcurrentDictionary<string, CategoryMetrics> _categoryMetrics = new();

    public class CategoryMetrics
    {
        public long FlushCount { get; set; }
        public long SavedCount { get; set; }
        public long FailedCount { get; set; }
        public long TotalFlushTimeMs { get; set; }

        public double AverageFlushTimeMs =>
            FlushCount > 0 ? (double)TotalFlushTimeMs / FlushCount : 0;

        public double SuccessRate =>
            (SavedCount + FailedCount) > 0
                ? (double)SavedCount / (SavedCount + FailedCount)
                : 1.0;
    }

    /// <summary>
    /// è®°å½•ä¸€æ¬¡åˆ·æ–°æ“ä½œ
    /// </summary>
    public void RecordFlush(PersistenceResult result)
    {
        Interlocked.Increment(ref _totalFlushCount);
        Interlocked.Add(ref _totalSavedCount, result.SavedCount);
        Interlocked.Add(ref _totalFailedCount, result.FailedCount);
        Interlocked.Add(ref _totalFlushTimeMs, result.ElapsedMilliseconds);

        foreach (var (category, categoryResult) in result.CategoryResults)
        {
            var metrics = _categoryMetrics.GetOrAdd(category, _ => new CategoryMetrics());
            Interlocked.Increment(ref metrics.FlushCount);
            Interlocked.Add(ref metrics.SavedCount, categoryResult.SavedCount);
            Interlocked.Add(ref metrics.FailedCount, categoryResult.FailedCount);
            Interlocked.Add(ref metrics.TotalFlushTimeMs, categoryResult.ElapsedMilliseconds);
        }
    }

    /// <summary>
    /// è·å–æ€»ä½“æŒ‡æ ‡
    /// </summary>
    public object GetOverallMetrics()
    {
        return new
        {
            TotalFlushCount = _totalFlushCount,
            TotalSavedCount = _totalSavedCount,
            TotalFailedCount = _totalFailedCount,
            AverageFlushTimeMs = _totalFlushCount > 0 ? (double)_totalFlushTimeMs / _totalFlushCount : 0,
            SuccessRate = (_totalSavedCount + _totalFailedCount) > 0
                ? (double)_totalSavedCount / (_totalSavedCount + _totalFailedCount)
                : 1.0
        };
    }

    /// <summary>
    /// è·å–æŒ‰ç±»åˆ«ç»Ÿè®¡çš„æŒ‡æ ‡
    /// </summary>
    public Dictionary<string, CategoryMetrics> GetCategoryMetrics()
    {
        return new Dictionary<string, CategoryMetrics>(_categoryMetrics);
    }
}
```

#### Step 4.2: å®ç°è¯Šæ–­API

**æ–‡ä»¶**: `BlazorIdle.Server/Api/DiagnosticsController.cs`

```csharp
namespace BlazorIdle.Server.Api;

[ApiController]
[Route("api/[controller]")]
public class DiagnosticsController : ControllerBase
{
    private readonly IPersistenceManager _persistenceManager;
    private readonly PersistenceMetrics _metrics;

    public DiagnosticsController(
        IPersistenceManager persistenceManager,
        PersistenceMetrics metrics)
    {
        _persistenceManager = persistenceManager;
        _metrics = metrics;
    }

    /// <summary>
    /// è·å–æŒä¹…åŒ–ç»Ÿè®¡ä¿¡æ¯
    /// </summary>
    [HttpGet("persistence/statistics")]
    public IActionResult GetStatistics()
    {
        var stats = _persistenceManager.GetStatistics();
        return Ok(stats);
    }

    /// <summary>
    /// è·å–æŒä¹…åŒ–æ€§èƒ½æŒ‡æ ‡
    /// </summary>
    [HttpGet("persistence/metrics")]
    public IActionResult GetMetrics()
    {
        return Ok(new
        {
            Overall = _metrics.GetOverallMetrics(),
            Categories = _metrics.GetCategoryMetrics()
        });
    }

    /// <summary>
    /// æ‰‹åŠ¨è§¦å‘æ‰¹é‡åˆ·æ–°ï¼ˆä»…å¼€å‘/æµ‹è¯•ç¯å¢ƒï¼‰
    /// </summary>
    [HttpPost("persistence/flush")]
    public async Task<IActionResult> TriggerFlush()
    {
        var result = await _persistenceManager.FlushAsync();
        return Ok(result);
    }
}
```

#### Step 4.3: æ³¨å†Œç›‘æ§æœåŠ¡

**æ–‡ä»¶**: `BlazorIdle.Server/Program.cs`

```csharp
// æ³¨å†Œç›‘æ§æœåŠ¡
builder.Services.AddSingleton<PersistenceMetrics>();

// åœ¨ PersistenceManager çš„ FlushAsync æ–¹æ³•ä¸­æ·»åŠ æŒ‡æ ‡è®°å½•
// ï¼ˆä¿®æ”¹ PersistenceManager.csï¼Œåœ¨ FlushAsync æœ€åæ·»åŠ ï¼‰
```

### 4.3 éªŒæ”¶æ ‡å‡†

- [ ] `PersistenceMetrics` æ­£ç¡®ç»Ÿè®¡æ‰€æœ‰åˆ·æ–°æ“ä½œ
- [ ] è¯Šæ–­APIèƒ½å¤Ÿè¿”å›å®Œæ•´çš„ç»Ÿè®¡ä¿¡æ¯å’ŒæŒ‡æ ‡
- [ ] æ‰‹åŠ¨è§¦å‘åˆ·æ–°åŠŸèƒ½å¯ç”¨
- [ ] æ—¥å¿—è®°å½•å…³é”®æ“ä½œ
- [ ] å•å…ƒæµ‹è¯•è¦†ç›–ç›‘æ§ç»„ä»¶
- [ ] æ‰€æœ‰æµ‹è¯•é€šè¿‡

---

## ä¸Šç¯‡æ€»ç»“ä¸éªŒæ”¶

### å®Œæˆæƒ…å†µæ£€æŸ¥æ¸…å•

#### Phase 1: é…ç½®ç³»ç»Ÿ âœ…
- [ ] `PersistenceOptions` ç±»å®Œæ•´
- [ ] é…ç½®éªŒè¯å™¨æœ‰æ•ˆ
- [ ] appsettings.json åŒ…å«å®Œæ•´é…ç½®
- [ ] é…ç½®æ³¨å†Œåˆ° DI å®¹å™¨
- [ ] å•å…ƒæµ‹è¯•è¦†ç›–ç‡â‰¥95%

#### Phase 2: æŒä¹…åŒ–ç®¡ç†å™¨ âœ…
- [ ] `IPersistenceManager` æ¥å£å®šä¹‰å®Œæ•´
- [ ] `DirtyTracker` çº¿ç¨‹å®‰å…¨
- [ ] `PersistenceManager` å®ç°æ‰€æœ‰åŠŸèƒ½
- [ ] ç«‹å³ä¿å­˜å’Œæ‰¹é‡ä¿å­˜éƒ½æ”¯æŒ
- [ ] é‡è¯•æœºåˆ¶æœ‰æ•ˆ
- [ ] å•å…ƒæµ‹è¯•è¦†ç›–ç‡â‰¥95%

#### Phase 3: æ‰¹é‡åˆ·æ–°æœåŠ¡ âœ…
- [ ] `BatchFlushHostedService` å®šæœŸåˆ·æ–°
- [ ] å…³é—­æ—¶æ‰§è¡Œæœ€ç»ˆåˆ·æ–°
- [ ] å¼‚å¸¸å¤„ç†å¥å£®
- [ ] é›†æˆæµ‹è¯•éªŒè¯åŠŸèƒ½

#### Phase 4: ç›‘æ§ä¸è¯Šæ–­ âœ…
- [ ] `PersistenceMetrics` ç»Ÿè®¡å‡†ç¡®
- [ ] è¯Šæ–­APIå¯ç”¨
- [ ] æ—¥å¿—è®°å½•å®Œæ•´

### æ€§èƒ½åŸºå‡†æµ‹è¯•

åœ¨ä¸Šç¯‡å®Œæˆåï¼Œæ‰§è¡Œä»¥ä¸‹åŸºå‡†æµ‹è¯•ï¼š

**æµ‹è¯•åœºæ™¯1ï¼šæ‰¹é‡ä¿å­˜æ€§èƒ½**
```
è¾“å…¥: 1000æ¡è„æ•°æ®
é¢„æœŸ: ä¿å­˜è€—æ—¶ < 500ms
é¢„æœŸ: æˆåŠŸç‡ = 100%
```

**æµ‹è¯•åœºæ™¯2ï¼šå¹¶å‘æ ‡è®°è„æ•°æ®**
```
è¾“å…¥: 10ä¸ªçº¿ç¨‹ï¼Œæ¯ä¸ªæ ‡è®°100æ¡
é¢„æœŸ: æ— æ•°æ®ä¸¢å¤±
é¢„æœŸ: æ— å¼‚å¸¸
```

**æµ‹è¯•åœºæ™¯3ï¼šå®šæ—¶åˆ·æ–°ç¨³å®šæ€§**
```
è¾“å…¥: è¿è¡Œ10åˆ†é’Ÿï¼Œæ¯ç§’æ ‡è®°10æ¡è„æ•°æ®
é¢„æœŸ: æ‰€æœ‰æ•°æ®æœ€ç»ˆä¿å­˜
é¢„æœŸ: æ— å†…å­˜æ³„æ¼
```

### æ–‡æ¡£äº¤ä»˜

- [ ] **ä¸Šç¯‡å®æ–½æ€»ç»“.md** - è®°å½•å®æ–½è¿‡ç¨‹å’Œç»éªŒ
- [ ] **é…ç½®å‚æ•°è¯´æ˜.md** - è¯¦ç»†è¯´æ˜æ‰€æœ‰é…ç½®å‚æ•°
- [ ] **APIæ–‡æ¡£.md** - è¯Šæ–­APIä½¿ç”¨è¯´æ˜

### ä¸‹ä¸€æ­¥è¡ŒåŠ¨

ä¸Šç¯‡å®Œæˆåï¼Œå¯ä»¥è¿›å…¥**ä¸­ç¯‡**ï¼šå…·ä½“ä¸šåŠ¡æ¨¡å—é›†æˆï¼ŒåŒ…æ‹¬ï¼š
- æˆ˜æ–—å¿«ç…§é›†æˆ
- è§’è‰²çŠ¶æ€é›†æˆ
- æ´»åŠ¨è®¡åˆ’é›†æˆ
- è£…å¤‡æ“ä½œé›†æˆ

---

**æ–‡æ¡£ç‰ˆæœ¬**: 1.0  
**åˆ›å»ºæ—¥æœŸ**: 2025-10-17  
**é¢„è®¡å®Œæˆ**: ä¸Šç¯‡å®æ–½éœ€ 7-9 å·¥ä½œæ—¥  
**çŠ¶æ€**: ğŸ“˜ å®æ–½æ–¹æ¡ˆå®Œæˆï¼Œå¾…æ‰§è¡Œ
