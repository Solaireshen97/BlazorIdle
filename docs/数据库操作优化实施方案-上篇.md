# BlazorIdle 数据库操作优化实施方案 - 上篇：基础设施建设

**项目**: BlazorIdle 服务端数据库操作优化  
**阶段**: 上篇 - 基础设施建设  
**工作量**: 7-9 工作日  
**优先级**: P0（最高）  
**文档版本**: 1.0

---

## 📋 目录

1. [上篇概述](#上篇概述)
2. [Phase 1: 配置系统设计与实现](#phase-1-配置系统设计与实现)
3. [Phase 2: 持久化管理器核心实现](#phase-2-持久化管理器核心实现)
4. [Phase 3: 批量刷新后台服务](#phase-3-批量刷新后台服务)
5. [Phase 4: 监控与诊断基础](#phase-4-监控与诊断基础)
6. [上篇总结与验收](#上篇总结与验收)

---

## 上篇概述

### 目标

上篇聚焦于**基础设施建设**，为批量持久化提供核心框架：

1. ✅ 建立配置系统，支持模块化配置
2. ✅ 实现持久化管理器（PersistenceManager）
3. ✅ 实现批量刷新后台服务（BatchFlushHostedService）
4. ✅ 建立基础监控和诊断能力

### 不涉及的内容

- ❌ 具体业务模块集成（中篇）
- ❌ 优雅关闭增强（下篇）
- ❌ 性能调优（下篇）

### 关键产出

- 📦 `PersistenceOptions.cs` - 配置模型
- 📦 `IPersistenceManager.cs` - 持久化管理器接口
- 📦 `PersistenceManager.cs` - 持久化管理器实现
- 📦 `BatchFlushHostedService.cs` - 批量刷新后台服务
- 📦 `PersistenceMetrics.cs` - 监控指标收集器
- 📄 上篇实施总结文档
- ✅ 单元测试（覆盖率≥95%）

---

## Phase 1: 配置系统设计与实现

**工作量**: 1.5 天  
**优先级**: P0

### 1.1 目标

建立灵活的配置系统，支持：
- 全局配置和模块化配置
- 开发/生产环境差异化配置
- 运行时配置验证

### 1.2 实施步骤

#### Step 1.1: 创建配置模型类

**文件**: `BlazorIdle.Server/Infrastructure/Configuration/PersistenceOptions.cs`

```csharp
namespace BlazorIdle.Server.Infrastructure.Configuration;

/// <summary>
/// 持久化配置选项
/// 支持批量持久化和模块化配置
/// </summary>
public class PersistenceOptions
{
    /// <summary>
    /// 配置节名称（对应 appsettings.json）
    /// </summary>
    public const string SectionName = "Persistence";

    /// <summary>
    /// 是否启用批量持久化（全局开关）
    /// </summary>
    public bool EnableBatchPersistence { get; set; } = true;

    /// <summary>
    /// 全局默认刷新间隔（秒）
    /// </summary>
    public double GlobalFlushIntervalSeconds { get; set; } = 10.0;

    /// <summary>
    /// 单次批量保存的最大记录数
    /// </summary>
    public int MaxBatchSize { get; set; } = 1000;

    /// <summary>
    /// 保存失败重试次数
    /// </summary>
    public int MaxRetryAttempts { get; set; } = 3;

    /// <summary>
    /// 重试延迟（毫秒）
    /// </summary>
    public int RetryDelayMilliseconds { get; set; } = 500;

    /// <summary>
    /// 模块化配置字典
    /// </summary>
    public Dictionary<string, CategoryOptions> Categories { get; set; } = new();

    /// <summary>
    /// 优雅关闭配置
    /// </summary>
    public GracefulShutdownOptions GracefulShutdown { get; set; } = new();

    /// <summary>
    /// 监控配置
    /// </summary>
    public MonitoringOptions Monitoring { get; set; } = new();
}

/// <summary>
/// 模块类别配置
/// </summary>
public class CategoryOptions
{
    /// <summary>
    /// 是否启用此类别的批量持久化
    /// </summary>
    public bool Enabled { get; set; } = true;

    /// <summary>
    /// 刷新间隔（秒），null 时使用全局默认值
    /// </summary>
    public double? FlushIntervalSeconds { get; set; }

    /// <summary>
    /// 最大批次大小，null 时使用全局默认值
    /// </summary>
    public int? MaxBatchSize { get; set; }

    /// <summary>
    /// 优先级（0 最高）
    /// </summary>
    public int Priority { get; set; } = 1;

    /// <summary>
    /// 是否在特定条件下立即保存
    /// </summary>
    public bool ImmediateOnCondition { get; set; } = false;

    /// <summary>
    /// 立即保存的条件标签列表
    /// </summary>
    public List<string> ImmediateConditions { get; set; } = new();
}

/// <summary>
/// 优雅关闭配置
/// </summary>
public class GracefulShutdownOptions
{
    /// <summary>
    /// 是否启用优雅关闭增强
    /// </summary>
    public bool Enabled { get; set; } = true;

    /// <summary>
    /// 关闭超时时间（秒）
    /// </summary>
    public int ShutdownTimeoutSeconds { get; set; } = 10;

    /// <summary>
    /// 是否保存所有脏数据
    /// </summary>
    public bool SaveAllDirtyData { get; set; } = true;

    /// <summary>
    /// 是否将所有角色设为离线
    /// </summary>
    public bool SetAllCharactersOffline { get; set; } = true;

    /// <summary>
    /// 是否等待进行中的操作完成
    /// </summary>
    public bool WaitForInProgressOperations { get; set; } = true;

    /// <summary>
    /// 超时时是否强制保存
    /// </summary>
    public bool ForceSaveOnTimeout { get; set; } = true;
}

/// <summary>
/// 监控配置
/// </summary>
public class MonitoringOptions
{
    /// <summary>
    /// 是否启用监控指标
    /// </summary>
    public bool EnableMetrics { get; set; } = true;

    /// <summary>
    /// 指标收集间隔（秒）
    /// </summary>
    public int MetricsCollectionIntervalSeconds { get; set; } = 60;

    /// <summary>
    /// 是否记录批量保存操作日志
    /// </summary>
    public bool LogFlushOperations { get; set; } = true;

    /// <summary>
    /// 日志级别
    /// </summary>
    public string LogLevel { get; set; } = "Information";

    /// <summary>
    /// 脏数据过多时是否告警
    /// </summary>
    public bool AlertOnHighDirtyCount { get; set; } = true;

    /// <summary>
    /// 告警阈值（脏数据条数）
    /// </summary>
    public int DirtyCountAlertThreshold { get; set; } = 5000;
}
```

#### Step 1.2: 添加配置验证

**文件**: `BlazorIdle.Server/Infrastructure/Configuration/PersistenceOptionsValidator.cs`

```csharp
namespace BlazorIdle.Server.Infrastructure.Configuration;

/// <summary>
/// 持久化配置验证器
/// 确保配置参数在合理范围内
/// </summary>
public static class PersistenceOptionsValidator
{
    /// <summary>
    /// 验证配置选项
    /// </summary>
    public static ValidationResult Validate(PersistenceOptions options)
    {
        var errors = new List<string>();

        // 全局配置验证
        if (options.GlobalFlushIntervalSeconds < 1.0 || options.GlobalFlushIntervalSeconds > 300.0)
        {
            errors.Add("GlobalFlushIntervalSeconds 必须在 1-300 秒之间");
        }

        if (options.MaxBatchSize < 10 || options.MaxBatchSize > 10000)
        {
            errors.Add("MaxBatchSize 必须在 10-10000 之间");
        }

        if (options.MaxRetryAttempts < 0 || options.MaxRetryAttempts > 10)
        {
            errors.Add("MaxRetryAttempts 必须在 0-10 之间");
        }

        // 模块配置验证
        foreach (var (category, categoryOptions) in options.Categories)
        {
            if (categoryOptions.FlushIntervalSeconds.HasValue)
            {
                if (categoryOptions.FlushIntervalSeconds.Value < 1.0 || 
                    categoryOptions.FlushIntervalSeconds.Value > 300.0)
                {
                    errors.Add($"类别 '{category}' 的 FlushIntervalSeconds 必须在 1-300 秒之间");
                }
            }

            if (categoryOptions.MaxBatchSize.HasValue)
            {
                if (categoryOptions.MaxBatchSize.Value < 10 || 
                    categoryOptions.MaxBatchSize.Value > 10000)
                {
                    errors.Add($"类别 '{category}' 的 MaxBatchSize 必须在 10-10000 之间");
                }
            }
        }

        // 优雅关闭配置验证
        if (options.GracefulShutdown.ShutdownTimeoutSeconds < 1 || 
            options.GracefulShutdown.ShutdownTimeoutSeconds > 60)
        {
            errors.Add("ShutdownTimeoutSeconds 必须在 1-60 秒之间");
        }

        return new ValidationResult
        {
            IsValid = errors.Count == 0,
            Errors = errors
        };
    }

    public class ValidationResult
    {
        public bool IsValid { get; set; }
        public List<string> Errors { get; set; } = new();
    }
}
```

#### Step 1.3: 更新 appsettings.json

**文件**: `BlazorIdle.Server/appsettings.json`

在现有配置基础上添加新配置节：

```json
{
  "Persistence": {
    "EnableBatchPersistence": true,
    "GlobalFlushIntervalSeconds": 10.0,
    "MaxBatchSize": 1000,
    "MaxRetryAttempts": 3,
    "RetryDelayMilliseconds": 500,
    
    "Categories": {
      "BattleSnapshot": {
        "Enabled": true,
        "FlushIntervalSeconds": 5.0,
        "MaxBatchSize": 100,
        "Priority": 0,
        "ImmediateOnCondition": true,
        "ImmediateConditions": ["BattleComplete"]
      },
      
      "CharacterStatus": {
        "Enabled": true,
        "FlushIntervalSeconds": 30.0,
        "MaxBatchSize": 500,
        "Priority": 1
      },
      
      "ActivityPlan": {
        "Enabled": true,
        "FlushIntervalSeconds": 10.0,
        "MaxBatchSize": 200,
        "Priority": 1
      },
      
      "Equipment": {
        "Enabled": true,
        "FlushIntervalSeconds": 5.0,
        "MaxBatchSize": 100,
        "Priority": 1,
        "ImmediateOnCondition": true,
        "ImmediateConditions": ["Purchase", "Disenchant"]
      }
    },
    
    "GracefulShutdown": {
      "Enabled": true,
      "ShutdownTimeoutSeconds": 10,
      "SaveAllDirtyData": true,
      "SetAllCharactersOffline": true,
      "WaitForInProgressOperations": true,
      "ForceSaveOnTimeout": true
    },
    
    "Monitoring": {
      "EnableMetrics": true,
      "MetricsCollectionIntervalSeconds": 60,
      "LogFlushOperations": true,
      "LogLevel": "Information",
      "AlertOnHighDirtyCount": true,
      "DirtyCountAlertThreshold": 5000
    }
  }
}
```

#### Step 1.4: 注册配置到 DI 容器

**文件**: `BlazorIdle.Server/Program.cs`

在现有服务注册部分添加：

```csharp
// 持久化配置注册（在现有 builder.Services 注册之后添加）
builder.Services.Configure<PersistenceOptions>(
    builder.Configuration.GetSection(PersistenceOptions.SectionName));

// 配置验证（启动时验证）
var persistenceOptions = builder.Configuration
    .GetSection(PersistenceOptions.SectionName)
    .Get<PersistenceOptions>() ?? new PersistenceOptions();

var validation = PersistenceOptionsValidator.Validate(persistenceOptions);
if (!validation.IsValid)
{
    var errors = string.Join(Environment.NewLine, validation.Errors);
    throw new InvalidOperationException(
        $"持久化配置验证失败:{Environment.NewLine}{errors}");
}
```

### 1.3 单元测试

**文件**: `tests/BlazorIdle.Tests/Infrastructure/Configuration/PersistenceOptionsTests.cs`

```csharp
public class PersistenceOptionsTests
{
    [Fact]
    public void DefaultOptions_ShouldBeValid()
    {
        // Arrange
        var options = new PersistenceOptions();

        // Act
        var result = PersistenceOptionsValidator.Validate(options);

        // Assert
        Assert.True(result.IsValid);
        Assert.Empty(result.Errors);
    }

    [Theory]
    [InlineData(0.5)]    // 小于最小值
    [InlineData(301.0)]  // 大于最大值
    public void GlobalFlushInterval_OutOfRange_ShouldBeInvalid(double interval)
    {
        // Arrange
        var options = new PersistenceOptions
        {
            GlobalFlushIntervalSeconds = interval
        };

        // Act
        var result = PersistenceOptionsValidator.Validate(options);

        // Assert
        Assert.False(result.IsValid);
        Assert.Contains(result.Errors, e => e.Contains("GlobalFlushIntervalSeconds"));
    }

    // 更多测试用例...
}
```

### 1.4 验收标准

- [ ] `PersistenceOptions` 类正确建模所有配置参数
- [ ] 配置验证器能够识别所有无效配置
- [ ] appsettings.json 包含完整的配置示例
- [ ] 配置能够正确注册到 DI 容器
- [ ] 单元测试覆盖率≥95%
- [ ] 所有测试通过

---

## Phase 2: 持久化管理器核心实现

**工作量**: 3 天  
**优先级**: P0

### 2.1 目标

实现持久化管理器（PersistenceManager），提供：
- 脏数据追踪
- 批量保存协调
- 立即保存支持
- 线程安全

### 2.2 实施步骤

#### Step 2.1: 定义核心接口和模型

**文件**: `BlazorIdle.Server/Application/Abstractions/IPersistenceManager.cs`

```csharp
namespace BlazorIdle.Server.Application.Abstractions;

/// <summary>
/// 持久化管理器接口
/// 统一管理内存数据的持久化操作
/// </summary>
public interface IPersistenceManager
{
    /// <summary>
    /// 标记实体为脏（需要保存）
    /// </summary>
    /// <param name="entity">实体对象</param>
    /// <param name="category">类别（如 "BattleSnapshot", "CharacterStatus"）</param>
    /// <param name="condition">可选条件标签（如 "BattleComplete"）</param>
    void MarkDirty<T>(T entity, string category, string? condition = null) where T : class;

    /// <summary>
    /// 批量标记实体为脏
    /// </summary>
    void MarkDirtyBatch<T>(IEnumerable<T> entities, string category, string? condition = null) where T : class;

    /// <summary>
    /// 批量保存所有脏数据
    /// </summary>
    /// <param name="ct">取消令牌</param>
    /// <returns>持久化结果</returns>
    Task<PersistenceResult> FlushAsync(CancellationToken ct = default);

    /// <summary>
    /// 批量保存指定类别的脏数据
    /// </summary>
    /// <param name="category">类别名称</param>
    /// <param name="ct">取消令牌</param>
    /// <returns>持久化结果</returns>
    Task<PersistenceResult> FlushCategoryAsync(string category, CancellationToken ct = default);

    /// <summary>
    /// 立即保存指定实体（不等待批量刷新）
    /// </summary>
    Task<PersistenceResult> SaveImmediatelyAsync<T>(T entity, string category, CancellationToken ct = default) where T : class;

    /// <summary>
    /// 获取脏数据统计信息
    /// </summary>
    PersistenceStatistics GetStatistics();

    /// <summary>
    /// 清除所有脏数据标记（不保存）
    /// </summary>
    void ClearDirty(string? category = null);
}

/// <summary>
/// 持久化结果
/// </summary>
public class PersistenceResult
{
    /// <summary>
    /// 是否成功
    /// </summary>
    public bool Success { get; set; }

    /// <summary>
    /// 保存的记录数
    /// </summary>
    public int SavedCount { get; set; }

    /// <summary>
    /// 失败的记录数
    /// </summary>
    public int FailedCount { get; set; }

    /// <summary>
    /// 耗时（毫秒）
    /// </summary>
    public long ElapsedMilliseconds { get; set; }

    /// <summary>
    /// 错误消息
    /// </summary>
    public List<string> Errors { get; set; } = new();

    /// <summary>
    /// 按类别统计
    /// </summary>
    public Dictionary<string, CategoryResult> CategoryResults { get; set; } = new();
}

/// <summary>
/// 类别持久化结果
/// </summary>
public class CategoryResult
{
    public string Category { get; set; } = "";
    public int SavedCount { get; set; }
    public int FailedCount { get; set; }
    public long ElapsedMilliseconds { get; set; }
}

/// <summary>
/// 持久化统计信息
/// </summary>
public class PersistenceStatistics
{
    /// <summary>
    /// 总脏数据条数
    /// </summary>
    public int TotalDirtyCount { get; set; }

    /// <summary>
    /// 按类别统计
    /// </summary>
    public Dictionary<string, int> DirtyCountByCategory { get; set; } = new();

    /// <summary>
    /// 最近一次刷新时间
    /// </summary>
    public DateTime? LastFlushTime { get; set; }

    /// <summary>
    /// 最近一次刷新耗时（毫秒）
    /// </summary>
    public long? LastFlushElapsedMs { get; set; }

    /// <summary>
    /// 累计刷新次数
    /// </summary>
    public long TotalFlushCount { get; set; }

    /// <summary>
    /// 累计保存记录数
    /// </summary>
    public long TotalSavedCount { get; set; }
}
```

#### Step 2.2: 实现脏数据追踪器

**文件**: `BlazorIdle.Server/Infrastructure/Persistence/DirtyTracker.cs`

```csharp
namespace BlazorIdle.Server.Infrastructure.Persistence;

/// <summary>
/// 脏数据追踪器
/// 线程安全的脏数据管理
/// </summary>
internal class DirtyTracker
{
    // 按类别组织的脏数据队列
    private readonly ConcurrentDictionary<string, ConcurrentBag<DirtyEntry>> _dirtyBags = new();
    
    // 立即保存队列（高优先级）
    private readonly ConcurrentBag<DirtyEntry> _immediateBag = new();
    
    // 统计信息
    private long _totalMarkedCount;
    private DateTime? _lastFlushTime;
    private long? _lastFlushElapsedMs;
    private long _totalFlushCount;
    private long _totalSavedCount;

    /// <summary>
    /// 脏数据条目
    /// </summary>
    internal class DirtyEntry
    {
        public object Entity { get; set; } = null!;
        public string Category { get; set; } = "";
        public string? Condition { get; set; }
        public DateTime MarkedAt { get; set; } = DateTime.UtcNow;
        public bool IsImmediate { get; set; }
    }

    /// <summary>
    /// 标记实体为脏
    /// </summary>
    public void MarkDirty(object entity, string category, string? condition, bool immediate)
    {
        var entry = new DirtyEntry
        {
            Entity = entity,
            Category = category,
            Condition = condition,
            IsImmediate = immediate
        };

        if (immediate)
        {
            _immediateBag.Add(entry);
        }
        else
        {
            var bag = _dirtyBags.GetOrAdd(category, _ => new ConcurrentBag<DirtyEntry>());
            bag.Add(entry);
        }

        Interlocked.Increment(ref _totalMarkedCount);
    }

    /// <summary>
    /// 获取并清空立即保存队列
    /// </summary>
    public List<DirtyEntry> TakeImmediate()
    {
        var entries = new List<DirtyEntry>();
        while (_immediateBag.TryTake(out var entry))
        {
            entries.Add(entry);
        }
        return entries;
    }

    /// <summary>
    /// 获取并清空指定类别的脏数据
    /// </summary>
    public List<DirtyEntry> TakeCategory(string category, int maxCount = int.MaxValue)
    {
        if (!_dirtyBags.TryGetValue(category, out var bag))
        {
            return new List<DirtyEntry>();
        }

        var entries = new List<DirtyEntry>();
        var taken = 0;

        while (taken < maxCount && bag.TryTake(out var entry))
        {
            entries.Add(entry);
            taken++;
        }

        return entries;
    }

    /// <summary>
    /// 获取并清空所有脏数据（按优先级排序）
    /// </summary>
    public Dictionary<string, List<DirtyEntry>> TakeAll(int maxTotalCount = int.MaxValue)
    {
        var result = new Dictionary<string, List<DirtyEntry>>();
        var totalTaken = 0;

        // 按优先级排序类别
        var sortedCategories = _dirtyBags.Keys.OrderBy(k => k).ToList();

        foreach (var category in sortedCategories)
        {
            if (totalTaken >= maxTotalCount)
                break;

            var remaining = maxTotalCount - totalTaken;
            var entries = TakeCategory(category, remaining);
            
            if (entries.Any())
            {
                result[category] = entries;
                totalTaken += entries.Count;
            }
        }

        return result;
    }

    /// <summary>
    /// 获取统计信息
    /// </summary>
    public PersistenceStatistics GetStatistics()
    {
        var stats = new PersistenceStatistics
        {
            TotalDirtyCount = _immediateBag.Count,
            LastFlushTime = _lastFlushTime,
            LastFlushElapsedMs = _lastFlushElapsedMs,
            TotalFlushCount = _totalFlushCount,
            TotalSavedCount = _totalSavedCount
        };

        foreach (var (category, bag) in _dirtyBags)
        {
            stats.DirtyCountByCategory[category] = bag.Count;
            stats.TotalDirtyCount += bag.Count;
        }

        return stats;
    }

    /// <summary>
    /// 更新统计信息（刷新完成后调用）
    /// </summary>
    public void UpdateStatistics(long savedCount, long elapsedMs)
    {
        _lastFlushTime = DateTime.UtcNow;
        _lastFlushElapsedMs = elapsedMs;
        Interlocked.Increment(ref _totalFlushCount);
        Interlocked.Add(ref _totalSavedCount, savedCount);
    }

    /// <summary>
    /// 清除所有脏数据（不保存）
    /// </summary>
    public void Clear(string? category = null)
    {
        if (category == null)
        {
            _dirtyBags.Clear();
            while (_immediateBag.TryTake(out _)) { }
        }
        else if (_dirtyBags.TryGetValue(category, out var bag))
        {
            while (bag.TryTake(out _)) { }
        }
    }
}
```

#### Step 2.3: 实现持久化管理器

**文件**: `BlazorIdle.Server/Infrastructure/Persistence/PersistenceManager.cs`

```csharp
namespace BlazorIdle.Server.Infrastructure.Persistence;

/// <summary>
/// 持久化管理器实现
/// 统一管理内存数据的持久化操作
/// </summary>
public class PersistenceManager : IPersistenceManager
{
    private readonly DirtyTracker _dirtyTracker = new();
    private readonly IServiceScopeFactory _scopeFactory;
    private readonly IOptions<PersistenceOptions> _options;
    private readonly ILogger<PersistenceManager> _logger;
    private readonly SemaphoreSlim _flushLock = new(1, 1);

    public PersistenceManager(
        IServiceScopeFactory scopeFactory,
        IOptions<PersistenceOptions> options,
        ILogger<PersistenceManager> logger)
    {
        _scopeFactory = scopeFactory;
        _options = options;
        _logger = logger;
    }

    public void MarkDirty<T>(T entity, string category, string? condition = null) where T : class
    {
        if (!_options.Value.EnableBatchPersistence)
        {
            return; // 批量持久化未启用，忽略
        }

        var categoryOptions = GetCategoryOptions(category);
        if (!categoryOptions.Enabled)
        {
            return; // 此类别未启用批量持久化
        }

        // 判断是否需要立即保存
        var immediate = categoryOptions.ImmediateOnCondition && 
                       condition != null && 
                       categoryOptions.ImmediateConditions.Contains(condition);

        _dirtyTracker.MarkDirty(entity, category, condition, immediate);

        // 监控告警
        CheckDirtyCountAlert();
    }

    public void MarkDirtyBatch<T>(IEnumerable<T> entities, string category, string? condition = null) where T : class
    {
        foreach (var entity in entities)
        {
            MarkDirty(entity, category, condition);
        }
    }

    public async Task<PersistenceResult> FlushAsync(CancellationToken ct = default)
    {
        if (!_options.Value.EnableBatchPersistence)
        {
            return new PersistenceResult { Success = true }; // 批量持久化未启用
        }

        var sw = Stopwatch.StartNew();
        var result = new PersistenceResult { Success = true };

        // 确保同时只有一个刷新操作
        await _flushLock.WaitAsync(ct);
        try
        {
            // 1. 先处理立即保存队列
            var immediateEntries = _dirtyTracker.TakeImmediate();
            if (immediateEntries.Any())
            {
                var immediateResult = await SaveEntriesAsync(immediateEntries, ct);
                MergeResults(result, immediateResult);
            }

            // 2. 按优先级处理普通队列
            var allEntries = _dirtyTracker.TakeAll(_options.Value.MaxBatchSize);
            if (allEntries.Any())
            {
                var batchResult = await SaveEntriesByCategory Async(allEntries, ct);
                MergeResults(result, batchResult);
            }

            sw.Stop();
            result.ElapsedMilliseconds = sw.ElapsedMilliseconds;

            // 更新统计
            _dirtyTracker.UpdateStatistics(result.SavedCount, sw.ElapsedMilliseconds);

            // 日志
            if (_options.Value.Monitoring.LogFlushOperations && result.SavedCount > 0)
            {
                _logger.LogInformation(
                    "批量保存完成: 成功 {SavedCount} 条, 失败 {FailedCount} 条, 耗时 {ElapsedMs}ms",
                    result.SavedCount, result.FailedCount, result.ElapsedMilliseconds);
            }
        }
        finally
        {
            _flushLock.Release();
        }

        return result;
    }

    public async Task<PersistenceResult> FlushCategoryAsync(string category, CancellationToken ct = default)
    {
        var categoryOptions = GetCategoryOptions(category);
        if (!categoryOptions.Enabled)
        {
            return new PersistenceResult { Success = true };
        }

        var maxBatchSize = categoryOptions.MaxBatchSize ?? _options.Value.MaxBatchSize;
        var entries = _dirtyTracker.TakeCategory(category, maxBatchSize);
        
        if (!entries.Any())
        {
            return new PersistenceResult { Success = true };
        }

        return await SaveEntriesAsync(entries, ct);
    }

    public async Task<PersistenceResult> SaveImmediatelyAsync<T>(T entity, string category, CancellationToken ct = default) where T : class
    {
        var entries = new List<DirtyTracker.DirtyEntry>
        {
            new() { Entity = entity, Category = category, IsImmediate = true }
        };

        return await SaveEntriesAsync(entries, ct);
    }

    public PersistenceStatistics GetStatistics()
    {
        return _dirtyTracker.GetStatistics();
    }

    public void ClearDirty(string? category = null)
    {
        _dirtyTracker.Clear(category);
    }

    // ===== 私有辅助方法 =====

    private CategoryOptions GetCategoryOptions(string category)
    {
        if (_options.Value.Categories.TryGetValue(category, out var options))
        {
            return options;
        }

        // 返回默认配置
        return new CategoryOptions
        {
            Enabled = true,
            FlushIntervalSeconds = _options.Value.GlobalFlushIntervalSeconds,
            MaxBatchSize = _options.Value.MaxBatchSize
        };
    }

    private async Task<PersistenceResult> SaveEntriesAsync(
        List<DirtyTracker.DirtyEntry> entries, 
        CancellationToken ct)
    {
        // 按类别分组
        var byCategory = entries.GroupBy(e => e.Category).ToDictionary(g => g.Key, g => g.ToList());
        return await SaveEntriesByCategoryAsync(byCategory, ct);
    }

    private async Task<PersistenceResult> SaveEntriesByCategoryAsync(
        Dictionary<string, List<DirtyTracker.DirtyEntry>> entriesByCategory,
        CancellationToken ct)
    {
        var result = new PersistenceResult { Success = true };

        foreach (var (category, entries) in entriesByCategory)
        {
            var categoryResult = await SaveCategoryEntriesAsync(category, entries, ct);
            result.CategoryResults[category] = categoryResult;
            result.SavedCount += categoryResult.SavedCount;
            result.FailedCount += categoryResult.FailedCount;
        }

        result.Success = result.FailedCount == 0;
        return result;
    }

    private async Task<CategoryResult> SaveCategoryEntriesAsync(
        string category,
        List<DirtyTracker.DirtyEntry> entries,
        CancellationToken ct)
    {
        var sw = Stopwatch.StartNew();
        var result = new CategoryResult { Category = category };

        try
        {
            using var scope = _scopeFactory.CreateScope();
            var db = scope.ServiceProvider.GetRequiredService<GameDbContext>();

            // 将实体附加到 DbContext 并标记为 Modified
            foreach (var entry in entries)
            {
                var entityEntry = db.Entry(entry.Entity);
                if (entityEntry.State == EntityState.Detached)
                {
                    db.Attach(entry.Entity);
                    entityEntry.State = EntityState.Modified;
                }
            }

            // 批量保存
            var savedCount = await SaveWithRetryAsync(db, ct);
            result.SavedCount = savedCount;
        }
        catch (Exception ex)
        {
            result.FailedCount = entries.Count;
            _logger.LogError(ex, "保存类别 {Category} 的数据失败", category);
        }

        sw.Stop();
        result.ElapsedMilliseconds = sw.ElapsedMilliseconds;
        return result;
    }

    private async Task<int> SaveWithRetryAsync(GameDbContext db, CancellationToken ct)
    {
        var maxAttempts = _options.Value.MaxRetryAttempts + 1;
        var delayMs = _options.Value.RetryDelayMilliseconds;

        for (int attempt = 1; attempt <= maxAttempts; attempt++)
        {
            try
            {
                return await db.SaveChangesAsync(ct);
            }
            catch (DbUpdateConcurrencyException) when (attempt < maxAttempts)
            {
                _logger.LogWarning("保存数据时发生并发冲突，重试 {Attempt}/{MaxAttempts}", attempt, maxAttempts);
                await Task.Delay(delayMs * attempt, ct); // 指数退避
            }
            catch (DbUpdateException) when (attempt < maxAttempts)
            {
                _logger.LogWarning("保存数据时发生数据库错误，重试 {Attempt}/{MaxAttempts}", attempt, maxAttempts);
                await Task.Delay(delayMs * attempt, ct);
            }
        }

        throw new InvalidOperationException($"保存数据失败，已重试 {maxAttempts} 次");
    }

    private void MergeResults(PersistenceResult target, PersistenceResult source)
    {
        target.SavedCount += source.SavedCount;
        target.FailedCount += source.FailedCount;
        target.Errors.AddRange(source.Errors);
        
        foreach (var (category, categoryResult) in source.CategoryResults)
        {
            target.CategoryResults[category] = categoryResult;
        }
    }

    private void CheckDirtyCountAlert()
    {
        if (!_options.Value.Monitoring.AlertOnHighDirtyCount)
        {
            return;
        }

        var stats = _dirtyTracker.GetStatistics();
        if (stats.TotalDirtyCount >= _options.Value.Monitoring.DirtyCountAlertThreshold)
        {
            _logger.LogWarning(
                "脏数据数量过多: {DirtyCount} (阈值: {Threshold})，建议检查批量刷新间隔",
                stats.TotalDirtyCount,
                _options.Value.Monitoring.DirtyCountAlertThreshold);
        }
    }
}
```

### 2.3 单元测试

**文件**: `tests/BlazorIdle.Tests/Infrastructure/Persistence/PersistenceManagerTests.cs`

```csharp
public class PersistenceManagerTests
{
    [Fact]
    public void MarkDirty_ShouldTrackEntity()
    {
        // Arrange
        var manager = CreateManager();
        var entity = new TestEntity { Id = Guid.NewGuid() };

        // Act
        manager.MarkDirty(entity, "TestCategory");
        var stats = manager.GetStatistics();

        // Assert
        Assert.Equal(1, stats.TotalDirtyCount);
        Assert.True(stats.DirtyCountByCategory.ContainsKey("TestCategory"));
    }

    [Fact]
    public async Task FlushAsync_ShouldSaveAllDirtyData()
    {
        // Arrange
        var manager = CreateManager();
        var entities = Enumerable.Range(1, 10)
            .Select(_ => new TestEntity { Id = Guid.NewGuid() })
            .ToList();

        foreach (var entity in entities)
        {
            manager.MarkDirty(entity, "TestCategory");
        }

        // Act
        var result = await manager.FlushAsync();

        // Assert
        Assert.True(result.Success);
        Assert.Equal(10, result.SavedCount);
        Assert.Equal(0, result.FailedCount);
    }

    // 更多测试用例...
}
```

### 2.4 验收标准

- [ ] `IPersistenceManager` 接口定义完整
- [ ] `DirtyTracker` 线程安全，支持并发操作
- [ ] `PersistenceManager` 正确实现所有接口方法
- [ ] 支持立即保存和批量保存两种模式
- [ ] 重试机制有效处理数据库锁和并发异常
- [ ] 统计信息准确
- [ ] 单元测试覆盖率≥95%
- [ ] 所有测试通过

---

## Phase 3: 批量刷新后台服务

**工作量**: 1.5 天  
**优先级**: P0

### 3.1 目标

实现批量刷新后台服务（BatchFlushHostedService），提供：
- 定时批量刷新
- 可配置的刷新间隔
- 优雅启动和关闭

### 3.2 实施步骤

#### Step 3.1: 实现后台服务

**文件**: `BlazorIdle.Server/Services/Batch FlushHostedService.cs`

```csharp
namespace BlazorIdle.Server.Services;

/// <summary>
/// 批量刷新后台服务
/// 定期触发持久化管理器的批量保存操作
/// </summary>
public class BatchFlushHostedService : BackgroundService
{
    private readonly IPersistenceManager _persistenceManager;
    private readonly IOptions<PersistenceOptions> _options;
    private readonly ILogger<BatchFlushHostedService> _logger;

    public BatchFlushHostedService(
        IPersistenceManager persistenceManager,
        IOptions<PersistenceOptions> options,
        ILogger<BatchFlushHostedService> logger)
    {
        _persistenceManager = persistenceManager;
        _options = options;
        _logger = logger;
    }

    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        if (!_options.Value.EnableBatchPersistence)
        {
            _logger.LogInformation("批量持久化未启用，BatchFlushHostedService 不执行");
            return;
        }

        _logger.LogInformation(
            "BatchFlushHostedService 启动，刷新间隔: {IntervalSeconds}秒",
            _options.Value.GlobalFlushIntervalSeconds);

        try
        {
            while (!stoppingToken.IsCancellationRequested)
            {
                // 等待刷新间隔
                var intervalMs = (int)(_options.Value.GlobalFlushIntervalSeconds * 1000);
                await Task.Delay(intervalMs, stoppingToken);

                // 执行批量刷新
                try
                {
                    var result = await _persistenceManager.FlushAsync(stoppingToken);
                    
                    if (result.FailedCount > 0)
                    {
                        _logger.LogWarning(
                            "批量刷新部分失败: 成功 {SavedCount}, 失败 {FailedCount}",
                            result.SavedCount, result.FailedCount);
                    }
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "批量刷新时发生异常");
                }
            }
        }
        catch (OperationCanceledException)
        {
            _logger.LogInformation("BatchFlushHostedService 收到停止信号");
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "BatchFlushHostedService 发生未处理的异常");
        }

        _logger.LogInformation("BatchFlushHostedService 已停止");
    }

    public override async Task StopAsync(CancellationToken cancellationToken)
    {
        _logger.LogInformation("BatchFlushHostedService 正在关闭，执行最终刷新...");

        try
        {
            // 关闭时执行最终刷新
            var result = await _persistenceManager.FlushAsync(cancellationToken);
            
            _logger.LogInformation(
                "最终刷新完成: 成功 {SavedCount}, 失败 {FailedCount}, 耗时 {ElapsedMs}ms",
                result.SavedCount, result.FailedCount, result.ElapsedMilliseconds);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "最终刷新时发生异常");
        }

        await base.StopAsync(cancellationToken);
    }
}
```

#### Step 3.2: 注册后台服务

**文件**: `BlazorIdle.Server/Program.cs`

在现有后台服务注册部分添加：

```csharp
// 注册持久化管理器和批量刷新服务
builder.Services.AddSingleton<IPersistenceManager, PersistenceManager>();
builder.Services.AddHostedService<BatchFlushHostedService>();
```

### 3.3 集成测试

**文件**: `tests/BlazorIdle.Tests/Services/BatchFlushHostedServiceTests.cs`

```csharp
public class BatchFlushHostedServiceTests
{
    [Fact]
    public async Task ExecuteAsync_ShouldFlushPeriodically()
    {
        // Arrange
        var persistenceManagerMock = new Mock<IPersistenceManager>();
        var options = Options.Create(new PersistenceOptions
        {
            EnableBatchPersistence = true,
            GlobalFlushIntervalSeconds = 0.5 // 测试用，0.5秒
        });
        var loggerMock = new Mock<ILogger<BatchFlushHostedService>>();

        persistenceManagerMock
            .Setup(m => m.FlushAsync(It.IsAny<CancellationToken>()))
            .ReturnsAsync(new PersistenceResult { Success = true });

        var service = new BatchFlushHostedService(
            persistenceManagerMock.Object,
            options,
            loggerMock.Object);

        var cts = new CancellationTokenSource();

        // Act
        var task = service.StartAsync(cts.Token);
        await Task.Delay(1500); // 等待足够时间触发至少2次刷新
        cts.Cancel();
        await service.StopAsync(CancellationToken.None);

        // Assert
        persistenceManagerMock.Verify(
            m => m.FlushAsync(It.IsAny<CancellationToken>()),
            Times.AtLeast(2)); // 至少触发2次刷新
    }

    // 更多测试用例...
}
```

### 3.4 验收标准

- [ ] `BatchFlushHostedService` 能够定期触发批量刷新
- [ ] 刷新间隔可配置
- [ ] 关闭时执行最终刷新
- [ ] 异常处理健壮，不会导致服务停止
- [ ] 日志记录完整
- [ ] 集成测试验证定期刷新功能
- [ ] 所有测试通过

---

## Phase 4: 监控与诊断基础

**工作量**: 1 天  
**优先级**: P1

### 4.1 目标

建立基础监控和诊断能力：
- 持久化指标收集
- 诊断API
- 日志增强

### 4.2 实施步骤

#### Step 4.1: 实现指标收集器

**文件**: `BlazorIdle.Server/Infrastructure/Monitoring/PersistenceMetrics.cs`

```csharp
namespace BlazorIdle.Server.Infrastructure.Monitoring;

/// <summary>
/// 持久化指标收集器
/// </summary>
public class PersistenceMetrics
{
    private long _totalFlushCount;
    private long _totalSavedCount;
    private long _totalFailedCount;
    private long _totalFlushTimeMs;
    private readonly ConcurrentDictionary<string, CategoryMetrics> _categoryMetrics = new();

    public class CategoryMetrics
    {
        public long FlushCount { get; set; }
        public long SavedCount { get; set; }
        public long FailedCount { get; set; }
        public long TotalFlushTimeMs { get; set; }

        public double AverageFlushTimeMs =>
            FlushCount > 0 ? (double)TotalFlushTimeMs / FlushCount : 0;

        public double SuccessRate =>
            (SavedCount + FailedCount) > 0
                ? (double)SavedCount / (SavedCount + FailedCount)
                : 1.0;
    }

    /// <summary>
    /// 记录一次刷新操作
    /// </summary>
    public void RecordFlush(PersistenceResult result)
    {
        Interlocked.Increment(ref _totalFlushCount);
        Interlocked.Add(ref _totalSavedCount, result.SavedCount);
        Interlocked.Add(ref _totalFailedCount, result.FailedCount);
        Interlocked.Add(ref _totalFlushTimeMs, result.ElapsedMilliseconds);

        foreach (var (category, categoryResult) in result.CategoryResults)
        {
            var metrics = _categoryMetrics.GetOrAdd(category, _ => new CategoryMetrics());
            Interlocked.Increment(ref metrics.FlushCount);
            Interlocked.Add(ref metrics.SavedCount, categoryResult.SavedCount);
            Interlocked.Add(ref metrics.FailedCount, categoryResult.FailedCount);
            Interlocked.Add(ref metrics.TotalFlushTimeMs, categoryResult.ElapsedMilliseconds);
        }
    }

    /// <summary>
    /// 获取总体指标
    /// </summary>
    public object GetOverallMetrics()
    {
        return new
        {
            TotalFlushCount = _totalFlushCount,
            TotalSavedCount = _totalSavedCount,
            TotalFailedCount = _totalFailedCount,
            AverageFlushTimeMs = _totalFlushCount > 0 ? (double)_totalFlushTimeMs / _totalFlushCount : 0,
            SuccessRate = (_totalSavedCount + _totalFailedCount) > 0
                ? (double)_totalSavedCount / (_totalSavedCount + _totalFailedCount)
                : 1.0
        };
    }

    /// <summary>
    /// 获取按类别统计的指标
    /// </summary>
    public Dictionary<string, CategoryMetrics> GetCategoryMetrics()
    {
        return new Dictionary<string, CategoryMetrics>(_categoryMetrics);
    }
}
```

#### Step 4.2: 实现诊断API

**文件**: `BlazorIdle.Server/Api/DiagnosticsController.cs`

```csharp
namespace BlazorIdle.Server.Api;

[ApiController]
[Route("api/[controller]")]
public class DiagnosticsController : ControllerBase
{
    private readonly IPersistenceManager _persistenceManager;
    private readonly PersistenceMetrics _metrics;

    public DiagnosticsController(
        IPersistenceManager persistenceManager,
        PersistenceMetrics metrics)
    {
        _persistenceManager = persistenceManager;
        _metrics = metrics;
    }

    /// <summary>
    /// 获取持久化统计信息
    /// </summary>
    [HttpGet("persistence/statistics")]
    public IActionResult GetStatistics()
    {
        var stats = _persistenceManager.GetStatistics();
        return Ok(stats);
    }

    /// <summary>
    /// 获取持久化性能指标
    /// </summary>
    [HttpGet("persistence/metrics")]
    public IActionResult GetMetrics()
    {
        return Ok(new
        {
            Overall = _metrics.GetOverallMetrics(),
            Categories = _metrics.GetCategoryMetrics()
        });
    }

    /// <summary>
    /// 手动触发批量刷新（仅开发/测试环境）
    /// </summary>
    [HttpPost("persistence/flush")]
    public async Task<IActionResult> TriggerFlush()
    {
        var result = await _persistenceManager.FlushAsync();
        return Ok(result);
    }
}
```

#### Step 4.3: 注册监控服务

**文件**: `BlazorIdle.Server/Program.cs`

```csharp
// 注册监控服务
builder.Services.AddSingleton<PersistenceMetrics>();

// 在 PersistenceManager 的 FlushAsync 方法中添加指标记录
// （修改 PersistenceManager.cs，在 FlushAsync 最后添加）
```

### 4.3 验收标准

- [ ] `PersistenceMetrics` 正确统计所有刷新操作
- [ ] 诊断API能够返回完整的统计信息和指标
- [ ] 手动触发刷新功能可用
- [ ] 日志记录关键操作
- [ ] 单元测试覆盖监控组件
- [ ] 所有测试通过

---

## 上篇总结与验收

### 完成情况检查清单

#### Phase 1: 配置系统 ✅
- [ ] `PersistenceOptions` 类完整
- [ ] 配置验证器有效
- [ ] appsettings.json 包含完整配置
- [ ] 配置注册到 DI 容器
- [ ] 单元测试覆盖率≥95%

#### Phase 2: 持久化管理器 ✅
- [ ] `IPersistenceManager` 接口定义完整
- [ ] `DirtyTracker` 线程安全
- [ ] `PersistenceManager` 实现所有功能
- [ ] 立即保存和批量保存都支持
- [ ] 重试机制有效
- [ ] 单元测试覆盖率≥95%

#### Phase 3: 批量刷新服务 ✅
- [ ] `BatchFlushHostedService` 定期刷新
- [ ] 关闭时执行最终刷新
- [ ] 异常处理健壮
- [ ] 集成测试验证功能

#### Phase 4: 监控与诊断 ✅
- [ ] `PersistenceMetrics` 统计准确
- [ ] 诊断API可用
- [ ] 日志记录完整

### 性能基准测试

在上篇完成后，执行以下基准测试：

**测试场景1：批量保存性能**
```
输入: 1000条脏数据
预期: 保存耗时 < 500ms
预期: 成功率 = 100%
```

**测试场景2：并发标记脏数据**
```
输入: 10个线程，每个标记100条
预期: 无数据丢失
预期: 无异常
```

**测试场景3：定时刷新稳定性**
```
输入: 运行10分钟，每秒标记10条脏数据
预期: 所有数据最终保存
预期: 无内存泄漏
```

### 文档交付

- [ ] **上篇实施总结.md** - 记录实施过程和经验
- [ ] **配置参数说明.md** - 详细说明所有配置参数
- [ ] **API文档.md** - 诊断API使用说明

### 下一步行动

上篇完成后，可以进入**中篇**：具体业务模块集成，包括：
- 战斗快照集成
- 角色状态集成
- 活动计划集成
- 装备操作集成

---

**文档版本**: 1.0  
**创建日期**: 2025-10-17  
**预计完成**: 上篇实施需 7-9 工作日  
**状态**: 📘 实施方案完成，待执行
