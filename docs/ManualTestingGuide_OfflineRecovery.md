# 离线恢复功能手动测试指南

## 测试目标

验证玩家离线后重新登录时，战斗能够正常恢复，包括：
- BattleId 不为空
- 战斗状态（敌人血量等）正确恢复
- 前端自动开始轮询战斗进度
- 用户看到的是正在进行的战斗，而不是新战斗

## 测试前准备

1. 启动 BlazorIdle 服务器
2. 打开浏览器，清除 localStorage（确保是全新会话）
3. 注册/登录账号
4. 创建一个测试角色

## 测试场景 1：正常离线恢复（计划未完成）

### 步骤

1. **创建战斗计划**
   - 点击"创建战斗计划"
   - 设置：
     - 活动类型：战斗（Combat）
     - 限制类型：持续时间（Duration）
     - 时长：300 秒（5分钟）
     - 敌人：dummy（或任意敌人）
   - 点击创建

2. **观察战斗开始**
   - 确认计划状态显示为"运行中"（State=1）
   - 确认显示 BattleId
   - 确认战斗统计（金币、经验、击杀数）在增加

3. **等待一段时间（例如30秒）**
   - 让战斗进行一段时间
   - 记录当前的 ExecutedSeconds（已执行秒数）
   - 记录当前的金币和经验

4. **模拟离线**
   - 方法1：直接关闭浏览器标签页（推荐）
   - 方法2：在数据库中手动修改 `LastSeenAtUtc` 为1小时前
   - 等待至少 30 秒（确保后端检测到离线）

5. **重新登录**
   - 打开新的浏览器标签页
   - 登录同一账号
   - 选择同一角色

6. **验证离线结算弹窗**
   - ✓ 应该显示离线结算弹窗
   - ✓ 显示离线时长
   - ✓ 显示获得的金币和经验
   - ✓ 显示战斗统计（击杀数、伤害等）

7. **验证战斗恢复**
   - ✓ 关闭弹窗后，计划列表中应该显示该计划
   - ✓ 计划状态应该是"运行中"（State=1）
   - ✓ **重点检查：BattleId 不为空**
   - ✓ ExecutedSeconds 应该增加了离线时长
   - ✓ 战斗统计（金币、经验）应该继续增加
   - ✓ 浏览器控制台应该显示正在轮询战斗状态

8. **验证战斗状态连续性**
   - 观察敌人血量：如果离线结算时敌人被击杀，应该看到新的敌人
   - 观察战斗时间：应该从离线结算后的时间继续
   - 观察击杀计数：应该从离线结算后的数量继续累加

## 测试场景 2：离线后计划完成

### 步骤

1. **创建短时战斗计划**
   - 时长：60 秒（1分钟）
   - 其他设置同上

2. **等待30秒后离线**
   - 让战斗进行30秒
   - 关闭浏览器

3. **等待2分钟后重新登录**
   - 离线时长超过计划剩余时间

4. **验证**
   - ✓ 应该显示离线结算弹窗
   - ✓ 计划状态应该是"已完成"（State=2）
   - ✓ CompletedAt 应该有值
   - ✓ BattleId 可能为空（因为计划已完成）
   - ✓ 如果有下一个待执行的计划，应该自动启动

## 测试场景 3：地下城模式离线恢复

### 步骤

1. **创建地下城计划**
   - 活动类型：地下城（Dungeon）
   - 地下城ID：intro_cave
   - 循环：是/否
   - 时长：300 秒

2. **等待一段时间后离线**
   - 记录当前波次（WaveIndex）
   - 记录已完成轮数（RunCount，如果是循环模式）

3. **重新登录**

4. **验证**
   - ✓ 离线结算正确计算
   - ✓ 战斗正确恢复
   - ✓ 波次索引正确继续
   - ✓ 轮数计数正确继续（如果是循环模式）

## 测试场景 4：手动恢复暂停的计划

### 步骤

1. **创建并启动计划**

2. **手动暂停计划**
   - 点击"暂停"按钮（如果有）
   - 或者关闭浏览器让系统自动暂停

3. **重新登录**
   - 不触发离线结算（LastSeenAtUtc 未超过阈值）

4. **手动点击"恢复"按钮**

5. **验证**
   - ✓ 计划状态变为"运行中"
   - ✓ BattleId 不为空
   - ✓ 战斗正确恢复
   - ✓ 前端自动开始轮询

## 检查点总结

### 后端检查点

1. **PausePlanAsync**
   - [ ] 保存战斗状态到 BattleStateJson
   - [ ] 更新 ExecutedSeconds
   - [ ] 设置 BattleId = null
   - [ ] 设置 State = Paused

2. **CheckAndSettleAsync**
   - [ ] 检测离线时长
   - [ ] 运行 OfflineFastForwardEngine
   - [ ] 更新 ExecutedSeconds
   - [ ] 更新 BattleStateJson（包含离线结算后的战斗状态）
   - [ ] 如果计划未完成，自动调用 StartPlanAsync
   - [ ] 返回包含 BattleId 的 OfflineCheckResult

3. **StartPlanAsync**
   - [ ] 从 BattleStateJson 加载战斗状态
   - [ ] 创建新的战斗
   - [ ] 调用 RestoreBattleState 恢复敌人血量等
   - [ ] 设置 BattleId
   - [ ] 设置 State = Running

### 前端检查点

1. **CheckOfflineRewardsAsync**
   - [ ] 调用 UpdateHeartbeatAsync
   - [ ] 显示离线结算弹窗
   - [ ] 刷新计划列表
   - [ ] 检查运行中的计划是否有 BattleId
   - [ ] 如果有，自动开始轮询

2. **RefreshPlansAsync**
   - [ ] 获取计划列表
   - [ ] 查找 State=1 且有 BattleId 的计划
   - [ ] 自动开始轮询

3. **StartPlanPollingAsync**
   - [ ] 每2秒轮询一次战斗状态
   - [ ] 更新显示（金币、经验、击杀数等）
   - [ ] 同时更新心跳时间

## 常见问题排查

### 问题1：登录后 BattleId 仍然为空

**可能原因**:
1. StartPlanAsync 抛出异常（检查服务器日志）
2. 依赖注入配置错误（检查 DependencyInjection.cs）
3. 有其他运行中的计划冲突

**排查步骤**:
1. 检查服务器日志是否有错误
2. 在 CheckAndSettleAsync 的 catch 块添加日志
3. 验证 _startPlan 委托不为 null
4. 检查是否有其他运行中的计划

### 问题2：战斗状态未正确恢复

**可能原因**:
1. BattleStateJson 为空或格式错误
2. RestoreBattleState 未正确调用
3. 战斗引擎恢复逻辑有问题

**排查步骤**:
1. 检查数据库中计划的 BattleStateJson 字段
2. 验证 JSON 格式正确
3. 在 RestoreBattleState 添加调试日志
4. 检查敌人血量是否正确恢复

### 问题3：前端未自动开始轮询

**可能原因**:
1. BattleId 为空（后端问题）
2. 计划状态不是 Running
3. 前端轮询已经在运行（planIsPolling = true）

**排查步骤**:
1. 打开浏览器开发者工具，检查 Network 标签
2. 查看是否有轮询请求（每2秒一次）
3. 检查 characterPlans 数据结构
4. 添加 console.log 输出调试信息

## 测试通过标准

✅ 所有场景测试通过
✅ BattleId 始终不为空（对于运行中的计划）
✅ 战斗状态正确恢复
✅ 前端自动轮询
✅ 无额外的手动操作
✅ 用户体验流畅，感觉不到战斗中断

## 回归测试

确保修复没有破坏现有功能：
- [ ] 创建新计划仍然正常工作
- [ ] 手动启动/停止/取消计划正常
- [ ] 在线战斗轮询正常
- [ ] 离线结算计算正确
- [ ] 计划自动衔接正常
