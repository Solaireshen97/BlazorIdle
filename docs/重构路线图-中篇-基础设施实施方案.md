# BlazorIdle é‡æ„è·¯çº¿å›¾ï¼ˆä¸­ç¯‡ï¼‰ï¼šåŸºç¡€è®¾æ–½å®æ–½æ–¹æ¡ˆ

**æ–‡æ¡£ç‰ˆæœ¬**: 1.0  
**ç”Ÿæˆæ—¥æœŸ**: 2025å¹´10æœˆ  
**çŠ¶æ€**: å®æ–½è§„åˆ’  
**ç›®æ ‡**: è¯¦ç»†è§„åˆ’åŸºç¡€è®¾æ–½å±‚çš„é‡æ„å®æ–½æ­¥éª¤

---

## ğŸ“‹ ç›®å½•

1. [å®æ–½æ€»è§ˆ](#å®æ–½æ€»è§ˆ)
2. [Phase 0: å‡†å¤‡é˜¶æ®µ](#phase-0-å‡†å¤‡é˜¶æ®µ)
3. [Phase 1: SignalRé‡æ„](#phase-1-signalré‡æ„)
4. [Phase 2: æŒä¹…åŒ–å±‚é‡æ„](#phase-2-æŒä¹…åŒ–å±‚é‡æ„)
5. [Phase 3: ç¼“å­˜ç³»ç»Ÿå®Œå–„](#phase-3-ç¼“å­˜ç³»ç»Ÿå®Œå–„)
6. [Phase 4: é…ç½®ç®¡ç†ç³»ç»Ÿ](#phase-4-é…ç½®ç®¡ç†ç³»ç»Ÿ)
7. [Phase 5: äº‹ä»¶æº¯æºä¸å¿«ç…§](#phase-5-äº‹ä»¶æº¯æºä¸å¿«ç…§)
8. [é˜¶æ®µé‡Œç¨‹ç¢‘](#é˜¶æ®µé‡Œç¨‹ç¢‘)

---

## å®æ–½æ€»è§ˆ

### é‡æ„ç­–ç•¥

#### æ ¸å¿ƒåŸåˆ™

```
âœ… å‘åå…¼å®¹ä¼˜å…ˆï¼šä¸ç ´åç°æœ‰åŠŸèƒ½
âœ… æ¸è¿›å¼è¿ç§»ï¼šé€æ­¥æ›¿æ¢æ—§å®ç°
âœ… å¹¶è¡Œè¿è¡Œï¼šæ–°æ—§ç³»ç»Ÿå…±å­˜è¿‡æ¸¡æœŸ
âœ… å……åˆ†æµ‹è¯•ï¼šæ¯ä¸ªé˜¶æ®µéƒ½æœ‰éªŒè¯
```

---

### æ—¶é—´è§„åˆ’

```
Phase 0: å‡†å¤‡é˜¶æ®µ          [1å‘¨]   â–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘
Phase 1: SignalRé‡æ„       [2å‘¨]   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘
Phase 2: æŒä¹…åŒ–å±‚é‡æ„      [2-3å‘¨] â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘
Phase 3: ç¼“å­˜ç³»ç»Ÿå®Œå–„      [1-2å‘¨] â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
Phase 4: é…ç½®ç®¡ç†ç³»ç»Ÿ      [1-2å‘¨] â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘
Phase 5: äº‹ä»¶æº¯æºä¸å¿«ç…§    [2å‘¨]   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ

æ€»è®¡ï¼š9-11å‘¨ï¼ˆçº¦2.5ä¸ªæœˆï¼‰
```

---

### ä¾èµ–å…³ç³»å›¾

```
Phase 0 (å‡†å¤‡)
    â”‚
    â”œâ”€â”€â†’ Phase 1 (SignalR)
    â”‚        â”‚
    â”‚        â””â”€â”€â†’ Phase 5 (äº‹ä»¶æº¯æº) [å¯å¹¶è¡Œ]
    â”‚
    â”œâ”€â”€â†’ Phase 2 (æŒä¹…åŒ–)
    â”‚        â”‚
    â”‚        â””â”€â”€â†’ Phase 3 (ç¼“å­˜)
    â”‚                 â”‚
    â”‚                 â””â”€â”€â†’ Phase 4 (é…ç½®)
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**å…³é”®è·¯å¾„**: Phase 0 â†’ Phase 2 â†’ Phase 3 â†’ Phase 4  
**å¹¶è¡Œæœºä¼š**: Phase 1 ä¸ Phase 2 å¯éƒ¨åˆ†å¹¶è¡Œ

---

## Phase 0: å‡†å¤‡é˜¶æ®µ

**ç›®æ ‡**: å»ºç«‹é‡æ„åŸºç¡€ï¼Œæœ€å°åŒ–åç»­é£é™©  
**æ—¶é—´**: 1å‘¨  
**ä¼˜å…ˆçº§**: ğŸ”´ æœ€é«˜

---

### æ­¥éª¤0.1: ä»£ç å®¡è®¡ä¸æ ‡è®°

**å·¥ä½œå†…å®¹**:
```
ğŸ“ æ ‡è®°æ‰€æœ‰ç›´æ¥ä½¿ç”¨DbContextçš„åœ°æ–¹
ğŸ“ æ ‡è®°æ‰€æœ‰SignalRæ¨é€é€»è¾‘
ğŸ“ æ ‡è®°æ‰€æœ‰ç¼“å­˜ä½¿ç”¨ç‚¹
ğŸ“ è¯†åˆ«å¾ªç¯ä¾èµ–å’Œè€¦åˆçƒ­ç‚¹
```

**è¾“å‡º**:
```
âœ… é‡æ„æ¸…å•ï¼ˆRefactoring Checklistï¼‰
âœ… ä¾èµ–å…³ç³»å›¾ï¼ˆDependency Graphï¼‰
âœ… é£é™©è¯„ä¼°æŠ¥å‘Šï¼ˆRisk Assessmentï¼‰
```

---

### æ­¥éª¤0.2: åˆ›å»ºæ–°ç›®å½•ç»“æ„

**ç›®æ ‡æ–‡ä»¶ç»“æ„**:
```
BlazorIdle.Server/
â”œâ”€â”€ Infrastructure/
â”‚   â”œâ”€â”€ Messaging/              # æ–°å¢ï¼šæ¶ˆæ¯æ€»çº¿
â”‚   â”‚   â”œâ”€â”€ IEventBus.cs
â”‚   â”‚   â”œâ”€â”€ InMemoryEventBus.cs
â”‚   â”‚   â”œâ”€â”€ IDomainEvent.cs
â”‚   â”‚   â””â”€â”€ SignalRDispatcher.cs
â”‚   â”‚
â”‚   â”œâ”€â”€ Persistence/            # é‡æ„ï¼šæŒä¹…åŒ–å±‚
â”‚   â”‚   â”œâ”€â”€ Abstractions/
â”‚   â”‚   â”‚   â”œâ”€â”€ IRepository.cs
â”‚   â”‚   â”‚   â”œâ”€â”€ IUnitOfWork.cs
â”‚   â”‚   â”‚   â””â”€â”€ IReadOnlyRepository.cs
â”‚   â”‚   â”œâ”€â”€ Repositories/
â”‚   â”‚   â”‚   â”œâ”€â”€ CharacterRepository.cs
â”‚   â”‚   â”‚   â”œâ”€â”€ BattleRecordRepository.cs
â”‚   â”‚   â”‚   â””â”€â”€ ...
â”‚   â”‚   â”œâ”€â”€ GameDbContext.cs    # ä¿ç•™ï¼Œå¢å¼º
â”‚   â”‚   â””â”€â”€ UnitOfWork.cs
â”‚   â”‚
â”‚   â”œâ”€â”€ Caching/                # é‡æ„ï¼šç¼“å­˜å±‚
â”‚   â”‚   â”œâ”€â”€ IMultiTierCache.cs
â”‚   â”‚   â”œâ”€â”€ MultiTierCacheManager.cs (å·²æœ‰ï¼Œä¼˜åŒ–)
â”‚   â”‚   â”œâ”€â”€ CacheInvalidationCoordinator.cs (å·²æœ‰)
â”‚   â”‚   â””â”€â”€ CacheStrategies/
â”‚   â”‚       â”œâ”€â”€ CharacterCacheStrategy.cs
â”‚   â”‚       â””â”€â”€ ConfigCacheStrategy.cs
â”‚   â”‚
â”‚   â”œâ”€â”€ Configuration/          # æ–°å¢ï¼šé…ç½®å±‚
â”‚   â”‚   â”œâ”€â”€ IConfigProvider.cs
â”‚   â”‚   â”œâ”€â”€ JsonConfigProvider.cs
â”‚   â”‚   â”œâ”€â”€ ConfigVersionManager.cs
â”‚   â”‚   â””â”€â”€ Validators/
â”‚   â”‚       â”œâ”€â”€ SkillConfigValidator.cs
â”‚   â”‚       â””â”€â”€ EquipmentConfigValidator.cs
â”‚   â”‚
â”‚   â””â”€â”€ EventSourcing/          # æ–°å¢ï¼šäº‹ä»¶æº¯æº
â”‚       â”œâ”€â”€ IEventStore.cs
â”‚       â”œâ”€â”€ EventStore.cs
â”‚       â”œâ”€â”€ ISnapshotStore.cs
â”‚       â””â”€â”€ SnapshotStore.cs
â”‚
â”œâ”€â”€ Application/                # åº”ç”¨å±‚ï¼ˆä¿æŒï¼‰
â”‚   â”œâ”€â”€ Services/
â”‚   â””â”€â”€ Commands/
â”‚
â””â”€â”€ Domain/                     # é¢†åŸŸå±‚ï¼ˆä¿æŒï¼‰
    â””â”€â”€ Combat/
```

---

### æ­¥éª¤0.3: å¼•å…¥ä¾èµ–åŒ…

**å®‰è£…å‘½ä»¤**:
```bash
# æ¶ˆæ¯æ€»çº¿ï¼ˆMediatRä½œä¸ºåŸºç¡€ï¼‰
dotnet add package MediatR --version 12.2.0

# é…ç½®éªŒè¯
dotnet add package FluentValidation --version 11.9.0

# æœªæ¥å¯é€‰ï¼šåˆ†å¸ƒå¼ç¼“å­˜
# dotnet add package StackExchange.Redis --version 2.7.10
```

---

### æ­¥éª¤0.4: å»ºç«‹æµ‹è¯•åŸºç¡€è®¾æ–½

**åˆ›å»ºæµ‹è¯•é¡¹ç›®ç»“æ„**:
```
BlazorIdle.Tests/
â”œâ”€â”€ Infrastructure/
â”‚   â”œâ”€â”€ Messaging/
â”‚   â”‚   â””â”€â”€ EventBusTests.cs
â”‚   â”œâ”€â”€ Persistence/
â”‚   â”‚   â”œâ”€â”€ RepositoryTests.cs
â”‚   â”‚   â””â”€â”€ UnitOfWorkTests.cs
â”‚   â”œâ”€â”€ Caching/
â”‚   â”‚   â””â”€â”€ MultiTierCacheTests.cs
â”‚   â””â”€â”€ Configuration/
â”‚       â””â”€â”€ ConfigProviderTests.cs
â”‚
â””â”€â”€ Fixtures/
    â”œâ”€â”€ InMemoryDbContextFixture.cs
    â””â”€â”€ TestDataBuilder.cs
```

---

### æ­¥éª¤0.5: åˆ›å»ºæ¥å£å®šä¹‰

**æ ¸å¿ƒæ¥å£å…ˆè¡Œ**:

```csharp
// Infrastructure/Messaging/IDomainEvent.cs
public interface IDomainEvent
{
    Guid EventId { get; }
    DateTime OccurredAt { get; }
    string EventType { get; }
}

// Infrastructure/Messaging/IEventBus.cs
public interface IEventBus
{
    Task PublishAsync<TEvent>(TEvent @event) 
        where TEvent : IDomainEvent;
    
    void Subscribe<TEvent>(Func<TEvent, Task> handler) 
        where TEvent : IDomainEvent;
}

// Infrastructure/Persistence/Abstractions/IRepository.cs
public interface IRepository<T> where T : class
{
    Task<T?> GetByIdAsync(Guid id, CancellationToken ct = default);
    Task<IEnumerable<T>> GetAllAsync(CancellationToken ct = default);
    Task AddAsync(T entity, CancellationToken ct = default);
    Task UpdateAsync(T entity, CancellationToken ct = default);
    Task DeleteAsync(Guid id, CancellationToken ct = default);
}

// Infrastructure/Persistence/Abstractions/IUnitOfWork.cs
public interface IUnitOfWork : IDisposable
{
    IRepository<T> Repository<T>() where T : class;
    Task<int> SaveChangesAsync(CancellationToken ct = default);
    Task BeginTransactionAsync(CancellationToken ct = default);
    Task CommitAsync(CancellationToken ct = default);
    Task RollbackAsync(CancellationToken ct = default);
}

// Infrastructure/Caching/IMultiTierCache.cs
public interface IMultiTierCache
{
    Task<T?> GetAsync<T>(string key, CancellationToken ct = default);
    Task SetAsync<T>(string key, T value, TimeSpan? expiration = null, 
        CancellationToken ct = default);
    Task RemoveAsync(string key, CancellationToken ct = default);
    Task InvalidateByTagAsync(string tag, CancellationToken ct = default);
    CacheStatistics GetStatistics();
}

// Infrastructure/Configuration/IConfigProvider.cs
public interface IConfigProvider
{
    T Get<T>(string key) where T : class;
    IEnumerable<T> GetAll<T>() where T : class;
    Task ReloadAsync(CancellationToken ct = default);
    string CurrentVersion { get; }
}
```

---

## Phase 1: SignalRé‡æ„

**ç›®æ ‡**: ç»Ÿä¸€SignalRæ¨é€æœºåˆ¶ï¼Œè§£è€¦ä¸šåŠ¡é€»è¾‘  
**æ—¶é—´**: 2å‘¨  
**ä¼˜å…ˆçº§**: ğŸ”´ é«˜

---

### æ­¥éª¤1.1: åˆ›å»ºSignalRæ¶ˆæ¯åˆ†å‘å™¨

**å®ç°è¦ç‚¹**:

```csharp
// Infrastructure/Messaging/SignalRDispatcher.cs
public class SignalRDispatcher : ISignalRDispatcher
{
    private readonly IHubContext<BattleNotificationHub> _hubContext;
    private readonly ILogger<SignalRDispatcher> _logger;
    private readonly ConcurrentQueue<SignalRMessage> _messageQueue;

    public SignalRDispatcher(
        IHubContext<BattleNotificationHub> hubContext,
        ILogger<SignalRDispatcher> logger)
    {
        _hubContext = hubContext;
        _logger = logger;
        _messageQueue = new ConcurrentQueue<SignalRMessage>();
        
        // å¯åŠ¨åå°å‘é€ä»»åŠ¡
        Task.Run(ProcessQueueAsync);
    }

    public async Task SendToUserAsync(
        Guid userId, 
        string method, 
        object data)
    {
        var message = new SignalRMessage
        {
            TargetType = TargetType.User,
            TargetId = userId.ToString(),
            Method = method,
            Data = data
        };
        
        _messageQueue.Enqueue(message);
    }

    public async Task SendToGroupAsync(
        string groupName, 
        string method, 
        object data)
    {
        var message = new SignalRMessage
        {
            TargetType = TargetType.Group,
            TargetId = groupName,
            Method = method,
            Data = data
        };
        
        _messageQueue.Enqueue(message);
    }

    private async Task ProcessQueueAsync()
    {
        while (true)
        {
            try
            {
                if (_messageQueue.TryDequeue(out var message))
                {
                    await SendMessageAsync(message);
                }
                else
                {
                    await Task.Delay(100); // é¿å…ç©ºè½¬
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "å‘é€SignalRæ¶ˆæ¯å¤±è´¥");
            }
        }
    }

    private async Task SendMessageAsync(SignalRMessage message)
    {
        try
        {
            switch (message.TargetType)
            {
                case TargetType.User:
                    await _hubContext.Clients
                        .User(message.TargetId)
                        .SendAsync(message.Method, message.Data);
                    break;
                    
                case TargetType.Group:
                    await _hubContext.Clients
                        .Group(message.TargetId)
                        .SendAsync(message.Method, message.Data);
                    break;
                    
                case TargetType.All:
                    await _hubContext.Clients
                        .All
                        .SendAsync(message.Method, message.Data);
                    break;
            }
            
            _logger.LogDebug(
                "SignalRæ¶ˆæ¯å·²å‘é€: {Method} -> {TargetType}:{TargetId}", 
                message.Method, message.TargetType, message.TargetId);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, 
                "å‘é€SignalRæ¶ˆæ¯å¤±è´¥: {Method} -> {TargetType}:{TargetId}", 
                message.Method, message.TargetType, message.TargetId);
        }
    }
}
```

---

### æ­¥éª¤1.2: é›†æˆåˆ°äº‹ä»¶æ€»çº¿

**å®ç°EventBusè®¢é˜…SignalRæ¨é€**:

```csharp
// Infrastructure/Messaging/InMemoryEventBus.cs
public class InMemoryEventBus : IEventBus
{
    private readonly Dictionary<Type, List<Delegate>> _subscribers = new();
    private readonly ISignalRDispatcher _signalRDispatcher;
    private readonly ILogger<InMemoryEventBus> _logger;

    public InMemoryEventBus(
        ISignalRDispatcher signalRDispatcher,
        ILogger<InMemoryEventBus> logger)
    {
        _signalRDispatcher = signalRDispatcher;
        _logger = logger;
    }

    public async Task PublishAsync<TEvent>(TEvent @event) 
        where TEvent : IDomainEvent
    {
        var eventType = typeof(TEvent);
        
        if (_subscribers.TryGetValue(eventType, out var handlers))
        {
            foreach (var handler in handlers)
            {
                try
                {
                    await ((Func<TEvent, Task>)handler)(@event);
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, 
                        "äº‹ä»¶å¤„ç†å¤±è´¥: {EventType}", eventType.Name);
                }
            }
        }
    }

    public void Subscribe<TEvent>(Func<TEvent, Task> handler) 
        where TEvent : IDomainEvent
    {
        var eventType = typeof(TEvent);
        
        if (!_subscribers.ContainsKey(eventType))
        {
            _subscribers[eventType] = new List<Delegate>();
        }
        
        _subscribers[eventType].Add(handler);
    }
}
```

---

### æ­¥éª¤1.3: å®šä¹‰æ ¸å¿ƒé¢†åŸŸäº‹ä»¶

**æˆ˜æ–—ç›¸å…³äº‹ä»¶**:

```csharp
// Domain/Combat/Events/BattleStartedEvent.cs
public record BattleStartedEvent(
    Guid BattleId,
    Guid CharacterId,
    string EnemyId,
    DateTime StartTime
) : IDomainEvent
{
    public Guid EventId { get; } = Guid.NewGuid();
    public DateTime OccurredAt { get; } = DateTime.UtcNow;
    public string EventType => nameof(BattleStartedEvent);
}

// Domain/Combat/Events/BattleSegmentCompletedEvent.cs
public record BattleSegmentCompletedEvent(
    Guid BattleId,
    Guid CharacterId,
    CombatSegment Segment
) : IDomainEvent
{
    public Guid EventId { get; } = Guid.NewGuid();
    public DateTime OccurredAt { get; } = DateTime.UtcNow;
    public string EventType => nameof(BattleSegmentCompletedEvent);
}

// Domain/Combat/Events/BattleCompletedEvent.cs
public record BattleCompletedEvent(
    Guid BattleId,
    Guid CharacterId,
    BattleOutcome Outcome,
    BattleStatistics Statistics
) : IDomainEvent
{
    public Guid EventId { get; } = Guid.NewGuid();
    public DateTime OccurredAt { get; } = DateTime.UtcNow;
    public string EventType => nameof(BattleCompletedEvent);
}
```

---

### æ­¥éª¤1.4: è®¢é˜…äº‹ä»¶å¹¶æ¨é€

**åœ¨Startup/Program.csä¸­æ³¨å†Œè®¢é˜…**:

```csharp
// æ³¨å†ŒSignalRæ¨é€è®¢é˜…
services.AddSingleton<IEventBus>(sp =>
{
    var eventBus = new InMemoryEventBus(
        sp.GetRequiredService<ISignalRDispatcher>(),
        sp.GetRequiredService<ILogger<InMemoryEventBus>>());

    // è®¢é˜…æˆ˜æ–—äº‹ä»¶ â†’ SignalRæ¨é€
    eventBus.Subscribe<BattleStartedEvent>(async @event =>
    {
        var dispatcher = sp.GetRequiredService<ISignalRDispatcher>();
        await dispatcher.SendToUserAsync(
            @event.CharacterId,
            "BattleStarted",
            new { @event.BattleId, @event.EnemyId, @event.StartTime });
    });

    eventBus.Subscribe<BattleSegmentCompletedEvent>(async @event =>
    {
        var dispatcher = sp.GetRequiredService<ISignalRDispatcher>();
        await dispatcher.SendToUserAsync(
            @event.CharacterId,
            "BattleSegment",
            @event.Segment);
    });

    eventBus.Subscribe<BattleCompletedEvent>(async @event =>
    {
        var dispatcher = sp.GetRequiredService<ISignalRDispatcher>();
        await dispatcher.SendToUserAsync(
            @event.CharacterId,
            "BattleCompleted",
            new { @event.BattleId, @event.Outcome, @event.Statistics });
    });

    return eventBus;
});
```

---

### æ­¥éª¤1.5: è¿ç§»ç°æœ‰æ¨é€é€»è¾‘

**é‡æ„æ–¹å¼**:

```csharp
// æ—§ä»£ç ï¼ˆç›´æ¥ä½¿ç”¨HubContextï¼‰
await _hubContext.Clients
    .User(characterId.ToString())
    .SendAsync("BattleUpdate", data);

// â†“â†“â†“ é‡æ„ä¸º â†“â†“â†“

// æ–°ä»£ç ï¼ˆå‘å¸ƒé¢†åŸŸäº‹ä»¶ï¼‰
await _eventBus.PublishAsync(new BattleSegmentCompletedEvent(
    battleId, characterId, segment));
```

**ä¼˜ç‚¹**:
```
âœ… ä¸šåŠ¡é€»è¾‘ä¸SignalRè§£è€¦
âœ… ç»Ÿä¸€æ¨é€å…¥å£ï¼Œä¾¿äºç›‘æ§
âœ… æ”¯æŒå¤šè®¢é˜…è€…ï¼ˆå¦‚æ—¥å¿—ã€ç»Ÿè®¡ï¼‰
âœ… æ˜“äºæµ‹è¯•ï¼ˆMock IEventBusï¼‰
```

---

## Phase 2: æŒä¹…åŒ–å±‚é‡æ„

**ç›®æ ‡**: ç»Ÿä¸€æ•°æ®è®¿é—®ï¼Œå®ç°Repositoryæ¨¡å¼  
**æ—¶é—´**: 2-3å‘¨  
**ä¼˜å…ˆçº§**: ğŸ”´ æœ€é«˜

---

### æ­¥éª¤2.1: å®ç°é€šç”¨Repository

**å®ç°è¦ç‚¹**:

```csharp
// Infrastructure/Persistence/Repositories/GenericRepository.cs
public class GenericRepository<T> : IRepository<T> where T : class
{
    protected readonly GameDbContext _context;
    protected readonly DbSet<T> _dbSet;

    public GenericRepository(GameDbContext context)
    {
        _context = context;
        _dbSet = context.Set<T>();
    }

    public virtual async Task<T?> GetByIdAsync(
        Guid id, 
        CancellationToken ct = default)
    {
        return await _dbSet.FindAsync(new object[] { id }, ct);
    }

    public virtual async Task<IEnumerable<T>> GetAllAsync(
        CancellationToken ct = default)
    {
        return await _dbSet.ToListAsync(ct);
    }

    public virtual async Task AddAsync(
        T entity, 
        CancellationToken ct = default)
    {
        await _dbSet.AddAsync(entity, ct);
    }

    public virtual async Task UpdateAsync(
        T entity, 
        CancellationToken ct = default)
    {
        _dbSet.Update(entity);
        await Task.CompletedTask;
    }

    public virtual async Task DeleteAsync(
        Guid id, 
        CancellationToken ct = default)
    {
        var entity = await GetByIdAsync(id, ct);
        if (entity != null)
        {
            _dbSet.Remove(entity);
        }
    }

    // æŸ¥è¯¢æ–¹æ³•
    public virtual async Task<IEnumerable<T>> FindAsync(
        Expression<Func<T, bool>> predicate,
        CancellationToken ct = default)
    {
        return await _dbSet.Where(predicate).ToListAsync(ct);
    }

    // æ‰¹é‡æ“ä½œ
    public virtual async Task AddRangeAsync(
        IEnumerable<T> entities,
        CancellationToken ct = default)
    {
        await _dbSet.AddRangeAsync(entities, ct);
    }

    public virtual async Task UpdateRangeAsync(
        IEnumerable<T> entities,
        CancellationToken ct = default)
    {
        _dbSet.UpdateRange(entities);
        await Task.CompletedTask;
    }
}
```

---

### æ­¥éª¤2.2: å®ç°UnitOfWork

```csharp
// Infrastructure/Persistence/UnitOfWork.cs
public class UnitOfWork : IUnitOfWork
{
    private readonly GameDbContext _context;
    private readonly Dictionary<Type, object> _repositories;
    private IDbContextTransaction? _transaction;

    public UnitOfWork(GameDbContext context)
    {
        _context = context;
        _repositories = new Dictionary<Type, object>();
    }

    public IRepository<T> Repository<T>() where T : class
    {
        var type = typeof(T);
        
        if (!_repositories.ContainsKey(type))
        {
            var repositoryType = typeof(GenericRepository<>)
                .MakeGenericType(type);
            var repositoryInstance = Activator
                .CreateInstance(repositoryType, _context);
            _repositories.Add(type, repositoryInstance!);
        }
        
        return (IRepository<T>)_repositories[type];
    }

    public async Task<int> SaveChangesAsync(
        CancellationToken ct = default)
    {
        return await _context.SaveChangesAsync(ct);
    }

    public async Task BeginTransactionAsync(
        CancellationToken ct = default)
    {
        _transaction = await _context.Database
            .BeginTransactionAsync(ct);
    }

    public async Task CommitAsync(CancellationToken ct = default)
    {
        try
        {
            await _context.SaveChangesAsync(ct);
            await _transaction?.CommitAsync(ct)!;
        }
        catch
        {
            await RollbackAsync(ct);
            throw;
        }
        finally
        {
            _transaction?.Dispose();
            _transaction = null;
        }
    }

    public async Task RollbackAsync(CancellationToken ct = default)
    {
        await _transaction?.RollbackAsync(ct)!;
        _transaction?.Dispose();
        _transaction = null;
    }

    public void Dispose()
    {
        _transaction?.Dispose();
        _context?.Dispose();
    }
}
```

---

### æ­¥éª¤2.3: åˆ›å»ºç‰¹å®šå®ä½“Repository

**ç¤ºä¾‹ï¼šCharacterRepository**:

```csharp
// Infrastructure/Persistence/Repositories/CharacterRepository.cs
public interface ICharacterRepository : IRepository<Character>
{
    Task<Character?> GetByUserIdAsync(Guid userId, CancellationToken ct = default);
    Task<IEnumerable<Character>> GetByUserWithStatsAsync(Guid userId, CancellationToken ct = default);
}

public class CharacterRepository : GenericRepository<Character>, ICharacterRepository
{
    public CharacterRepository(GameDbContext context) : base(context) { }

    public async Task<Character?> GetByUserIdAsync(
        Guid userId, 
        CancellationToken ct = default)
    {
        return await _dbSet
            .FirstOrDefaultAsync(c => c.UserId == userId, ct);
    }

    public async Task<IEnumerable<Character>> GetByUserWithStatsAsync(
        Guid userId, 
        CancellationToken ct = default)
    {
        return await _dbSet
            .Include(c => c.Stats)       // é¢„åŠ è½½ç»Ÿè®¡æ•°æ®
            .Include(c => c.Equipment)   // é¢„åŠ è½½è£…å¤‡
            .Where(c => c.UserId == userId)
            .ToListAsync(ct);
    }
}
```

---

### æ­¥éª¤2.4: æ³¨å†Œåˆ°DIå®¹å™¨

```csharp
// Program.cs æˆ– DependencyInjection.cs
services.AddScoped<IUnitOfWork, UnitOfWork>();
services.AddScoped(typeof(IRepository<>), typeof(GenericRepository<>));

// ç‰¹å®šRepository
services.AddScoped<ICharacterRepository, CharacterRepository>();
services.AddScoped<IBattleRecordRepository, BattleRecordRepository>();
```

---

### æ­¥éª¤2.5: è¿ç§»ç°æœ‰ä»£ç 

**é‡æ„ç¤ºä¾‹**:

```csharp
// æ—§ä»£ç ï¼ˆç›´æ¥ä½¿ç”¨DbContextï¼‰
public class BattleService
{
    private readonly GameDbContext _context;
    
    public async Task<BattleRecord> GetBattleAsync(Guid id)
    {
        return await _context.BattleRecords
            .Include(b => b.Segments)
            .FirstOrDefaultAsync(b => b.Id == id);
    }
}

// â†“â†“â†“ é‡æ„ä¸º â†“â†“â†“

// æ–°ä»£ç ï¼ˆä½¿ç”¨Repositoryï¼‰
public class BattleService
{
    private readonly IUnitOfWork _unitOfWork;
    
    public async Task<BattleRecord> GetBattleAsync(Guid id)
    {
        var repository = _unitOfWork.Repository<BattleRecord>();
        return await repository.GetByIdAsync(id);
    }
}
```

---

## Phase 3: ç¼“å­˜ç³»ç»Ÿå®Œå–„

**ç›®æ ‡**: ç»Ÿä¸€ç¼“å­˜æ¥å£ï¼Œä¼˜åŒ–ç¼“å­˜ç­–ç•¥  
**æ—¶é—´**: 1-2å‘¨  
**ä¼˜å…ˆçº§**: ğŸŸ¡ ä¸­

---

### æ­¥éª¤3.1: å®Œå–„IMultiTierCacheå®ç°

**å½“å‰çŠ¶æ€**: å·²æœ‰`MultiTierCacheManager`ï¼Œéœ€è¦å®Œå–„æ¥å£

```csharp
// Infrastructure/Caching/IMultiTierCache.cs (å¢å¼º)
public interface IMultiTierCache
{
    // åŸºç¡€æ“ä½œ
    Task<T?> GetAsync<T>(string key, CancellationToken ct = default);
    Task SetAsync<T>(string key, T value, TimeSpan? expiration = null, 
        CancellationToken ct = default);
    Task RemoveAsync(string key, CancellationToken ct = default);
    
    // æ‰¹é‡æ“ä½œ
    Task<IDictionary<string, T>> GetManyAsync<T>(
        IEnumerable<string> keys, CancellationToken ct = default);
    Task SetManyAsync<T>(
        IDictionary<string, T> items, TimeSpan? expiration = null, 
        CancellationToken ct = default);
    
    // æ ‡ç­¾å¤±æ•ˆ
    Task InvalidateByTagAsync(string tag, CancellationToken ct = default);
    Task InvalidateByPatternAsync(string pattern, CancellationToken ct = default);
    
    // ç»Ÿè®¡
    CacheStatistics GetStatistics();
}
```

---

### æ­¥éª¤3.2: åˆ›å»ºç¼“å­˜ç­–ç•¥

**Characterç¼“å­˜ç­–ç•¥**:

```csharp
// Infrastructure/Caching/Strategies/CharacterCacheStrategy.cs
public class CharacterCacheStrategy
{
    private readonly IMultiTierCache _cache;
    private const string KEY_PREFIX = "character:";
    private const string TAG = "character";
    private static readonly TimeSpan EXPIRATION = TimeSpan.FromMinutes(30);

    public CharacterCacheStrategy(IMultiTierCache cache)
    {
        _cache = cache;
    }

    public async Task<Character?> GetAsync(Guid characterId)
    {
        var key = $"{KEY_PREFIX}{characterId}";
        return await _cache.GetAsync<Character>(key);
    }

    public async Task SetAsync(Character character)
    {
        var key = $"{KEY_PREFIX}{character.Id}";
        await _cache.SetAsync(key, character, EXPIRATION);
    }

    public async Task InvalidateAsync(Guid characterId)
    {
        var key = $"{KEY_PREFIX}{characterId}";
        await _cache.RemoveAsync(key);
    }

    public async Task InvalidateAllAsync()
    {
        await _cache.InvalidateByTagAsync(TAG);
    }
}
```

---

### æ­¥éª¤3.3: é›†æˆç¼“å­˜åˆ°Repository

**CacheAwareRepositoryæ¨¡å¼**:

```csharp
// Infrastructure/Persistence/CacheAwareRepository.cs
public class CacheAwareCharacterRepository : ICharacterRepository
{
    private readonly ICharacterRepository _innerRepository;
    private readonly CharacterCacheStrategy _cacheStrategy;

    public CacheAwareCharacterRepository(
        ICharacterRepository innerRepository,
        CharacterCacheStrategy cacheStrategy)
    {
        _innerRepository = innerRepository;
        _cacheStrategy = cacheStrategy;
    }

    public async Task<Character?> GetByIdAsync(
        Guid id, 
        CancellationToken ct = default)
    {
        // å…ˆæŸ¥ç¼“å­˜
        var cached = await _cacheStrategy.GetAsync(id);
        if (cached != null)
        {
            return cached;
        }

        // ç¼“å­˜æœªå‘½ä¸­ï¼ŒæŸ¥æ•°æ®åº“
        var character = await _innerRepository.GetByIdAsync(id, ct);
        
        // å†™å…¥ç¼“å­˜
        if (character != null)
        {
            await _cacheStrategy.SetAsync(character);
        }

        return character;
    }

    public async Task UpdateAsync(
        Character entity, 
        CancellationToken ct = default)
    {
        await _innerRepository.UpdateAsync(entity, ct);
        
        // æ›´æ–°åå¤±æ•ˆç¼“å­˜
        await _cacheStrategy.InvalidateAsync(entity.Id);
    }

    // å…¶ä»–æ–¹æ³•å§”æ‰˜ç»™innerRepository...
}
```

---

### æ­¥éª¤3.4: é…ç½®ç¼“å­˜å±‚æ¬¡

```csharp
// appsettings.json
{
  "Caching": {
    "L1": {
      "Enabled": true,
      "SizeLimit": 1024,  // MB
      "CompactionPercentage": 0.2
    },
    "L2": {
      "Enabled": false,    // æœªæ¥å¯ç”¨Redis
      "ConnectionString": "localhost:6379",
      "Database": 0
    },
    "DefaultExpiration": "00:30:00",  // 30åˆ†é’Ÿ
    "Strategies": {
      "Character": {
        "Expiration": "00:30:00",
        "Priority": "High"
      },
      "Config": {
        "Expiration": "01:00:00",
        "Priority": "NeverRemove"
      }
    }
  }
}
```

---

## Phase 4: é…ç½®ç®¡ç†ç³»ç»Ÿ

**ç›®æ ‡**: å»ºç«‹æ•°æ®é©±åŠ¨çš„é…ç½®ç®¡ç†  
**æ—¶é—´**: 1-2å‘¨  
**ä¼˜å…ˆçº§**: ğŸŸ¡ ä¸­

---

### æ­¥éª¤4.1: å®ç°JsonConfigProvider

```csharp
// Infrastructure/Configuration/JsonConfigProvider.cs
public class JsonConfigProvider : IConfigProvider
{
    private readonly ILogger<JsonConfigProvider> _logger;
    private readonly string _configDirectory;
    private readonly Dictionary<string, object> _configCache;
    private string _currentVersion;

    public JsonConfigProvider(
        IConfiguration configuration,
        ILogger<JsonConfigProvider> logger)
    {
        _logger = logger;
        _configDirectory = configuration["ConfigDirectory"] 
            ?? "GameData/Config";
        _configCache = new Dictionary<string, object>();
        _currentVersion = "1.0.0";
        
        LoadAllConfigs();
    }

    public string CurrentVersion => _currentVersion;

    public T Get<T>(string key) where T : class
    {
        if (_configCache.TryGetValue(key, out var cached))
        {
            return (T)cached;
        }

        throw new KeyNotFoundException($"é…ç½®é”®ä¸å­˜åœ¨: {key}");
    }

    public IEnumerable<T> GetAll<T>() where T : class
    {
        var typeName = typeof(T).Name;
        var fileName = $"{typeName}s.json"; // çº¦å®šï¼šå¤æ•°å½¢å¼
        var filePath = Path.Combine(_configDirectory, fileName);

        if (!File.Exists(filePath))
        {
            return Enumerable.Empty<T>();
        }

        var json = File.ReadAllText(filePath);
        var items = JsonSerializer.Deserialize<List<T>>(json);
        
        return items ?? Enumerable.Empty<T>();
    }

    public async Task ReloadAsync(CancellationToken ct = default)
    {
        _configCache.Clear();
        LoadAllConfigs();
        
        OnConfigChanged?.Invoke(this, 
            new ConfigChangedEventArgs { Version = _currentVersion });
    }

    public event EventHandler<ConfigChangedEventArgs>? OnConfigChanged;

    private void LoadAllConfigs()
    {
        _logger.LogInformation("åŠ è½½é…ç½®æ–‡ä»¶ä»: {Directory}", _configDirectory);

        // åŠ è½½æŠ€èƒ½é…ç½®
        LoadConfigFile<SkillDefinition>("Skills");
        
        // åŠ è½½è£…å¤‡é…ç½®
        LoadConfigFile<GearDefinition>("Gears");
        
        // åŠ è½½æ•Œäººé…ç½®
        LoadConfigFile<EnemyDefinition>("Enemies");
        
        _logger.LogInformation("é…ç½®åŠ è½½å®Œæˆï¼Œç‰ˆæœ¬: {Version}", _currentVersion);
    }

    private void LoadConfigFile<T>(string configName) where T : class
    {
        var fileName = $"{configName}.json";
        var filePath = Path.Combine(_configDirectory, fileName);

        if (File.Exists(filePath))
        {
            var json = File.ReadAllText(filePath);
            var items = JsonSerializer.Deserialize<List<T>>(json);
            _configCache[configName] = items ?? new List<T>();
            
            _logger.LogDebug("é…ç½®åŠ è½½: {ConfigName}, é¡¹æ•°: {Count}", 
                configName, (items?.Count ?? 0));
        }
    }
}
```

---

### æ­¥éª¤4.2: åˆ›å»ºé…ç½®æ–‡ä»¶ç»“æ„

```
GameData/
â””â”€â”€ Config/
    â”œâ”€â”€ version.json           # ç‰ˆæœ¬ä¿¡æ¯
    â”œâ”€â”€ Skills.json            # æŠ€èƒ½é…ç½®
    â”œâ”€â”€ Gears.json             # è£…å¤‡é…ç½®
    â”œâ”€â”€ Enemies.json           # æ•Œäººé…ç½®
    â”œâ”€â”€ Professions.json       # èŒä¸šé…ç½®
    â””â”€â”€ Maps.json              # åœ°å›¾é…ç½®ï¼ˆæœªæ¥ï¼‰
```

**ç¤ºä¾‹é…ç½®æ–‡ä»¶** (Skills.json):

```json
{
  "version": "1.0.0",
  "skills": [
    {
      "id": "warrior_slash",
      "name": "æ–©å‡»",
      "description": "åŸºç¡€æ”»å‡»æŠ€èƒ½",
      "profession": "Warrior",
      "baseDamage": 50,
      "damageType": "Physical",
      "cooldown": 3.0,
      "castTime": 0.0,
      "costs": [
        {
          "resource": "rage",
          "amount": 20
        }
      ],
      "effects": [
        {
          "type": "Damage",
          "value": 50,
          "coefficient": 1.2
        }
      ]
    }
  ]
}
```

---

### æ­¥éª¤4.3: é…ç½®éªŒè¯å™¨

```csharp
// Infrastructure/Configuration/Validators/SkillConfigValidator.cs
public class SkillConfigValidator : AbstractValidator<SkillDefinition>
{
    public SkillConfigValidator()
    {
        RuleFor(x => x.Id)
            .NotEmpty()
            .WithMessage("æŠ€èƒ½IDä¸èƒ½ä¸ºç©º");

        RuleFor(x => x.BaseDamage)
            .GreaterThanOrEqualTo(0)
            .WithMessage("åŸºç¡€ä¼¤å®³ä¸èƒ½ä¸ºè´Ÿæ•°");

        RuleFor(x => x.Cooldown)
            .GreaterThan(0)
            .WithMessage("å†·å´æ—¶é—´å¿…é¡»å¤§äº0");

        RuleFor(x => x.Costs)
            .NotNull()
            .WithMessage("æ¶ˆè€—é…ç½®ä¸èƒ½ä¸ºç©º");

        RuleForEach(x => x.Costs)
            .Must(cost => cost.Amount > 0)
            .WithMessage("æ¶ˆè€—æ•°é‡å¿…é¡»å¤§äº0");
    }
}
```

---

### æ­¥éª¤4.4: é…ç½®çƒ­æ›´æ–°

```csharp
// APIç«¯ç‚¹
[ApiController]
[Route("api/admin/config")]
public class ConfigAdminController : ControllerBase
{
    private readonly IConfigProvider _configProvider;
    private readonly ILogger<ConfigAdminController> _logger;

    public ConfigAdminController(
        IConfigProvider configProvider,
        ILogger<ConfigAdminController> logger)
    {
        _configProvider = configProvider;
        _logger = logger;
    }

    [HttpPost("reload")]
    public async Task<IActionResult> ReloadConfig()
    {
        try
        {
            await _configProvider.ReloadAsync();
            return Ok(new { success = true, version = _configProvider.CurrentVersion });
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "é…ç½®é‡æ–°åŠ è½½å¤±è´¥");
            return StatusCode(500, new { success = false, error = ex.Message });
        }
    }

    [HttpGet("version")]
    public IActionResult GetVersion()
    {
        return Ok(new { version = _configProvider.CurrentVersion });
    }
}
```

---

## Phase 5: äº‹ä»¶æº¯æºä¸å¿«ç…§

**ç›®æ ‡**: å»ºç«‹äº‹ä»¶å­˜å‚¨ä¸å¿«ç…§æœºåˆ¶  
**æ—¶é—´**: 2å‘¨  
**ä¼˜å…ˆçº§**: ğŸŸ¡ ä¸­ï¼ˆä¸ºç¦»çº¿æ”¶ç›Šå‡†å¤‡ï¼‰

---

### æ­¥éª¤5.1: å®šä¹‰äº‹ä»¶å­˜å‚¨æ¥å£

```csharp
// Infrastructure/EventSourcing/IEventStore.cs
public interface IEventStore
{
    Task AppendAsync(IDomainEvent @event, CancellationToken ct = default);
    Task AppendBatchAsync(IEnumerable<IDomainEvent> events, CancellationToken ct = default);
    Task<IEnumerable<IDomainEvent>> GetEventsAsync(Guid aggregateId, CancellationToken ct = default);
    Task<IEnumerable<IDomainEvent>> GetEventsSinceAsync(Guid aggregateId, long version, CancellationToken ct = default);
}

// Infrastructure/EventSourcing/ISnapshotStore.cs
public interface ISnapshotStore
{
    Task SaveSnapshotAsync<T>(Guid aggregateId, T snapshot, long version, CancellationToken ct = default) where T : class;
    Task<(T? Snapshot, long Version)> GetLatestSnapshotAsync<T>(Guid aggregateId, CancellationToken ct = default) where T : class;
}
```

---

### æ­¥éª¤5.2: å®ç°äº‹ä»¶å­˜å‚¨

```csharp
// Infrastructure/EventSourcing/EventStore.cs
public class EventStore : IEventStore
{
    private readonly GameDbContext _context;
    private readonly ILogger<EventStore> _logger;

    public EventStore(GameDbContext context, ILogger<EventStore> logger)
    {
        _context = context;
        _logger = logger;
    }

    public async Task AppendAsync(IDomainEvent @event, CancellationToken ct = default)
    {
        var eventRecord = new EventRecord
        {
            EventId = @event.EventId,
            EventType = @event.EventType,
            AggregateId = GetAggregateId(@event),
            Data = JsonSerializer.Serialize(@event),
            OccurredAt = @event.OccurredAt
        };

        _context.Events.Add(eventRecord);
        await _context.SaveChangesAsync(ct);
    }

    public async Task AppendBatchAsync(
        IEnumerable<IDomainEvent> events, 
        CancellationToken ct = default)
    {
        var eventRecords = events.Select(@event => new EventRecord
        {
            EventId = @event.EventId,
            EventType = @event.EventType,
            AggregateId = GetAggregateId(@event),
            Data = JsonSerializer.Serialize(@event),
            OccurredAt = @event.OccurredAt
        });

        _context.Events.AddRange(eventRecords);
        await _context.SaveChangesAsync(ct);
    }

    public async Task<IEnumerable<IDomainEvent>> GetEventsAsync(
        Guid aggregateId, 
        CancellationToken ct = default)
    {
        var records = await _context.Events
            .Where(e => e.AggregateId == aggregateId)
            .OrderBy(e => e.Version)
            .ToListAsync(ct);

        return records.Select(DeserializeEvent);
    }

    private Guid GetAggregateId(IDomainEvent @event)
    {
        // æ ¹æ®äº‹ä»¶ç±»å‹æå–èšåˆæ ¹ID
        return @event switch
        {
            BattleStartedEvent e => e.BattleId,
            BattleSegmentCompletedEvent e => e.BattleId,
            BattleCompletedEvent e => e.BattleId,
            _ => throw new ArgumentException($"æœªçŸ¥äº‹ä»¶ç±»å‹: {@event.EventType}")
        };
    }

    private IDomainEvent DeserializeEvent(EventRecord record)
    {
        var eventType = Type.GetType(record.EventType);
        if (eventType == null)
        {
            throw new InvalidOperationException($"æ— æ³•æ‰¾åˆ°äº‹ä»¶ç±»å‹: {record.EventType}");
        }

        return (IDomainEvent)JsonSerializer.Deserialize(record.Data, eventType)!;
    }
}
```

---

### æ­¥éª¤5.3: å®ç°å¿«ç…§å­˜å‚¨

```csharp
// Infrastructure/EventSourcing/SnapshotStore.cs
public class SnapshotStore : ISnapshotStore
{
    private readonly GameDbContext _context;

    public SnapshotStore(GameDbContext context)
    {
        _context = context;
    }

    public async Task SaveSnapshotAsync<T>(
        Guid aggregateId, 
        T snapshot, 
        long version, 
        CancellationToken ct = default) where T : class
    {
        var snapshotRecord = new SnapshotRecord
        {
            Id = Guid.NewGuid(),
            AggregateId = aggregateId,
            SnapshotType = typeof(T).FullName!,
            Data = JsonSerializer.Serialize(snapshot),
            Version = version,
            CreatedAt = DateTime.UtcNow
        };

        _context.Snapshots.Add(snapshotRecord);
        await _context.SaveChangesAsync(ct);
    }

    public async Task<(T? Snapshot, long Version)> GetLatestSnapshotAsync<T>(
        Guid aggregateId, 
        CancellationToken ct = default) where T : class
    {
        var record = await _context.Snapshots
            .Where(s => s.AggregateId == aggregateId 
                && s.SnapshotType == typeof(T).FullName)
            .OrderByDescending(s => s.Version)
            .FirstOrDefaultAsync(ct);

        if (record == null)
        {
            return (null, 0);
        }

        var snapshot = JsonSerializer.Deserialize<T>(record.Data);
        return (snapshot, record.Version);
    }
}
```

---

## é˜¶æ®µé‡Œç¨‹ç¢‘

### Phase 0 å®Œæˆæ ‡å¿—

```
âœ… æ–°ç›®å½•ç»“æ„åˆ›å»ºå®Œæˆ
âœ… æ ¸å¿ƒæ¥å£å®šä¹‰å®Œæˆ
âœ… æµ‹è¯•åŸºç¡€è®¾æ–½å°±ç»ª
âœ… ä¾èµ–åŒ…å®‰è£…å®Œæˆ
```

### Phase 1 å®Œæˆæ ‡å¿—

```
âœ… SignalRDispatcherå®ç°å¹¶æµ‹è¯•
âœ… EventBusé›†æˆSignalR
âœ… é¢†åŸŸäº‹ä»¶å®šä¹‰å®Œæˆ
âœ… è‡³å°‘1ä¸ªä¸šåŠ¡æ¨¡å—è¿ç§»å®Œæˆ
âœ… æ¨é€ç›‘æ§æŒ‡æ ‡å¯è§
```

### Phase 2 å®Œæˆæ ‡å¿—

```
âœ… Repositoryæ¨¡å¼å®ç°å®Œæˆ
âœ… UnitOfWorkå®ç°å®Œæˆ
âœ… è‡³å°‘3ä¸ªEntity Repositoryå®ç°
âœ… 50%ä»¥ä¸ŠDbContextç›´æ¥ä½¿ç”¨å·²è¿ç§»
âœ… æ€§èƒ½æµ‹è¯•é€šè¿‡ï¼ˆæ— æ€§èƒ½é€€åŒ–ï¼‰
```

### Phase 3 å®Œæˆæ ‡å¿—

```
âœ… MultiTierCacheå¢å¼ºå®Œæˆ
âœ… è‡³å°‘2ä¸ªç¼“å­˜ç­–ç•¥å®ç°
âœ… CacheAwareRepositoryæ¨¡å¼å®ç°
âœ… ç¼“å­˜å‘½ä¸­ç‡ç›‘æ§å¯è§
âœ… ç¼“å­˜å¤±æ•ˆæœºåˆ¶æµ‹è¯•é€šè¿‡
```

### Phase 4 å®Œæˆæ ‡å¿—

```
âœ… JsonConfigProviderå®ç°å®Œæˆ
âœ… è‡³å°‘3ç§é…ç½®æ–‡ä»¶åˆ›å»º
âœ… é…ç½®éªŒè¯å™¨å®ç°
âœ… çƒ­æ›´æ–°APIæµ‹è¯•é€šè¿‡
âœ… é…ç½®ç‰ˆæœ¬ç®¡ç†å¯ç”¨
```

### Phase 5 å®Œæˆæ ‡å¿—

```
âœ… EventStoreå®ç°å®Œæˆ
âœ… SnapshotStoreå®ç°å®Œæˆ
âœ… æˆ˜æ–—äº‹ä»¶å¯æŒä¹…åŒ–
âœ… å¿«ç…§åˆ›å»ºä¸æ¢å¤æµ‹è¯•é€šè¿‡
âœ… äº‹ä»¶é‡æ”¾éªŒè¯é€šè¿‡
```

---

## ä¸‹ä¸€æ­¥

å®Œæˆæœ¬ç¯‡ï¼ˆä¸­ç¯‡ï¼‰åï¼Œå°†åˆ›å»ºã€Šé‡æ„è·¯çº¿å›¾-ä¸‹ç¯‡-åŠŸèƒ½é›†æˆä¸æµ‹è¯•ã€‹ï¼Œæ¶µç›–ï¼š

1. **ç¦»çº¿æ”¶ç›Šç³»ç»Ÿå®ç°**
2. **æ´»åŠ¨è®¡åˆ’ç³»ç»Ÿå®ç°**
3. **è£…å¤‡ç³»ç»Ÿå®Œå–„**
4. **ç»æµå¾ªç¯å»ºç«‹**
5. **é›†æˆæµ‹è¯•ä¸æ€§èƒ½ä¼˜åŒ–**

---

**æ–‡æ¡£çŠ¶æ€**: âœ… å®Œæˆ  
**é¢„è®¡é˜…è¯»æ—¶é—´**: 30-40åˆ†é’Ÿ  
**å®æ–½æ—¶é—´**: 9-11å‘¨ï¼ˆçº¦2.5ä¸ªæœˆï¼‰

---

**å…³é”®æç¤º**:
- æ‰€æœ‰é˜¶æ®µå‡éœ€å……åˆ†æµ‹è¯•åå†è¿›è¡Œä¸‹ä¸€é˜¶æ®µ
- å¯æ ¹æ®å®é™…æƒ…å†µè°ƒæ•´Phaseé¡ºåº
- Phase 1å’ŒPhase 2å¯éƒ¨åˆ†å¹¶è¡Œå¼€å‘
- ä¿æŒå‘åå…¼å®¹ï¼Œé¿å…ç ´åç°æœ‰åŠŸèƒ½
