# BlazorIdle 重构路线图（中篇）：基础设施实施方案

**文档版本**: 1.0  
**生成日期**: 2025年10月  
**状态**: 实施规划  
**目标**: 详细规划基础设施层的重构实施步骤

---

## 📋 目录

1. [实施总览](#实施总览)
2. [Phase 0: 准备阶段](#phase-0-准备阶段)
3. [Phase 1: SignalR重构](#phase-1-signalr重构)
4. [Phase 2: 持久化层重构](#phase-2-持久化层重构)
5. [Phase 3: 缓存系统完善](#phase-3-缓存系统完善)
6. [Phase 4: 配置管理系统](#phase-4-配置管理系统)
7. [Phase 5: 事件溯源与快照](#phase-5-事件溯源与快照)
8. [阶段里程碑](#阶段里程碑)

---

## 实施总览

### 重构策略

#### 核心原则

```
✅ 向后兼容优先：不破坏现有功能
✅ 渐进式迁移：逐步替换旧实现
✅ 并行运行：新旧系统共存过渡期
✅ 充分测试：每个阶段都有验证
```

---

### 时间规划

```
Phase 0: 准备阶段          [1周]   ████░░░░░░░░░░░░
Phase 1: SignalR重构       [2周]   ████████░░░░░░░░
Phase 2: 持久化层重构      [2-3周] ████████████░░░░
Phase 3: 缓存系统完善      [1-2周] ████████████████
Phase 4: 配置管理系统      [1-2周] ████████████████░░
Phase 5: 事件溯源与快照    [2周]   ████████████████████

总计：9-11周（约2.5个月）
```

---

### 依赖关系图

```
Phase 0 (准备)
    │
    ├──→ Phase 1 (SignalR)
    │        │
    │        └──→ Phase 5 (事件溯源) [可并行]
    │
    ├──→ Phase 2 (持久化)
    │        │
    │        └──→ Phase 3 (缓存)
    │                 │
    │                 └──→ Phase 4 (配置)
    └─────────────────────────┘
```

**关键路径**: Phase 0 → Phase 2 → Phase 3 → Phase 4  
**并行机会**: Phase 1 与 Phase 2 可部分并行

---

## Phase 0: 准备阶段

**目标**: 建立重构基础，最小化后续风险  
**时间**: 1周  
**优先级**: 🔴 最高

---

### 步骤0.1: 代码审计与标记

**工作内容**:
```
📝 标记所有直接使用DbContext的地方
📝 标记所有SignalR推送逻辑
📝 标记所有缓存使用点
📝 识别循环依赖和耦合热点
```

**输出**:
```
✅ 重构清单（Refactoring Checklist）
✅ 依赖关系图（Dependency Graph）
✅ 风险评估报告（Risk Assessment）
```

---

### 步骤0.2: 创建新目录结构

**目标文件结构**:
```
BlazorIdle.Server/
├── Infrastructure/
│   ├── Messaging/              # 新增：消息总线
│   │   ├── IEventBus.cs
│   │   ├── InMemoryEventBus.cs
│   │   ├── IDomainEvent.cs
│   │   └── SignalRDispatcher.cs
│   │
│   ├── Persistence/            # 重构：持久化层
│   │   ├── Abstractions/
│   │   │   ├── IRepository.cs
│   │   │   ├── IUnitOfWork.cs
│   │   │   └── IReadOnlyRepository.cs
│   │   ├── Repositories/
│   │   │   ├── CharacterRepository.cs
│   │   │   ├── BattleRecordRepository.cs
│   │   │   └── ...
│   │   ├── GameDbContext.cs    # 保留，增强
│   │   └── UnitOfWork.cs
│   │
│   ├── Caching/                # 重构：缓存层
│   │   ├── IMultiTierCache.cs
│   │   ├── MultiTierCacheManager.cs (已有，优化)
│   │   ├── CacheInvalidationCoordinator.cs (已有)
│   │   └── CacheStrategies/
│   │       ├── CharacterCacheStrategy.cs
│   │       └── ConfigCacheStrategy.cs
│   │
│   ├── Configuration/          # 新增：配置层
│   │   ├── IConfigProvider.cs
│   │   ├── JsonConfigProvider.cs
│   │   ├── ConfigVersionManager.cs
│   │   └── Validators/
│   │       ├── SkillConfigValidator.cs
│   │       └── EquipmentConfigValidator.cs
│   │
│   └── EventSourcing/          # 新增：事件溯源
│       ├── IEventStore.cs
│       ├── EventStore.cs
│       ├── ISnapshotStore.cs
│       └── SnapshotStore.cs
│
├── Application/                # 应用层（保持）
│   ├── Services/
│   └── Commands/
│
└── Domain/                     # 领域层（保持）
    └── Combat/
```

---

### 步骤0.3: 引入依赖包

**安装命令**:
```bash
# 消息总线（MediatR作为基础）
dotnet add package MediatR --version 12.2.0

# 配置验证
dotnet add package FluentValidation --version 11.9.0

# 未来可选：分布式缓存
# dotnet add package StackExchange.Redis --version 2.7.10
```

---

### 步骤0.4: 建立测试基础设施

**创建测试项目结构**:
```
BlazorIdle.Tests/
├── Infrastructure/
│   ├── Messaging/
│   │   └── EventBusTests.cs
│   ├── Persistence/
│   │   ├── RepositoryTests.cs
│   │   └── UnitOfWorkTests.cs
│   ├── Caching/
│   │   └── MultiTierCacheTests.cs
│   └── Configuration/
│       └── ConfigProviderTests.cs
│
└── Fixtures/
    ├── InMemoryDbContextFixture.cs
    └── TestDataBuilder.cs
```

---

### 步骤0.5: 创建接口定义

**核心接口先行**:

```csharp
// Infrastructure/Messaging/IDomainEvent.cs
public interface IDomainEvent
{
    Guid EventId { get; }
    DateTime OccurredAt { get; }
    string EventType { get; }
}

// Infrastructure/Messaging/IEventBus.cs
public interface IEventBus
{
    Task PublishAsync<TEvent>(TEvent @event) 
        where TEvent : IDomainEvent;
    
    void Subscribe<TEvent>(Func<TEvent, Task> handler) 
        where TEvent : IDomainEvent;
}

// Infrastructure/Persistence/Abstractions/IRepository.cs
public interface IRepository<T> where T : class
{
    Task<T?> GetByIdAsync(Guid id, CancellationToken ct = default);
    Task<IEnumerable<T>> GetAllAsync(CancellationToken ct = default);
    Task AddAsync(T entity, CancellationToken ct = default);
    Task UpdateAsync(T entity, CancellationToken ct = default);
    Task DeleteAsync(Guid id, CancellationToken ct = default);
}

// Infrastructure/Persistence/Abstractions/IUnitOfWork.cs
public interface IUnitOfWork : IDisposable
{
    IRepository<T> Repository<T>() where T : class;
    Task<int> SaveChangesAsync(CancellationToken ct = default);
    Task BeginTransactionAsync(CancellationToken ct = default);
    Task CommitAsync(CancellationToken ct = default);
    Task RollbackAsync(CancellationToken ct = default);
}

// Infrastructure/Caching/IMultiTierCache.cs
public interface IMultiTierCache
{
    Task<T?> GetAsync<T>(string key, CancellationToken ct = default);
    Task SetAsync<T>(string key, T value, TimeSpan? expiration = null, 
        CancellationToken ct = default);
    Task RemoveAsync(string key, CancellationToken ct = default);
    Task InvalidateByTagAsync(string tag, CancellationToken ct = default);
    CacheStatistics GetStatistics();
}

// Infrastructure/Configuration/IConfigProvider.cs
public interface IConfigProvider
{
    T Get<T>(string key) where T : class;
    IEnumerable<T> GetAll<T>() where T : class;
    Task ReloadAsync(CancellationToken ct = default);
    string CurrentVersion { get; }
}
```

---

## Phase 1: SignalR重构

**目标**: 统一SignalR推送机制，解耦业务逻辑  
**时间**: 2周  
**优先级**: 🔴 高

---

### 步骤1.1: 创建SignalR消息分发器

**实现要点**:

```csharp
// Infrastructure/Messaging/SignalRDispatcher.cs
public class SignalRDispatcher : ISignalRDispatcher
{
    private readonly IHubContext<BattleNotificationHub> _hubContext;
    private readonly ILogger<SignalRDispatcher> _logger;
    private readonly ConcurrentQueue<SignalRMessage> _messageQueue;

    public SignalRDispatcher(
        IHubContext<BattleNotificationHub> hubContext,
        ILogger<SignalRDispatcher> logger)
    {
        _hubContext = hubContext;
        _logger = logger;
        _messageQueue = new ConcurrentQueue<SignalRMessage>();
        
        // 启动后台发送任务
        Task.Run(ProcessQueueAsync);
    }

    public async Task SendToUserAsync(
        Guid userId, 
        string method, 
        object data)
    {
        var message = new SignalRMessage
        {
            TargetType = TargetType.User,
            TargetId = userId.ToString(),
            Method = method,
            Data = data
        };
        
        _messageQueue.Enqueue(message);
    }

    public async Task SendToGroupAsync(
        string groupName, 
        string method, 
        object data)
    {
        var message = new SignalRMessage
        {
            TargetType = TargetType.Group,
            TargetId = groupName,
            Method = method,
            Data = data
        };
        
        _messageQueue.Enqueue(message);
    }

    private async Task ProcessQueueAsync()
    {
        while (true)
        {
            try
            {
                if (_messageQueue.TryDequeue(out var message))
                {
                    await SendMessageAsync(message);
                }
                else
                {
                    await Task.Delay(100); // 避免空转
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "发送SignalR消息失败");
            }
        }
    }

    private async Task SendMessageAsync(SignalRMessage message)
    {
        try
        {
            switch (message.TargetType)
            {
                case TargetType.User:
                    await _hubContext.Clients
                        .User(message.TargetId)
                        .SendAsync(message.Method, message.Data);
                    break;
                    
                case TargetType.Group:
                    await _hubContext.Clients
                        .Group(message.TargetId)
                        .SendAsync(message.Method, message.Data);
                    break;
                    
                case TargetType.All:
                    await _hubContext.Clients
                        .All
                        .SendAsync(message.Method, message.Data);
                    break;
            }
            
            _logger.LogDebug(
                "SignalR消息已发送: {Method} -> {TargetType}:{TargetId}", 
                message.Method, message.TargetType, message.TargetId);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, 
                "发送SignalR消息失败: {Method} -> {TargetType}:{TargetId}", 
                message.Method, message.TargetType, message.TargetId);
        }
    }
}
```

---

### 步骤1.2: 集成到事件总线

**实现EventBus订阅SignalR推送**:

```csharp
// Infrastructure/Messaging/InMemoryEventBus.cs
public class InMemoryEventBus : IEventBus
{
    private readonly Dictionary<Type, List<Delegate>> _subscribers = new();
    private readonly ISignalRDispatcher _signalRDispatcher;
    private readonly ILogger<InMemoryEventBus> _logger;

    public InMemoryEventBus(
        ISignalRDispatcher signalRDispatcher,
        ILogger<InMemoryEventBus> logger)
    {
        _signalRDispatcher = signalRDispatcher;
        _logger = logger;
    }

    public async Task PublishAsync<TEvent>(TEvent @event) 
        where TEvent : IDomainEvent
    {
        var eventType = typeof(TEvent);
        
        if (_subscribers.TryGetValue(eventType, out var handlers))
        {
            foreach (var handler in handlers)
            {
                try
                {
                    await ((Func<TEvent, Task>)handler)(@event);
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, 
                        "事件处理失败: {EventType}", eventType.Name);
                }
            }
        }
    }

    public void Subscribe<TEvent>(Func<TEvent, Task> handler) 
        where TEvent : IDomainEvent
    {
        var eventType = typeof(TEvent);
        
        if (!_subscribers.ContainsKey(eventType))
        {
            _subscribers[eventType] = new List<Delegate>();
        }
        
        _subscribers[eventType].Add(handler);
    }
}
```

---

### 步骤1.3: 定义核心领域事件

**战斗相关事件**:

```csharp
// Domain/Combat/Events/BattleStartedEvent.cs
public record BattleStartedEvent(
    Guid BattleId,
    Guid CharacterId,
    string EnemyId,
    DateTime StartTime
) : IDomainEvent
{
    public Guid EventId { get; } = Guid.NewGuid();
    public DateTime OccurredAt { get; } = DateTime.UtcNow;
    public string EventType => nameof(BattleStartedEvent);
}

// Domain/Combat/Events/BattleSegmentCompletedEvent.cs
public record BattleSegmentCompletedEvent(
    Guid BattleId,
    Guid CharacterId,
    CombatSegment Segment
) : IDomainEvent
{
    public Guid EventId { get; } = Guid.NewGuid();
    public DateTime OccurredAt { get; } = DateTime.UtcNow;
    public string EventType => nameof(BattleSegmentCompletedEvent);
}

// Domain/Combat/Events/BattleCompletedEvent.cs
public record BattleCompletedEvent(
    Guid BattleId,
    Guid CharacterId,
    BattleOutcome Outcome,
    BattleStatistics Statistics
) : IDomainEvent
{
    public Guid EventId { get; } = Guid.NewGuid();
    public DateTime OccurredAt { get; } = DateTime.UtcNow;
    public string EventType => nameof(BattleCompletedEvent);
}
```

---

### 步骤1.4: 订阅事件并推送

**在Startup/Program.cs中注册订阅**:

```csharp
// 注册SignalR推送订阅
services.AddSingleton<IEventBus>(sp =>
{
    var eventBus = new InMemoryEventBus(
        sp.GetRequiredService<ISignalRDispatcher>(),
        sp.GetRequiredService<ILogger<InMemoryEventBus>>());

    // 订阅战斗事件 → SignalR推送
    eventBus.Subscribe<BattleStartedEvent>(async @event =>
    {
        var dispatcher = sp.GetRequiredService<ISignalRDispatcher>();
        await dispatcher.SendToUserAsync(
            @event.CharacterId,
            "BattleStarted",
            new { @event.BattleId, @event.EnemyId, @event.StartTime });
    });

    eventBus.Subscribe<BattleSegmentCompletedEvent>(async @event =>
    {
        var dispatcher = sp.GetRequiredService<ISignalRDispatcher>();
        await dispatcher.SendToUserAsync(
            @event.CharacterId,
            "BattleSegment",
            @event.Segment);
    });

    eventBus.Subscribe<BattleCompletedEvent>(async @event =>
    {
        var dispatcher = sp.GetRequiredService<ISignalRDispatcher>();
        await dispatcher.SendToUserAsync(
            @event.CharacterId,
            "BattleCompleted",
            new { @event.BattleId, @event.Outcome, @event.Statistics });
    });

    return eventBus;
});
```

---

### 步骤1.5: 迁移现有推送逻辑

**重构方式**:

```csharp
// 旧代码（直接使用HubContext）
await _hubContext.Clients
    .User(characterId.ToString())
    .SendAsync("BattleUpdate", data);

// ↓↓↓ 重构为 ↓↓↓

// 新代码（发布领域事件）
await _eventBus.PublishAsync(new BattleSegmentCompletedEvent(
    battleId, characterId, segment));
```

**优点**:
```
✅ 业务逻辑与SignalR解耦
✅ 统一推送入口，便于监控
✅ 支持多订阅者（如日志、统计）
✅ 易于测试（Mock IEventBus）
```

---

## Phase 2: 持久化层重构

**目标**: 统一数据访问，实现Repository模式  
**时间**: 2-3周  
**优先级**: 🔴 最高

---

### 步骤2.1: 实现通用Repository

**实现要点**:

```csharp
// Infrastructure/Persistence/Repositories/GenericRepository.cs
public class GenericRepository<T> : IRepository<T> where T : class
{
    protected readonly GameDbContext _context;
    protected readonly DbSet<T> _dbSet;

    public GenericRepository(GameDbContext context)
    {
        _context = context;
        _dbSet = context.Set<T>();
    }

    public virtual async Task<T?> GetByIdAsync(
        Guid id, 
        CancellationToken ct = default)
    {
        return await _dbSet.FindAsync(new object[] { id }, ct);
    }

    public virtual async Task<IEnumerable<T>> GetAllAsync(
        CancellationToken ct = default)
    {
        return await _dbSet.ToListAsync(ct);
    }

    public virtual async Task AddAsync(
        T entity, 
        CancellationToken ct = default)
    {
        await _dbSet.AddAsync(entity, ct);
    }

    public virtual async Task UpdateAsync(
        T entity, 
        CancellationToken ct = default)
    {
        _dbSet.Update(entity);
        await Task.CompletedTask;
    }

    public virtual async Task DeleteAsync(
        Guid id, 
        CancellationToken ct = default)
    {
        var entity = await GetByIdAsync(id, ct);
        if (entity != null)
        {
            _dbSet.Remove(entity);
        }
    }

    // 查询方法
    public virtual async Task<IEnumerable<T>> FindAsync(
        Expression<Func<T, bool>> predicate,
        CancellationToken ct = default)
    {
        return await _dbSet.Where(predicate).ToListAsync(ct);
    }

    // 批量操作
    public virtual async Task AddRangeAsync(
        IEnumerable<T> entities,
        CancellationToken ct = default)
    {
        await _dbSet.AddRangeAsync(entities, ct);
    }

    public virtual async Task UpdateRangeAsync(
        IEnumerable<T> entities,
        CancellationToken ct = default)
    {
        _dbSet.UpdateRange(entities);
        await Task.CompletedTask;
    }
}
```

---

### 步骤2.2: 实现UnitOfWork

```csharp
// Infrastructure/Persistence/UnitOfWork.cs
public class UnitOfWork : IUnitOfWork
{
    private readonly GameDbContext _context;
    private readonly Dictionary<Type, object> _repositories;
    private IDbContextTransaction? _transaction;

    public UnitOfWork(GameDbContext context)
    {
        _context = context;
        _repositories = new Dictionary<Type, object>();
    }

    public IRepository<T> Repository<T>() where T : class
    {
        var type = typeof(T);
        
        if (!_repositories.ContainsKey(type))
        {
            var repositoryType = typeof(GenericRepository<>)
                .MakeGenericType(type);
            var repositoryInstance = Activator
                .CreateInstance(repositoryType, _context);
            _repositories.Add(type, repositoryInstance!);
        }
        
        return (IRepository<T>)_repositories[type];
    }

    public async Task<int> SaveChangesAsync(
        CancellationToken ct = default)
    {
        return await _context.SaveChangesAsync(ct);
    }

    public async Task BeginTransactionAsync(
        CancellationToken ct = default)
    {
        _transaction = await _context.Database
            .BeginTransactionAsync(ct);
    }

    public async Task CommitAsync(CancellationToken ct = default)
    {
        try
        {
            await _context.SaveChangesAsync(ct);
            await _transaction?.CommitAsync(ct)!;
        }
        catch
        {
            await RollbackAsync(ct);
            throw;
        }
        finally
        {
            _transaction?.Dispose();
            _transaction = null;
        }
    }

    public async Task RollbackAsync(CancellationToken ct = default)
    {
        await _transaction?.RollbackAsync(ct)!;
        _transaction?.Dispose();
        _transaction = null;
    }

    public void Dispose()
    {
        _transaction?.Dispose();
        _context?.Dispose();
    }
}
```

---

### 步骤2.3: 创建特定实体Repository

**示例：CharacterRepository**:

```csharp
// Infrastructure/Persistence/Repositories/CharacterRepository.cs
public interface ICharacterRepository : IRepository<Character>
{
    Task<Character?> GetByUserIdAsync(Guid userId, CancellationToken ct = default);
    Task<IEnumerable<Character>> GetByUserWithStatsAsync(Guid userId, CancellationToken ct = default);
}

public class CharacterRepository : GenericRepository<Character>, ICharacterRepository
{
    public CharacterRepository(GameDbContext context) : base(context) { }

    public async Task<Character?> GetByUserIdAsync(
        Guid userId, 
        CancellationToken ct = default)
    {
        return await _dbSet
            .FirstOrDefaultAsync(c => c.UserId == userId, ct);
    }

    public async Task<IEnumerable<Character>> GetByUserWithStatsAsync(
        Guid userId, 
        CancellationToken ct = default)
    {
        return await _dbSet
            .Include(c => c.Stats)       // 预加载统计数据
            .Include(c => c.Equipment)   // 预加载装备
            .Where(c => c.UserId == userId)
            .ToListAsync(ct);
    }
}
```

---

### 步骤2.4: 注册到DI容器

```csharp
// Program.cs 或 DependencyInjection.cs
services.AddScoped<IUnitOfWork, UnitOfWork>();
services.AddScoped(typeof(IRepository<>), typeof(GenericRepository<>));

// 特定Repository
services.AddScoped<ICharacterRepository, CharacterRepository>();
services.AddScoped<IBattleRecordRepository, BattleRecordRepository>();
```

---

### 步骤2.5: 迁移现有代码

**重构示例**:

```csharp
// 旧代码（直接使用DbContext）
public class BattleService
{
    private readonly GameDbContext _context;
    
    public async Task<BattleRecord> GetBattleAsync(Guid id)
    {
        return await _context.BattleRecords
            .Include(b => b.Segments)
            .FirstOrDefaultAsync(b => b.Id == id);
    }
}

// ↓↓↓ 重构为 ↓↓↓

// 新代码（使用Repository）
public class BattleService
{
    private readonly IUnitOfWork _unitOfWork;
    
    public async Task<BattleRecord> GetBattleAsync(Guid id)
    {
        var repository = _unitOfWork.Repository<BattleRecord>();
        return await repository.GetByIdAsync(id);
    }
}
```

---

## Phase 3: 缓存系统完善

**目标**: 统一缓存接口，优化缓存策略  
**时间**: 1-2周  
**优先级**: 🟡 中

---

### 步骤3.1: 完善IMultiTierCache实现

**当前状态**: 已有`MultiTierCacheManager`，需要完善接口

```csharp
// Infrastructure/Caching/IMultiTierCache.cs (增强)
public interface IMultiTierCache
{
    // 基础操作
    Task<T?> GetAsync<T>(string key, CancellationToken ct = default);
    Task SetAsync<T>(string key, T value, TimeSpan? expiration = null, 
        CancellationToken ct = default);
    Task RemoveAsync(string key, CancellationToken ct = default);
    
    // 批量操作
    Task<IDictionary<string, T>> GetManyAsync<T>(
        IEnumerable<string> keys, CancellationToken ct = default);
    Task SetManyAsync<T>(
        IDictionary<string, T> items, TimeSpan? expiration = null, 
        CancellationToken ct = default);
    
    // 标签失效
    Task InvalidateByTagAsync(string tag, CancellationToken ct = default);
    Task InvalidateByPatternAsync(string pattern, CancellationToken ct = default);
    
    // 统计
    CacheStatistics GetStatistics();
}
```

---

### 步骤3.2: 创建缓存策略

**Character缓存策略**:

```csharp
// Infrastructure/Caching/Strategies/CharacterCacheStrategy.cs
public class CharacterCacheStrategy
{
    private readonly IMultiTierCache _cache;
    private const string KEY_PREFIX = "character:";
    private const string TAG = "character";
    private static readonly TimeSpan EXPIRATION = TimeSpan.FromMinutes(30);

    public CharacterCacheStrategy(IMultiTierCache cache)
    {
        _cache = cache;
    }

    public async Task<Character?> GetAsync(Guid characterId)
    {
        var key = $"{KEY_PREFIX}{characterId}";
        return await _cache.GetAsync<Character>(key);
    }

    public async Task SetAsync(Character character)
    {
        var key = $"{KEY_PREFIX}{character.Id}";
        await _cache.SetAsync(key, character, EXPIRATION);
    }

    public async Task InvalidateAsync(Guid characterId)
    {
        var key = $"{KEY_PREFIX}{characterId}";
        await _cache.RemoveAsync(key);
    }

    public async Task InvalidateAllAsync()
    {
        await _cache.InvalidateByTagAsync(TAG);
    }
}
```

---

### 步骤3.3: 集成缓存到Repository

**CacheAwareRepository模式**:

```csharp
// Infrastructure/Persistence/CacheAwareRepository.cs
public class CacheAwareCharacterRepository : ICharacterRepository
{
    private readonly ICharacterRepository _innerRepository;
    private readonly CharacterCacheStrategy _cacheStrategy;

    public CacheAwareCharacterRepository(
        ICharacterRepository innerRepository,
        CharacterCacheStrategy cacheStrategy)
    {
        _innerRepository = innerRepository;
        _cacheStrategy = cacheStrategy;
    }

    public async Task<Character?> GetByIdAsync(
        Guid id, 
        CancellationToken ct = default)
    {
        // 先查缓存
        var cached = await _cacheStrategy.GetAsync(id);
        if (cached != null)
        {
            return cached;
        }

        // 缓存未命中，查数据库
        var character = await _innerRepository.GetByIdAsync(id, ct);
        
        // 写入缓存
        if (character != null)
        {
            await _cacheStrategy.SetAsync(character);
        }

        return character;
    }

    public async Task UpdateAsync(
        Character entity, 
        CancellationToken ct = default)
    {
        await _innerRepository.UpdateAsync(entity, ct);
        
        // 更新后失效缓存
        await _cacheStrategy.InvalidateAsync(entity.Id);
    }

    // 其他方法委托给innerRepository...
}
```

---

### 步骤3.4: 配置缓存层次

```csharp
// appsettings.json
{
  "Caching": {
    "L1": {
      "Enabled": true,
      "SizeLimit": 1024,  // MB
      "CompactionPercentage": 0.2
    },
    "L2": {
      "Enabled": false,    // 未来启用Redis
      "ConnectionString": "localhost:6379",
      "Database": 0
    },
    "DefaultExpiration": "00:30:00",  // 30分钟
    "Strategies": {
      "Character": {
        "Expiration": "00:30:00",
        "Priority": "High"
      },
      "Config": {
        "Expiration": "01:00:00",
        "Priority": "NeverRemove"
      }
    }
  }
}
```

---

## Phase 4: 配置管理系统

**目标**: 建立数据驱动的配置管理  
**时间**: 1-2周  
**优先级**: 🟡 中

---

### 步骤4.1: 实现JsonConfigProvider

```csharp
// Infrastructure/Configuration/JsonConfigProvider.cs
public class JsonConfigProvider : IConfigProvider
{
    private readonly ILogger<JsonConfigProvider> _logger;
    private readonly string _configDirectory;
    private readonly Dictionary<string, object> _configCache;
    private string _currentVersion;

    public JsonConfigProvider(
        IConfiguration configuration,
        ILogger<JsonConfigProvider> logger)
    {
        _logger = logger;
        _configDirectory = configuration["ConfigDirectory"] 
            ?? "GameData/Config";
        _configCache = new Dictionary<string, object>();
        _currentVersion = "1.0.0";
        
        LoadAllConfigs();
    }

    public string CurrentVersion => _currentVersion;

    public T Get<T>(string key) where T : class
    {
        if (_configCache.TryGetValue(key, out var cached))
        {
            return (T)cached;
        }

        throw new KeyNotFoundException($"配置键不存在: {key}");
    }

    public IEnumerable<T> GetAll<T>() where T : class
    {
        var typeName = typeof(T).Name;
        var fileName = $"{typeName}s.json"; // 约定：复数形式
        var filePath = Path.Combine(_configDirectory, fileName);

        if (!File.Exists(filePath))
        {
            return Enumerable.Empty<T>();
        }

        var json = File.ReadAllText(filePath);
        var items = JsonSerializer.Deserialize<List<T>>(json);
        
        return items ?? Enumerable.Empty<T>();
    }

    public async Task ReloadAsync(CancellationToken ct = default)
    {
        _configCache.Clear();
        LoadAllConfigs();
        
        OnConfigChanged?.Invoke(this, 
            new ConfigChangedEventArgs { Version = _currentVersion });
    }

    public event EventHandler<ConfigChangedEventArgs>? OnConfigChanged;

    private void LoadAllConfigs()
    {
        _logger.LogInformation("加载配置文件从: {Directory}", _configDirectory);

        // 加载技能配置
        LoadConfigFile<SkillDefinition>("Skills");
        
        // 加载装备配置
        LoadConfigFile<GearDefinition>("Gears");
        
        // 加载敌人配置
        LoadConfigFile<EnemyDefinition>("Enemies");
        
        _logger.LogInformation("配置加载完成，版本: {Version}", _currentVersion);
    }

    private void LoadConfigFile<T>(string configName) where T : class
    {
        var fileName = $"{configName}.json";
        var filePath = Path.Combine(_configDirectory, fileName);

        if (File.Exists(filePath))
        {
            var json = File.ReadAllText(filePath);
            var items = JsonSerializer.Deserialize<List<T>>(json);
            _configCache[configName] = items ?? new List<T>();
            
            _logger.LogDebug("配置加载: {ConfigName}, 项数: {Count}", 
                configName, (items?.Count ?? 0));
        }
    }
}
```

---

### 步骤4.2: 创建配置文件结构

```
GameData/
└── Config/
    ├── version.json           # 版本信息
    ├── Skills.json            # 技能配置
    ├── Gears.json             # 装备配置
    ├── Enemies.json           # 敌人配置
    ├── Professions.json       # 职业配置
    └── Maps.json              # 地图配置（未来）
```

**示例配置文件** (Skills.json):

```json
{
  "version": "1.0.0",
  "skills": [
    {
      "id": "warrior_slash",
      "name": "斩击",
      "description": "基础攻击技能",
      "profession": "Warrior",
      "baseDamage": 50,
      "damageType": "Physical",
      "cooldown": 3.0,
      "castTime": 0.0,
      "costs": [
        {
          "resource": "rage",
          "amount": 20
        }
      ],
      "effects": [
        {
          "type": "Damage",
          "value": 50,
          "coefficient": 1.2
        }
      ]
    }
  ]
}
```

---

### 步骤4.3: 配置验证器

```csharp
// Infrastructure/Configuration/Validators/SkillConfigValidator.cs
public class SkillConfigValidator : AbstractValidator<SkillDefinition>
{
    public SkillConfigValidator()
    {
        RuleFor(x => x.Id)
            .NotEmpty()
            .WithMessage("技能ID不能为空");

        RuleFor(x => x.BaseDamage)
            .GreaterThanOrEqualTo(0)
            .WithMessage("基础伤害不能为负数");

        RuleFor(x => x.Cooldown)
            .GreaterThan(0)
            .WithMessage("冷却时间必须大于0");

        RuleFor(x => x.Costs)
            .NotNull()
            .WithMessage("消耗配置不能为空");

        RuleForEach(x => x.Costs)
            .Must(cost => cost.Amount > 0)
            .WithMessage("消耗数量必须大于0");
    }
}
```

---

### 步骤4.4: 配置热更新

```csharp
// API端点
[ApiController]
[Route("api/admin/config")]
public class ConfigAdminController : ControllerBase
{
    private readonly IConfigProvider _configProvider;
    private readonly ILogger<ConfigAdminController> _logger;

    public ConfigAdminController(
        IConfigProvider configProvider,
        ILogger<ConfigAdminController> logger)
    {
        _configProvider = configProvider;
        _logger = logger;
    }

    [HttpPost("reload")]
    public async Task<IActionResult> ReloadConfig()
    {
        try
        {
            await _configProvider.ReloadAsync();
            return Ok(new { success = true, version = _configProvider.CurrentVersion });
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "配置重新加载失败");
            return StatusCode(500, new { success = false, error = ex.Message });
        }
    }

    [HttpGet("version")]
    public IActionResult GetVersion()
    {
        return Ok(new { version = _configProvider.CurrentVersion });
    }
}
```

---

## Phase 5: 事件溯源与快照

**目标**: 建立事件存储与快照机制  
**时间**: 2周  
**优先级**: 🟡 中（为离线收益准备）

---

### 步骤5.1: 定义事件存储接口

```csharp
// Infrastructure/EventSourcing/IEventStore.cs
public interface IEventStore
{
    Task AppendAsync(IDomainEvent @event, CancellationToken ct = default);
    Task AppendBatchAsync(IEnumerable<IDomainEvent> events, CancellationToken ct = default);
    Task<IEnumerable<IDomainEvent>> GetEventsAsync(Guid aggregateId, CancellationToken ct = default);
    Task<IEnumerable<IDomainEvent>> GetEventsSinceAsync(Guid aggregateId, long version, CancellationToken ct = default);
}

// Infrastructure/EventSourcing/ISnapshotStore.cs
public interface ISnapshotStore
{
    Task SaveSnapshotAsync<T>(Guid aggregateId, T snapshot, long version, CancellationToken ct = default) where T : class;
    Task<(T? Snapshot, long Version)> GetLatestSnapshotAsync<T>(Guid aggregateId, CancellationToken ct = default) where T : class;
}
```

---

### 步骤5.2: 实现事件存储

```csharp
// Infrastructure/EventSourcing/EventStore.cs
public class EventStore : IEventStore
{
    private readonly GameDbContext _context;
    private readonly ILogger<EventStore> _logger;

    public EventStore(GameDbContext context, ILogger<EventStore> logger)
    {
        _context = context;
        _logger = logger;
    }

    public async Task AppendAsync(IDomainEvent @event, CancellationToken ct = default)
    {
        var eventRecord = new EventRecord
        {
            EventId = @event.EventId,
            EventType = @event.EventType,
            AggregateId = GetAggregateId(@event),
            Data = JsonSerializer.Serialize(@event),
            OccurredAt = @event.OccurredAt
        };

        _context.Events.Add(eventRecord);
        await _context.SaveChangesAsync(ct);
    }

    public async Task AppendBatchAsync(
        IEnumerable<IDomainEvent> events, 
        CancellationToken ct = default)
    {
        var eventRecords = events.Select(@event => new EventRecord
        {
            EventId = @event.EventId,
            EventType = @event.EventType,
            AggregateId = GetAggregateId(@event),
            Data = JsonSerializer.Serialize(@event),
            OccurredAt = @event.OccurredAt
        });

        _context.Events.AddRange(eventRecords);
        await _context.SaveChangesAsync(ct);
    }

    public async Task<IEnumerable<IDomainEvent>> GetEventsAsync(
        Guid aggregateId, 
        CancellationToken ct = default)
    {
        var records = await _context.Events
            .Where(e => e.AggregateId == aggregateId)
            .OrderBy(e => e.Version)
            .ToListAsync(ct);

        return records.Select(DeserializeEvent);
    }

    private Guid GetAggregateId(IDomainEvent @event)
    {
        // 根据事件类型提取聚合根ID
        return @event switch
        {
            BattleStartedEvent e => e.BattleId,
            BattleSegmentCompletedEvent e => e.BattleId,
            BattleCompletedEvent e => e.BattleId,
            _ => throw new ArgumentException($"未知事件类型: {@event.EventType}")
        };
    }

    private IDomainEvent DeserializeEvent(EventRecord record)
    {
        var eventType = Type.GetType(record.EventType);
        if (eventType == null)
        {
            throw new InvalidOperationException($"无法找到事件类型: {record.EventType}");
        }

        return (IDomainEvent)JsonSerializer.Deserialize(record.Data, eventType)!;
    }
}
```

---

### 步骤5.3: 实现快照存储

```csharp
// Infrastructure/EventSourcing/SnapshotStore.cs
public class SnapshotStore : ISnapshotStore
{
    private readonly GameDbContext _context;

    public SnapshotStore(GameDbContext context)
    {
        _context = context;
    }

    public async Task SaveSnapshotAsync<T>(
        Guid aggregateId, 
        T snapshot, 
        long version, 
        CancellationToken ct = default) where T : class
    {
        var snapshotRecord = new SnapshotRecord
        {
            Id = Guid.NewGuid(),
            AggregateId = aggregateId,
            SnapshotType = typeof(T).FullName!,
            Data = JsonSerializer.Serialize(snapshot),
            Version = version,
            CreatedAt = DateTime.UtcNow
        };

        _context.Snapshots.Add(snapshotRecord);
        await _context.SaveChangesAsync(ct);
    }

    public async Task<(T? Snapshot, long Version)> GetLatestSnapshotAsync<T>(
        Guid aggregateId, 
        CancellationToken ct = default) where T : class
    {
        var record = await _context.Snapshots
            .Where(s => s.AggregateId == aggregateId 
                && s.SnapshotType == typeof(T).FullName)
            .OrderByDescending(s => s.Version)
            .FirstOrDefaultAsync(ct);

        if (record == null)
        {
            return (null, 0);
        }

        var snapshot = JsonSerializer.Deserialize<T>(record.Data);
        return (snapshot, record.Version);
    }
}
```

---

## 阶段里程碑

### Phase 0 完成标志

```
✅ 新目录结构创建完成
✅ 核心接口定义完成
✅ 测试基础设施就绪
✅ 依赖包安装完成
```

### Phase 1 完成标志

```
✅ SignalRDispatcher实现并测试
✅ EventBus集成SignalR
✅ 领域事件定义完成
✅ 至少1个业务模块迁移完成
✅ 推送监控指标可见
```

### Phase 2 完成标志

```
✅ Repository模式实现完成
✅ UnitOfWork实现完成
✅ 至少3个Entity Repository实现
✅ 50%以上DbContext直接使用已迁移
✅ 性能测试通过（无性能退化）
```

### Phase 3 完成标志

```
✅ MultiTierCache增强完成
✅ 至少2个缓存策略实现
✅ CacheAwareRepository模式实现
✅ 缓存命中率监控可见
✅ 缓存失效机制测试通过
```

### Phase 4 完成标志

```
✅ JsonConfigProvider实现完成
✅ 至少3种配置文件创建
✅ 配置验证器实现
✅ 热更新API测试通过
✅ 配置版本管理可用
```

### Phase 5 完成标志

```
✅ EventStore实现完成
✅ SnapshotStore实现完成
✅ 战斗事件可持久化
✅ 快照创建与恢复测试通过
✅ 事件重放验证通过
```

---

## 下一步

完成本篇（中篇）后，将创建《重构路线图-下篇-功能集成与测试》，涵盖：

1. **离线收益系统实现**
2. **活动计划系统实现**
3. **装备系统完善**
4. **经济循环建立**
5. **集成测试与性能优化**

---

**文档状态**: ✅ 完成  
**预计阅读时间**: 30-40分钟  
**实施时间**: 9-11周（约2.5个月）

---

**关键提示**:
- 所有阶段均需充分测试后再进行下一阶段
- 可根据实际情况调整Phase顺序
- Phase 1和Phase 2可部分并行开发
- 保持向后兼容，避免破坏现有功能
