# 前端渲染策略与时间同步

**文档版本**: 2.0  
**适用于**: BlazorIdle 实时帧推送系统  
**前置文档**: [实时帧推送设计方案](./实时帧推送设计方案.md)

---

## 📋 目录

1. [时间同步机制](#时间同步机制)
2. [插值与外推算法](#插值与外推算法)
3. [平滑纠正策略](#平滑纠正策略)
4. [演出节奏控制](#演出节奏控制)
5. [性能监控](#性能监控)
6. [最佳实践](#最佳实践)

---

## 时间同步机制

### 为什么需要时间同步

在实时战斗系统中，客户端和服务器的时间可能存在偏差：

```
服务器时间：2025-10-21 10:00:00.000
客户端时间：2025-10-21 10:00:00.150  (+150ms)
```

如果不同步时间，客户端会：
- 误判事件发生时间
- 插值计算错误
- 动画时机不准确

### 时间同步算法

#### 1. 基于帧的时间校准

```typescript
// Services/BattleTimeManager.ts
export class BattleTimeManager {
  private serverTimeOffset: number = 0;
  private offsetSamples: number[] = [];
  private readonly maxSamples: number = 20;
  private readonly sampleInterval: number = 5000; // 每5秒校准一次
  private lastSampleTime: number = 0;
  
  /**
   * 根据接收到的帧校准时间偏移
   * @param serverTime 服务器时间戳（来自 FrameTick.serverTime）
   * @param receiveTime 客户端接收时间（可选，默认为 Date.now()）
   */
  calibrateTime(serverTime: number, receiveTime: number = Date.now()): void {
    const now = Date.now();
    
    // 限制校准频率
    if (now - this.lastSampleTime < this.sampleInterval) {
      return;
    }
    
    this.lastSampleTime = now;
    
    // 计算单程延迟（假设往返延迟的一半）
    // 注意：这是一个简化估计，实际可能需要更精确的 RTT 测量
    const networkDelay = (receiveTime - serverTime) / 2;
    
    // 估计服务器在"发送时"的真实时间
    const estimatedServerTime = serverTime + networkDelay;
    
    // 计算偏移量：服务器时间 - 客户端时间
    const offset = estimatedServerTime - receiveTime;
    
    // 添加样本
    this.offsetSamples.push(offset);
    
    if (this.offsetSamples.length > this.maxSamples) {
      this.offsetSamples.shift();
    }
    
    // 使用中位数减少抖动
    this.serverTimeOffset = this.median(this.offsetSamples);
    
    console.debug(`Time sync: offset=${this.serverTimeOffset.toFixed(2)}ms, samples=${this.offsetSamples.length}`);
  }
  
  /**
   * 获取当前服务器时间（估计值）
   */
  getServerTime(): number {
    return Date.now() + this.serverTimeOffset;
  }
  
  /**
   * 将客户端时间转换为服务器时间
   */
  toServerTime(clientTime: number): number {
    return clientTime + this.serverTimeOffset;
  }
  
  /**
   * 将服务器时间转换为客户端时间
   */
  toClientTime(serverTime: number): number {
    return serverTime - this.serverTimeOffset;
  }
  
  /**
   * 获取当前时间偏移量（用于监控）
   */
  getOffset(): number {
    return this.serverTimeOffset;
  }
  
  /**
   * 计算中位数
   */
  private median(values: number[]): number {
    if (values.length === 0) return 0;
    
    const sorted = [...values].sort((a, b) => a - b);
    const mid = Math.floor(sorted.length / 2);
    
    if (sorted.length % 2 === 0) {
      return (sorted[mid - 1] + sorted[mid]) / 2;
    } else {
      return sorted[mid];
    }
  }
  
  /**
   * 重置时间同步状态
   */
  reset(): void {
    this.serverTimeOffset = 0;
    this.offsetSamples = [];
    this.lastSampleTime = 0;
  }
}
```

#### 2. 精确的 RTT 测量（可选）

```typescript
export class NetworkLatencyMeasurer {
  private rttSamples: number[] = [];
  private readonly maxSamples: number = 10;
  
  /**
   * 通过 ping-pong 测量往返时延
   */
  async measureRTT(connection: signalR.HubConnection): Promise<number> {
    const startTime = Date.now();
    
    await connection.invoke("Ping");
    
    const endTime = Date.now();
    const rtt = endTime - startTime;
    
    this.rttSamples.push(rtt);
    if (this.rttSamples.length > this.maxSamples) {
      this.rttSamples.shift();
    }
    
    return rtt;
  }
  
  /**
   * 获取平均 RTT
   */
  getAverageRTT(): number {
    if (this.rttSamples.length === 0) return 0;
    
    const sum = this.rttSamples.reduce((a, b) => a + b, 0);
    return sum / this.rttSamples.length;
  }
  
  /**
   * 估计单程延迟
   */
  getOneWayLatency(): number {
    return this.getAverageRTT() / 2;
  }
}
```

---

## 插值与外推算法

### 渲染时间线

```
Past          Present           Future
  |             |                 |
  v             v                 v
[Frame A]   [Render Point]   [Frame B]
  t=100ms     t=150ms          t=200ms
  
插值：根据 Frame A 和 Frame B 计算 t=150ms 的状态
外推：当 Frame B 未到达时，根据 Frame A 预测 t=150ms 的状态
```

### 插值实现

```typescript
// Services/BattleRenderer.ts
export class BattleRenderer {
  private previousFrame: FrameTick | null = null;
  private currentFrame: FrameTick | null = null;
  private nextFrame: FrameTick | null = null;
  
  // 插值延迟：为了有下一帧可用，故意延迟渲染
  private readonly interpolationDelay: number = 100; // ms
  
  // 外推限制：最多外推的时间
  private readonly maxExtrapolationTime: number = 200; // ms
  
  constructor(private timeManager: BattleTimeManager) {}
  
  /**
   * 接收新帧
   */
  onFrameTick(frame: FrameTick): void {
    // 时间校准
    this.timeManager.calibrateTime(frame.serverTime);
    
    // 帧滑动
    this.previousFrame = this.currentFrame;
    this.currentFrame = this.nextFrame;
    this.nextFrame = frame;
    
    console.debug(`Frame received: version=${frame.version}, serverTime=${frame.serverTime}`);
  }
  
  /**
   * 渲染当前状态
   * @param renderTime 客户端渲染时间（通常是 requestAnimationFrame 回调时间）
   */
  render(renderTime: number): void {
    if (!this.currentFrame) {
      // 还没有足够的帧数据
      return;
    }
    
    // 计算目标渲染的服务器时间（带插值延迟）
    const serverTime = this.timeManager.getServerTime();
    const targetTime = serverTime - this.interpolationDelay;
    
    if (this.nextFrame && targetTime >= this.currentFrame.serverTime && targetTime <= this.nextFrame.serverTime) {
      // 插值模式：在两帧之间
      this.renderInterpolated(this.currentFrame, this.nextFrame, targetTime);
    } else if (targetTime > this.currentFrame.serverTime) {
      // 外推模式：下一帧未到达
      const extrapolationTime = targetTime - this.currentFrame.serverTime;
      
      if (extrapolationTime <= this.maxExtrapolationTime) {
        this.renderExtrapolated(this.currentFrame, extrapolationTime);
      } else {
        // 外推时间过长，直接显示当前帧（避免偏差过大）
        this.renderCurrent(this.currentFrame);
      }
    } else {
      // 目标时间早于当前帧（异常情况），直接显示当前帧
      this.renderCurrent(this.currentFrame);
    }
  }
  
  /**
   * 插值渲染：在两帧之间平滑过渡
   */
  private renderInterpolated(from: FrameTick, to: FrameTick, targetTime: number): void {
    // 计算插值因子 t (0.0 - 1.0)
    const fromTime = from.serverTime;
    const toTime = to.serverTime;
    const t = (targetTime - fromTime) / (toTime - fromTime);
    const clampedT = Math.max(0, Math.min(1, t));
    
    // 插值数值型字段
    const health = this.lerp(from.metrics.health.current, to.metrics.health.current, clampedT);
    const shield = this.lerp(from.metrics.shield.current, to.metrics.shield.current, clampedT);
    
    // 读条进度插值
    let castProgress = 0;
    if (from.metrics.castProgress && to.metrics.castProgress) {
      if (from.metrics.castProgress.skillId === to.metrics.castProgress.skillId) {
        // 同一技能，插值进度
        castProgress = this.lerp(
          from.metrics.castProgress.progress,
          to.metrics.castProgress.progress,
          clampedT
        );
      } else {
        // 不同技能，使用目标帧的值
        castProgress = to.metrics.castProgress.progress;
      }
    } else if (to.metrics.castProgress) {
      castProgress = to.metrics.castProgress.progress;
    }
    
    // 更新 UI
    this.updateHealthBar(health);
    this.updateShieldBar(shield);
    this.updateCastBar(castProgress);
    
    // 非数值字段使用离散状态（不插值）
    this.updateBuffs(to.metrics.buffs || [], to.metrics.expiredBuffs || []);
    
    // DPS 使用加权平均
    const dps = this.lerp(from.metrics.dps.player, to.metrics.dps.player, clampedT);
    this.updateDpsDisplay(dps);
    
    console.debug(`Interpolated render: t=${clampedT.toFixed(2)}, health=${health.toFixed(0)}`);
  }
  
  /**
   * 外推渲染：根据当前帧预测未来状态
   */
  private renderExtrapolated(frame: FrameTick, deltaTime: number): void {
    // 简单线性外推（保守策略）
    
    let health = frame.metrics.health.current;
    let shield = frame.metrics.shield.current;
    let castProgress = 0;
    
    // 读条进度外推
    if (frame.metrics.castProgress) {
      const cast = frame.metrics.castProgress;
      const remainingTime = cast.remaining;
      const totalTime = remainingTime / (1 - cast.progress);
      
      // 外推进度
      castProgress = cast.progress + (deltaTime / totalTime);
      castProgress = Math.min(castProgress, 1.0);
    }
    
    // 血量变化外推（基于 delta）
    const deltaPerMs = frame.metrics.health.delta / 100; // 假设 100ms 窗口
    health = health + (deltaPerMs * deltaTime);
    health = Math.max(0, Math.min(frame.metrics.health.max, health));
    
    // 更新 UI
    this.updateHealthBar(health);
    this.updateShieldBar(shield);
    this.updateCastBar(castProgress);
    this.updateBuffs(frame.metrics.buffs || [], frame.metrics.expiredBuffs || []);
    
    console.debug(`Extrapolated render: deltaTime=${deltaTime.toFixed(0)}ms, castProgress=${castProgress.toFixed(2)}`);
  }
  
  /**
   * 直接渲染当前帧
   */
  private renderCurrent(frame: FrameTick): void {
    this.updateHealthBar(frame.metrics.health.current);
    this.updateShieldBar(frame.metrics.shield.current);
    this.updateCastBar(frame.metrics.castProgress?.progress || 0);
    this.updateBuffs(frame.metrics.buffs || [], frame.metrics.expiredBuffs || []);
    this.updateDpsDisplay(frame.metrics.dps.player);
  }
  
  /**
   * 线性插值
   */
  private lerp(a: number, b: number, t: number): number {
    return a + (b - a) * t;
  }
  
  // UI 更新方法（需要根据实际 UI 框架实现）
  private updateHealthBar(value: number): void {
    // 实现：更新血条 UI
  }
  
  private updateShieldBar(value: number): void {
    // 实现：更新护盾 UI
  }
  
  private updateCastBar(progress: number): void {
    // 实现：更新读条 UI
  }
  
  private updateBuffs(buffs: any[], expiredBuffs: string[]): void {
    // 实现：更新 Buff/Debuff UI
  }
  
  private updateDpsDisplay(dps: number): void {
    // 实现：更新 DPS 显示
  }
}
```

---

## 平滑纠正策略

### 问题场景

当客户端显示的值与服务器权威值有偏差时（例如外推过度），需要平滑纠正，避免突兀跳变。

### 实现方法

```typescript
export class SmoothValueCorrector {
  private displayValue: number;
  private targetValue: number;
  private correctionSpeed: number = 5.0; // 每秒纠正速度
  
  constructor(initialValue: number) {
    this.displayValue = initialValue;
    this.targetValue = initialValue;
  }
  
  /**
   * 设置新的目标值（来自权威帧）
   */
  setTarget(value: number): void {
    this.targetValue = value;
  }
  
  /**
   * 更新显示值（每帧调用）
   * @param deltaTime 距离上次更新的时间（秒）
   * @returns 当前显示值
   */
  update(deltaTime: number): number {
    const error = this.targetValue - this.displayValue;
    
    // 误差很小，直接对齐
    if (Math.abs(error) < 0.01) {
      this.displayValue = this.targetValue;
      return this.displayValue;
    }
    
    // 根据误差大小动态调整纠正速度
    const adaptiveSpeed = this.correctionSpeed * (1 + Math.abs(error) / 100);
    const correction = error * adaptiveSpeed * deltaTime;
    
    this.displayValue += correction;
    
    return this.displayValue;
  }
  
  /**
   * 获取当前显示值
   */
  getValue(): number {
    return this.displayValue;
  }
  
  /**
   * 强制设置值（用于快照恢复）
   */
  forceSet(value: number): void {
    this.displayValue = value;
    this.targetValue = value;
  }
}
```

### 使用示例

```typescript
class BattleUI {
  private healthCorrector = new SmoothValueCorrector(1000);
  private lastUpdateTime = Date.now();
  
  onFrameTick(frame: FrameTick): void {
    // 设置权威值
    this.healthCorrector.setTarget(frame.metrics.health.current);
  }
  
  render(): void {
    const now = Date.now();
    const deltaTime = (now - this.lastUpdateTime) / 1000;
    this.lastUpdateTime = now;
    
    // 平滑更新到目标值
    const displayHealth = this.healthCorrector.update(deltaTime);
    
    this.healthBar.setValue(displayHealth);
  }
  
  onSnapshot(snapshot: BattleSnapshot): void {
    // 快照时强制对齐
    this.healthCorrector.forceSet(snapshot.state.player.health.current);
  }
}
```

---

## 演出节奏控制

### 事件分级

```typescript
enum EventImportance {
  Low = 0,       // 普通伤害、普通治疗
  Normal = 1,    // 技能释放、Buff 应用
  High = 2,      // 暴击、怪物死亡
  Critical = 3   // Boss 死亡、玩家死亡、稀有掉落
}
```

### 伤害数字演出

```typescript
export class DamageNumberManager {
  private damageQueue: DamageEvent[] = [];
  private mergeWindow: number = 100; // ms
  
  /**
   * 添加伤害事件
   */
  addDamage(damage: number, isCritical: boolean = false): void {
    this.damageQueue.push({
      damage,
      isCritical,
      timestamp: Date.now()
    });
  }
  
  /**
   * 处理伤害队列（每帧调用）
   */
  update(): void {
    const now = Date.now();
    
    // 将窗口内的普通伤害合并
    const normalDamages = this.damageQueue.filter(d => 
      !d.isCritical && (now - d.timestamp) < this.mergeWindow
    );
    
    const criticalDamages = this.damageQueue.filter(d => 
      d.isCritical && (now - d.timestamp) < this.mergeWindow
    );
    
    // 显示合并的普通伤害
    if (normalDamages.length > 0) {
      const total = normalDamages.reduce((sum, d) => sum + d.damage, 0);
      this.showNormalDamage(total, normalDamages.length);
    }
    
    // 单独显示每个暴击
    for (const crit of criticalDamages) {
      this.showCriticalDamage(crit.damage);
    }
    
    // 清理已处理的事件
    this.damageQueue = this.damageQueue.filter(d => 
      (now - d.timestamp) >= this.mergeWindow
    );
  }
  
  private showNormalDamage(total: number, count: number): void {
    // 实现：显示合并的伤害数字
    const text = count > 1 ? `${total} (×${count})` : `${total}`;
    this.createFloatingText(text, {
      color: "#ffffff",
      fontSize: 24,
      duration: 1000
    });
  }
  
  private showCriticalDamage(damage: number): void {
    // 实现：显示暴击效果
    this.createFloatingText(`${damage}!`, {
      color: "#ff0000",
      fontSize: 36,
      shake: true,
      particles: true,
      duration: 1500
    });
    
    // 震屏效果
    this.cameraShake(0.3, 150);
  }
  
  private createFloatingText(text: string, options: any): void {
    // 实现：创建飘字动画
  }
  
  private cameraShake(intensity: number, duration: number): void {
    // 实现：相机震动效果
  }
}
```

### 关键事件动画

```typescript
export class BattleEventAnimator {
  /**
   * 处理关键事件
   */
  onKeyEvent(event: KeyEvent): void {
    switch (event.eventType) {
      case KeyEventType.MonsterDeath:
        this.playMonsterDeathAnimation(event.data);
        break;
      
      case KeyEventType.ItemDrop:
        this.playItemDropAnimation(event.data);
        break;
      
      case KeyEventType.PhaseTransition:
        this.playPhaseTransitionAnimation(event.data);
        break;
      
      case KeyEventType.CriticalHit:
        this.playCriticalHitAnimation(event.data);
        break;
      
      case KeyEventType.BossSpawn:
        this.playBossSpawnAnimation(event.data);
        break;
      
      default:
        console.log("Unhandled key event:", event.eventType);
    }
  }
  
  private playMonsterDeathAnimation(data: any): void {
    // 1. 播放死亡动画
    this.playAnimation("death", data.monsterId);
    
    // 2. 显示经验获得
    this.showExpGain(data.experience);
    
    // 3. 音效
    this.playSound("monster_death");
    
    // 4. 粒子效果
    this.spawnParticles("death_particles", data.position);
  }
  
  private playItemDropAnimation(data: any): void {
    // 1. 物品从天而降动画
    this.dropItemFromSky(data.itemId, data.position);
    
    // 2. 根据稀有度显示特效
    const rarityColor = this.getRarityColor(data.rarity);
    this.spawnGlow(data.position, rarityColor);
    
    // 3. 音效（根据稀有度）
    this.playSound(`item_drop_${data.rarity}`);
    
    // 4. 如果是稀有物品，显示通知
    if (data.rarity === "legendary") {
      this.showNotification(`获得 ${data.itemName}！`, "legendary");
    }
  }
  
  private playPhaseTransitionAnimation(data: any): void {
    // 1. 淡入淡出效果
    this.fadeToBlack(500);
    
    // 2. 显示阶段文字
    setTimeout(() => {
      this.showPhaseText(data.toPhase);
      this.fadeFromBlack(500);
    }, 500);
    
    // 3. 音效
    this.playSound("phase_transition");
  }
  
  private playCriticalHitAnimation(data: any): void {
    // 已在 DamageNumberManager 中实现
    // 这里可以添加额外的屏幕特效
    this.screenFlash("#ff0000", 100);
  }
  
  private playBossSpawnAnimation(data: any): void {
    // 1. 震屏
    this.cameraShake(1.0, 1000);
    
    // 2. 显示 Boss 名称
    this.showBossNameplate(data.bossName);
    
    // 3. 播放 Boss 登场音乐
    this.playMusic("boss_theme");
    
    // 4. 暗化屏幕边缘
    this.vignette(1.0, 500);
  }
  
  // 辅助方法（需要根据实际渲染引擎实现）
  private playAnimation(name: string, entityId: string): void {}
  private showExpGain(exp: number): void {}
  private playSound(soundId: string): void {}
  private spawnParticles(particleId: string, position: any): void {}
  private dropItemFromSky(itemId: string, position: any): void {}
  private spawnGlow(position: any, color: string): void {}
  private getRarityColor(rarity: string): string { return "#ffffff"; }
  private showNotification(message: string, style: string): void {}
  private fadeToBlack(duration: number): void {}
  private fadeFromBlack(duration: number): void {}
  private showPhaseText(phase: string): void {}
  private screenFlash(color: string, duration: number): void {}
  private cameraShake(intensity: number, duration: number): void {}
  private showBossNameplate(name: string): void {}
  private playMusic(musicId: string): void {}
  private vignette(intensity: number, duration: number): void {}
}
```

---

## 性能监控

### 渲染性能指标

```typescript
export class RenderPerformanceMonitor {
  private frameTimes: number[] = [];
  private lastFrameTime: number = Date.now();
  private readonly sampleSize: number = 60;
  
  /**
   * 记录一帧的渲染时间
   */
  recordFrame(): void {
    const now = Date.now();
    const frameTime = now - this.lastFrameTime;
    
    this.frameTimes.push(frameTime);
    if (this.frameTimes.length > this.sampleSize) {
      this.frameTimes.shift();
    }
    
    this.lastFrameTime = now;
  }
  
  /**
   * 获取当前 FPS
   */
  getFPS(): number {
    if (this.frameTimes.length === 0) return 0;
    
    const avgFrameTime = this.frameTimes.reduce((a, b) => a + b, 0) / this.frameTimes.length;
    return 1000 / avgFrameTime;
  }
  
  /**
   * 获取帧时间统计
   */
  getStats(): {
    fps: number;
    avgFrameTime: number;
    minFrameTime: number;
    maxFrameTime: number;
  } {
    if (this.frameTimes.length === 0) {
      return { fps: 0, avgFrameTime: 0, minFrameTime: 0, maxFrameTime: 0 };
    }
    
    const avgFrameTime = this.frameTimes.reduce((a, b) => a + b, 0) / this.frameTimes.length;
    const minFrameTime = Math.min(...this.frameTimes);
    const maxFrameTime = Math.max(...this.frameTimes);
    const fps = 1000 / avgFrameTime;
    
    return { fps, avgFrameTime, minFrameTime, maxFrameTime };
  }
  
  /**
   * 检查性能是否良好
   */
  isPerformanceGood(): boolean {
    return this.getFPS() >= 50; // 目标 60 FPS，允许一定波动
  }
}
```

### 网络性能指标

```typescript
export class NetworkPerformanceMonitor {
  private latencies: number[] = [];
  private frameReceiveTimes: number[] = [];
  private lastFrameReceiveTime: number = Date.now();
  
  /**
   * 记录帧接收延迟
   * @param frameSentTime 帧的服务器发送时间
   * @param frameReceiveTime 帧的客户端接收时间
   */
  recordFrameLatency(frameSentTime: number, frameReceiveTime: number): void {
    const latency = frameReceiveTime - frameSentTime;
    this.latencies.push(latency);
    
    if (this.latencies.length > 60) {
      this.latencies.shift();
    }
  }
  
  /**
   * 记录帧接收间隔
   */
  recordFrameReceive(): void {
    const now = Date.now();
    const interval = now - this.lastFrameReceiveTime;
    
    this.frameReceiveTimes.push(interval);
    if (this.frameReceiveTimes.length > 60) {
      this.frameReceiveTimes.shift();
    }
    
    this.lastFrameReceiveTime = now;
  }
  
  /**
   * 获取平均延迟
   */
  getAverageLatency(): number {
    if (this.latencies.length === 0) return 0;
    return this.latencies.reduce((a, b) => a + b, 0) / this.latencies.length;
  }
  
  /**
   * 获取平均帧接收频率（Hz）
   */
  getFrameReceiveRate(): number {
    if (this.frameReceiveTimes.length === 0) return 0;
    const avgInterval = this.frameReceiveTimes.reduce((a, b) => a + b, 0) / this.frameReceiveTimes.length;
    return 1000 / avgInterval;
  }
  
  /**
   * 获取网络统计
   */
  getStats(): {
    avgLatency: number;
    minLatency: number;
    maxLatency: number;
    frameReceiveRate: number;
  } {
    if (this.latencies.length === 0) {
      return { avgLatency: 0, minLatency: 0, maxLatency: 0, frameReceiveRate: 0 };
    }
    
    return {
      avgLatency: this.getAverageLatency(),
      minLatency: Math.min(...this.latencies),
      maxLatency: Math.max(...this.latencies),
      frameReceiveRate: this.getFrameReceiveRate()
    };
  }
}
```

### 性能面板 UI

```typescript
export class PerformancePanel {
  private renderMonitor: RenderPerformanceMonitor;
  private networkMonitor: NetworkPerformanceMonitor;
  private panelElement: HTMLElement;
  
  constructor() {
    this.renderMonitor = new RenderPerformanceMonitor();
    this.networkMonitor = new NetworkPerformanceMonitor();
    this.panelElement = this.createPanel();
  }
  
  private createPanel(): HTMLElement {
    const panel = document.createElement("div");
    panel.id = "performance-panel";
    panel.style.cssText = `
      position: fixed;
      top: 10px;
      right: 10px;
      background: rgba(0, 0, 0, 0.8);
      color: #00ff00;
      padding: 10px;
      font-family: monospace;
      font-size: 12px;
      z-index: 9999;
    `;
    document.body.appendChild(panel);
    return panel;
  }
  
  /**
   * 更新性能面板显示
   */
  update(): void {
    const renderStats = this.renderMonitor.getStats();
    const networkStats = this.networkMonitor.getStats();
    
    this.panelElement.innerHTML = `
      <div><strong>Render Performance</strong></div>
      <div>FPS: ${renderStats.fps.toFixed(1)}</div>
      <div>Frame Time: ${renderStats.avgFrameTime.toFixed(1)}ms (${renderStats.minFrameTime.toFixed(0)}-${renderStats.maxFrameTime.toFixed(0)})</div>
      <br>
      <div><strong>Network Performance</strong></div>
      <div>Latency: ${networkStats.avgLatency.toFixed(1)}ms (${networkStats.minLatency.toFixed(0)}-${networkStats.maxLatency.toFixed(0)})</div>
      <div>Frame Rate: ${networkStats.frameReceiveRate.toFixed(1)} Hz</div>
    `;
  }
  
  /**
   * 显示/隐藏面板
   */
  toggle(): void {
    this.panelElement.style.display = 
      this.panelElement.style.display === "none" ? "block" : "none";
  }
}
```

---

## 最佳实践

### 1. 渲染循环结构

```typescript
export class BattleRenderLoop {
  private renderer: BattleRenderer;
  private animator: BattleEventAnimator;
  private performanceMonitor: RenderPerformanceMonitor;
  private isRunning: boolean = false;
  
  constructor() {
    this.renderer = new BattleRenderer(new BattleTimeManager());
    this.animator = new BattleEventAnimator();
    this.performanceMonitor = new RenderPerformanceMonitor();
  }
  
  start(): void {
    this.isRunning = true;
    this.loop();
  }
  
  stop(): void {
    this.isRunning = false;
  }
  
  private loop = (): void => {
    if (!this.isRunning) return;
    
    // 渲染当前状态
    this.renderer.render(Date.now());
    
    // 性能监控
    this.performanceMonitor.recordFrame();
    
    // 下一帧
    requestAnimationFrame(this.loop);
  };
  
  onFrameTick(frame: FrameTick): void {
    this.renderer.onFrameTick(frame);
  }
  
  onKeyEvent(event: KeyEvent): void {
    this.animator.onKeyEvent(event);
  }
}
```

### 2. 自适应质量

```typescript
export class AdaptiveQualityManager {
  private qualityLevel: number = 2; // 0=低, 1=中, 2=高
  private performanceMonitor: RenderPerformanceMonitor;
  
  constructor(performanceMonitor: RenderPerformanceMonitor) {
    this.performanceMonitor = performanceMonitor;
  }
  
  /**
   * 根据性能自动调整质量
   */
  update(): void {
    const fps = this.performanceMonitor.getFPS();
    
    if (fps < 40 && this.qualityLevel > 0) {
      // 降低质量
      this.qualityLevel--;
      this.applyQuality(this.qualityLevel);
      console.info(`Performance drop, quality reduced to ${this.qualityLevel}`);
    } else if (fps > 55 && this.qualityLevel < 2) {
      // 提升质量
      this.qualityLevel++;
      this.applyQuality(this.qualityLevel);
      console.info(`Performance good, quality increased to ${this.qualityLevel}`);
    }
  }
  
  private applyQuality(level: number): void {
    switch (level) {
      case 0: // 低质量
        this.setParticleQuality("low");
        this.setAnimationQuality("low");
        this.setEffectQuality("low");
        break;
      case 1: // 中质量
        this.setParticleQuality("medium");
        this.setAnimationQuality("medium");
        this.setEffectQuality("medium");
        break;
      case 2: // 高质量
        this.setParticleQuality("high");
        this.setAnimationQuality("high");
        this.setEffectQuality("high");
        break;
    }
  }
  
  private setParticleQuality(quality: string): void {
    // 实现：调整粒子系统质量
  }
  
  private setAnimationQuality(quality: string): void {
    // 实现：调整动画质量
  }
  
  private setEffectQuality(quality: string): void {
    // 实现：调整特效质量
  }
}
```

### 3. 前台/后台自适应

```typescript
export class VisibilityManager {
  private onVisibilityChange?: (isVisible: boolean) => void;
  
  constructor() {
    document.addEventListener("visibilitychange", () => {
      const isVisible = document.visibilityState === "visible";
      this.onVisibilityChange?.(isVisible);
    });
  }
  
  setCallback(callback: (isVisible: boolean) => void): void {
    this.onVisibilityChange = callback;
  }
}

// 使用示例
const visibilityManager = new VisibilityManager();
visibilityManager.setCallback((isVisible) => {
  if (isVisible) {
    // 切换到前台：提升帧率
    battleConnection.setFrequency(10);
    console.info("Switched to foreground, frame rate increased to 10Hz");
  } else {
    // 切换到后台：降低帧率
    battleConnection.setFrequency(2);
    console.info("Switched to background, frame rate reduced to 2Hz");
  }
});
```

---

## 📝 总结

本文档提供了完整的前端渲染策略：

✅ **时间同步**: 基于帧的时间校准，减少客户端-服务器时间偏差  
✅ **插值算法**: 在两帧之间平滑过渡，实现流畅渲染  
✅ **外推算法**: 在帧未到达时预测状态，减少卡顿感  
✅ **平滑纠正**: 避免权威值纠正时的突兀跳变  
✅ **演出分级**: 普通伤害合并，关键事件独立动画  
✅ **性能监控**: 实时监控渲染和网络性能  
✅ **自适应质量**: 根据性能动态调整渲染质量

遵循这些策略，可以实现**低延迟、高流畅度**的战斗渲染体验。

---

**文档状态**: ✅ 完成  
**最后更新**: 2025年10月21日
