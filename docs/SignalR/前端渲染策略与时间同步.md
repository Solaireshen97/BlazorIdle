# å‰ç«¯æ¸²æŸ“ç­–ç•¥ä¸æ—¶é—´åŒæ­¥

**æ–‡æ¡£ç‰ˆæœ¬**: 2.0  
**é€‚ç”¨äº**: BlazorIdle å®æ—¶å¸§æ¨é€ç³»ç»Ÿ  
**å‰ç½®æ–‡æ¡£**: [å®æ—¶å¸§æ¨é€è®¾è®¡æ–¹æ¡ˆ](./å®æ—¶å¸§æ¨é€è®¾è®¡æ–¹æ¡ˆ.md)

---

## ğŸ“‹ ç›®å½•

1. [æ—¶é—´åŒæ­¥æœºåˆ¶](#æ—¶é—´åŒæ­¥æœºåˆ¶)
2. [æ’å€¼ä¸å¤–æ¨ç®—æ³•](#æ’å€¼ä¸å¤–æ¨ç®—æ³•)
3. [å¹³æ»‘çº æ­£ç­–ç•¥](#å¹³æ»‘çº æ­£ç­–ç•¥)
4. [æ¼”å‡ºèŠ‚å¥æ§åˆ¶](#æ¼”å‡ºèŠ‚å¥æ§åˆ¶)
5. [æ€§èƒ½ç›‘æ§](#æ€§èƒ½ç›‘æ§)
6. [æœ€ä½³å®è·µ](#æœ€ä½³å®è·µ)

---

## æ—¶é—´åŒæ­¥æœºåˆ¶

### ä¸ºä»€ä¹ˆéœ€è¦æ—¶é—´åŒæ­¥

åœ¨å®æ—¶æˆ˜æ–—ç³»ç»Ÿä¸­ï¼Œå®¢æˆ·ç«¯å’ŒæœåŠ¡å™¨çš„æ—¶é—´å¯èƒ½å­˜åœ¨åå·®ï¼š

```
æœåŠ¡å™¨æ—¶é—´ï¼š2025-10-21 10:00:00.000
å®¢æˆ·ç«¯æ—¶é—´ï¼š2025-10-21 10:00:00.150  (+150ms)
```

å¦‚æœä¸åŒæ­¥æ—¶é—´ï¼Œå®¢æˆ·ç«¯ä¼šï¼š
- è¯¯åˆ¤äº‹ä»¶å‘ç”Ÿæ—¶é—´
- æ’å€¼è®¡ç®—é”™è¯¯
- åŠ¨ç”»æ—¶æœºä¸å‡†ç¡®

### æ—¶é—´åŒæ­¥ç®—æ³•

#### 1. åŸºäºå¸§çš„æ—¶é—´æ ¡å‡†

```typescript
// Services/BattleTimeManager.ts
export class BattleTimeManager {
  private serverTimeOffset: number = 0;
  private offsetSamples: number[] = [];
  private readonly maxSamples: number = 20;
  private readonly sampleInterval: number = 5000; // æ¯5ç§’æ ¡å‡†ä¸€æ¬¡
  private lastSampleTime: number = 0;
  
  /**
   * æ ¹æ®æ¥æ”¶åˆ°çš„å¸§æ ¡å‡†æ—¶é—´åç§»
   * @param serverTime æœåŠ¡å™¨æ—¶é—´æˆ³ï¼ˆæ¥è‡ª FrameTick.serverTimeï¼‰
   * @param receiveTime å®¢æˆ·ç«¯æ¥æ”¶æ—¶é—´ï¼ˆå¯é€‰ï¼Œé»˜è®¤ä¸º Date.now()ï¼‰
   */
  calibrateTime(serverTime: number, receiveTime: number = Date.now()): void {
    const now = Date.now();
    
    // é™åˆ¶æ ¡å‡†é¢‘ç‡
    if (now - this.lastSampleTime < this.sampleInterval) {
      return;
    }
    
    this.lastSampleTime = now;
    
    // è®¡ç®—å•ç¨‹å»¶è¿Ÿï¼ˆå‡è®¾å¾€è¿”å»¶è¿Ÿçš„ä¸€åŠï¼‰
    // æ³¨æ„ï¼šè¿™æ˜¯ä¸€ä¸ªç®€åŒ–ä¼°è®¡ï¼Œå®é™…å¯èƒ½éœ€è¦æ›´ç²¾ç¡®çš„ RTT æµ‹é‡
    const networkDelay = (receiveTime - serverTime) / 2;
    
    // ä¼°è®¡æœåŠ¡å™¨åœ¨"å‘é€æ—¶"çš„çœŸå®æ—¶é—´
    const estimatedServerTime = serverTime + networkDelay;
    
    // è®¡ç®—åç§»é‡ï¼šæœåŠ¡å™¨æ—¶é—´ - å®¢æˆ·ç«¯æ—¶é—´
    const offset = estimatedServerTime - receiveTime;
    
    // æ·»åŠ æ ·æœ¬
    this.offsetSamples.push(offset);
    
    if (this.offsetSamples.length > this.maxSamples) {
      this.offsetSamples.shift();
    }
    
    // ä½¿ç”¨ä¸­ä½æ•°å‡å°‘æŠ–åŠ¨
    this.serverTimeOffset = this.median(this.offsetSamples);
    
    console.debug(`Time sync: offset=${this.serverTimeOffset.toFixed(2)}ms, samples=${this.offsetSamples.length}`);
  }
  
  /**
   * è·å–å½“å‰æœåŠ¡å™¨æ—¶é—´ï¼ˆä¼°è®¡å€¼ï¼‰
   */
  getServerTime(): number {
    return Date.now() + this.serverTimeOffset;
  }
  
  /**
   * å°†å®¢æˆ·ç«¯æ—¶é—´è½¬æ¢ä¸ºæœåŠ¡å™¨æ—¶é—´
   */
  toServerTime(clientTime: number): number {
    return clientTime + this.serverTimeOffset;
  }
  
  /**
   * å°†æœåŠ¡å™¨æ—¶é—´è½¬æ¢ä¸ºå®¢æˆ·ç«¯æ—¶é—´
   */
  toClientTime(serverTime: number): number {
    return serverTime - this.serverTimeOffset;
  }
  
  /**
   * è·å–å½“å‰æ—¶é—´åç§»é‡ï¼ˆç”¨äºç›‘æ§ï¼‰
   */
  getOffset(): number {
    return this.serverTimeOffset;
  }
  
  /**
   * è®¡ç®—ä¸­ä½æ•°
   */
  private median(values: number[]): number {
    if (values.length === 0) return 0;
    
    const sorted = [...values].sort((a, b) => a - b);
    const mid = Math.floor(sorted.length / 2);
    
    if (sorted.length % 2 === 0) {
      return (sorted[mid - 1] + sorted[mid]) / 2;
    } else {
      return sorted[mid];
    }
  }
  
  /**
   * é‡ç½®æ—¶é—´åŒæ­¥çŠ¶æ€
   */
  reset(): void {
    this.serverTimeOffset = 0;
    this.offsetSamples = [];
    this.lastSampleTime = 0;
  }
}
```

#### 2. ç²¾ç¡®çš„ RTT æµ‹é‡ï¼ˆå¯é€‰ï¼‰

```typescript
export class NetworkLatencyMeasurer {
  private rttSamples: number[] = [];
  private readonly maxSamples: number = 10;
  
  /**
   * é€šè¿‡ ping-pong æµ‹é‡å¾€è¿”æ—¶å»¶
   */
  async measureRTT(connection: signalR.HubConnection): Promise<number> {
    const startTime = Date.now();
    
    await connection.invoke("Ping");
    
    const endTime = Date.now();
    const rtt = endTime - startTime;
    
    this.rttSamples.push(rtt);
    if (this.rttSamples.length > this.maxSamples) {
      this.rttSamples.shift();
    }
    
    return rtt;
  }
  
  /**
   * è·å–å¹³å‡ RTT
   */
  getAverageRTT(): number {
    if (this.rttSamples.length === 0) return 0;
    
    const sum = this.rttSamples.reduce((a, b) => a + b, 0);
    return sum / this.rttSamples.length;
  }
  
  /**
   * ä¼°è®¡å•ç¨‹å»¶è¿Ÿ
   */
  getOneWayLatency(): number {
    return this.getAverageRTT() / 2;
  }
}
```

---

## æ’å€¼ä¸å¤–æ¨ç®—æ³•

### æ¸²æŸ“æ—¶é—´çº¿

```
Past          Present           Future
  |             |                 |
  v             v                 v
[Frame A]   [Render Point]   [Frame B]
  t=100ms     t=150ms          t=200ms
  
æ’å€¼ï¼šæ ¹æ® Frame A å’Œ Frame B è®¡ç®— t=150ms çš„çŠ¶æ€
å¤–æ¨ï¼šå½“ Frame B æœªåˆ°è¾¾æ—¶ï¼Œæ ¹æ® Frame A é¢„æµ‹ t=150ms çš„çŠ¶æ€
```

### æ’å€¼å®ç°

```typescript
// Services/BattleRenderer.ts
export class BattleRenderer {
  private previousFrame: FrameTick | null = null;
  private currentFrame: FrameTick | null = null;
  private nextFrame: FrameTick | null = null;
  
  // æ’å€¼å»¶è¿Ÿï¼šä¸ºäº†æœ‰ä¸‹ä¸€å¸§å¯ç”¨ï¼Œæ•…æ„å»¶è¿Ÿæ¸²æŸ“
  private readonly interpolationDelay: number = 100; // ms
  
  // å¤–æ¨é™åˆ¶ï¼šæœ€å¤šå¤–æ¨çš„æ—¶é—´
  private readonly maxExtrapolationTime: number = 200; // ms
  
  constructor(private timeManager: BattleTimeManager) {}
  
  /**
   * æ¥æ”¶æ–°å¸§
   */
  onFrameTick(frame: FrameTick): void {
    // æ—¶é—´æ ¡å‡†
    this.timeManager.calibrateTime(frame.serverTime);
    
    // å¸§æ»‘åŠ¨
    this.previousFrame = this.currentFrame;
    this.currentFrame = this.nextFrame;
    this.nextFrame = frame;
    
    console.debug(`Frame received: version=${frame.version}, serverTime=${frame.serverTime}`);
  }
  
  /**
   * æ¸²æŸ“å½“å‰çŠ¶æ€
   * @param renderTime å®¢æˆ·ç«¯æ¸²æŸ“æ—¶é—´ï¼ˆé€šå¸¸æ˜¯ requestAnimationFrame å›è°ƒæ—¶é—´ï¼‰
   */
  render(renderTime: number): void {
    if (!this.currentFrame) {
      // è¿˜æ²¡æœ‰è¶³å¤Ÿçš„å¸§æ•°æ®
      return;
    }
    
    // è®¡ç®—ç›®æ ‡æ¸²æŸ“çš„æœåŠ¡å™¨æ—¶é—´ï¼ˆå¸¦æ’å€¼å»¶è¿Ÿï¼‰
    const serverTime = this.timeManager.getServerTime();
    const targetTime = serverTime - this.interpolationDelay;
    
    if (this.nextFrame && targetTime >= this.currentFrame.serverTime && targetTime <= this.nextFrame.serverTime) {
      // æ’å€¼æ¨¡å¼ï¼šåœ¨ä¸¤å¸§ä¹‹é—´
      this.renderInterpolated(this.currentFrame, this.nextFrame, targetTime);
    } else if (targetTime > this.currentFrame.serverTime) {
      // å¤–æ¨æ¨¡å¼ï¼šä¸‹ä¸€å¸§æœªåˆ°è¾¾
      const extrapolationTime = targetTime - this.currentFrame.serverTime;
      
      if (extrapolationTime <= this.maxExtrapolationTime) {
        this.renderExtrapolated(this.currentFrame, extrapolationTime);
      } else {
        // å¤–æ¨æ—¶é—´è¿‡é•¿ï¼Œç›´æ¥æ˜¾ç¤ºå½“å‰å¸§ï¼ˆé¿å…åå·®è¿‡å¤§ï¼‰
        this.renderCurrent(this.currentFrame);
      }
    } else {
      // ç›®æ ‡æ—¶é—´æ—©äºå½“å‰å¸§ï¼ˆå¼‚å¸¸æƒ…å†µï¼‰ï¼Œç›´æ¥æ˜¾ç¤ºå½“å‰å¸§
      this.renderCurrent(this.currentFrame);
    }
  }
  
  /**
   * æ’å€¼æ¸²æŸ“ï¼šåœ¨ä¸¤å¸§ä¹‹é—´å¹³æ»‘è¿‡æ¸¡
   */
  private renderInterpolated(from: FrameTick, to: FrameTick, targetTime: number): void {
    // è®¡ç®—æ’å€¼å› å­ t (0.0 - 1.0)
    const fromTime = from.serverTime;
    const toTime = to.serverTime;
    const t = (targetTime - fromTime) / (toTime - fromTime);
    const clampedT = Math.max(0, Math.min(1, t));
    
    // æ’å€¼æ•°å€¼å‹å­—æ®µ
    const health = this.lerp(from.metrics.health.current, to.metrics.health.current, clampedT);
    const shield = this.lerp(from.metrics.shield.current, to.metrics.shield.current, clampedT);
    
    // è¯»æ¡è¿›åº¦æ’å€¼
    let castProgress = 0;
    if (from.metrics.castProgress && to.metrics.castProgress) {
      if (from.metrics.castProgress.skillId === to.metrics.castProgress.skillId) {
        // åŒä¸€æŠ€èƒ½ï¼Œæ’å€¼è¿›åº¦
        castProgress = this.lerp(
          from.metrics.castProgress.progress,
          to.metrics.castProgress.progress,
          clampedT
        );
      } else {
        // ä¸åŒæŠ€èƒ½ï¼Œä½¿ç”¨ç›®æ ‡å¸§çš„å€¼
        castProgress = to.metrics.castProgress.progress;
      }
    } else if (to.metrics.castProgress) {
      castProgress = to.metrics.castProgress.progress;
    }
    
    // æ›´æ–° UI
    this.updateHealthBar(health);
    this.updateShieldBar(shield);
    this.updateCastBar(castProgress);
    
    // éæ•°å€¼å­—æ®µä½¿ç”¨ç¦»æ•£çŠ¶æ€ï¼ˆä¸æ’å€¼ï¼‰
    this.updateBuffs(to.metrics.buffs || [], to.metrics.expiredBuffs || []);
    
    // DPS ä½¿ç”¨åŠ æƒå¹³å‡
    const dps = this.lerp(from.metrics.dps.player, to.metrics.dps.player, clampedT);
    this.updateDpsDisplay(dps);
    
    console.debug(`Interpolated render: t=${clampedT.toFixed(2)}, health=${health.toFixed(0)}`);
  }
  
  /**
   * å¤–æ¨æ¸²æŸ“ï¼šæ ¹æ®å½“å‰å¸§é¢„æµ‹æœªæ¥çŠ¶æ€
   */
  private renderExtrapolated(frame: FrameTick, deltaTime: number): void {
    // ç®€å•çº¿æ€§å¤–æ¨ï¼ˆä¿å®ˆç­–ç•¥ï¼‰
    
    let health = frame.metrics.health.current;
    let shield = frame.metrics.shield.current;
    let castProgress = 0;
    
    // è¯»æ¡è¿›åº¦å¤–æ¨
    if (frame.metrics.castProgress) {
      const cast = frame.metrics.castProgress;
      const remainingTime = cast.remaining;
      const totalTime = remainingTime / (1 - cast.progress);
      
      // å¤–æ¨è¿›åº¦
      castProgress = cast.progress + (deltaTime / totalTime);
      castProgress = Math.min(castProgress, 1.0);
    }
    
    // è¡€é‡å˜åŒ–å¤–æ¨ï¼ˆåŸºäº deltaï¼‰
    const deltaPerMs = frame.metrics.health.delta / 100; // å‡è®¾ 100ms çª—å£
    health = health + (deltaPerMs * deltaTime);
    health = Math.max(0, Math.min(frame.metrics.health.max, health));
    
    // æ›´æ–° UI
    this.updateHealthBar(health);
    this.updateShieldBar(shield);
    this.updateCastBar(castProgress);
    this.updateBuffs(frame.metrics.buffs || [], frame.metrics.expiredBuffs || []);
    
    console.debug(`Extrapolated render: deltaTime=${deltaTime.toFixed(0)}ms, castProgress=${castProgress.toFixed(2)}`);
  }
  
  /**
   * ç›´æ¥æ¸²æŸ“å½“å‰å¸§
   */
  private renderCurrent(frame: FrameTick): void {
    this.updateHealthBar(frame.metrics.health.current);
    this.updateShieldBar(frame.metrics.shield.current);
    this.updateCastBar(frame.metrics.castProgress?.progress || 0);
    this.updateBuffs(frame.metrics.buffs || [], frame.metrics.expiredBuffs || []);
    this.updateDpsDisplay(frame.metrics.dps.player);
  }
  
  /**
   * çº¿æ€§æ’å€¼
   */
  private lerp(a: number, b: number, t: number): number {
    return a + (b - a) * t;
  }
  
  // UI æ›´æ–°æ–¹æ³•ï¼ˆéœ€è¦æ ¹æ®å®é™… UI æ¡†æ¶å®ç°ï¼‰
  private updateHealthBar(value: number): void {
    // å®ç°ï¼šæ›´æ–°è¡€æ¡ UI
  }
  
  private updateShieldBar(value: number): void {
    // å®ç°ï¼šæ›´æ–°æŠ¤ç›¾ UI
  }
  
  private updateCastBar(progress: number): void {
    // å®ç°ï¼šæ›´æ–°è¯»æ¡ UI
  }
  
  private updateBuffs(buffs: any[], expiredBuffs: string[]): void {
    // å®ç°ï¼šæ›´æ–° Buff/Debuff UI
  }
  
  private updateDpsDisplay(dps: number): void {
    // å®ç°ï¼šæ›´æ–° DPS æ˜¾ç¤º
  }
}
```

---

## å¹³æ»‘çº æ­£ç­–ç•¥

### é—®é¢˜åœºæ™¯

å½“å®¢æˆ·ç«¯æ˜¾ç¤ºçš„å€¼ä¸æœåŠ¡å™¨æƒå¨å€¼æœ‰åå·®æ—¶ï¼ˆä¾‹å¦‚å¤–æ¨è¿‡åº¦ï¼‰ï¼Œéœ€è¦å¹³æ»‘çº æ­£ï¼Œé¿å…çªå…€è·³å˜ã€‚

### å®ç°æ–¹æ³•

```typescript
export class SmoothValueCorrector {
  private displayValue: number;
  private targetValue: number;
  private correctionSpeed: number = 5.0; // æ¯ç§’çº æ­£é€Ÿåº¦
  
  constructor(initialValue: number) {
    this.displayValue = initialValue;
    this.targetValue = initialValue;
  }
  
  /**
   * è®¾ç½®æ–°çš„ç›®æ ‡å€¼ï¼ˆæ¥è‡ªæƒå¨å¸§ï¼‰
   */
  setTarget(value: number): void {
    this.targetValue = value;
  }
  
  /**
   * æ›´æ–°æ˜¾ç¤ºå€¼ï¼ˆæ¯å¸§è°ƒç”¨ï¼‰
   * @param deltaTime è·ç¦»ä¸Šæ¬¡æ›´æ–°çš„æ—¶é—´ï¼ˆç§’ï¼‰
   * @returns å½“å‰æ˜¾ç¤ºå€¼
   */
  update(deltaTime: number): number {
    const error = this.targetValue - this.displayValue;
    
    // è¯¯å·®å¾ˆå°ï¼Œç›´æ¥å¯¹é½
    if (Math.abs(error) < 0.01) {
      this.displayValue = this.targetValue;
      return this.displayValue;
    }
    
    // æ ¹æ®è¯¯å·®å¤§å°åŠ¨æ€è°ƒæ•´çº æ­£é€Ÿåº¦
    const adaptiveSpeed = this.correctionSpeed * (1 + Math.abs(error) / 100);
    const correction = error * adaptiveSpeed * deltaTime;
    
    this.displayValue += correction;
    
    return this.displayValue;
  }
  
  /**
   * è·å–å½“å‰æ˜¾ç¤ºå€¼
   */
  getValue(): number {
    return this.displayValue;
  }
  
  /**
   * å¼ºåˆ¶è®¾ç½®å€¼ï¼ˆç”¨äºå¿«ç…§æ¢å¤ï¼‰
   */
  forceSet(value: number): void {
    this.displayValue = value;
    this.targetValue = value;
  }
}
```

### ä½¿ç”¨ç¤ºä¾‹

```typescript
class BattleUI {
  private healthCorrector = new SmoothValueCorrector(1000);
  private lastUpdateTime = Date.now();
  
  onFrameTick(frame: FrameTick): void {
    // è®¾ç½®æƒå¨å€¼
    this.healthCorrector.setTarget(frame.metrics.health.current);
  }
  
  render(): void {
    const now = Date.now();
    const deltaTime = (now - this.lastUpdateTime) / 1000;
    this.lastUpdateTime = now;
    
    // å¹³æ»‘æ›´æ–°åˆ°ç›®æ ‡å€¼
    const displayHealth = this.healthCorrector.update(deltaTime);
    
    this.healthBar.setValue(displayHealth);
  }
  
  onSnapshot(snapshot: BattleSnapshot): void {
    // å¿«ç…§æ—¶å¼ºåˆ¶å¯¹é½
    this.healthCorrector.forceSet(snapshot.state.player.health.current);
  }
}
```

---

## æ¼”å‡ºèŠ‚å¥æ§åˆ¶

### äº‹ä»¶åˆ†çº§

```typescript
enum EventImportance {
  Low = 0,       // æ™®é€šä¼¤å®³ã€æ™®é€šæ²»ç–—
  Normal = 1,    // æŠ€èƒ½é‡Šæ”¾ã€Buff åº”ç”¨
  High = 2,      // æš´å‡»ã€æ€ªç‰©æ­»äº¡
  Critical = 3   // Boss æ­»äº¡ã€ç©å®¶æ­»äº¡ã€ç¨€æœ‰æ‰è½
}
```

### ä¼¤å®³æ•°å­—æ¼”å‡º

```typescript
export class DamageNumberManager {
  private damageQueue: DamageEvent[] = [];
  private mergeWindow: number = 100; // ms
  
  /**
   * æ·»åŠ ä¼¤å®³äº‹ä»¶
   */
  addDamage(damage: number, isCritical: boolean = false): void {
    this.damageQueue.push({
      damage,
      isCritical,
      timestamp: Date.now()
    });
  }
  
  /**
   * å¤„ç†ä¼¤å®³é˜Ÿåˆ—ï¼ˆæ¯å¸§è°ƒç”¨ï¼‰
   */
  update(): void {
    const now = Date.now();
    
    // å°†çª—å£å†…çš„æ™®é€šä¼¤å®³åˆå¹¶
    const normalDamages = this.damageQueue.filter(d => 
      !d.isCritical && (now - d.timestamp) < this.mergeWindow
    );
    
    const criticalDamages = this.damageQueue.filter(d => 
      d.isCritical && (now - d.timestamp) < this.mergeWindow
    );
    
    // æ˜¾ç¤ºåˆå¹¶çš„æ™®é€šä¼¤å®³
    if (normalDamages.length > 0) {
      const total = normalDamages.reduce((sum, d) => sum + d.damage, 0);
      this.showNormalDamage(total, normalDamages.length);
    }
    
    // å•ç‹¬æ˜¾ç¤ºæ¯ä¸ªæš´å‡»
    for (const crit of criticalDamages) {
      this.showCriticalDamage(crit.damage);
    }
    
    // æ¸…ç†å·²å¤„ç†çš„äº‹ä»¶
    this.damageQueue = this.damageQueue.filter(d => 
      (now - d.timestamp) >= this.mergeWindow
    );
  }
  
  private showNormalDamage(total: number, count: number): void {
    // å®ç°ï¼šæ˜¾ç¤ºåˆå¹¶çš„ä¼¤å®³æ•°å­—
    const text = count > 1 ? `${total} (Ã—${count})` : `${total}`;
    this.createFloatingText(text, {
      color: "#ffffff",
      fontSize: 24,
      duration: 1000
    });
  }
  
  private showCriticalDamage(damage: number): void {
    // å®ç°ï¼šæ˜¾ç¤ºæš´å‡»æ•ˆæœ
    this.createFloatingText(`${damage}!`, {
      color: "#ff0000",
      fontSize: 36,
      shake: true,
      particles: true,
      duration: 1500
    });
    
    // éœ‡å±æ•ˆæœ
    this.cameraShake(0.3, 150);
  }
  
  private createFloatingText(text: string, options: any): void {
    // å®ç°ï¼šåˆ›å»ºé£˜å­—åŠ¨ç”»
  }
  
  private cameraShake(intensity: number, duration: number): void {
    // å®ç°ï¼šç›¸æœºéœ‡åŠ¨æ•ˆæœ
  }
}
```

### å…³é”®äº‹ä»¶åŠ¨ç”»

```typescript
export class BattleEventAnimator {
  /**
   * å¤„ç†å…³é”®äº‹ä»¶
   */
  onKeyEvent(event: KeyEvent): void {
    switch (event.eventType) {
      case KeyEventType.MonsterDeath:
        this.playMonsterDeathAnimation(event.data);
        break;
      
      case KeyEventType.ItemDrop:
        this.playItemDropAnimation(event.data);
        break;
      
      case KeyEventType.PhaseTransition:
        this.playPhaseTransitionAnimation(event.data);
        break;
      
      case KeyEventType.CriticalHit:
        this.playCriticalHitAnimation(event.data);
        break;
      
      case KeyEventType.BossSpawn:
        this.playBossSpawnAnimation(event.data);
        break;
      
      default:
        console.log("Unhandled key event:", event.eventType);
    }
  }
  
  private playMonsterDeathAnimation(data: any): void {
    // 1. æ’­æ”¾æ­»äº¡åŠ¨ç”»
    this.playAnimation("death", data.monsterId);
    
    // 2. æ˜¾ç¤ºç»éªŒè·å¾—
    this.showExpGain(data.experience);
    
    // 3. éŸ³æ•ˆ
    this.playSound("monster_death");
    
    // 4. ç²’å­æ•ˆæœ
    this.spawnParticles("death_particles", data.position);
  }
  
  private playItemDropAnimation(data: any): void {
    // 1. ç‰©å“ä»å¤©è€Œé™åŠ¨ç”»
    this.dropItemFromSky(data.itemId, data.position);
    
    // 2. æ ¹æ®ç¨€æœ‰åº¦æ˜¾ç¤ºç‰¹æ•ˆ
    const rarityColor = this.getRarityColor(data.rarity);
    this.spawnGlow(data.position, rarityColor);
    
    // 3. éŸ³æ•ˆï¼ˆæ ¹æ®ç¨€æœ‰åº¦ï¼‰
    this.playSound(`item_drop_${data.rarity}`);
    
    // 4. å¦‚æœæ˜¯ç¨€æœ‰ç‰©å“ï¼Œæ˜¾ç¤ºé€šçŸ¥
    if (data.rarity === "legendary") {
      this.showNotification(`è·å¾— ${data.itemName}ï¼`, "legendary");
    }
  }
  
  private playPhaseTransitionAnimation(data: any): void {
    // 1. æ·¡å…¥æ·¡å‡ºæ•ˆæœ
    this.fadeToBlack(500);
    
    // 2. æ˜¾ç¤ºé˜¶æ®µæ–‡å­—
    setTimeout(() => {
      this.showPhaseText(data.toPhase);
      this.fadeFromBlack(500);
    }, 500);
    
    // 3. éŸ³æ•ˆ
    this.playSound("phase_transition");
  }
  
  private playCriticalHitAnimation(data: any): void {
    // å·²åœ¨ DamageNumberManager ä¸­å®ç°
    // è¿™é‡Œå¯ä»¥æ·»åŠ é¢å¤–çš„å±å¹•ç‰¹æ•ˆ
    this.screenFlash("#ff0000", 100);
  }
  
  private playBossSpawnAnimation(data: any): void {
    // 1. éœ‡å±
    this.cameraShake(1.0, 1000);
    
    // 2. æ˜¾ç¤º Boss åç§°
    this.showBossNameplate(data.bossName);
    
    // 3. æ’­æ”¾ Boss ç™»åœºéŸ³ä¹
    this.playMusic("boss_theme");
    
    // 4. æš—åŒ–å±å¹•è¾¹ç¼˜
    this.vignette(1.0, 500);
  }
  
  // è¾…åŠ©æ–¹æ³•ï¼ˆéœ€è¦æ ¹æ®å®é™…æ¸²æŸ“å¼•æ“å®ç°ï¼‰
  private playAnimation(name: string, entityId: string): void {}
  private showExpGain(exp: number): void {}
  private playSound(soundId: string): void {}
  private spawnParticles(particleId: string, position: any): void {}
  private dropItemFromSky(itemId: string, position: any): void {}
  private spawnGlow(position: any, color: string): void {}
  private getRarityColor(rarity: string): string { return "#ffffff"; }
  private showNotification(message: string, style: string): void {}
  private fadeToBlack(duration: number): void {}
  private fadeFromBlack(duration: number): void {}
  private showPhaseText(phase: string): void {}
  private screenFlash(color: string, duration: number): void {}
  private cameraShake(intensity: number, duration: number): void {}
  private showBossNameplate(name: string): void {}
  private playMusic(musicId: string): void {}
  private vignette(intensity: number, duration: number): void {}
}
```

---

## æ€§èƒ½ç›‘æ§

### æ¸²æŸ“æ€§èƒ½æŒ‡æ ‡

```typescript
export class RenderPerformanceMonitor {
  private frameTimes: number[] = [];
  private lastFrameTime: number = Date.now();
  private readonly sampleSize: number = 60;
  
  /**
   * è®°å½•ä¸€å¸§çš„æ¸²æŸ“æ—¶é—´
   */
  recordFrame(): void {
    const now = Date.now();
    const frameTime = now - this.lastFrameTime;
    
    this.frameTimes.push(frameTime);
    if (this.frameTimes.length > this.sampleSize) {
      this.frameTimes.shift();
    }
    
    this.lastFrameTime = now;
  }
  
  /**
   * è·å–å½“å‰ FPS
   */
  getFPS(): number {
    if (this.frameTimes.length === 0) return 0;
    
    const avgFrameTime = this.frameTimes.reduce((a, b) => a + b, 0) / this.frameTimes.length;
    return 1000 / avgFrameTime;
  }
  
  /**
   * è·å–å¸§æ—¶é—´ç»Ÿè®¡
   */
  getStats(): {
    fps: number;
    avgFrameTime: number;
    minFrameTime: number;
    maxFrameTime: number;
  } {
    if (this.frameTimes.length === 0) {
      return { fps: 0, avgFrameTime: 0, minFrameTime: 0, maxFrameTime: 0 };
    }
    
    const avgFrameTime = this.frameTimes.reduce((a, b) => a + b, 0) / this.frameTimes.length;
    const minFrameTime = Math.min(...this.frameTimes);
    const maxFrameTime = Math.max(...this.frameTimes);
    const fps = 1000 / avgFrameTime;
    
    return { fps, avgFrameTime, minFrameTime, maxFrameTime };
  }
  
  /**
   * æ£€æŸ¥æ€§èƒ½æ˜¯å¦è‰¯å¥½
   */
  isPerformanceGood(): boolean {
    return this.getFPS() >= 50; // ç›®æ ‡ 60 FPSï¼Œå…è®¸ä¸€å®šæ³¢åŠ¨
  }
}
```

### ç½‘ç»œæ€§èƒ½æŒ‡æ ‡

```typescript
export class NetworkPerformanceMonitor {
  private latencies: number[] = [];
  private frameReceiveTimes: number[] = [];
  private lastFrameReceiveTime: number = Date.now();
  
  /**
   * è®°å½•å¸§æ¥æ”¶å»¶è¿Ÿ
   * @param frameSentTime å¸§çš„æœåŠ¡å™¨å‘é€æ—¶é—´
   * @param frameReceiveTime å¸§çš„å®¢æˆ·ç«¯æ¥æ”¶æ—¶é—´
   */
  recordFrameLatency(frameSentTime: number, frameReceiveTime: number): void {
    const latency = frameReceiveTime - frameSentTime;
    this.latencies.push(latency);
    
    if (this.latencies.length > 60) {
      this.latencies.shift();
    }
  }
  
  /**
   * è®°å½•å¸§æ¥æ”¶é—´éš”
   */
  recordFrameReceive(): void {
    const now = Date.now();
    const interval = now - this.lastFrameReceiveTime;
    
    this.frameReceiveTimes.push(interval);
    if (this.frameReceiveTimes.length > 60) {
      this.frameReceiveTimes.shift();
    }
    
    this.lastFrameReceiveTime = now;
  }
  
  /**
   * è·å–å¹³å‡å»¶è¿Ÿ
   */
  getAverageLatency(): number {
    if (this.latencies.length === 0) return 0;
    return this.latencies.reduce((a, b) => a + b, 0) / this.latencies.length;
  }
  
  /**
   * è·å–å¹³å‡å¸§æ¥æ”¶é¢‘ç‡ï¼ˆHzï¼‰
   */
  getFrameReceiveRate(): number {
    if (this.frameReceiveTimes.length === 0) return 0;
    const avgInterval = this.frameReceiveTimes.reduce((a, b) => a + b, 0) / this.frameReceiveTimes.length;
    return 1000 / avgInterval;
  }
  
  /**
   * è·å–ç½‘ç»œç»Ÿè®¡
   */
  getStats(): {
    avgLatency: number;
    minLatency: number;
    maxLatency: number;
    frameReceiveRate: number;
  } {
    if (this.latencies.length === 0) {
      return { avgLatency: 0, minLatency: 0, maxLatency: 0, frameReceiveRate: 0 };
    }
    
    return {
      avgLatency: this.getAverageLatency(),
      minLatency: Math.min(...this.latencies),
      maxLatency: Math.max(...this.latencies),
      frameReceiveRate: this.getFrameReceiveRate()
    };
  }
}
```

### æ€§èƒ½é¢æ¿ UI

```typescript
export class PerformancePanel {
  private renderMonitor: RenderPerformanceMonitor;
  private networkMonitor: NetworkPerformanceMonitor;
  private panelElement: HTMLElement;
  
  constructor() {
    this.renderMonitor = new RenderPerformanceMonitor();
    this.networkMonitor = new NetworkPerformanceMonitor();
    this.panelElement = this.createPanel();
  }
  
  private createPanel(): HTMLElement {
    const panel = document.createElement("div");
    panel.id = "performance-panel";
    panel.style.cssText = `
      position: fixed;
      top: 10px;
      right: 10px;
      background: rgba(0, 0, 0, 0.8);
      color: #00ff00;
      padding: 10px;
      font-family: monospace;
      font-size: 12px;
      z-index: 9999;
    `;
    document.body.appendChild(panel);
    return panel;
  }
  
  /**
   * æ›´æ–°æ€§èƒ½é¢æ¿æ˜¾ç¤º
   */
  update(): void {
    const renderStats = this.renderMonitor.getStats();
    const networkStats = this.networkMonitor.getStats();
    
    this.panelElement.innerHTML = `
      <div><strong>Render Performance</strong></div>
      <div>FPS: ${renderStats.fps.toFixed(1)}</div>
      <div>Frame Time: ${renderStats.avgFrameTime.toFixed(1)}ms (${renderStats.minFrameTime.toFixed(0)}-${renderStats.maxFrameTime.toFixed(0)})</div>
      <br>
      <div><strong>Network Performance</strong></div>
      <div>Latency: ${networkStats.avgLatency.toFixed(1)}ms (${networkStats.minLatency.toFixed(0)}-${networkStats.maxLatency.toFixed(0)})</div>
      <div>Frame Rate: ${networkStats.frameReceiveRate.toFixed(1)} Hz</div>
    `;
  }
  
  /**
   * æ˜¾ç¤º/éšè—é¢æ¿
   */
  toggle(): void {
    this.panelElement.style.display = 
      this.panelElement.style.display === "none" ? "block" : "none";
  }
}
```

---

## æœ€ä½³å®è·µ

### 1. æ¸²æŸ“å¾ªç¯ç»“æ„

```typescript
export class BattleRenderLoop {
  private renderer: BattleRenderer;
  private animator: BattleEventAnimator;
  private performanceMonitor: RenderPerformanceMonitor;
  private isRunning: boolean = false;
  
  constructor() {
    this.renderer = new BattleRenderer(new BattleTimeManager());
    this.animator = new BattleEventAnimator();
    this.performanceMonitor = new RenderPerformanceMonitor();
  }
  
  start(): void {
    this.isRunning = true;
    this.loop();
  }
  
  stop(): void {
    this.isRunning = false;
  }
  
  private loop = (): void => {
    if (!this.isRunning) return;
    
    // æ¸²æŸ“å½“å‰çŠ¶æ€
    this.renderer.render(Date.now());
    
    // æ€§èƒ½ç›‘æ§
    this.performanceMonitor.recordFrame();
    
    // ä¸‹ä¸€å¸§
    requestAnimationFrame(this.loop);
  };
  
  onFrameTick(frame: FrameTick): void {
    this.renderer.onFrameTick(frame);
  }
  
  onKeyEvent(event: KeyEvent): void {
    this.animator.onKeyEvent(event);
  }
}
```

### 2. è‡ªé€‚åº”è´¨é‡

```typescript
export class AdaptiveQualityManager {
  private qualityLevel: number = 2; // 0=ä½, 1=ä¸­, 2=é«˜
  private performanceMonitor: RenderPerformanceMonitor;
  
  constructor(performanceMonitor: RenderPerformanceMonitor) {
    this.performanceMonitor = performanceMonitor;
  }
  
  /**
   * æ ¹æ®æ€§èƒ½è‡ªåŠ¨è°ƒæ•´è´¨é‡
   */
  update(): void {
    const fps = this.performanceMonitor.getFPS();
    
    if (fps < 40 && this.qualityLevel > 0) {
      // é™ä½è´¨é‡
      this.qualityLevel--;
      this.applyQuality(this.qualityLevel);
      console.info(`Performance drop, quality reduced to ${this.qualityLevel}`);
    } else if (fps > 55 && this.qualityLevel < 2) {
      // æå‡è´¨é‡
      this.qualityLevel++;
      this.applyQuality(this.qualityLevel);
      console.info(`Performance good, quality increased to ${this.qualityLevel}`);
    }
  }
  
  private applyQuality(level: number): void {
    switch (level) {
      case 0: // ä½è´¨é‡
        this.setParticleQuality("low");
        this.setAnimationQuality("low");
        this.setEffectQuality("low");
        break;
      case 1: // ä¸­è´¨é‡
        this.setParticleQuality("medium");
        this.setAnimationQuality("medium");
        this.setEffectQuality("medium");
        break;
      case 2: // é«˜è´¨é‡
        this.setParticleQuality("high");
        this.setAnimationQuality("high");
        this.setEffectQuality("high");
        break;
    }
  }
  
  private setParticleQuality(quality: string): void {
    // å®ç°ï¼šè°ƒæ•´ç²’å­ç³»ç»Ÿè´¨é‡
  }
  
  private setAnimationQuality(quality: string): void {
    // å®ç°ï¼šè°ƒæ•´åŠ¨ç”»è´¨é‡
  }
  
  private setEffectQuality(quality: string): void {
    // å®ç°ï¼šè°ƒæ•´ç‰¹æ•ˆè´¨é‡
  }
}
```

### 3. å‰å°/åå°è‡ªé€‚åº”

```typescript
export class VisibilityManager {
  private onVisibilityChange?: (isVisible: boolean) => void;
  
  constructor() {
    document.addEventListener("visibilitychange", () => {
      const isVisible = document.visibilityState === "visible";
      this.onVisibilityChange?.(isVisible);
    });
  }
  
  setCallback(callback: (isVisible: boolean) => void): void {
    this.onVisibilityChange = callback;
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const visibilityManager = new VisibilityManager();
visibilityManager.setCallback((isVisible) => {
  if (isVisible) {
    // åˆ‡æ¢åˆ°å‰å°ï¼šæå‡å¸§ç‡
    battleConnection.setFrequency(10);
    console.info("Switched to foreground, frame rate increased to 10Hz");
  } else {
    // åˆ‡æ¢åˆ°åå°ï¼šé™ä½å¸§ç‡
    battleConnection.setFrequency(2);
    console.info("Switched to background, frame rate reduced to 2Hz");
  }
});
```

---

## ğŸ“ æ€»ç»“

æœ¬æ–‡æ¡£æä¾›äº†å®Œæ•´çš„å‰ç«¯æ¸²æŸ“ç­–ç•¥ï¼š

âœ… **æ—¶é—´åŒæ­¥**: åŸºäºå¸§çš„æ—¶é—´æ ¡å‡†ï¼Œå‡å°‘å®¢æˆ·ç«¯-æœåŠ¡å™¨æ—¶é—´åå·®  
âœ… **æ’å€¼ç®—æ³•**: åœ¨ä¸¤å¸§ä¹‹é—´å¹³æ»‘è¿‡æ¸¡ï¼Œå®ç°æµç•…æ¸²æŸ“  
âœ… **å¤–æ¨ç®—æ³•**: åœ¨å¸§æœªåˆ°è¾¾æ—¶é¢„æµ‹çŠ¶æ€ï¼Œå‡å°‘å¡é¡¿æ„Ÿ  
âœ… **å¹³æ»‘çº æ­£**: é¿å…æƒå¨å€¼çº æ­£æ—¶çš„çªå…€è·³å˜  
âœ… **æ¼”å‡ºåˆ†çº§**: æ™®é€šä¼¤å®³åˆå¹¶ï¼Œå…³é”®äº‹ä»¶ç‹¬ç«‹åŠ¨ç”»  
âœ… **æ€§èƒ½ç›‘æ§**: å®æ—¶ç›‘æ§æ¸²æŸ“å’Œç½‘ç»œæ€§èƒ½  
âœ… **è‡ªé€‚åº”è´¨é‡**: æ ¹æ®æ€§èƒ½åŠ¨æ€è°ƒæ•´æ¸²æŸ“è´¨é‡

éµå¾ªè¿™äº›ç­–ç•¥ï¼Œå¯ä»¥å®ç°**ä½å»¶è¿Ÿã€é«˜æµç•…åº¦**çš„æˆ˜æ–—æ¸²æŸ“ä½“éªŒã€‚

---

**æ–‡æ¡£çŠ¶æ€**: âœ… å®Œæˆ  
**æœ€åæ›´æ–°**: 2025å¹´10æœˆ21æ—¥
