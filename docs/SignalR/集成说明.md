# SignalR 系统与现有架构集成说明

**文档版本**: 1.0  
**生成日期**: 2025年10月  
**目的**: 说明 SignalR 系统如何与当前项目架构集成

---

## 📁 当前项目结构分析

### 现有目录结构

```
BlazorIdle.Server/
├── Api/                    # 控制器层
│   ├── BattlesController.cs
│   ├── StepBattlesController.cs
│   └── CharactersController.cs
│
├── Application/            # 应用服务层
│   ├── Abstractions/
│   │   ├── IBattleRepository.cs
│   │   └── ICharacterRepository.cs
│   └── Battles/
│       ├── BattleRunner.cs
│       └── Step/
│           ├── StepBattleCoordinator.cs
│           ├── RunningBattle.cs
│           └── StepBattleHostedService.cs
│
├── Domain/                 # 领域模型层
│   ├── Combat/
│   │   ├── BattleAggregate.cs
│   │   ├── BattleContext.cs
│   │   ├── EventScheduler.cs
│   │   ├── SegmentCollector.cs
│   │   ├── IGameEvent.cs
│   │   ├── Skills/
│   │   ├── Buffs/
│   │   ├── Resources/
│   │   └── Professions/
│   └── Characters/
│
└── Infrastructure/         # 基础设施层
    ├── Persistence/
    │   ├── GameDbContext.cs
    │   └── Repositories/
    ├── Startup/
    └── DependencyInjection/
```

---

## 🎯 SignalR 系统集成点

### 新增目录结构

```
BlazorIdle.Server/
├── Domain/
│   └── Events/  ← 新增：领域事件定义
│       ├── IDomainEvent.cs
│       ├── INotificationEvent.cs
│       └── Combat/
│           ├── CombatSegmentFlushedEvent.cs
│           ├── BattleStartedEvent.cs
│           └── BattleEndedEvent.cs
│
├── Infrastructure/
│   └── Messaging/  ← 新增：消息基础设施
│       ├── IDomainEventBus.cs
│       ├── InMemoryEventBus.cs
│       ├── ISignalRDispatcher.cs
│       ├── SignalRDispatcher.cs
│       ├── ConnectionManager.cs
│       ├── NotificationEventSubscriber.cs
│       └── Hubs/
│           └── GameNotificationHub.cs
│
└── Api/
    └── MonitoringController.cs  ← 新增：监控端点
```

---

## 🔗 与现有代码的集成方式

### 1. Domain.Combat 层集成

#### SegmentCollector 修改（最小化）

**位置**: `Domain/Combat/SegmentCollector.cs`

**修改内容**:
```csharp
// 添加委托属性
public Action<CombatSegment>? OnSegmentFlushed { get; set; }

// 在 Flush() 方法末尾添加
public CombatSegment Flush(double currentTime)
{
    // ... 现有逻辑 ...
    
    var seg = new CombatSegment { /* ... */ };
    
    // 新增：触发回调
    OnSegmentFlushed?.Invoke(seg);
    
    Reset(currentTime);
    return seg;
}
```

**影响**: 
- ✅ 不破坏现有逻辑
- ✅ 向后兼容（委托可为 null）
- ✅ Domain 层无外部依赖

---

### 2. Application 层集成

#### StepBattleCoordinator 修改

**位置**: `Application/Battles/Step/StepBattleCoordinator.cs`

**修改内容**:

```csharp
// 1. 添加依赖注入
private readonly IDomainEventBus _eventBus;

public StepBattleCoordinator(
    IServiceScopeFactory scopeFactory,
    IDomainEventBus eventBus)  // ← 新增
{
    _scopeFactory = scopeFactory;
    _eventBus = eventBus;
}

// 2. 在 Start() 中注册回调并发布事件
public Guid Start(/* 参数 */)
{
    // ... 现有逻辑 ...
    
    var rb = new RunningBattle(/* ... */);
    
    // 新增：注册 Segment 刷新回调
    rb.Collector.OnSegmentFlushed = segment =>
    {
        PublishSegmentFlushedEvent(id, characterId, rb.Clock.CurrentTime, segment);
    };
    
    _running.TryAdd(id, rb);
    
    // 新增：发布战斗开始事件
    PublishBattleStartedEvent(id, characterId, profession, enemyId, /* ... */);
    
    return id;
}

// 3. 在 Stop() 中发布事件
public async Task<(bool, StepBattleStatusDto?)> Stop(Guid id)
{
    // ... 现有逻辑 ...
    
    // 新增：发布战斗结束事件
    if (finalStatus.found)
    {
        PublishBattleEndedEvent(rb, finalStatus.status);
    }
    
    return finalStatus;
}

// 4. 新增辅助方法
private void PublishSegmentFlushedEvent(/* 参数 */)
{
    var @event = new CombatSegmentFlushedEvent { /* ... */ };
    _eventBus.Publish(@event);
}

private void PublishBattleStartedEvent(/* 参数 */)
{
    var @event = new BattleStartedEvent { /* ... */ };
    _eventBus.Publish(@event);
}

private void PublishBattleEndedEvent(/* 参数 */)
{
    var @event = new BattleEndedEvent { /* ... */ };
    _eventBus.Publish(@event);
}
```

**影响**:
- ✅ 只在上层服务注入事件总线
- ✅ Domain 层保持纯净
- ✅ 事件发布逻辑集中管理

---

### 3. Infrastructure 层集成

#### 依赖注入配置

**位置**: `Infrastructure/DependencyInjection.cs` 或新建 `Infrastructure/DependencyInjection/MessagingExtensions.cs`

**新增内容**:

```csharp
// Infrastructure/DependencyInjection/MessagingExtensions.cs
public static class MessagingExtensions
{
    public static IServiceCollection AddMessaging(
        this IServiceCollection services,
        IConfiguration configuration)
    {
        // 事件总线
        services.AddSingleton<IDomainEventBus, InMemoryEventBus>();

        // SignalR
        services.AddSignalR(options =>
        {
            options.EnableDetailedErrors = 
                configuration.GetValue<bool>("Messaging:SignalR:EnableDetailedErrors", false);
            options.MaximumReceiveMessageSize = 128 * 1024;
            options.KeepAliveInterval = TimeSpan.FromSeconds(15);
            options.ClientTimeoutInterval = TimeSpan.FromSeconds(30);
        });

        // SignalR 分发器
        services.AddSingleton<ISignalRDispatcher, SignalRDispatcher>();

        // 连接管理器
        services.AddSingleton<ConnectionManager>();

        // 事件订阅服务
        services.AddHostedService<NotificationEventSubscriber>();

        // 监控服务（可选）
        services.AddSingleton<EventStatisticsService>();
        services.AddHostedService(sp => sp.GetRequiredService<EventStatisticsService>());

        return services;
    }
}
```

---

### 4. Program.cs 修改

**位置**: `BlazorIdle.Server/Program.cs`

**修改内容**:

```csharp
var builder = WebApplication.CreateBuilder(args);

// 现有服务注册
builder.Services.AddControllers();
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();

builder.Services
    .AddInfrastructure(builder.Configuration)
    .AddApplication()
    .AddMessaging(builder.Configuration);  // ← 新增

// CORS 配置更新（SignalR 需要 AllowCredentials）
builder.Services.AddCors(options =>
{
    options.AddPolicy("AllowBlazorClient", policy =>
    {
        policy
            .WithOrigins("https://localhost:5001", "http://localhost:5000")
            .AllowAnyHeader()
            .AllowAnyMethod()
            .AllowCredentials();  // ← 新增或确保存在
    });
});

var app = builder.Build();

// ... 现有中间件配置 ...

app.UseHttpsRedirection();
app.UseCors("AllowBlazorClient");

// 新增：映射 SignalR Hub
app.MapHub<GameNotificationHub>("/hubs/notifications");

app.MapControllers();
app.Run();
```

**影响**:
- ✅ 最小化修改
- ✅ 模块化配置
- ✅ 易于启用/禁用

---

## 🧪 验证集成正确性

### 步骤 1: 编译检查

```bash
cd /home/runner/work/BlazorIdle/BlazorIdle
dotnet build
```

**期望**: 无编译错误

---

### 步骤 2: 启动服务器

```bash
dotnet run --project BlazorIdle.Server
```

**期望**: 
- 服务正常启动
- 日志显示 `NotificationEventSubscriber started`
- 无异常抛出

---

### 步骤 3: 检查 SignalR Hub 端点

```bash
curl https://localhost:7001/hubs/notifications
```

**期望**: 返回 SignalR 协商响应（非 404）

---

### 步骤 4: 测试事件发布

创建测试控制器：

```csharp
// Api/TestController.cs
[ApiController]
[Route("api/test")]
public class TestController : ControllerBase
{
    private readonly IDomainEventBus _eventBus;

    public TestController(IDomainEventBus eventBus)
    {
        _eventBus = eventBus;
    }

    [HttpPost("publish-event")]
    public IActionResult PublishTestEvent()
    {
        var @event = new BattleStartedEvent
        {
            EventId = Guid.NewGuid(),
            OccurredAtUtc = DateTime.UtcNow,
            CharacterId = Guid.NewGuid(),
            BattleId = Guid.NewGuid(),
            Profession = Profession.Warrior,
            EnemyId = "dummy",
            EnemyCount = 1,
            Mode = "test",
            DungeonId = null
        };

        _eventBus.Publish(@event);

        return Ok(new { message = "Event published", eventId = @event.EventId });
    }
}
```

**测试**:
```bash
curl -X POST https://localhost:7001/api/test/publish-event
```

**期望**: 
- 返回成功响应
- 日志显示事件被处理
- 如有 SignalR 客户端连接，应收到推送

---

## 📊 与现有代码的兼容性检查表

### Domain 层

- [x] `IGameEvent` 接口保持不变
- [x] `EventScheduler` 逻辑不受影响
- [x] `BattleRunner` 执行流程不变
- [x] `SegmentCollector` 仅添加委托（可选）
- [x] 所有战斗逻辑保持原样

**结论**: ✅ 完全兼容，无破坏性修改

---

### Application 层

- [x] `BattleRunner` 使用方式不变
- [x] `StepBattleCoordinator` 添加事件发布逻辑
- [x] 现有 API 端点保持不变
- [x] Repository 接口无修改

**结论**: ✅ 最小化修改，向后兼容

---

### Infrastructure 层

- [x] `GameDbContext` 无修改
- [x] Repository 实现无修改
- [x] 现有服务注册保持不变
- [x] 新增服务通过扩展方法独立注册

**结论**: ✅ 模块化扩展，不影响现有功能

---

### Api 层

- [x] 现有控制器无需修改
- [x] 现有端点继续工作
- [x] 新增监控端点独立
- [x] 客户端调用方式不变

**结论**: ✅ 完全兼容

---

## 🎨 代码风格一致性

### 命名规范

SignalR 系统遵循现有命名规范：

| 类型 | 现有示例 | SignalR 系统 |
|------|---------|-------------|
| 接口 | `IGameEvent`, `IBattleRepository` | `IDomainEvent`, `ISignalRDispatcher` |
| 实现类 | `EventScheduler`, `BattleRunner` | `InMemoryEventBus`, `SignalRDispatcher` |
| 领域模型 | `Battle`, `CombatSegment` | `BattleStartedEvent`, `CombatSegmentData` |
| 服务 | `StepBattleCoordinator` | `NotificationEventSubscriber` |

**结论**: ✅ 一致

---

### 代码组织

```
现有模式:
Domain/
  Combat/
    BattleAggregate.cs      (聚合根)
    SegmentCollector.cs     (值对象/服务)
    IGameEvent.cs           (接口)

SignalR 模式:
Domain/
  Events/
    IDomainEvent.cs         (接口)
    Combat/
      BattleStartedEvent.cs (事件)
```

**结论**: ✅ 遵循现有分层和模块划分

---

### 依赖注入模式

```csharp
// 现有模式
public class StepBattleCoordinator
{
    private readonly IServiceScopeFactory _scopeFactory;
    
    public StepBattleCoordinator(IServiceScopeFactory scopeFactory)
    {
        _scopeFactory = scopeFactory;
    }
}

// SignalR 系统（一致）
public class SignalRDispatcher : ISignalRDispatcher
{
    private readonly IHubContext<GameNotificationHub> _hubContext;
    private readonly ILogger<SignalRDispatcher> _logger;
    
    public SignalRDispatcher(
        IHubContext<GameNotificationHub> hubContext,
        ILogger<SignalRDispatcher> logger)
    {
        _hubContext = hubContext;
        _logger = logger;
    }
}
```

**结论**: ✅ 完全一致

---

## 🔍 潜在问题和解决方案

### 问题 1: 事件总线线程安全

**描述**: 多个战斗实例并发发布事件

**解决方案**:
- 使用 `Channel<T>` 实现异步队列
- 单一处理线程消费事件
- 无锁数据结构（`ConcurrentDictionary`）

**状态**: ✅ 已在设计中解决

---

### 问题 2: SignalR 连接状态管理

**描述**: 客户端断线后重连，可能丢失消息

**解决方案**:
- 自动重连机制（SignalR 内置）
- 客户端缓冲队列
- 可选：消息序列号和补发机制

**状态**: ✅ 已在设计中考虑

---

### 问题 3: 性能影响

**描述**: 频繁推送可能影响战斗计算性能

**解决方案**:
- 事件发布异步执行
- Segment 聚合减少推送频率
- 批量发送优化
- 优先级队列控制

**状态**: ✅ 已优化

---

## 📈 性能评估

### 预期性能指标

| 指标 | 目标值 | 实测值（待验证） |
|------|--------|-----------------|
| 消息延迟 (P99) | < 500ms | - |
| 战斗性能影响 | < 5% | - |
| 并发连接数 | > 1000 | - |
| 内存占用（1000连接） | < 500MB | - |
| CPU 占用（空闲） | < 20% | - |

---

### 性能测试建议

```csharp
// 1. 战斗性能测试
// 对比启用/禁用事件发布的战斗执行时间

// 2. SignalR 推送性能测试
// 测试大量并发连接时的吞吐量

// 3. 内存泄漏测试
// 长时间运行检查内存增长

// 4. 压力测试
// 模拟高频率战斗和推送场景
```

---

## ✅ 集成检查清单

### Phase 1 完成检查

- [ ] Domain 层事件接口定义
- [ ] Infrastructure 层事件总线实现
- [ ] SignalR Hub 创建和配置
- [ ] SignalR 分发器实现
- [ ] 连接管理器实现
- [ ] 依赖注入配置
- [ ] Program.cs 集成
- [ ] 单元测试通过
- [ ] 集成测试通过
- [ ] 文档完整

---

### Phase 2 完成检查

- [ ] 战斗事件定义
- [ ] SegmentCollector 集成
- [ ] StepBattleCoordinator 集成
- [ ] 客户端服务实现
- [ ] UI 集成测试
- [ ] 性能测试通过
- [ ] 向后兼容性验证
- [ ] 文档更新

---

### Phase 3 完成检查

- [ ] 优先级支持实现
- [ ] 监控端点创建
- [ ] 统计服务实现
- [ ] 健康检查实现
- [ ] 扩展文档完善
- [ ] 示例代码齐全
- [ ] 最佳实践文档

---

## 📞 技术支持

如在集成过程中遇到问题：

1. **查阅设计文档**: 查看对应 Phase 的详细说明
2. **检查代码示例**: 文档中提供了完整的代码示例
3. **参考现有代码**: 遵循项目现有的代码风格和模式
4. **查看日志**: 启用详细日志查看事件流转
5. **单元测试**: 编写测试验证集成点

---

## 🎉 总结

SignalR 推送系统设计：

✅ **最小化侵入性** - Domain 层几乎无修改  
✅ **遵循现有架构** - 分层清晰，职责明确  
✅ **保持代码风格** - 命名、组织、模式一致  
✅ **向后兼容** - 不破坏现有功能  
✅ **易于扩展** - 新增事件类型简单  
✅ **高性能** - 异步、批量、聚合优化  

可以安全、渐进式地集成到现有项目中！🚀
