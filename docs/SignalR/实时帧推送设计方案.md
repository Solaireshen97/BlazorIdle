# BlazorIdle 实时帧推送设计方案

**文档版本**: 2.0  
**生成日期**: 2025年10月  
**状态**: 设计规划 - 修订版  
**目标**: 基于固定频率帧广播的低延迟实时战斗推送系统

---

## 📚 设计背景与目标

### 原设计的问题

1. **轮询降级不需要**: 后续前端的轮询功能将被 SignalR 完全替代，无需保留轮询退级功能
2. **CombatSegment 延迟问题**: 聚合多个原子事件后推送会造成显著延迟，无法满足低延迟实时更新需求
3. **缺少平滑渲染**: 前端需要及时获取战斗信息更新，实现流畅的战斗演出

### 新设计目标

✅ **持续 SignalR 事件流**: 完全替代轮询，连接失败时直接重连或返回失败  
✅ **低延迟推送**: 5-10Hz 固定频率帧广播，延迟 < 200ms  
✅ **平滑渲染**: 前端基于时间插值和外推，实现流畅战斗效果  
✅ **可靠传输**: 版本号机制处理乱序/丢包，支持差异补发和快照恢复  
✅ **灵活节流**: 根据前台/后台和设备性能动态调整推送频率

---

## 🏗️ 整体架构

### 核心组件

```
┌─────────────────────────────────────────────────────────┐
│  Blazor WebAssembly Client                              │
│                                                          │
│  ┌────────────────────────────────────────────────┐     │
│  │  BattleFrameReceiver                           │     │
│  │  - 接收 FrameTick、KeyEvent、Snapshot         │     │
│  │  - 维护 lastVersion                           │     │
│  │  - 检测版本缺口，请求补发/快照                 │     │
│  └──────────────────┬─────────────────────────────┘     │
│                     │                                   │
│  ┌──────────────────▼─────────────────────────────┐     │
│  │  BattleStateManager                            │     │
│  │  - 维护客户端战斗状态                          │     │
│  │  - 时间偏移校准（serverTime vs clientTime）    │     │
│  │  - 应用 FrameTick 更新                         │     │
│  └──────────────────┬─────────────────────────────┘     │
│                     │                                   │
│  ┌──────────────────▼─────────────────────────────┐     │
│  │  BattleRenderer                                │     │
│  │  - 插值/外推绘制进度与数值                      │     │
│  │  - 平滑纠正到权威值                            │     │
│  │  - 演出节奏控制（合并普通伤害，独立关键事件）    │     │
│  └────────────────────────────────────────────────┘     │
│                                                          │
└────────────────────┬─────────────────────────────────────┘
                     │ SignalR WebSocket (无轮询降级)
┌────────────────────▼─────────────────────────────────────┐
│  ASP.NET Core Server                                     │
│                                                          │
│  ┌────────────────────────────────────────────────┐     │
│  │  BattleHub (SignalR Hub)                       │     │
│  │  - 管理 battle group（每战斗一个 group）       │     │
│  │  - 玩家加入/离开 group                         │     │
│  │  - 推送 FrameTick、KeyEvent、Snapshot         │     │
│  │  - 处理补发请求                                │     │
│  └──────────────────┬─────────────────────────────┘     │
│                     │                                   │
│  ┌──────────────────▼─────────────────────────────┐     │
│  │  BattleFrameBroadcaster                        │     │
│  │  - 固定频率广播（5-10Hz）                      │     │
│  │  - 生成 FrameTick                              │     │
│  │  - 节流与频率调整                              │     │
│  └──────────────────┬─────────────────────────────┘     │
│                     │                                   │
│  ┌──────────────────▼─────────────────────────────┐     │
│  │  BattleFrameBuffer                             │     │
│  │  - 缓存最近 N 个帧（用于补发）                  │     │
│  │  - 周期生成 Snapshot                           │     │
│  │  - 维护 currentVersion                         │     │
│  └──────────────────┬─────────────────────────────┘     │
│                     │                                   │
│  ┌──────────────────▼─────────────────────────────┐     │
│  │  BattleRunner (Domain)                         │     │
│  │  - 战斗逻辑执行                                │     │
│  │  - 产生关键事件（怪物死亡、掉落、阶段切换）     │     │
│  │  - 更新战斗状态（HP、资源、Buff/Debuff）       │     │
│  └────────────────────────────────────────────────┘     │
│                                                          │
└──────────────────────────────────────────────────────────┘
```

---

## 📊 帧类型定义

### 1. FrameTick（固定频率广播帧）

**推送频率**: 5–10Hz（100-200ms 间隔）  
**作用**: 提供战斗状态的持续更新，支持前端平滑渲染

#### 数据结构

```typescript
interface FrameTick {
  // ===== Header =====
  version: number;           // 单调递增版本号
  serverTime: number;        // 服务器时间戳 (ms)
  battleId: string;          // 战斗实例 ID
  phase: BattlePhase;        // 战斗阶段 (active/paused/ended)
  
  // ===== Metrics =====
  metrics: {
    // 进度类
    castProgress?: {         // 读条进度（如果有）
      skillId: string;
      progress: number;      // 0.0 - 1.0
      remaining: number;     // 剩余时间 (ms)
    };
    
    // DPS 统计
    dps: {
      player: number;        // 玩家 DPS
      received: number;      // 承受 DPS
    };
    
    // 血量与护盾
    health: {
      current: number;
      max: number;
      delta: number;         // 本帧变化量
    };
    shield: {
      current: number;
      delta: number;
    };
    
    // Buff/Debuff 列表（仅发送变化项）
    buffs?: BuffChange[];    // 新增/刷新的 Buff
    debuffs?: BuffChange[];  // 新增/刷新的 Debuff
    expiredBuffs?: string[]; // 过期的 Buff ID 列表
  };
  
  // ===== Aggregates =====
  aggregates: {
    windowStart: number;     // 统计窗口起始时间
    windowEnd: number;       // 统计窗口结束时间
    damage: {
      total: number;         // 本窗口累计伤害
      bySkill: Record<string, number>; // 按技能分类
      byType: Record<string, number>;  // 按伤害类型分类
    };
    healing: {
      total: number;
      selfHeal: number;
      received: number;
    };
    hits: {
      total: number;
      critical: number;
      miss: number;
    };
  };
  
  // ===== Events =====
  events?: KeyEvent[];       // 本帧携带的关键事件（可选）
}

enum BattlePhase {
  Active = "active",
  Paused = "paused",
  Ended = "ended"
}

interface BuffChange {
  buffId: string;
  stacks: number;
  duration: number;          // 剩余持续时间 (ms)
  appliedAt: number;         // 应用时间
}
```

#### 推送策略

```
正常前台：10Hz (每 100ms)
网络好/设备好：可达 10Hz 上限
默认配置：5-8Hz 足够平滑

后台或低性能：降频到 2Hz (每 500ms)
关键事件：仍即时发送（不受节流限制）
```

---

### 2. KeyEvent（关键事件）

**推送时机**: 立即推送，不受频率限制  
**作用**: 通知重要战斗事件，前端可独立展示动画

#### 事件类型

```typescript
interface KeyEvent {
  eventId: string;
  version: number;           // 事件版本号（与 FrameTick 共享版本序列）
  timestamp: number;         // 服务器时间戳
  battleId: string;
  eventType: KeyEventType;
  data: any;                 // 事件特定数据
}

enum KeyEventType {
  MonsterDeath = "monster_death",      // 怪物死亡
  ItemDrop = "item_drop",              // 物品掉落
  PhaseTransition = "phase_transition", // 阶段转换
  SkillCastComplete = "skill_cast_complete", // 技能读条完成
  CriticalHit = "critical_hit",        // 暴击
  PlayerDeath = "player_death",        // 玩家死亡
  BossSpawn = "boss_spawn",            // Boss 出现
  AchievementUnlock = "achievement_unlock" // 成就解锁
}
```

#### 示例事件数据

```typescript
// 怪物死亡事件
interface MonsterDeathEvent extends KeyEvent {
  eventType: KeyEventType.MonsterDeath;
  data: {
    monsterId: string;
    monsterName: string;
    killerId: string;      // 击杀者 ID
    position?: Vector3;    // 死亡位置（如果有）
    experience: number;    // 获得经验
  };
}

// 物品掉落事件
interface ItemDropEvent extends KeyEvent {
  eventType: KeyEventType.ItemDrop;
  data: {
    itemId: string;
    itemName: string;
    rarity: string;        // common/rare/epic/legendary
    quantity: number;
    autoPickup: boolean;   // 是否自动拾取
  };
}

// 阶段转换事件
interface PhaseTransitionEvent extends KeyEvent {
  eventType: KeyEventType.PhaseTransition;
  data: {
    fromPhase: string;
    toPhase: string;
    reason: string;        // timeout/cleared/failed
  };
}
```

#### 关键事件可附加在 FrameTick 中

为减少网络开销，非紧急关键事件可附加在下一个 FrameTick 的 `events` 字段中一起发送。

```
紧急事件（立即发送）：
  - 玩家死亡
  - Boss 出现
  - 成就解锁

可延迟事件（附加在 FrameTick）：
  - 普通怪物死亡
  - 普通物品掉落
  - 技能读条完成
```

---

### 3. Snapshot（快照）

**推送时机**: 
- 定期快照：每 30-60 秒
- 异常恢复：客户端请求或检测到版本缺口过大时

**作用**: 提供完整战斗状态，用于快速恢复

#### 数据结构

```typescript
interface BattleSnapshot {
  version: number;           // 快照版本号
  serverTime: number;
  battleId: string;
  
  // 完整战斗状态
  state: {
    phase: BattlePhase;
    elapsedTime: number;     // 战斗已进行时间 (ms)
    
    // 玩家状态
    player: {
      health: { current: number; max: number; };
      shield: number;
      resources: Record<string, number>; // 资源（怒气、法力等）
      buffs: BuffSnapshot[];
      debuffs: BuffSnapshot[];
      position?: Vector3;
    };
    
    // 敌人状态
    enemies: EnemySnapshot[];
    
    // 统计数据
    statistics: {
      totalDamage: number;
      totalHealing: number;
      totalHits: number;
      criticalHits: number;
      killCount: number;
      deathCount: number;
    };
  };
}

interface BuffSnapshot {
  buffId: string;
  stacks: number;
  remainingDuration: number;
  appliedAt: number;
}

interface EnemySnapshot {
  enemyId: string;
  enemyType: string;
  health: { current: number; max: number; };
  position?: Vector3;
  buffs: BuffSnapshot[];
}
```

#### 快照策略

```
定期快照（每 30-60 秒）：
  - 减少版本缺口补发压力
  - 支持长时间战斗

差异补发失败时：
  - 当客户端请求补发版本范围 > 100 时
  - 直接发送最新快照

客户端重连时：
  - 携带 lastVersion
  - 如果 lastVersion 过旧（> 300），发送快照
  - 否则补发增量帧
```

---

## 🔄 版本机制与消息顺序

### 版本号设计

```
每个战斗实例维护一个单调递增的版本号：
  - FrameTick: 每帧 version++
  - KeyEvent: 即时事件也分配 version
  - Snapshot: 快照记录当前 version

示例序列：
  version=1  -> FrameTick
  version=2  -> FrameTick
  version=3  -> KeyEvent (MonsterDeath)
  version=4  -> FrameTick (可能携带 version=3 的事件)
  version=5  -> FrameTick
  ...
  version=100 -> Snapshot
```

### 客户端版本管理

```typescript
class BattleFrameReceiver {
  private lastVersion: number = 0;
  private maxGapBeforeSnapshot: number = 100;
  
  onFrameReceived(frame: FrameTick | KeyEvent) {
    const receivedVersion = frame.version;
    
    if (receivedVersion === this.lastVersion + 1) {
      // 正常情况：顺序接收
      this.applyFrame(frame);
      this.lastVersion = receivedVersion;
    }
    else if (receivedVersion > this.lastVersion + 1) {
      // 检测到版本缺口
      const gap = receivedVersion - this.lastVersion;
      
      if (gap > this.maxGapBeforeSnapshot) {
        // 缺口过大，请求快照
        this.requestSnapshot(this.lastVersion);
      } else {
        // 请求差异补发
        this.requestDeltaFrames(this.lastVersion + 1, receivedVersion - 1);
      }
      
      // 临时缓存当前帧（等待补发后应用）
      this.bufferOutOfOrderFrame(frame);
    }
    else if (receivedVersion <= this.lastVersion) {
      // 重复包或乱序旧包，直接丢弃
      console.warn(`Discarding duplicate/old frame: ${receivedVersion}`);
    }
  }
  
  onSnapshotReceived(snapshot: BattleSnapshot) {
    // 应用快照，直接更新到最新状态
    this.applySnapshot(snapshot);
    this.lastVersion = snapshot.version;
    this.clearBufferedFrames(); // 清空缓存的乱序帧
  }
  
  onDeltaFramesReceived(frames: FrameTick[]) {
    // 按顺序应用补发的帧
    for (const frame of frames.sort((a, b) => a.version - b.version)) {
      if (frame.version === this.lastVersion + 1) {
        this.applyFrame(frame);
        this.lastVersion = frame.version;
      }
    }
    
    // 尝试应用之前缓存的乱序帧
    this.flushBufferedFrames();
  }
}
```

### 服务端补发机制

```typescript
class BattleFrameBuffer {
  private frameHistory: Map<number, FrameTick> = new Map();
  private maxHistorySize: number = 300; // 保留最近 300 帧
  private latestSnapshot: BattleSnapshot | null = null;
  
  addFrame(frame: FrameTick) {
    this.frameHistory.set(frame.version, frame);
    
    // 清理过旧的历史帧
    if (this.frameHistory.size > this.maxHistorySize) {
      const oldestVersion = Math.min(...this.frameHistory.keys());
      this.frameHistory.delete(oldestVersion);
    }
  }
  
  getDeltaFrames(fromVersion: number, toVersion: number): FrameTick[] {
    const frames: FrameTick[] = [];
    
    for (let v = fromVersion; v <= toVersion; v++) {
      const frame = this.frameHistory.get(v);
      if (frame) {
        frames.push(frame);
      } else {
        // 部分帧已被清理，返回空表示需要快照
        return [];
      }
    }
    
    return frames;
  }
  
  getSnapshot(): BattleSnapshot | null {
    return this.latestSnapshot;
  }
  
  updateSnapshot(snapshot: BattleSnapshot) {
    this.latestSnapshot = snapshot;
  }
}
```

---

## 🔌 断线重连流程

### 客户端重连策略

```typescript
class BattleConnection {
  private reconnectAttempts: number = 0;
  private maxReconnectAttempts: number = 5;
  private reconnectDelays: number[] = [0, 2000, 5000, 10000, 20000]; // ms
  
  async onDisconnected() {
    console.warn("Battle connection lost, attempting to reconnect...");
    
    while (this.reconnectAttempts < this.maxReconnectAttempts) {
      const delay = this.reconnectDelays[this.reconnectAttempts] || 20000;
      await this.sleep(delay);
      
      try {
        await this.reconnect();
        console.info("Reconnected successfully");
        
        // 重连成功，携带 lastVersion 恢复数据
        await this.syncAfterReconnect();
        return;
      } catch (error) {
        this.reconnectAttempts++;
        console.error(`Reconnect attempt ${this.reconnectAttempts} failed:`, error);
      }
    }
    
    // 重连失败
    this.onReconnectFailed();
  }
  
  async syncAfterReconnect() {
    const lastVersion = this.frameReceiver.getLastVersion();
    
    // 请求同步（服务端会判断是补发增量还是快照）
    await this.hub.invoke("SyncBattleState", this.battleId, lastVersion);
  }
  
  onReconnectFailed() {
    // 显示连接失败提示，允许用户手动重试或退出战斗
    this.ui.showConnectionError({
      message: "无法连接到战斗服务器",
      actions: ["重试", "退出战斗"]
    });
  }
}
```

### 服务端同步处理

```csharp
// BattleHub.cs
public async Task SyncBattleState(string battleId, long clientLastVersion)
{
    var battle = _battleManager.GetBattle(battleId);
    if (battle == null)
    {
        await Clients.Caller.SendAsync("OnBattleNotFound", battleId);
        return;
    }
    
    var currentVersion = battle.CurrentVersion;
    var versionGap = currentVersion - clientLastVersion;
    
    if (versionGap <= 0)
    {
        // 客户端已是最新，无需同步
        await Clients.Caller.SendAsync("OnSyncComplete", currentVersion);
        return;
    }
    
    // 判断是否需要发送快照
    const long SnapshotThreshold = 300;
    
    if (versionGap > SnapshotThreshold || clientLastVersion == 0)
    {
        // 发送快照
        var snapshot = battle.GenerateSnapshot();
        await Clients.Caller.SendAsync("OnBattleSnapshot", snapshot);
    }
    else
    {
        // 补发增量帧
        var deltaFrames = battle.GetDeltaFrames(clientLastVersion + 1, currentVersion);
        
        if (deltaFrames.Count == 0)
        {
            // 增量帧已被清理，降级为快照
            var snapshot = battle.GenerateSnapshot();
            await Clients.Caller.SendAsync("OnBattleSnapshot", snapshot);
        }
        else
        {
            await Clients.Caller.SendAsync("OnDeltaFrames", deltaFrames);
        }
    }
    
    await Clients.Caller.SendAsync("OnSyncComplete", currentVersion);
}
```

---

## 🎨 前端渲染策略

### 时间同步

```typescript
class BattleTimeManager {
  private serverTimeOffset: number = 0; // 服务器时间 - 客户端时间
  private offsetSamples: number[] = [];
  private maxSamples: number = 10;
  
  // 根据 FrameTick 中的 serverTime 校准时间偏移
  calibrateTime(serverTime: number) {
    const clientTime = Date.now();
    const offset = serverTime - clientTime;
    
    this.offsetSamples.push(offset);
    if (this.offsetSamples.length > this.maxSamples) {
      this.offsetSamples.shift();
    }
    
    // 使用中位数减少抖动
    this.serverTimeOffset = this.median(this.offsetSamples);
  }
  
  getServerTime(): number {
    return Date.now() + this.serverTimeOffset;
  }
  
  private median(values: number[]): number {
    const sorted = [...values].sort((a, b) => a - b);
    const mid = Math.floor(sorted.length / 2);
    return sorted.length % 2 === 0
      ? (sorted[mid - 1] + sorted[mid]) / 2
      : sorted[mid];
  }
}
```

### 插值与外推

```typescript
class BattleRenderer {
  private previousState: BattleState;
  private currentState: BattleState;
  private nextState: BattleState | null = null;
  
  private interpolationDelay: number = 100; // ms，延迟用于插值
  
  onFrameTick(frame: FrameTick) {
    // 更新状态快照
    this.previousState = this.currentState;
    this.currentState = this.nextState || this.currentState;
    this.nextState = this.extractState(frame);
  }
  
  render(renderTime: number) {
    const serverTime = this.timeManager.getServerTime();
    const targetTime = serverTime - this.interpolationDelay;
    
    // 插值渲染
    if (this.nextState && targetTime >= this.currentState.timestamp) {
      const t = (targetTime - this.currentState.timestamp) 
                / (this.nextState.timestamp - this.currentState.timestamp);
      const clampedT = Math.min(Math.max(t, 0), 1);
      
      this.renderInterpolated(this.currentState, this.nextState, clampedT);
    } else {
      // 外推渲染（网络延迟或帧未到达）
      const extrapolationTime = targetTime - this.currentState.timestamp;
      this.renderExtrapolated(this.currentState, extrapolationTime);
    }
  }
  
  renderInterpolated(from: BattleState, to: BattleState, t: number) {
    // 线性插值关键数值
    const health = this.lerp(from.health, to.health, t);
    const castProgress = this.lerp(from.castProgress || 0, to.castProgress || 0, t);
    
    this.ui.updateHealthBar(health);
    this.ui.updateCastBar(castProgress);
    
    // Buff/Debuff 使用离散状态（不插值）
    this.ui.updateBuffs(to.buffs);
  }
  
  renderExtrapolated(state: BattleState, deltaTime: number) {
    // 简单外推：假设线性变化
    // 注意：外推应保守，避免与权威值偏差过大
    
    if (state.castProgress !== null && state.castProgress < 1.0) {
      const extrapolatedProgress = state.castProgress + (deltaTime / state.castDuration);
      this.ui.updateCastBar(Math.min(extrapolatedProgress, 1.0));
    }
    
    // 其他数值保持不变（等待权威更新）
    this.ui.updateHealthBar(state.health);
  }
  
  // 平滑纠正到权威值
  smoothCorrect(displayValue: number, authorityValue: number, deltaTime: number): number {
    const error = authorityValue - displayValue;
    const correctionSpeed = 5.0; // 每秒纠正速度
    
    if (Math.abs(error) < 0.01) {
      return authorityValue;
    }
    
    const correction = error * correctionSpeed * (deltaTime / 1000);
    return displayValue + correction;
  }
  
  private lerp(a: number, b: number, t: number): number {
    return a + (b - a) * t;
  }
}
```

### 演出节奏控制

```typescript
class BattleFXManager {
  private damageQueue: DamageEvent[] = [];
  private criticalQueue: CriticalEvent[] = [];
  
  onFrameTick(frame: FrameTick) {
    // 普通伤害：合并为单个数字飘字
    if (frame.aggregates.damage.total > 0) {
      this.showMergedDamage(frame.aggregates.damage.total);
    }
  }
  
  onKeyEvent(event: KeyEvent) {
    switch (event.eventType) {
      case KeyEventType.CriticalHit:
        // 暴击：独立动画，震屏效果
        this.playCriticalAnimation(event.data);
        break;
      
      case KeyEventType.MonsterDeath:
        // 怪物死亡：播放死亡动画
        this.playDeathAnimation(event.data);
        break;
      
      case KeyEventType.ItemDrop:
        // 物品掉落：闪光特效 + 声音
        this.playItemDropFX(event.data);
        break;
      
      default:
        this.playGenericEventFX(event);
    }
  }
  
  private showMergedDamage(totalDamage: number) {
    // 在敌人头顶显示合并后的伤害数字
    this.damageText.show(totalDamage, { color: "white", fontSize: 24 });
  }
  
  private playCriticalAnimation(data: any) {
    // 显著的暴击效果
    this.damageText.show(data.damage, {
      color: "red",
      fontSize: 36,
      shake: true,
      particles: true
    });
    this.camera.shake(0.5, 200); // 震屏
    this.audio.play("critical_hit");
  }
}
```

---

## 🎛️ 频率与节流策略

### 动态频率调整

```typescript
class BattleFrameScheduler {
  private baseFrequency: number = 10; // Hz
  private currentFrequency: number = 10;
  private minFrequency: number = 2;
  private maxFrequency: number = 10;
  
  // 根据性能和网络状态调整频率
  adjustFrequency() {
    const isForeground = document.visibilityState === "visible";
    const fps = this.performanceMonitor.getFPS();
    const latency = this.networkMonitor.getLatency();
    
    if (!isForeground) {
      // 后台：降低到 2Hz
      this.currentFrequency = 2;
    } else if (fps < 30 || latency > 300) {
      // 低性能/高延迟：降低频率
      this.currentFrequency = Math.max(this.minFrequency, this.currentFrequency - 1);
    } else if (fps > 50 && latency < 100) {
      // 高性能/低延迟：提升频率
      this.currentFrequency = Math.min(this.maxFrequency, this.currentFrequency + 1);
    }
    
    // 通知服务器调整推送频率
    this.hub.invoke("SetFrameFrequency", this.currentFrequency);
  }
}
```

### 服务端节流

```csharp
// BattleFrameBroadcaster.cs
public class BattleFrameBroadcaster : BackgroundService
{
    private readonly IHubContext<BattleHub> _hubContext;
    private readonly ConcurrentDictionary<string, BattleFrameConfig> _battleConfigs;
    
    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        while (!stoppingToken.IsCancellationRequested)
        {
            foreach (var (battleId, config) in _battleConfigs)
            {
                var interval = 1000 / config.Frequency; // ms
                
                if (DateTime.UtcNow - config.LastBroadcast >= TimeSpan.FromMilliseconds(interval))
                {
                    await BroadcastFrame(battleId, config);
                    config.LastBroadcast = DateTime.UtcNow;
                }
            }
            
            await Task.Delay(10, stoppingToken); // 高精度轮询
        }
    }
    
    private async Task BroadcastFrame(string battleId, BattleFrameConfig config)
    {
        var battle = _battleManager.GetBattle(battleId);
        if (battle == null) return;
        
        // 生成 FrameTick
        var frame = battle.GenerateFrameTick();
        
        // 帧合并：如果有积压的关键事件，附加到本帧
        var pendingEvents = battle.GetPendingKeyEvents();
        if (pendingEvents.Count > 0)
        {
            frame.Events = pendingEvents;
            battle.ClearPendingKeyEvents();
        }
        
        // 推送到 group
        await _hubContext.Clients.Group(battleId).SendAsync("OnFrameTick", frame);
        
        // 缓存帧（用于补发）
        battle.BufferFrame(frame);
    }
    
    public void SetBattleFrequency(string battleId, int frequency)
    {
        if (_battleConfigs.TryGetValue(battleId, out var config))
        {
            config.Frequency = Math.Clamp(frequency, 2, 10);
        }
    }
}

public class BattleFrameConfig
{
    public int Frequency { get; set; } = 8; // 默认 8Hz
    public DateTime LastBroadcast { get; set; }
}
```

---

## 🔐 连接失败处理

### 完全移除轮询降级

原设计中的轮询降级逻辑**完全移除**，SignalR 连接失败时：

1. **立即重试**: 按指数退避策略重连（0s → 2s → 5s → 10s → 20s）
2. **重连次数限制**: 最多 5 次重连尝试
3. **失败后提示**: 显示连接失败对话框，提供"重试"和"退出战斗"选项

```typescript
// 无轮询降级
class BattleConnection {
  // ❌ 移除：pollBattleState() 方法
  // ❌ 移除：fallbackToPolling() 方法
  
  // ✅ 保留：纯 SignalR 重连逻辑
  async onDisconnected() {
    // 仅重连 SignalR，不降级到轮询
    await this.retryConnection();
  }
  
  async retryConnection() {
    for (let i = 0; i < this.maxRetries; i++) {
      try {
        await this.connection.start();
        return; // 成功
      } catch {
        await this.sleep(this.retryDelays[i]);
      }
    }
    
    // 重连失败
    this.showConnectionFailure();
  }
  
  showConnectionFailure() {
    this.ui.showModal({
      title: "连接失败",
      message: "无法连接到战斗服务器，请检查网络连接",
      buttons: [
        { text: "重试", action: () => this.retryConnection() },
        { text: "退出战斗", action: () => this.exitBattle() }
      ]
    });
  }
}
```

### 服务端连接监控

```csharp
// BattleHub.cs
public override async Task OnConnectedAsync()
{
    var userId = Context.User?.FindFirst("sub")?.Value;
    if (string.IsNullOrEmpty(userId))
    {
        Context.Abort();
        return;
    }
    
    _logger.LogInformation("User {UserId} connected to BattleHub", userId);
    await base.OnConnectedAsync();
}

public override async Task OnDisconnectedAsync(Exception? exception)
{
    var userId = Context.User?.FindFirst("sub")?.Value;
    
    if (exception != null)
    {
        _logger.LogWarning(exception, "User {UserId} disconnected with error", userId);
    }
    else
    {
        _logger.LogInformation("User {UserId} disconnected normally", userId);
    }
    
    // 清理用户的 battle group 订阅
    await CleanupUserBattles(userId);
    
    await base.OnDisconnectedAsync(exception);
}
```

---

## 📈 性能优化

### 帧合并策略

```
场景 1：50ms 内产生多个关键事件
  → 合并为下一个 FrameTick 的 events 字段携带

场景 2：服务器负载高
  → 允许延迟一个 Tick 周期合并发送
  → 优先保证 FrameTick 频率稳定

场景 3：紧急关键事件（玩家死亡、Boss 出现）
  → 立即单独发送，不等待合并
```

### 带宽优化

```typescript
// 仅发送变化的 Buff/Debuff
interface FrameTick {
  metrics: {
    buffs?: BuffChange[];      // 新增或刷新的
    expiredBuffs?: string[];   // 过期的 ID 列表（仅 ID）
  };
}

// 客户端维护完整 Buff 列表
class BuffManager {
  private activeBuffs: Map<string, BuffState> = new Map();
  
  applyBuffChanges(changes: BuffChange[], expired: string[]) {
    // 应用新增/刷新
    for (const change of changes) {
      this.activeBuffs.set(change.buffId, {
        stacks: change.stacks,
        duration: change.duration,
        appliedAt: change.appliedAt
      });
    }
    
    // 移除过期
    for (const buffId of expired) {
      this.activeBuffs.delete(buffId);
    }
  }
}
```

### 压缩优化

```csharp
// 启用 MessagePack 协议（可选）
services.AddSignalR()
    .AddMessagePackProtocol(options =>
    {
        options.SerializerOptions = MessagePackSerializerOptions.Standard
            .WithCompression(MessagePackCompression.Lz4BlockArray);
    });
```

---

## 📊 监控指标

### 服务端指标

```
battle_frame_broadcast_rate{battle_id}       # 实际广播频率
battle_frame_buffer_size{battle_id}          # 帧缓冲区大小
battle_delta_request_count{battle_id}        # 补发请求次数
battle_snapshot_request_count{battle_id}     # 快照请求次数
battle_active_connections{battle_id}         # 活跃连接数

battle_frame_generation_duration_ms          # 帧生成耗时
battle_frame_send_duration_ms                # 帧发送耗时
battle_key_event_delay_ms                    # 关键事件延迟
```

### 客户端指标

```
client_frame_receive_rate                    # 实际接收频率
client_frame_loss_count                      # 丢帧次数
client_version_gap_count                     # 版本缺口次数
client_delta_request_count                   # 补发请求次数
client_snapshot_apply_count                  # 快照应用次数

client_render_fps                            # 渲染帧率
client_time_sync_offset_ms                   # 时间同步偏移
client_interpolation_lag_ms                  # 插值延迟
```

---

## 🧪 测试方案

### 单元测试

```typescript
describe("BattleFrameReceiver", () => {
  it("should apply frames in order", () => {
    const receiver = new BattleFrameReceiver();
    
    receiver.onFrameReceived({ version: 1, /* ... */ });
    receiver.onFrameReceived({ version: 2, /* ... */ });
    
    expect(receiver.getLastVersion()).toBe(2);
  });
  
  it("should detect version gap and request delta", () => {
    const receiver = new BattleFrameReceiver();
    const requestSpy = jest.spyOn(receiver, "requestDeltaFrames");
    
    receiver.onFrameReceived({ version: 1, /* ... */ });
    receiver.onFrameReceived({ version: 5, /* ... */ }); // 缺口
    
    expect(requestSpy).toHaveBeenCalledWith(2, 4);
  });
  
  it("should request snapshot for large gap", () => {
    const receiver = new BattleFrameReceiver();
    const requestSpy = jest.spyOn(receiver, "requestSnapshot");
    
    receiver.onFrameReceived({ version: 1, /* ... */ });
    receiver.onFrameReceived({ version: 150, /* ... */ }); // 大缺口
    
    expect(requestSpy).toHaveBeenCalled();
  });
});
```

### 集成测试

```csharp
[Fact]
public async Task BattleFrameBroadcaster_ShouldSendFramesAtConfiguredFrequency()
{
    // Arrange
    var broadcaster = CreateBroadcaster();
    var battle = CreateMockBattle();
    var receivedFrames = new List<FrameTick>();
    
    // Act
    broadcaster.StartBroadcast(battle.Id, frequency: 10); // 10Hz
    await Task.Delay(1100); // 等待 1.1 秒
    broadcaster.StopBroadcast(battle.Id);
    
    // Assert
    Assert.InRange(receivedFrames.Count, 9, 12); // 允许 ±1 帧误差
}

[Fact]
public async Task BattleHub_ShouldHandleDeltaRequest()
{
    // Arrange
    var hub = CreateHub();
    var battle = CreateBattleWithHistory(version: 100);
    
    // Act
    await hub.SyncBattleState(battle.Id, clientLastVersion: 80);
    
    // Assert
    // 验证客户端收到 version 81-100 的帧
}
```

### 压力测试

```typescript
describe("Performance", () => {
  it("should handle 1000 concurrent battles at 10Hz", async () => {
    const battles = Array(1000).fill(null).map(() => createBattle());
    const startTime = Date.now();
    
    // 运行 10 秒
    await runBattlesFor(battles, 10000);
    
    const elapsedTime = Date.now() - startTime;
    const framesSent = battles.reduce((sum, b) => sum + b.frameCount, 0);
    const avgFrameRate = framesSent / (elapsedTime / 1000) / 1000;
    
    expect(avgFrameRate).toBeGreaterThanOrEqual(9); // 至少 9Hz
  });
});
```

---

## 📦 部署配置

### appsettings.json

```json
{
  "BattleFrameSystem": {
    "DefaultFrequency": 8,
    "MinFrequency": 2,
    "MaxFrequency": 10,
    "ForegroundFrequency": 10,
    "BackgroundFrequency": 2,
    "SnapshotInterval": 60000,
    "MaxFrameBufferSize": 300,
    "SnapshotThreshold": 100,
    "MaxDeltaRequestGap": 100
  },
  "SignalR": {
    "MaximumReceiveMessageSize": 1048576,
    "StreamBufferCapacity": 10,
    "EnableDetailedErrors": true,
    "KeepAliveInterval": "00:00:10",
    "ClientTimeoutInterval": "00:00:30"
  }
}
```

### Program.cs

```csharp
builder.Services.AddSignalR(options =>
{
    options.EnableDetailedErrors = builder.Environment.IsDevelopment();
    options.MaximumReceiveMessageSize = 1 * 1024 * 1024; // 1MB
    options.KeepAliveInterval = TimeSpan.FromSeconds(10);
    options.ClientTimeoutInterval = TimeSpan.FromSeconds(30);
});

// 注册帧广播服务
builder.Services.AddHostedService<BattleFrameBroadcaster>();
builder.Services.AddSingleton<IBattleFrameBuffer, BattleFrameBuffer>();

app.MapHub<BattleHub>("/hubs/battle");
```

---

## 📝 迁移指南

### 从旧设计迁移

#### 1. 移除轮询相关代码

```typescript
// ❌ 删除
class BattleApiService {
  pollBattleState() { /* ... */ }
  startPolling() { /* ... */ }
  stopPolling() { /* ... */ }
}

// ❌ 删除降级逻辑
if (signalRFailed) {
  fallbackToPolling();
}
```

#### 2. 替换 CombatSegment 为 FrameTick

```typescript
// 旧代码
connection.on("OnCombatSegmentUpdate", (segment: CombatSegment) => {
  // 应用聚合数据
});

// 新代码
connection.on("OnFrameTick", (frame: FrameTick) => {
  // 应用实时帧数据
  this.frameReceiver.onFrameReceived(frame);
});

connection.on("OnKeyEvent", (event: KeyEvent) => {
  // 处理关键事件
  this.eventHandler.handleKeyEvent(event);
});
```

#### 3. 添加版本管理

```typescript
// 新增
class BattleState {
  private lastVersion: number = 0;
  
  applyFrame(frame: FrameTick) {
    if (frame.version !== this.lastVersion + 1) {
      this.handleVersionGap(frame);
    } else {
      this.updateState(frame);
      this.lastVersion = frame.version;
    }
  }
}
```

#### 4. 实现时间同步

```typescript
// 新增
class TimeSync {
  private offsetSamples: number[] = [];
  
  calibrate(serverTime: number) {
    const offset = serverTime - Date.now();
    this.offsetSamples.push(offset);
    // ...
  }
}
```

---

## 🎯 总结

### 核心改进

✅ **持续 SignalR 流**: 完全替代轮询，连接失败直接重连  
✅ **低延迟推送**: 5-10Hz 固定频率，延迟 < 200ms  
✅ **版本机制**: 处理乱序/丢包，支持差异补发  
✅ **快照恢复**: 定期快照 + 断线重连快速恢复  
✅ **平滑渲染**: 时间同步 + 插值外推 + 平滑纠正  
✅ **演出分级**: 普通伤害合并，关键事件独立动画

### 关键指标

| 指标 | 目标 |
|------|------|
| 推送延迟 | < 200ms (10Hz) |
| 版本缺口恢复 | < 500ms |
| 快照生成 | < 50ms |
| 客户端渲染 | 60 FPS |
| 重连恢复 | < 3s (正常网络) |

### 后续优化方向

1. **WebTransport**: 未来可替代 WebSocket，进一步降低延迟
2. **预测渲染**: 客户端预测玩家操作，减少感知延迟
3. **自适应码率**: 根据网络状况动态调整数据详细度
4. **分布式 SignalR**: 使用 Redis Backplane 支持横向扩展

---

**文档状态**: ✅ 完成  
**最后更新**: 2025年10月21日
