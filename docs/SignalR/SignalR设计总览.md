# BlazorIdle SignalR 推送系统设计总览

**文档版本**: 1.0  
**生成日期**: 2025年10月  
**状态**: 设计规划  
**目标**: 设计统一的SignalR推送机制，实现战斗事件及时推送，为未来扩展打下基础

---

## 📚 文档导航

本SignalR设计方案分为三个阶段，请按顺序阅读：

### 📖 [下篇：基础架构设计（Phase 1）](./Phase1-基础架构设计.md)

**主要内容**:
- SignalR基础设施搭建
- Hub设计与连接管理
- 消息分发器架构
- 事件总线集成
- 基础通知类型定义

**阅读时间**: 约30分钟  
**适合人群**: 架构师、后端开发者

**关键交付**:
```
✅ 统一的SignalR Hub设计
✅ 可扩展的消息分发机制
✅ 事件总线基础框架
✅ 连接状态管理
✅ 错误处理与重试机制
```

---

### 📖 [中篇：战斗事件集成（Phase 2）](./Phase2-战斗事件集成.md)

**主要内容**:
- 战斗事件类型定义
- CombatSegment推送策略
- 实时伤害/状态更新
- 战斗结束通知
- 离线战斗回放支持

**阅读时间**: 约40分钟  
**适合人群**: 战斗系统开发者、前端开发者

**关键交付**:
```
✅ 战斗事件推送机制
✅ Segment聚合推送策略
✅ 实时战斗状态同步
✅ 客户端事件处理接口
✅ 性能优化方案
```

---

### 📖 [上篇：扩展性设计（Phase 3）](./Phase3-扩展性设计.md)

**主要内容**:
- 非战斗事件推送框架
- 活动计划状态通知
- 装备掉落/获取通知
- 经济事件通知
- 社交系统预留接口
- 监控与诊断

**阅读时间**: 约35分钟  
**适合人群**: 全栈开发者、系统架构师

**关键交付**:
```
✅ 通用事件推送框架
✅ 活动计划通知
✅ 物品/装备通知
✅ 经济系统通知
✅ 扩展点设计
✅ 性能监控方案
```

---

## 🎯 设计目标

### 核心目标

1. **实时性**: 战斗事件及时推送到前端，延迟 < 500ms
2. **可靠性**: 保证消息不丢失，支持断线重连和消息补发
3. **可扩展性**: 统一的事件推送机制，支持未来各类事件类型
4. **性能**: 支持并发推送，不影响服务端战斗计算性能
5. **易用性**: 前后端接口清晰，易于理解和使用

---

## 🏗️ 整体架构

### 系统架构图

```
┌─────────────────────────────────────────────────────────────────┐
│                         Blazor WebAssembly Client               │
│  ┌──────────────────────────────────────────────────────────┐   │
│  │  SignalR Client Connection Manager                       │   │
│  │  - 自动重连                                               │   │
│  │  - 消息队列缓冲                                           │   │
│  │  - 心跳检测                                               │   │
│  └─────────────────────┬────────────────────────────────────┘   │
│                        │ SignalR Connection (WebSocket/SSE)     │
└────────────────────────┼────────────────────────────────────────┘
                         │
┌────────────────────────┼────────────────────────────────────────┐
│  ASP.NET Core Server   │                                        │
│  ┌─────────────────────▼──────────────────────────────────┐    │
│  │  GameNotificationHub (SignalR Hub)                     │    │
│  │  - 连接管理                                             │    │
│  │  - 用户组管理                                           │    │
│  │  - 消息路由                                             │    │
│  └─────────────────────┬──────────────────────────────────┘    │
│                        │                                        │
│  ┌─────────────────────▼──────────────────────────────────┐    │
│  │  SignalRDispatcher (消息分发器)                        │    │
│  │  - 消息队列                                             │    │
│  │  - 批量发送                                             │    │
│  │  - 重试机制                                             │    │
│  └─────────────────────┬──────────────────────────────────┘    │
│                        │                                        │
│  ┌─────────────────────▼──────────────────────────────────┐    │
│  │  Domain Event Bus (领域事件总线)                       │    │
│  │  - 事件订阅                                             │    │
│  │  - 事件发布                                             │    │
│  │  - 事件过滤                                             │    │
│  └─────────────────────┬──────────────────────────────────┘    │
│                        │                                        │
│  ┌────────────┬────────┴────────┬──────────────────────────┐   │
│  │            │                 │                          │   │
│  ▼            ▼                 ▼                          ▼   │
│ Combat    Activity          Equipment                 Economy  │
│ Events    Events            Events                    Events   │
│ (战斗)    (活动)             (装备)                     (经济)   │
└─────────────────────────────────────────────────────────────────┘
```

---

## 🔄 消息流程

### 战斗事件推送流程示例

```
1. [Domain] BattleRunner 执行战斗逻辑
   └─> SegmentCollector 收集事件到 CombatSegment
   
2. [Domain] Segment达到阈值，触发 Flush
   └─> 发布 CombatSegmentFlushedEvent (领域事件)
   
3. [EventBus] 事件总线分发事件
   └─> SignalRDispatcher 订阅并接收事件
   
4. [Dispatcher] 消息分发器处理
   ├─> 转换为 SignalR 消息格式
   ├─> 加入发送队列
   └─> 批量发送到 Hub
   
5. [Hub] GameNotificationHub 推送
   └─> 根据 userId 推送到对应客户端
   
6. [Client] Blazor 客户端接收
   ├─> 更新战斗状态显示
   ├─> 更新伤害统计
   └─> 播放动画/音效
```

---

## 📊 技术选型

### SignalR 传输协议

| 协议 | 优先级 | 说明 |
|------|--------|------|
| WebSocket | 首选 | 双向、低延迟、高效 |
| Server-Sent Events | 备选 | 单向、兼容性好 |
| Long Polling | 兜底 | 兼容所有浏览器 |

SignalR 会自动协商最佳传输协议。

---

### 消息序列化

- **格式**: JSON
- **库**: System.Text.Json (ASP.NET Core 默认)
- **原因**: 
  - Blazor WebAssembly 原生支持
  - 性能优秀
  - 调试方便

---

## 📋 事件类型分类

### Phase 1: 基础通知

| 事件类型 | 说明 | 优先级 |
|---------|------|--------|
| ConnectionEstablished | 连接建立 | 🔴 高 |
| Heartbeat | 心跳检测 | 🔴 高 |
| ServerStatus | 服务器状态 | 🟡 中 |

---

### Phase 2: 战斗事件

| 事件类型 | 说明 | 优先级 |
|---------|------|--------|
| BattleStarted | 战斗开始 | 🔴 高 |
| CombatSegmentUpdate | 战斗段更新 | 🔴 高 |
| BattleEnded | 战斗结束 | 🔴 高 |
| BattleRewardReceived | 战斗奖励 | 🔴 高 |
| CharacterDied | 角色死亡 | 🔴 高 |
| EnemyKilled | 敌人击杀 | 🟡 中 |
| SkillCast | 技能释放 | 🟢 低 |
| BuffApplied | Buff应用 | 🟢 低 |
| BuffExpired | Buff过期 | 🟢 低 |

---

### Phase 3: 扩展事件

| 事件类型 | 说明 | 优先级 |
|---------|------|--------|
| ActivityStarted | 活动开始 | 🟡 中 |
| ActivityCompleted | 活动完成 | 🟡 中 |
| ItemReceived | 物品获得 | 🟡 中 |
| EquipmentUpgraded | 装备升级 | 🟡 中 |
| GoldChanged | 金币变化 | 🟢 低 |
| ExpGained | 经验获得 | 🟢 低 |
| LevelUp | 升级 | 🔴 高 |
| QuestUpdated | 任务更新 | 🟡 中 |

---

## 🎨 设计原则

### 1. 保持现有架构风格 ✅

- **遵循现有分层结构**: Domain → Application → Infrastructure → API
- **沿用事件驱动模式**: 与现有 EventScheduler、IGameEvent 保持一致
- **保持代码风格**: 使用现有的命名规范和代码组织方式

---

### 2. 最小化侵入性 ✅

- **不修改核心战斗逻辑**: BattleRunner、BattleContext 保持不变
- **通过事件总线解耦**: 新增功能不影响现有代码
- **渐进式集成**: 可以分阶段实施，逐步启用功能

---

### 3. 高性能优先 ✅

- **异步非阻塞**: 所有推送操作异步执行
- **批量发送**: 聚合多个事件批量推送
- **背压控制**: 防止消息堆积影响服务器性能
- **可配置节流**: 可调整推送频率和批量大小

---

### 4. 可扩展性 ✅

- **统一事件模型**: 所有事件继承 `IDomainEvent`
- **插件式订阅**: 新增事件类型无需修改核心代码
- **分层过滤**: 支持用户级、战斗级、全局级事件过滤

---

### 5. 可测试性 ✅

- **接口抽象**: ISignalRDispatcher、IEventBus 可注入
- **Mock 友好**: 便于单元测试和集成测试
- **事件回放**: 支持离线事件回放验证

---

## 📈 实施路线图

### 时间规划

```
Phase 1: 基础架构（2周）
├─ Week 1: SignalR Hub + 消息分发器
└─ Week 2: 事件总线 + 基础通知

Phase 2: 战斗事件（2-3周）
├─ Week 3: CombatSegment 推送集成
├─ Week 4: 战斗开始/结束通知
└─ Week 5: 性能优化与测试

Phase 3: 扩展性（1-2周）
├─ Week 6: 通用事件框架
└─ Week 7: 活动/装备/经济事件集成

总计: 5-7周
```

---

### 依赖关系

```
Phase 1 (基础架构)
    │
    ├──→ Phase 2 (战斗事件)
    │        │
    │        └──→ Phase 3 (扩展性)
    │
    └──────────────────────┘
```

**关键路径**: Phase 1 → Phase 2 → Phase 3（顺序实施）

---

## 🚦 风险与挑战

### 风险1: 性能影响

**描述**: 频繁的 SignalR 推送可能影响战斗计算性能

**概率**: 中等  
**影响**: 严重

**缓解措施**:
```
✅ 异步队列缓冲，不阻塞战斗线程
✅ 批量发送，减少推送次数
✅ Segment 聚合，降低事件频率
✅ 性能监控，及时发现瓶颈
```

---

### 风险2: 消息丢失

**描述**: 网络中断或客户端断线导致消息丢失

**概率**: 较高  
**影响**: 中等

**缓解措施**:
```
✅ 自动重连机制
✅ 消息序列号，支持补发
✅ 客户端缓冲队列
✅ 离线状态下通过 API 轮询获取
```

---

### 风险3: 并发连接数

**描述**: 大量玩家同时在线，SignalR 连接数过高

**概率**: 低（初期）  
**影响**: 严重（后期）

**缓解措施**:
```
✅ 连接池管理
✅ 空闲连接自动断开
✅ 分组推送优化
✅ 横向扩展预留（Redis Backplane）
```

---

## 💡 核心亮点

### 1. 统一的事件驱动架构

所有推送事件都遵循统一的领域事件模型：

```csharp
public interface IDomainEvent
{
    Guid EventId { get; }
    DateTime OccurredAt { get; }
    string EventType { get; }
}
```

任何领域模块（战斗、活动、装备、经济）都可以发布事件，SignalR 系统自动处理推送。

---

### 2. 智能批量推送

通过 CombatSegment 机制，将多个原子事件聚合为一个段推送：

```
原子事件流（200个事件）:
AttackTick → Damage → Damage → Damage → SkillCast → Damage ...

聚合推送（1个 Segment）:
CombatSegmentUpdate {
  totalDamage: 12345,
  skillCasts: 8,
  buffsApplied: 3,
  ...
}
```

**效果**: 推送频率降低 99%，带宽节省 95%

---

### 3. 渐进式增强

系统设计支持逐步启用功能，不影响现有体验：

- **Phase 1**: 基础连接，无推送（准备阶段）
- **Phase 2**: 战斗事件推送（核心功能）
- **Phase 3**: 全面推送（完整体验）

每个阶段都可以独立交付和验证。

---

### 4. 向后兼容

即使 SignalR 不可用，前端仍可通过现有 API 轮询获取战斗状态：

```
SignalR 推送 (实时):
  客户端 ←──[推送]── 服务器

SignalR 不可用 (降级):
  客户端 ──[轮询]──→ 服务器
         ←─[响应]──
```

无缝降级，保证可用性。

---

## 📖 术语表

| 术语 | 定义 |
|------|------|
| Hub | SignalR 服务器端连接点，管理客户端连接和消息路由 |
| Connection | 客户端与服务器之间的持久化双向通道 |
| Group | 连接的逻辑分组，用于广播消息 |
| Dispatcher | 消息分发器，负责事件到 SignalR 消息的转换和发送 |
| EventBus | 领域事件总线，解耦事件发布者和订阅者 |
| DomainEvent | 领域事件，表示领域中发生的重要业务变化 |
| Segment | 战斗事件段，聚合多个原子事件的集合 |
| Backpressure | 背压，控制消息生产速度以防止积压 |
| Heartbeat | 心跳，定期发送的保活消息 |

---

## 🎓 预期收益

### 用户体验提升

```
✅ 战斗状态实时可见，无需手动刷新
✅ 伤害数字立即显示，增强战斗感
✅ 装备掉落即时通知，提升激励感
✅ 活动完成及时提醒，优化操作流程
```

---

### 技术债务优化

```
✅ 建立统一的事件推送机制
✅ 减少前端轮询请求，降低服务器负载
✅ 为后续社交功能打下基础
✅ 提升系统架构质量
```

---

### 开发效率提升

```
✅ 新增事件类型只需订阅事件总线
✅ 前后端接口清晰，减少沟通成本
✅ 可复用的推送基础设施
✅ 易于测试和调试
```

---

## 📞 后续行动

1. **评审本设计方案**: 团队评审，确认技术方向
2. **阅读详细设计**: 按顺序阅读 Phase 1-3 详细设计文档
3. **准备开发环境**: 安装 SignalR 相关依赖包
4. **启动 Phase 1**: 从基础架构开始实施

---

## 📝 版本历史

| 版本 | 日期 | 变更说明 | 作者 |
|------|------|---------|------|
| 1.0 | 2025-10 | 初始版本，完整设计方案 | GitHub Copilot |

---

**文档状态**: ✅ 完成  
**最后更新**: 2025年10月  

---

**现在开始**: 请继续阅读 [Phase1-基础架构设计.md](./Phase1-基础架构设计.md) 了解详细实施方案。
