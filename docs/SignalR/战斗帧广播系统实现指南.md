# æˆ˜æ–—å¸§å¹¿æ’­ç³»ç»Ÿå®ç°æŒ‡å—

**æ–‡æ¡£ç‰ˆæœ¬**: 2.0  
**é€‚ç”¨äº**: BlazorIdle å®æ—¶å¸§æ¨é€ç³»ç»Ÿ  
**å‰ç½®æ–‡æ¡£**: [å®æ—¶å¸§æ¨é€è®¾è®¡æ–¹æ¡ˆ](./å®æ—¶å¸§æ¨é€è®¾è®¡æ–¹æ¡ˆ.md)

---

## ğŸ“‹ ç›®å½•

1. [æœåŠ¡ç«¯å®ç°](#æœåŠ¡ç«¯å®ç°)
2. [å®¢æˆ·ç«¯å®ç°](#å®¢æˆ·ç«¯å®ç°)
3. [SignalR Hub è®¾è®¡](#signalr-hub-è®¾è®¡)
4. [ç‰ˆæœ¬ç®¡ç†å®ç°](#ç‰ˆæœ¬ç®¡ç†å®ç°)
5. [æ€§èƒ½ä¼˜åŒ–å®è·µ](#æ€§èƒ½ä¼˜åŒ–å®è·µ)
6. [æµ‹è¯•ä¸éªŒè¯](#æµ‹è¯•ä¸éªŒè¯)

---

## æœåŠ¡ç«¯å®ç°

### 1. æˆ˜æ–—å®ä¾‹æ‰©å±•

ä¸ºç°æœ‰çš„ `BattleInstance` æ·»åŠ å¸§ç®¡ç†èƒ½åŠ›ï¼š

```csharp
// Domain/Combat/BattleInstance.cs
public class BattleInstance
{
    // ç°æœ‰å­—æ®µ...
    private long _currentVersion = 0;
    private readonly BattleFrameBuffer _frameBuffer;
    private readonly List<KeyEvent> _pendingKeyEvents = new();
    
    public long CurrentVersion => _currentVersion;
    
    public BattleInstance(/* ç°æœ‰å‚æ•° */)
    {
        // ç°æœ‰åˆå§‹åŒ–...
        _frameBuffer = new BattleFrameBuffer(maxSize: 300);
    }
    
    // ç”Ÿæˆå¸§æ•°æ®
    public FrameTick GenerateFrameTick()
    {
        var version = Interlocked.Increment(ref _currentVersion);
        
        var frame = new FrameTick
        {
            Version = version,
            ServerTime = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds(),
            BattleId = Id.ToString(),
            Phase = GetCurrentPhase(),
            
            Metrics = new FrameMetrics
            {
                CastProgress = GetCastProgress(),
                Dps = new DpsMetrics
                {
                    Player = CalculatePlayerDps(),
                    Received = CalculateReceivedDps()
                },
                Health = new HealthMetrics
                {
                    Current = _characterState.CurrentHp,
                    Max = _characterState.MaxHp,
                    Delta = _characterState.HpDeltaSinceLastFrame
                },
                Shield = new ShieldMetrics
                {
                    Current = _characterState.Shield,
                    Delta = _characterState.ShieldDeltaSinceLastFrame
                },
                Buffs = GetBuffChanges(),
                ExpiredBuffs = GetExpiredBuffIds()
            },
            
            Aggregates = new FrameAggregates
            {
                WindowStart = _lastFrameTime,
                WindowEnd = _clock.CurrentTime,
                Damage = AggregrateDamage(),
                Healing = AggregateHealing(),
                Hits = AggregateHits()
            },
            
            Events = _pendingKeyEvents.Count > 0 ? _pendingKeyEvents.ToArray() : null
        };
        
        // é‡ç½®å¢é‡ç»Ÿè®¡
        ResetFrameDeltas();
        _lastFrameTime = _clock.CurrentTime;
        
        return frame;
    }
    
    // ç”Ÿæˆå¿«ç…§
    public BattleSnapshot GenerateSnapshot()
    {
        return new BattleSnapshot
        {
            Version = _currentVersion,
            ServerTime = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds(),
            BattleId = Id.ToString(),
            State = new BattleState
            {
                Phase = GetCurrentPhase(),
                ElapsedTime = _clock.CurrentTime,
                Player = new PlayerState
                {
                    Health = new HealthSnapshot { Current = _characterState.CurrentHp, Max = _characterState.MaxHp },
                    Shield = _characterState.Shield,
                    Resources = _characterState.Resources.ToDictionary(r => r.Key, r => r.Value.Current),
                    Buffs = _characterState.Buffs.Select(b => ToBuffSnapshot(b)).ToArray(),
                    Debuffs = _characterState.Debuffs.Select(d => ToBuffSnapshot(d)).ToArray()
                },
                Enemies = _enemyStates.Select(e => ToEnemySnapshot(e)).ToArray(),
                Statistics = GetCurrentStatistics()
            }
        };
    }
    
    // æ·»åŠ å…³é”®äº‹ä»¶
    public void AddKeyEvent(KeyEvent evt)
    {
        evt.Version = Interlocked.Increment(ref _currentVersion);
        evt.Timestamp = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds();
        evt.BattleId = Id.ToString();
        
        _pendingKeyEvents.Add(evt);
    }
    
    // æ¸…é™¤å·²å‘é€çš„å…³é”®äº‹ä»¶
    public void ClearPendingKeyEvents()
    {
        _pendingKeyEvents.Clear();
    }
    
    // è·å–å†å²å¸§
    public List<FrameTick> GetDeltaFrames(long fromVersion, long toVersion)
    {
        return _frameBuffer.GetFrames(fromVersion, toVersion);
    }
    
    // ç¼“å­˜å¸§
    public void BufferFrame(FrameTick frame)
    {
        _frameBuffer.AddFrame(frame);
    }
    
    // è¾…åŠ©æ–¹æ³•
    private BattlePhase GetCurrentPhase()
    {
        if (_isCompleted) return BattlePhase.Ended;
        if (_isPaused) return BattlePhase.Paused;
        return BattlePhase.Active;
    }
    
    private CastProgress? GetCastProgress()
    {
        // å¦‚æœæœ‰æŠ€èƒ½æ­£åœ¨è¯»æ¡ï¼Œè¿”å›è¿›åº¦
        var casting = _characterState.CurrentCast;
        if (casting == null) return null;
        
        var elapsed = _clock.CurrentTime - casting.StartTime;
        var progress = elapsed / casting.CastTime;
        
        return new CastProgress
        {
            SkillId = casting.SkillId,
            Progress = Math.Clamp(progress, 0, 1),
            Remaining = Math.Max(0, casting.CastTime - elapsed)
        };
    }
    
    private double CalculatePlayerDps()
    {
        var window = 5.0; // 5ç§’çª—å£
        var recentDamage = _damageHistory
            .Where(d => d.Timestamp > _clock.CurrentTime - window)
            .Sum(d => d.Amount);
        
        return recentDamage / window;
    }
    
    private List<BuffChange> GetBuffChanges()
    {
        // è¿”å›è‡ªä¸Šæ¬¡å¸§ä»¥æ¥æ–°å¢æˆ–åˆ·æ–°çš„ Buff
        return _characterState.Buffs
            .Where(b => b.LastUpdateTime > _lastFrameTime)
            .Select(b => new BuffChange
            {
                BuffId = b.Id,
                Stacks = b.Stacks,
                Duration = b.RemainingDuration(_clock.CurrentTime),
                AppliedAt = b.AppliedAt
            })
            .ToList();
    }
    
    private List<string> GetExpiredBuffIds()
    {
        // è¿”å›è‡ªä¸Šæ¬¡å¸§ä»¥æ¥è¿‡æœŸçš„ Buff ID
        return _characterState.ExpiredBuffsSinceLastFrame.ToList();
    }
    
    private void ResetFrameDeltas()
    {
        _characterState.HpDeltaSinceLastFrame = 0;
        _characterState.ShieldDeltaSinceLastFrame = 0;
        _characterState.ExpiredBuffsSinceLastFrame.Clear();
    }
}
```

### 2. å¸§ç¼“å†²ç®¡ç†

```csharp
// Infrastructure/Messaging/BattleFrameBuffer.cs
public class BattleFrameBuffer
{
    private readonly ConcurrentDictionary<long, FrameTick> _frames = new();
    private readonly int _maxSize;
    private long _minVersion = 0;
    
    public BattleFrameBuffer(int maxSize = 300)
    {
        _maxSize = maxSize;
    }
    
    public void AddFrame(FrameTick frame)
    {
        _frames[frame.Version] = frame;
        
        // æ¸…ç†è¿‡æ—§çš„å¸§
        if (_frames.Count > _maxSize)
        {
            CleanupOldFrames();
        }
    }
    
    public List<FrameTick> GetFrames(long fromVersion, long toVersion)
    {
        var frames = new List<FrameTick>();
        
        for (long v = fromVersion; v <= toVersion; v++)
        {
            if (_frames.TryGetValue(v, out var frame))
            {
                frames.Add(frame);
            }
            else
            {
                // ç¼ºå°‘æŸäº›å¸§ï¼Œè¿”å›ç©ºè¡¨ç¤ºéœ€è¦å¿«ç…§
                return new List<FrameTick>();
            }
        }
        
        return frames;
    }
    
    private void CleanupOldFrames()
    {
        var versions = _frames.Keys.OrderBy(v => v).ToList();
        var toRemove = versions.Take(versions.Count - _maxSize).ToList();
        
        foreach (var version in toRemove)
        {
            _frames.TryRemove(version, out _);
        }
        
        _minVersion = versions.Skip(versions.Count - _maxSize).FirstOrDefault();
    }
}
```

### 3. å¸§å¹¿æ’­æœåŠ¡

```csharp
// Infrastructure/Messaging/BattleFrameBroadcaster.cs
public class BattleFrameBroadcaster : BackgroundService
{
    private readonly IHubContext<BattleHub> _hubContext;
    private readonly IBattleManager _battleManager;
    private readonly ILogger<BattleFrameBroadcaster> _logger;
    private readonly ConcurrentDictionary<string, BattleFrameConfig> _configs = new();
    
    public BattleFrameBroadcaster(
        IHubContext<BattleHub> hubContext,
        IBattleManager battleManager,
        ILogger<BattleFrameBroadcaster> logger)
    {
        _hubContext = hubContext;
        _battleManager = battleManager;
        _logger = logger;
    }
    
    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        _logger.LogInformation("BattleFrameBroadcaster started");
        
        while (!stoppingToken.IsCancellationRequested)
        {
            try
            {
                await BroadcastFrames(stoppingToken);
                await Task.Delay(10, stoppingToken); // 10ms ç²¾åº¦
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error in BattleFrameBroadcaster");
            }
        }
        
        _logger.LogInformation("BattleFrameBroadcaster stopped");
    }
    
    private async Task BroadcastFrames(CancellationToken ct)
    {
        var now = DateTime.UtcNow;
        
        foreach (var (battleId, config) in _configs)
        {
            if (ct.IsCancellationRequested) break;
            
            var intervalMs = 1000.0 / config.Frequency;
            var elapsed = (now - config.LastBroadcast).TotalMilliseconds;
            
            if (elapsed >= intervalMs)
            {
                await BroadcastFrame(battleId, config);
                config.LastBroadcast = now;
            }
        }
    }
    
    private async Task BroadcastFrame(string battleId, BattleFrameConfig config)
    {
        try
        {
            var battle = _battleManager.GetBattle(Guid.Parse(battleId));
            if (battle == null)
            {
                // æˆ˜æ–—å·²ç»“æŸï¼Œç§»é™¤é…ç½®
                _configs.TryRemove(battleId, out _);
                return;
            }
            
            // ç”Ÿæˆå¸§
            var frame = battle.GenerateFrameTick();
            
            // ç¼“å­˜å¸§ï¼ˆç”¨äºè¡¥å‘ï¼‰
            battle.BufferFrame(frame);
            
            // æ¨é€åˆ° group
            await _hubContext.Clients.Group(battleId).SendAsync("OnFrameTick", frame);
            
            // å®šæœŸç”Ÿæˆå¿«ç…§
            if (frame.Version % 300 == 0) // æ¯ 300 å¸§
            {
                var snapshot = battle.GenerateSnapshot();
                config.LastSnapshot = snapshot;
                _logger.LogDebug("Generated snapshot for battle {BattleId} at version {Version}",
                    battleId, snapshot.Version);
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error broadcasting frame for battle {BattleId}", battleId);
        }
    }
    
    public void StartBroadcast(string battleId, int frequency = 8)
    {
        _configs[battleId] = new BattleFrameConfig
        {
            Frequency = Math.Clamp(frequency, 2, 10),
            LastBroadcast = DateTime.UtcNow
        };
        
        _logger.LogInformation("Started broadcast for battle {BattleId} at {Frequency}Hz",
            battleId, frequency);
    }
    
    public void StopBroadcast(string battleId)
    {
        if (_configs.TryRemove(battleId, out _))
        {
            _logger.LogInformation("Stopped broadcast for battle {BattleId}", battleId);
        }
    }
    
    public void SetFrequency(string battleId, int frequency)
    {
        if (_configs.TryGetValue(battleId, out var config))
        {
            config.Frequency = Math.Clamp(frequency, 2, 10);
            _logger.LogDebug("Updated frequency for battle {BattleId} to {Frequency}Hz",
                battleId, frequency);
        }
    }
}

public class BattleFrameConfig
{
    public int Frequency { get; set; } = 8;
    public DateTime LastBroadcast { get; set; } = DateTime.UtcNow;
    public BattleSnapshot? LastSnapshot { get; set; }
}
```

---

## SignalR Hub è®¾è®¡

### BattleHub å®ç°

```csharp
// API/Hubs/BattleHub.cs
public class BattleHub : Hub
{
    private readonly IBattleManager _battleManager;
    private readonly IBattleFrameBroadcaster _broadcaster;
    private readonly ILogger<BattleHub> _logger;
    
    public BattleHub(
        IBattleManager battleManager,
        IBattleFrameBroadcaster broadcaster,
        ILogger<BattleHub> logger)
    {
        _battleManager = battleManager;
        _broadcaster = broadcaster;
        _logger = logger;
    }
    
    // è¿æ¥ç®¡ç†
    public override async Task OnConnectedAsync()
    {
        var userId = GetUserId();
        _logger.LogInformation("User {UserId} connected to BattleHub", userId);
        await base.OnConnectedAsync();
    }
    
    public override async Task OnDisconnectedAsync(Exception? exception)
    {
        var userId = GetUserId();
        
        if (exception != null)
        {
            _logger.LogWarning(exception, "User {UserId} disconnected with error", userId);
        }
        
        // æ¸…ç†è®¢é˜…
        await CleanupUserSubscriptions(userId);
        
        await base.OnDisconnectedAsync(exception);
    }
    
    // è®¢é˜…æˆ˜æ–—
    public async Task SubscribeToBattle(string battleId)
    {
        var userId = GetUserId();
        var battle = _battleManager.GetBattle(Guid.Parse(battleId));
        
        if (battle == null)
        {
            await Clients.Caller.SendAsync("OnBattleNotFound", battleId);
            return;
        }
        
        // åŠ å…¥ group
        await Groups.AddToGroupAsync(Context.ConnectionId, battleId);
        _logger.LogInformation("User {UserId} subscribed to battle {BattleId}", userId, battleId);
        
        // å¯åŠ¨å¸§å¹¿æ’­ï¼ˆå¦‚æœå°šæœªå¯åŠ¨ï¼‰
        _broadcaster.StartBroadcast(battleId);
        
        // å‘é€å½“å‰å¿«ç…§
        var snapshot = battle.GenerateSnapshot();
        await Clients.Caller.SendAsync("OnBattleSnapshot", snapshot);
    }
    
    // å–æ¶ˆè®¢é˜…æˆ˜æ–—
    public async Task UnsubscribeFromBattle(string battleId)
    {
        var userId = GetUserId();
        
        await Groups.RemoveFromGroupAsync(Context.ConnectionId, battleId);
        _logger.LogInformation("User {UserId} unsubscribed from battle {BattleId}", userId, battleId);
        
        // æ£€æŸ¥ group æ˜¯å¦ä¸ºç©ºï¼Œå¦‚æœæ˜¯åˆ™åœæ­¢å¹¿æ’­
        // æ³¨æ„ï¼šSignalR æ²¡æœ‰ç›´æ¥ API æ£€æŸ¥ group æˆå‘˜æ•°ï¼Œéœ€è¦è‡ªå·±ç»´æŠ¤
    }
    
    // åŒæ­¥æˆ˜æ–—çŠ¶æ€ï¼ˆé‡è¿åï¼‰
    public async Task SyncBattleState(string battleId, long clientLastVersion)
    {
        var userId = GetUserId();
        var battle = _battleManager.GetBattle(Guid.Parse(battleId));
        
        if (battle == null)
        {
            await Clients.Caller.SendAsync("OnBattleNotFound", battleId);
            return;
        }
        
        var currentVersion = battle.CurrentVersion;
        var gap = currentVersion - clientLastVersion;
        
        _logger.LogInformation(
            "User {UserId} syncing battle {BattleId}, clientVersion={ClientVersion}, currentVersion={CurrentVersion}, gap={Gap}",
            userId, battleId, clientLastVersion, currentVersion, gap);
        
        if (gap <= 0)
        {
            // å®¢æˆ·ç«¯å·²æ˜¯æœ€æ–°
            await Clients.Caller.SendAsync("OnSyncComplete", currentVersion);
            return;
        }
        
        // åˆ¤æ–­æ˜¯å‘é€å¢é‡è¿˜æ˜¯å¿«ç…§
        const long SnapshotThreshold = 100;
        
        if (gap > SnapshotThreshold || clientLastVersion == 0)
        {
            // å‘é€å¿«ç…§
            var snapshot = battle.GenerateSnapshot();
            await Clients.Caller.SendAsync("OnBattleSnapshot", snapshot);
            _logger.LogInformation("Sent snapshot to {UserId} for battle {BattleId}", userId, battleId);
        }
        else
        {
            // å°è¯•å‘é€å¢é‡
            var deltaFrames = battle.GetDeltaFrames(clientLastVersion + 1, currentVersion);
            
            if (deltaFrames.Count == 0)
            {
                // å¢é‡ä¸å¯ç”¨ï¼Œé™çº§ä¸ºå¿«ç…§
                var snapshot = battle.GenerateSnapshot();
                await Clients.Caller.SendAsync("OnBattleSnapshot", snapshot);
                _logger.LogWarning("Delta frames not available, sent snapshot to {UserId} for battle {BattleId}",
                    userId, battleId);
            }
            else
            {
                // å‘é€å¢é‡
                await Clients.Caller.SendAsync("OnDeltaFrames", deltaFrames);
                _logger.LogInformation("Sent {Count} delta frames to {UserId} for battle {BattleId}",
                    deltaFrames.Count, userId, battleId);
            }
        }
        
        await Clients.Caller.SendAsync("OnSyncComplete", currentVersion);
    }
    
    // è®¾ç½®æ¨é€é¢‘ç‡
    public async Task SetFrameFrequency(int frequency)
    {
        var userId = GetUserId();
        
        // éœ€è¦ç»´æŠ¤ç”¨æˆ·å½“å‰è®¢é˜…çš„æˆ˜æ–—åˆ—è¡¨
        var userBattles = GetUserBattles(userId);
        
        foreach (var battleId in userBattles)
        {
            _broadcaster.SetFrequency(battleId, frequency);
        }
        
        _logger.LogInformation("User {UserId} set frame frequency to {Frequency}Hz", userId, frequency);
        await Task.CompletedTask;
    }
    
    // å¿ƒè·³ï¼ˆä¿æ´»ï¼‰
    public Task Heartbeat()
    {
        return Task.CompletedTask;
    }
    
    // è¾…åŠ©æ–¹æ³•
    private string GetUserId()
    {
        return Context.User?.FindFirst("sub")?.Value 
            ?? Context.User?.FindFirst(ClaimTypes.NameIdentifier)?.Value
            ?? "anonymous";
    }
    
    private async Task CleanupUserSubscriptions(string userId)
    {
        var userBattles = GetUserBattles(userId);
        
        foreach (var battleId in userBattles)
        {
            await Groups.RemoveFromGroupAsync(Context.ConnectionId, battleId);
        }
    }
    
    private List<string> GetUserBattles(string userId)
    {
        // å®ç°ï¼šä»ç¼“å­˜æˆ–æ•°æ®åº“è·å–ç”¨æˆ·å½“å‰è®¢é˜…çš„æˆ˜æ–—åˆ—è¡¨
        // è¿™éœ€è¦é¢å¤–çš„çŠ¶æ€ç®¡ç†
        return new List<string>();
    }
}
```

---

## å®¢æˆ·ç«¯å®ç°

### 1. å¸§æ¥æ”¶å™¨

```typescript
// Services/BattleFrameReceiver.ts
export class BattleFrameReceiver {
  private lastVersion: number = 0;
  private bufferedFrames: Map<number, FrameTick | KeyEvent> = new Map();
  private maxGapBeforeSnapshot: number = 100;
  
  private onFrameApplied?: (frame: FrameTick) => void;
  private onKeyEventReceived?: (event: KeyEvent) => void;
  private onSnapshotApplied?: (snapshot: BattleSnapshot) => void;
  
  constructor(
    private connection: signalR.HubConnection,
    private battleId: string
  ) {}
  
  // è®¾ç½®å›è°ƒ
  setCallbacks(callbacks: {
    onFrameApplied?: (frame: FrameTick) => void;
    onKeyEventReceived?: (event: KeyEvent) => void;
    onSnapshotApplied?: (snapshot: BattleSnapshot) => void;
  }) {
    this.onFrameApplied = callbacks.onFrameApplied;
    this.onKeyEventReceived = callbacks.onKeyEventReceived;
    this.onSnapshotApplied = callbacks.onSnapshotApplied;
  }
  
  // å¤„ç†æ¥æ”¶åˆ°çš„å¸§
  onFrameReceived(frame: FrameTick) {
    const receivedVersion = frame.version;
    
    if (receivedVersion === this.lastVersion + 1) {
      // æ­£å¸¸é¡ºåº
      this.applyFrame(frame);
      this.lastVersion = receivedVersion;
      
      // å°è¯•åº”ç”¨ç¼“å­˜çš„å¸§
      this.flushBufferedFrames();
    }
    else if (receivedVersion > this.lastVersion + 1) {
      // æ£€æµ‹åˆ°ç¼ºå£
      const gap = receivedVersion - this.lastVersion;
      
      console.warn(`Frame gap detected: expected ${this.lastVersion + 1}, got ${receivedVersion}, gap=${gap}`);
      
      if (gap > this.maxGapBeforeSnapshot) {
        // ç¼ºå£è¿‡å¤§ï¼Œè¯·æ±‚å¿«ç…§
        this.requestSnapshot();
      } else {
        // è¯·æ±‚å¢é‡
        this.requestDeltaFrames(this.lastVersion + 1, receivedVersion - 1);
      }
      
      // ç¼“å­˜å½“å‰å¸§
      this.bufferedFrames.set(receivedVersion, frame);
    }
    else {
      // é‡å¤æˆ–ä¹±åºæ—§åŒ…ï¼Œä¸¢å¼ƒ
      console.debug(`Discarding old/duplicate frame: ${receivedVersion}`);
    }
  }
  
  // å¤„ç†å…³é”®äº‹ä»¶
  onKeyEventReceived(event: KeyEvent) {
    // å…³é”®äº‹ä»¶ä¹Ÿéµå¾ªç‰ˆæœ¬æœºåˆ¶
    if (event.version === this.lastVersion + 1) {
      this.onKeyEventReceived?.(event);
      this.lastVersion = event.version;
      this.flushBufferedFrames();
    }
    else if (event.version > this.lastVersion + 1) {
      // ç¼“å­˜
      this.bufferedFrames.set(event.version, event);
    }
    // å¦åˆ™ä¸¢å¼ƒ
  }
  
  // åº”ç”¨å¿«ç…§
  onSnapshotReceived(snapshot: BattleSnapshot) {
    console.info(`Applying snapshot at version ${snapshot.version}`);
    
    this.onSnapshotApplied?.(snapshot);
    this.lastVersion = snapshot.version;
    
    // æ¸…ç©ºç¼“å­˜
    this.bufferedFrames.clear();
  }
  
  // åº”ç”¨å¢é‡å¸§
  onDeltaFramesReceived(frames: FrameTick[]) {
    console.info(`Received ${frames.length} delta frames`);
    
    // æŒ‰ç‰ˆæœ¬å·æ’åº
    frames.sort((a, b) => a.version - b.version);
    
    for (const frame of frames) {
      if (frame.version === this.lastVersion + 1) {
        this.applyFrame(frame);
        this.lastVersion = frame.version;
      }
    }
    
    // å°è¯•åº”ç”¨ç¼“å­˜çš„å¸§
    this.flushBufferedFrames();
  }
  
  // åº”ç”¨å¸§
  private applyFrame(frame: FrameTick) {
    this.onFrameApplied?.(frame);
    
    // å¤„ç†é™„åŠ çš„å…³é”®äº‹ä»¶
    if (frame.events) {
      for (const event of frame.events) {
        this.onKeyEventReceived?.(event);
      }
    }
  }
  
  // åˆ·æ–°ç¼“å­˜çš„å¸§
  private flushBufferedFrames() {
    while (this.bufferedFrames.has(this.lastVersion + 1)) {
      const frame = this.bufferedFrames.get(this.lastVersion + 1)!;
      this.bufferedFrames.delete(this.lastVersion + 1);
      
      if ('metrics' in frame) {
        // FrameTick
        this.applyFrame(frame as FrameTick);
      } else {
        // KeyEvent
        this.onKeyEventReceived?.(frame as KeyEvent);
      }
      
      this.lastVersion++;
    }
  }
  
  // è¯·æ±‚å¿«ç…§
  private requestSnapshot() {
    console.info(`Requesting snapshot for battle ${this.battleId}`);
    this.connection.invoke("SyncBattleState", this.battleId, this.lastVersion);
  }
  
  // è¯·æ±‚å¢é‡å¸§
  private requestDeltaFrames(fromVersion: number, toVersion: number) {
    console.info(`Requesting delta frames ${fromVersion}-${toVersion} for battle ${this.battleId}`);
    this.connection.invoke("SyncBattleState", this.battleId, this.lastVersion);
  }
  
  getLastVersion(): number {
    return this.lastVersion;
  }
  
  reset() {
    this.lastVersion = 0;
    this.bufferedFrames.clear();
  }
}
```

### 2. æˆ˜æ–—è¿æ¥ç®¡ç†

```typescript
// Services/BattleConnection.ts
export class BattleConnection {
  private connection: signalR.HubConnection | null = null;
  private frameReceiver: BattleFrameReceiver | null = null;
  private reconnectAttempts: number = 0;
  private maxReconnectAttempts: number = 5;
  private reconnectDelays: number[] = [0, 2000, 5000, 10000, 20000];
  
  constructor(
    private hubUrl: string,
    private battleId: string
  ) {}
  
  async connect(): Promise<void> {
    this.connection = new signalR.HubConnectionBuilder()
      .withUrl(this.hubUrl)
      .withAutomaticReconnect({
        nextRetryDelayInMilliseconds: (retryContext) => {
          return this.reconnectDelays[Math.min(retryContext.previousRetryCount, 4)];
        }
      })
      .configureLogging(signalR.LogLevel.Information)
      .build();
    
    // æ³¨å†Œäº‹ä»¶å¤„ç†
    this.setupEventHandlers();
    
    // å¯åŠ¨è¿æ¥
    await this.connection.start();
    console.info("Connected to BattleHub");
    
    // è®¢é˜…æˆ˜æ–—
    await this.connection.invoke("SubscribeToBattle", this.battleId);
    
    // åˆ›å»ºå¸§æ¥æ”¶å™¨
    this.frameReceiver = new BattleFrameReceiver(this.connection, this.battleId);
  }
  
  private setupEventHandlers() {
    if (!this.connection) return;
    
    // å¸§æ›´æ–°
    this.connection.on("OnFrameTick", (frame: FrameTick) => {
      this.frameReceiver?.onFrameReceived(frame);
    });
    
    // å…³é”®äº‹ä»¶
    this.connection.on("OnKeyEvent", (event: KeyEvent) => {
      this.frameReceiver?.onKeyEventReceived(event);
    });
    
    // å¿«ç…§
    this.connection.on("OnBattleSnapshot", (snapshot: BattleSnapshot) => {
      this.frameReceiver?.onSnapshotReceived(snapshot);
    });
    
    // å¢é‡å¸§
    this.connection.on("OnDeltaFrames", (frames: FrameTick[]) => {
      this.frameReceiver?.onDeltaFramesReceived(frames);
    });
    
    // åŒæ­¥å®Œæˆ
    this.connection.on("OnSyncComplete", (version: number) => {
      console.info(`Sync complete at version ${version}`);
    });
    
    // æˆ˜æ–—æœªæ‰¾åˆ°
    this.connection.on("OnBattleNotFound", (battleId: string) => {
      console.error(`Battle ${battleId} not found`);
      this.onConnectionFailed("Battle not found");
    });
    
    // é‡è¿äº‹ä»¶
    this.connection.onreconnecting((error) => {
      console.warn("Connection lost, reconnecting...", error);
    });
    
    this.connection.onreconnected((connectionId) => {
      console.info("Reconnected with connection", connectionId);
      this.onReconnected();
    });
    
    this.connection.onclose((error) => {
      console.error("Connection closed", error);
      this.onConnectionFailed(error?.message || "Connection closed");
    });
  }
  
  private async onReconnected() {
    this.reconnectAttempts = 0;
    
    // é‡æ–°è®¢é˜…æˆ˜æ–—
    await this.connection!.invoke("SubscribeToBattle", this.battleId);
    
    // åŒæ­¥çŠ¶æ€
    const lastVersion = this.frameReceiver?.getLastVersion() || 0;
    await this.connection!.invoke("SyncBattleState", this.battleId, lastVersion);
  }
  
  private onConnectionFailed(reason: string) {
    // æ˜¾ç¤ºé”™è¯¯æç¤º
    this.showConnectionError(reason);
  }
  
  private showConnectionError(reason: string) {
    // æ˜¾ç¤ºå¯¹è¯æ¡†
    const modal = document.createElement("div");
    modal.innerHTML = `
      <div class="modal">
        <h2>è¿æ¥å¤±è´¥</h2>
        <p>æ— æ³•è¿æ¥åˆ°æˆ˜æ–—æœåŠ¡å™¨ï¼š${reason}</p>
        <button onclick="window.battleConnection.retry()">é‡è¯•</button>
        <button onclick="window.battleConnection.exit()">é€€å‡ºæˆ˜æ–—</button>
      </div>
    `;
    document.body.appendChild(modal);
  }
  
  async setFrequency(frequency: number) {
    if (this.connection?.state === signalR.HubConnectionState.Connected) {
      await this.connection.invoke("SetFrameFrequency", frequency);
    }
  }
  
  async disconnect() {
    if (this.connection) {
      await this.connection.invoke("UnsubscribeFromBattle", this.battleId);
      await this.connection.stop();
    }
  }
  
  getFrameReceiver(): BattleFrameReceiver | null {
    return this.frameReceiver;
  }
}
```

---

## ç‰ˆæœ¬ç®¡ç†å®ç°

### å®Œæ•´çš„ç‰ˆæœ¬å¤„ç†æµç¨‹

```typescript
// ç¤ºä¾‹ï¼šå®Œæ•´çš„ç‰ˆæœ¬å¤„ç†é€»è¾‘
class VersionManager {
  private lastAppliedVersion: number = 0;
  private pendingVersions: Map<number, any> = new Map();
  private missingVersions: Set<number> = new Set();
  
  processIncoming(data: { version: number; [key: string]: any }) {
    const { version } = data;
    
    // Case 1: æœŸæœ›çš„ä¸‹ä¸€ä¸ªç‰ˆæœ¬
    if (version === this.lastAppliedVersion + 1) {
      this.apply(data);
      this.lastAppliedVersion = version;
      this.checkPending();
      return;
    }
    
    // Case 2: è·³è¿‡äº†æŸäº›ç‰ˆæœ¬
    if (version > this.lastAppliedVersion + 1) {
      // æ ‡è®°ç¼ºå¤±çš„ç‰ˆæœ¬
      for (let v = this.lastAppliedVersion + 1; v < version; v++) {
        this.missingVersions.add(v);
      }
      
      // ç¼“å­˜å½“å‰ç‰ˆæœ¬
      this.pendingVersions.set(version, data);
      
      // è¯·æ±‚è¡¥å‘
      this.requestMissing();
      return;
    }
    
    // Case 3: é‡å¤æˆ–è¿‡æ—¶çš„ç‰ˆæœ¬
    console.debug(`Ignoring old version ${version}, current is ${this.lastAppliedVersion}`);
  }
  
  private checkPending() {
    // å°è¯•åº”ç”¨ç¼“å­˜çš„åç»­ç‰ˆæœ¬
    while (this.pendingVersions.has(this.lastAppliedVersion + 1)) {
      const data = this.pendingVersions.get(this.lastAppliedVersion + 1)!;
      this.pendingVersions.delete(this.lastAppliedVersion + 1);
      this.missingVersions.delete(this.lastAppliedVersion + 1);
      
      this.apply(data);
      this.lastAppliedVersion++;
    }
  }
  
  private requestMissing() {
    if (this.missingVersions.size === 0) return;
    
    const missing = Array.from(this.missingVersions).sort((a, b) => a - b);
    const from = missing[0];
    const to = missing[missing.length - 1];
    
    if (to - from > 100) {
      // ç¼ºå£è¿‡å¤§ï¼Œè¯·æ±‚å¿«ç…§
      this.requestSnapshot();
    } else {
      // è¯·æ±‚å¢é‡
      this.requestDelta(from, to);
    }
  }
  
  private apply(data: any) {
    // å®é™…åº”ç”¨æ•°æ®åˆ°çŠ¶æ€
    console.log(`Applied version ${data.version}`);
  }
  
  private requestSnapshot() {
    console.log("Requesting snapshot");
    // å®ç°è¯·æ±‚å¿«ç…§çš„é€»è¾‘
  }
  
  private requestDelta(from: number, to: number) {
    console.log(`Requesting delta ${from}-${to}`);
    // å®ç°è¯·æ±‚å¢é‡çš„é€»è¾‘
  }
}
```

---

## æ€§èƒ½ä¼˜åŒ–å®è·µ

### 1. æ‰¹é‡å‘é€ä¼˜åŒ–

```csharp
// å°†å¤šä¸ªå°å¸§åˆå¹¶ä¸ºä¸€ä¸ªæ‰¹æ¬¡å‘é€
public class BatchedFrameSender
{
    private readonly List<FrameTick> _batch = new();
    private readonly int _maxBatchSize = 5;
    
    public void AddFrame(FrameTick frame)
    {
        _batch.Add(frame);
        
        if (_batch.Count >= _maxBatchSize)
        {
            Flush();
        }
    }
    
    public async Task Flush()
    {
        if (_batch.Count == 0) return;
        
        await _hubContext.Clients.Group(battleId).SendAsync("OnFrameBatch", _batch);
        _batch.Clear();
    }
}
```

### 2. å®¢æˆ·ç«¯èŠ‚æµ

```typescript
class ThrottledRenderer {
  private lastRenderTime: number = 0;
  private minRenderInterval: number = 16; // 60 FPS
  
  requestRender(frame: FrameTick) {
    const now = Date.now();
    
    if (now - this.lastRenderTime < this.minRenderInterval) {
      // è·³è¿‡æ­¤æ¬¡æ¸²æŸ“
      return;
    }
    
    this.render(frame);
    this.lastRenderTime = now;
  }
}
```

---

## æµ‹è¯•ä¸éªŒè¯

### å•å…ƒæµ‹è¯•ç¤ºä¾‹

```csharp
[Fact]
public void BattleInstance_ShouldGenerateFrameWithIncrementingVersion()
{
    // Arrange
    var battle = CreateTestBattle();
    
    // Act
    var frame1 = battle.GenerateFrameTick();
    var frame2 = battle.GenerateFrameTick();
    
    // Assert
    Assert.Equal(1, frame1.Version);
    Assert.Equal(2, frame2.Version);
}

[Fact]
public void BattleFrameBuffer_ShouldReturnDeltaFrames()
{
    // Arrange
    var buffer = new BattleFrameBuffer();
    var frames = Enumerable.Range(1, 10)
        .Select(v => new FrameTick { Version = v })
        .ToList();
    
    foreach (var frame in frames)
    {
        buffer.AddFrame(frame);
    }
    
    // Act
    var delta = buffer.GetFrames(3, 7);
    
    // Assert
    Assert.Equal(5, delta.Count);
    Assert.Equal(3, delta[0].Version);
    Assert.Equal(7, delta[4].Version);
}
```

### é›†æˆæµ‹è¯•ç¤ºä¾‹

```typescript
describe("BattleFrameReceiver", () => {
  it("should handle out-of-order frames", async () => {
    const receiver = new BattleFrameReceiver(mockConnection, "battle-123");
    const appliedFrames: number[] = [];
    
    receiver.setCallbacks({
      onFrameApplied: (frame) => appliedFrames.push(frame.version)
    });
    
    // æ¥æ”¶ä¹±åºçš„å¸§
    receiver.onFrameReceived({ version: 1, /* ... */ });
    receiver.onFrameReceived({ version: 3, /* ... */ }); // è·³è¿‡ 2
    receiver.onFrameReceived({ version: 2, /* ... */ }); // è¡¥å…… 2
    
    // éªŒè¯æŒ‰é¡ºåºåº”ç”¨
    expect(appliedFrames).toEqual([1, 2, 3]);
  });
});
```

---

## ğŸ“ æ€»ç»“

æœ¬å®ç°æŒ‡å—æä¾›äº†ï¼š

âœ… **æœåŠ¡ç«¯æˆ˜æ–—å®ä¾‹æ‰©å±•**: æ·»åŠ å¸§ç”Ÿæˆã€ç¼“å†²å’Œç‰ˆæœ¬ç®¡ç†  
âœ… **å¸§å¹¿æ’­æœåŠ¡**: åå°æœåŠ¡å®šæ—¶å¹¿æ’­å¸§  
âœ… **SignalR Hub**: è¿æ¥ç®¡ç†ã€è®¢é˜…å’ŒåŒæ­¥  
âœ… **å®¢æˆ·ç«¯å¸§æ¥æ”¶å™¨**: ç‰ˆæœ¬å¤„ç†ã€ç¼ºå£æ£€æµ‹å’Œè¡¥å‘  
âœ… **è¿æ¥ç®¡ç†**: é‡è¿ã€åŒæ­¥å’Œé”™è¯¯å¤„ç†  
âœ… **æ€§èƒ½ä¼˜åŒ–**: æ‰¹é‡å‘é€å’Œå®¢æˆ·ç«¯èŠ‚æµ  
âœ… **æµ‹è¯•æ–¹æ¡ˆ**: å•å…ƒæµ‹è¯•å’Œé›†æˆæµ‹è¯•ç¤ºä¾‹

éµå¾ªæœ¬æŒ‡å—å®ç°ï¼Œå¯ä»¥æ„å»ºä¸€ä¸ª**ä½å»¶è¿Ÿã€é«˜å¯é æ€§**çš„å®æ—¶æˆ˜æ–—å¸§æ¨é€ç³»ç»Ÿã€‚

---

**æ–‡æ¡£çŠ¶æ€**: âœ… å®Œæˆ  
**æœ€åæ›´æ–°**: 2025å¹´10æœˆ21æ—¥
