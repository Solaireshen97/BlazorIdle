# 战斗帧广播系统实现指南

**文档版本**: 2.0  
**适用于**: BlazorIdle 实时帧推送系统  
**前置文档**: [实时帧推送设计方案](./实时帧推送设计方案.md)

---

## 📋 目录

1. [服务端实现](#服务端实现)
2. [客户端实现](#客户端实现)
3. [SignalR Hub 设计](#signalr-hub-设计)
4. [版本管理实现](#版本管理实现)
5. [性能优化实践](#性能优化实践)
6. [测试与验证](#测试与验证)

---

## 服务端实现

### 1. 战斗实例扩展

为现有的 `BattleInstance` 添加帧管理能力：

```csharp
// Domain/Combat/BattleInstance.cs
public class BattleInstance
{
    // 现有字段...
    private long _currentVersion = 0;
    private readonly BattleFrameBuffer _frameBuffer;
    private readonly List<KeyEvent> _pendingKeyEvents = new();
    
    public long CurrentVersion => _currentVersion;
    
    public BattleInstance(/* 现有参数 */)
    {
        // 现有初始化...
        _frameBuffer = new BattleFrameBuffer(maxSize: 300);
    }
    
    // 生成帧数据
    public FrameTick GenerateFrameTick()
    {
        var version = Interlocked.Increment(ref _currentVersion);
        
        var frame = new FrameTick
        {
            Version = version,
            ServerTime = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds(),
            BattleId = Id.ToString(),
            Phase = GetCurrentPhase(),
            
            Metrics = new FrameMetrics
            {
                CastProgress = GetCastProgress(),
                Dps = new DpsMetrics
                {
                    Player = CalculatePlayerDps(),
                    Received = CalculateReceivedDps()
                },
                Health = new HealthMetrics
                {
                    Current = _characterState.CurrentHp,
                    Max = _characterState.MaxHp,
                    Delta = _characterState.HpDeltaSinceLastFrame
                },
                Shield = new ShieldMetrics
                {
                    Current = _characterState.Shield,
                    Delta = _characterState.ShieldDeltaSinceLastFrame
                },
                Buffs = GetBuffChanges(),
                ExpiredBuffs = GetExpiredBuffIds()
            },
            
            Aggregates = new FrameAggregates
            {
                WindowStart = _lastFrameTime,
                WindowEnd = _clock.CurrentTime,
                Damage = AggregrateDamage(),
                Healing = AggregateHealing(),
                Hits = AggregateHits()
            },
            
            Events = _pendingKeyEvents.Count > 0 ? _pendingKeyEvents.ToArray() : null
        };
        
        // 重置增量统计
        ResetFrameDeltas();
        _lastFrameTime = _clock.CurrentTime;
        
        return frame;
    }
    
    // 生成快照
    public BattleSnapshot GenerateSnapshot()
    {
        return new BattleSnapshot
        {
            Version = _currentVersion,
            ServerTime = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds(),
            BattleId = Id.ToString(),
            State = new BattleState
            {
                Phase = GetCurrentPhase(),
                ElapsedTime = _clock.CurrentTime,
                Player = new PlayerState
                {
                    Health = new HealthSnapshot { Current = _characterState.CurrentHp, Max = _characterState.MaxHp },
                    Shield = _characterState.Shield,
                    Resources = _characterState.Resources.ToDictionary(r => r.Key, r => r.Value.Current),
                    Buffs = _characterState.Buffs.Select(b => ToBuffSnapshot(b)).ToArray(),
                    Debuffs = _characterState.Debuffs.Select(d => ToBuffSnapshot(d)).ToArray()
                },
                Enemies = _enemyStates.Select(e => ToEnemySnapshot(e)).ToArray(),
                Statistics = GetCurrentStatistics()
            }
        };
    }
    
    // 添加关键事件
    public void AddKeyEvent(KeyEvent evt)
    {
        evt.Version = Interlocked.Increment(ref _currentVersion);
        evt.Timestamp = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds();
        evt.BattleId = Id.ToString();
        
        _pendingKeyEvents.Add(evt);
    }
    
    // 清除已发送的关键事件
    public void ClearPendingKeyEvents()
    {
        _pendingKeyEvents.Clear();
    }
    
    // 获取历史帧
    public List<FrameTick> GetDeltaFrames(long fromVersion, long toVersion)
    {
        return _frameBuffer.GetFrames(fromVersion, toVersion);
    }
    
    // 缓存帧
    public void BufferFrame(FrameTick frame)
    {
        _frameBuffer.AddFrame(frame);
    }
    
    // 辅助方法
    private BattlePhase GetCurrentPhase()
    {
        if (_isCompleted) return BattlePhase.Ended;
        if (_isPaused) return BattlePhase.Paused;
        return BattlePhase.Active;
    }
    
    private CastProgress? GetCastProgress()
    {
        // 如果有技能正在读条，返回进度
        var casting = _characterState.CurrentCast;
        if (casting == null) return null;
        
        var elapsed = _clock.CurrentTime - casting.StartTime;
        var progress = elapsed / casting.CastTime;
        
        return new CastProgress
        {
            SkillId = casting.SkillId,
            Progress = Math.Clamp(progress, 0, 1),
            Remaining = Math.Max(0, casting.CastTime - elapsed)
        };
    }
    
    private double CalculatePlayerDps()
    {
        var window = 5.0; // 5秒窗口
        var recentDamage = _damageHistory
            .Where(d => d.Timestamp > _clock.CurrentTime - window)
            .Sum(d => d.Amount);
        
        return recentDamage / window;
    }
    
    private List<BuffChange> GetBuffChanges()
    {
        // 返回自上次帧以来新增或刷新的 Buff
        return _characterState.Buffs
            .Where(b => b.LastUpdateTime > _lastFrameTime)
            .Select(b => new BuffChange
            {
                BuffId = b.Id,
                Stacks = b.Stacks,
                Duration = b.RemainingDuration(_clock.CurrentTime),
                AppliedAt = b.AppliedAt
            })
            .ToList();
    }
    
    private List<string> GetExpiredBuffIds()
    {
        // 返回自上次帧以来过期的 Buff ID
        return _characterState.ExpiredBuffsSinceLastFrame.ToList();
    }
    
    private void ResetFrameDeltas()
    {
        _characterState.HpDeltaSinceLastFrame = 0;
        _characterState.ShieldDeltaSinceLastFrame = 0;
        _characterState.ExpiredBuffsSinceLastFrame.Clear();
    }
}
```

### 2. 帧缓冲管理

```csharp
// Infrastructure/Messaging/BattleFrameBuffer.cs
public class BattleFrameBuffer
{
    private readonly ConcurrentDictionary<long, FrameTick> _frames = new();
    private readonly int _maxSize;
    private long _minVersion = 0;
    
    public BattleFrameBuffer(int maxSize = 300)
    {
        _maxSize = maxSize;
    }
    
    public void AddFrame(FrameTick frame)
    {
        _frames[frame.Version] = frame;
        
        // 清理过旧的帧
        if (_frames.Count > _maxSize)
        {
            CleanupOldFrames();
        }
    }
    
    public List<FrameTick> GetFrames(long fromVersion, long toVersion)
    {
        var frames = new List<FrameTick>();
        
        for (long v = fromVersion; v <= toVersion; v++)
        {
            if (_frames.TryGetValue(v, out var frame))
            {
                frames.Add(frame);
            }
            else
            {
                // 缺少某些帧，返回空表示需要快照
                return new List<FrameTick>();
            }
        }
        
        return frames;
    }
    
    private void CleanupOldFrames()
    {
        var versions = _frames.Keys.OrderBy(v => v).ToList();
        var toRemove = versions.Take(versions.Count - _maxSize).ToList();
        
        foreach (var version in toRemove)
        {
            _frames.TryRemove(version, out _);
        }
        
        _minVersion = versions.Skip(versions.Count - _maxSize).FirstOrDefault();
    }
}
```

### 3. 帧广播服务

```csharp
// Infrastructure/Messaging/BattleFrameBroadcaster.cs
public class BattleFrameBroadcaster : BackgroundService
{
    private readonly IHubContext<BattleHub> _hubContext;
    private readonly IBattleManager _battleManager;
    private readonly ILogger<BattleFrameBroadcaster> _logger;
    private readonly ConcurrentDictionary<string, BattleFrameConfig> _configs = new();
    
    public BattleFrameBroadcaster(
        IHubContext<BattleHub> hubContext,
        IBattleManager battleManager,
        ILogger<BattleFrameBroadcaster> logger)
    {
        _hubContext = hubContext;
        _battleManager = battleManager;
        _logger = logger;
    }
    
    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        _logger.LogInformation("BattleFrameBroadcaster started");
        
        while (!stoppingToken.IsCancellationRequested)
        {
            try
            {
                await BroadcastFrames(stoppingToken);
                await Task.Delay(10, stoppingToken); // 10ms 精度
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error in BattleFrameBroadcaster");
            }
        }
        
        _logger.LogInformation("BattleFrameBroadcaster stopped");
    }
    
    private async Task BroadcastFrames(CancellationToken ct)
    {
        var now = DateTime.UtcNow;
        
        foreach (var (battleId, config) in _configs)
        {
            if (ct.IsCancellationRequested) break;
            
            var intervalMs = 1000.0 / config.Frequency;
            var elapsed = (now - config.LastBroadcast).TotalMilliseconds;
            
            if (elapsed >= intervalMs)
            {
                await BroadcastFrame(battleId, config);
                config.LastBroadcast = now;
            }
        }
    }
    
    private async Task BroadcastFrame(string battleId, BattleFrameConfig config)
    {
        try
        {
            var battle = _battleManager.GetBattle(Guid.Parse(battleId));
            if (battle == null)
            {
                // 战斗已结束，移除配置
                _configs.TryRemove(battleId, out _);
                return;
            }
            
            // 生成帧
            var frame = battle.GenerateFrameTick();
            
            // 缓存帧（用于补发）
            battle.BufferFrame(frame);
            
            // 推送到 group
            await _hubContext.Clients.Group(battleId).SendAsync("OnFrameTick", frame);
            
            // 定期生成快照
            if (frame.Version % 300 == 0) // 每 300 帧
            {
                var snapshot = battle.GenerateSnapshot();
                config.LastSnapshot = snapshot;
                _logger.LogDebug("Generated snapshot for battle {BattleId} at version {Version}",
                    battleId, snapshot.Version);
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error broadcasting frame for battle {BattleId}", battleId);
        }
    }
    
    public void StartBroadcast(string battleId, int frequency = 8)
    {
        _configs[battleId] = new BattleFrameConfig
        {
            Frequency = Math.Clamp(frequency, 2, 10),
            LastBroadcast = DateTime.UtcNow
        };
        
        _logger.LogInformation("Started broadcast for battle {BattleId} at {Frequency}Hz",
            battleId, frequency);
    }
    
    public void StopBroadcast(string battleId)
    {
        if (_configs.TryRemove(battleId, out _))
        {
            _logger.LogInformation("Stopped broadcast for battle {BattleId}", battleId);
        }
    }
    
    public void SetFrequency(string battleId, int frequency)
    {
        if (_configs.TryGetValue(battleId, out var config))
        {
            config.Frequency = Math.Clamp(frequency, 2, 10);
            _logger.LogDebug("Updated frequency for battle {BattleId} to {Frequency}Hz",
                battleId, frequency);
        }
    }
}

public class BattleFrameConfig
{
    public int Frequency { get; set; } = 8;
    public DateTime LastBroadcast { get; set; } = DateTime.UtcNow;
    public BattleSnapshot? LastSnapshot { get; set; }
}
```

---

## SignalR Hub 设计

### BattleHub 实现

```csharp
// API/Hubs/BattleHub.cs
public class BattleHub : Hub
{
    private readonly IBattleManager _battleManager;
    private readonly IBattleFrameBroadcaster _broadcaster;
    private readonly ILogger<BattleHub> _logger;
    
    public BattleHub(
        IBattleManager battleManager,
        IBattleFrameBroadcaster broadcaster,
        ILogger<BattleHub> logger)
    {
        _battleManager = battleManager;
        _broadcaster = broadcaster;
        _logger = logger;
    }
    
    // 连接管理
    public override async Task OnConnectedAsync()
    {
        var userId = GetUserId();
        _logger.LogInformation("User {UserId} connected to BattleHub", userId);
        await base.OnConnectedAsync();
    }
    
    public override async Task OnDisconnectedAsync(Exception? exception)
    {
        var userId = GetUserId();
        
        if (exception != null)
        {
            _logger.LogWarning(exception, "User {UserId} disconnected with error", userId);
        }
        
        // 清理订阅
        await CleanupUserSubscriptions(userId);
        
        await base.OnDisconnectedAsync(exception);
    }
    
    // 订阅战斗
    public async Task SubscribeToBattle(string battleId)
    {
        var userId = GetUserId();
        var battle = _battleManager.GetBattle(Guid.Parse(battleId));
        
        if (battle == null)
        {
            await Clients.Caller.SendAsync("OnBattleNotFound", battleId);
            return;
        }
        
        // 加入 group
        await Groups.AddToGroupAsync(Context.ConnectionId, battleId);
        _logger.LogInformation("User {UserId} subscribed to battle {BattleId}", userId, battleId);
        
        // 启动帧广播（如果尚未启动）
        _broadcaster.StartBroadcast(battleId);
        
        // 发送当前快照
        var snapshot = battle.GenerateSnapshot();
        await Clients.Caller.SendAsync("OnBattleSnapshot", snapshot);
    }
    
    // 取消订阅战斗
    public async Task UnsubscribeFromBattle(string battleId)
    {
        var userId = GetUserId();
        
        await Groups.RemoveFromGroupAsync(Context.ConnectionId, battleId);
        _logger.LogInformation("User {UserId} unsubscribed from battle {BattleId}", userId, battleId);
        
        // 检查 group 是否为空，如果是则停止广播
        // 注意：SignalR 没有直接 API 检查 group 成员数，需要自己维护
    }
    
    // 同步战斗状态（重连后）
    public async Task SyncBattleState(string battleId, long clientLastVersion)
    {
        var userId = GetUserId();
        var battle = _battleManager.GetBattle(Guid.Parse(battleId));
        
        if (battle == null)
        {
            await Clients.Caller.SendAsync("OnBattleNotFound", battleId);
            return;
        }
        
        var currentVersion = battle.CurrentVersion;
        var gap = currentVersion - clientLastVersion;
        
        _logger.LogInformation(
            "User {UserId} syncing battle {BattleId}, clientVersion={ClientVersion}, currentVersion={CurrentVersion}, gap={Gap}",
            userId, battleId, clientLastVersion, currentVersion, gap);
        
        if (gap <= 0)
        {
            // 客户端已是最新
            await Clients.Caller.SendAsync("OnSyncComplete", currentVersion);
            return;
        }
        
        // 判断是发送增量还是快照
        const long SnapshotThreshold = 100;
        
        if (gap > SnapshotThreshold || clientLastVersion == 0)
        {
            // 发送快照
            var snapshot = battle.GenerateSnapshot();
            await Clients.Caller.SendAsync("OnBattleSnapshot", snapshot);
            _logger.LogInformation("Sent snapshot to {UserId} for battle {BattleId}", userId, battleId);
        }
        else
        {
            // 尝试发送增量
            var deltaFrames = battle.GetDeltaFrames(clientLastVersion + 1, currentVersion);
            
            if (deltaFrames.Count == 0)
            {
                // 增量不可用，降级为快照
                var snapshot = battle.GenerateSnapshot();
                await Clients.Caller.SendAsync("OnBattleSnapshot", snapshot);
                _logger.LogWarning("Delta frames not available, sent snapshot to {UserId} for battle {BattleId}",
                    userId, battleId);
            }
            else
            {
                // 发送增量
                await Clients.Caller.SendAsync("OnDeltaFrames", deltaFrames);
                _logger.LogInformation("Sent {Count} delta frames to {UserId} for battle {BattleId}",
                    deltaFrames.Count, userId, battleId);
            }
        }
        
        await Clients.Caller.SendAsync("OnSyncComplete", currentVersion);
    }
    
    // 设置推送频率
    public async Task SetFrameFrequency(int frequency)
    {
        var userId = GetUserId();
        
        // 需要维护用户当前订阅的战斗列表
        var userBattles = GetUserBattles(userId);
        
        foreach (var battleId in userBattles)
        {
            _broadcaster.SetFrequency(battleId, frequency);
        }
        
        _logger.LogInformation("User {UserId} set frame frequency to {Frequency}Hz", userId, frequency);
        await Task.CompletedTask;
    }
    
    // 心跳（保活）
    public Task Heartbeat()
    {
        return Task.CompletedTask;
    }
    
    // 辅助方法
    private string GetUserId()
    {
        return Context.User?.FindFirst("sub")?.Value 
            ?? Context.User?.FindFirst(ClaimTypes.NameIdentifier)?.Value
            ?? "anonymous";
    }
    
    private async Task CleanupUserSubscriptions(string userId)
    {
        var userBattles = GetUserBattles(userId);
        
        foreach (var battleId in userBattles)
        {
            await Groups.RemoveFromGroupAsync(Context.ConnectionId, battleId);
        }
    }
    
    private List<string> GetUserBattles(string userId)
    {
        // 实现：从缓存或数据库获取用户当前订阅的战斗列表
        // 这需要额外的状态管理
        return new List<string>();
    }
}
```

---

## 客户端实现

### 1. 帧接收器

```typescript
// Services/BattleFrameReceiver.ts
export class BattleFrameReceiver {
  private lastVersion: number = 0;
  private bufferedFrames: Map<number, FrameTick | KeyEvent> = new Map();
  private maxGapBeforeSnapshot: number = 100;
  
  private onFrameApplied?: (frame: FrameTick) => void;
  private onKeyEventReceived?: (event: KeyEvent) => void;
  private onSnapshotApplied?: (snapshot: BattleSnapshot) => void;
  
  constructor(
    private connection: signalR.HubConnection,
    private battleId: string
  ) {}
  
  // 设置回调
  setCallbacks(callbacks: {
    onFrameApplied?: (frame: FrameTick) => void;
    onKeyEventReceived?: (event: KeyEvent) => void;
    onSnapshotApplied?: (snapshot: BattleSnapshot) => void;
  }) {
    this.onFrameApplied = callbacks.onFrameApplied;
    this.onKeyEventReceived = callbacks.onKeyEventReceived;
    this.onSnapshotApplied = callbacks.onSnapshotApplied;
  }
  
  // 处理接收到的帧
  onFrameReceived(frame: FrameTick) {
    const receivedVersion = frame.version;
    
    if (receivedVersion === this.lastVersion + 1) {
      // 正常顺序
      this.applyFrame(frame);
      this.lastVersion = receivedVersion;
      
      // 尝试应用缓存的帧
      this.flushBufferedFrames();
    }
    else if (receivedVersion > this.lastVersion + 1) {
      // 检测到缺口
      const gap = receivedVersion - this.lastVersion;
      
      console.warn(`Frame gap detected: expected ${this.lastVersion + 1}, got ${receivedVersion}, gap=${gap}`);
      
      if (gap > this.maxGapBeforeSnapshot) {
        // 缺口过大，请求快照
        this.requestSnapshot();
      } else {
        // 请求增量
        this.requestDeltaFrames(this.lastVersion + 1, receivedVersion - 1);
      }
      
      // 缓存当前帧
      this.bufferedFrames.set(receivedVersion, frame);
    }
    else {
      // 重复或乱序旧包，丢弃
      console.debug(`Discarding old/duplicate frame: ${receivedVersion}`);
    }
  }
  
  // 处理关键事件
  onKeyEventReceived(event: KeyEvent) {
    // 关键事件也遵循版本机制
    if (event.version === this.lastVersion + 1) {
      this.onKeyEventReceived?.(event);
      this.lastVersion = event.version;
      this.flushBufferedFrames();
    }
    else if (event.version > this.lastVersion + 1) {
      // 缓存
      this.bufferedFrames.set(event.version, event);
    }
    // 否则丢弃
  }
  
  // 应用快照
  onSnapshotReceived(snapshot: BattleSnapshot) {
    console.info(`Applying snapshot at version ${snapshot.version}`);
    
    this.onSnapshotApplied?.(snapshot);
    this.lastVersion = snapshot.version;
    
    // 清空缓存
    this.bufferedFrames.clear();
  }
  
  // 应用增量帧
  onDeltaFramesReceived(frames: FrameTick[]) {
    console.info(`Received ${frames.length} delta frames`);
    
    // 按版本号排序
    frames.sort((a, b) => a.version - b.version);
    
    for (const frame of frames) {
      if (frame.version === this.lastVersion + 1) {
        this.applyFrame(frame);
        this.lastVersion = frame.version;
      }
    }
    
    // 尝试应用缓存的帧
    this.flushBufferedFrames();
  }
  
  // 应用帧
  private applyFrame(frame: FrameTick) {
    this.onFrameApplied?.(frame);
    
    // 处理附加的关键事件
    if (frame.events) {
      for (const event of frame.events) {
        this.onKeyEventReceived?.(event);
      }
    }
  }
  
  // 刷新缓存的帧
  private flushBufferedFrames() {
    while (this.bufferedFrames.has(this.lastVersion + 1)) {
      const frame = this.bufferedFrames.get(this.lastVersion + 1)!;
      this.bufferedFrames.delete(this.lastVersion + 1);
      
      if ('metrics' in frame) {
        // FrameTick
        this.applyFrame(frame as FrameTick);
      } else {
        // KeyEvent
        this.onKeyEventReceived?.(frame as KeyEvent);
      }
      
      this.lastVersion++;
    }
  }
  
  // 请求快照
  private requestSnapshot() {
    console.info(`Requesting snapshot for battle ${this.battleId}`);
    this.connection.invoke("SyncBattleState", this.battleId, this.lastVersion);
  }
  
  // 请求增量帧
  private requestDeltaFrames(fromVersion: number, toVersion: number) {
    console.info(`Requesting delta frames ${fromVersion}-${toVersion} for battle ${this.battleId}`);
    this.connection.invoke("SyncBattleState", this.battleId, this.lastVersion);
  }
  
  getLastVersion(): number {
    return this.lastVersion;
  }
  
  reset() {
    this.lastVersion = 0;
    this.bufferedFrames.clear();
  }
}
```

### 2. 战斗连接管理

```typescript
// Services/BattleConnection.ts
export class BattleConnection {
  private connection: signalR.HubConnection | null = null;
  private frameReceiver: BattleFrameReceiver | null = null;
  private reconnectAttempts: number = 0;
  private maxReconnectAttempts: number = 5;
  private reconnectDelays: number[] = [0, 2000, 5000, 10000, 20000];
  
  constructor(
    private hubUrl: string,
    private battleId: string
  ) {}
  
  async connect(): Promise<void> {
    this.connection = new signalR.HubConnectionBuilder()
      .withUrl(this.hubUrl)
      .withAutomaticReconnect({
        nextRetryDelayInMilliseconds: (retryContext) => {
          return this.reconnectDelays[Math.min(retryContext.previousRetryCount, 4)];
        }
      })
      .configureLogging(signalR.LogLevel.Information)
      .build();
    
    // 注册事件处理
    this.setupEventHandlers();
    
    // 启动连接
    await this.connection.start();
    console.info("Connected to BattleHub");
    
    // 订阅战斗
    await this.connection.invoke("SubscribeToBattle", this.battleId);
    
    // 创建帧接收器
    this.frameReceiver = new BattleFrameReceiver(this.connection, this.battleId);
  }
  
  private setupEventHandlers() {
    if (!this.connection) return;
    
    // 帧更新
    this.connection.on("OnFrameTick", (frame: FrameTick) => {
      this.frameReceiver?.onFrameReceived(frame);
    });
    
    // 关键事件
    this.connection.on("OnKeyEvent", (event: KeyEvent) => {
      this.frameReceiver?.onKeyEventReceived(event);
    });
    
    // 快照
    this.connection.on("OnBattleSnapshot", (snapshot: BattleSnapshot) => {
      this.frameReceiver?.onSnapshotReceived(snapshot);
    });
    
    // 增量帧
    this.connection.on("OnDeltaFrames", (frames: FrameTick[]) => {
      this.frameReceiver?.onDeltaFramesReceived(frames);
    });
    
    // 同步完成
    this.connection.on("OnSyncComplete", (version: number) => {
      console.info(`Sync complete at version ${version}`);
    });
    
    // 战斗未找到
    this.connection.on("OnBattleNotFound", (battleId: string) => {
      console.error(`Battle ${battleId} not found`);
      this.onConnectionFailed("Battle not found");
    });
    
    // 重连事件
    this.connection.onreconnecting((error) => {
      console.warn("Connection lost, reconnecting...", error);
    });
    
    this.connection.onreconnected((connectionId) => {
      console.info("Reconnected with connection", connectionId);
      this.onReconnected();
    });
    
    this.connection.onclose((error) => {
      console.error("Connection closed", error);
      this.onConnectionFailed(error?.message || "Connection closed");
    });
  }
  
  private async onReconnected() {
    this.reconnectAttempts = 0;
    
    // 重新订阅战斗
    await this.connection!.invoke("SubscribeToBattle", this.battleId);
    
    // 同步状态
    const lastVersion = this.frameReceiver?.getLastVersion() || 0;
    await this.connection!.invoke("SyncBattleState", this.battleId, lastVersion);
  }
  
  private onConnectionFailed(reason: string) {
    // 显示错误提示
    this.showConnectionError(reason);
  }
  
  private showConnectionError(reason: string) {
    // 显示对话框
    const modal = document.createElement("div");
    modal.innerHTML = `
      <div class="modal">
        <h2>连接失败</h2>
        <p>无法连接到战斗服务器：${reason}</p>
        <button onclick="window.battleConnection.retry()">重试</button>
        <button onclick="window.battleConnection.exit()">退出战斗</button>
      </div>
    `;
    document.body.appendChild(modal);
  }
  
  async setFrequency(frequency: number) {
    if (this.connection?.state === signalR.HubConnectionState.Connected) {
      await this.connection.invoke("SetFrameFrequency", frequency);
    }
  }
  
  async disconnect() {
    if (this.connection) {
      await this.connection.invoke("UnsubscribeFromBattle", this.battleId);
      await this.connection.stop();
    }
  }
  
  getFrameReceiver(): BattleFrameReceiver | null {
    return this.frameReceiver;
  }
}
```

---

## 版本管理实现

### 完整的版本处理流程

```typescript
// 示例：完整的版本处理逻辑
class VersionManager {
  private lastAppliedVersion: number = 0;
  private pendingVersions: Map<number, any> = new Map();
  private missingVersions: Set<number> = new Set();
  
  processIncoming(data: { version: number; [key: string]: any }) {
    const { version } = data;
    
    // Case 1: 期望的下一个版本
    if (version === this.lastAppliedVersion + 1) {
      this.apply(data);
      this.lastAppliedVersion = version;
      this.checkPending();
      return;
    }
    
    // Case 2: 跳过了某些版本
    if (version > this.lastAppliedVersion + 1) {
      // 标记缺失的版本
      for (let v = this.lastAppliedVersion + 1; v < version; v++) {
        this.missingVersions.add(v);
      }
      
      // 缓存当前版本
      this.pendingVersions.set(version, data);
      
      // 请求补发
      this.requestMissing();
      return;
    }
    
    // Case 3: 重复或过时的版本
    console.debug(`Ignoring old version ${version}, current is ${this.lastAppliedVersion}`);
  }
  
  private checkPending() {
    // 尝试应用缓存的后续版本
    while (this.pendingVersions.has(this.lastAppliedVersion + 1)) {
      const data = this.pendingVersions.get(this.lastAppliedVersion + 1)!;
      this.pendingVersions.delete(this.lastAppliedVersion + 1);
      this.missingVersions.delete(this.lastAppliedVersion + 1);
      
      this.apply(data);
      this.lastAppliedVersion++;
    }
  }
  
  private requestMissing() {
    if (this.missingVersions.size === 0) return;
    
    const missing = Array.from(this.missingVersions).sort((a, b) => a - b);
    const from = missing[0];
    const to = missing[missing.length - 1];
    
    if (to - from > 100) {
      // 缺口过大，请求快照
      this.requestSnapshot();
    } else {
      // 请求增量
      this.requestDelta(from, to);
    }
  }
  
  private apply(data: any) {
    // 实际应用数据到状态
    console.log(`Applied version ${data.version}`);
  }
  
  private requestSnapshot() {
    console.log("Requesting snapshot");
    // 实现请求快照的逻辑
  }
  
  private requestDelta(from: number, to: number) {
    console.log(`Requesting delta ${from}-${to}`);
    // 实现请求增量的逻辑
  }
}
```

---

## 性能优化实践

### 1. 批量发送优化

```csharp
// 将多个小帧合并为一个批次发送
public class BatchedFrameSender
{
    private readonly List<FrameTick> _batch = new();
    private readonly int _maxBatchSize = 5;
    
    public void AddFrame(FrameTick frame)
    {
        _batch.Add(frame);
        
        if (_batch.Count >= _maxBatchSize)
        {
            Flush();
        }
    }
    
    public async Task Flush()
    {
        if (_batch.Count == 0) return;
        
        await _hubContext.Clients.Group(battleId).SendAsync("OnFrameBatch", _batch);
        _batch.Clear();
    }
}
```

### 2. 客户端节流

```typescript
class ThrottledRenderer {
  private lastRenderTime: number = 0;
  private minRenderInterval: number = 16; // 60 FPS
  
  requestRender(frame: FrameTick) {
    const now = Date.now();
    
    if (now - this.lastRenderTime < this.minRenderInterval) {
      // 跳过此次渲染
      return;
    }
    
    this.render(frame);
    this.lastRenderTime = now;
  }
}
```

---

## 测试与验证

### 单元测试示例

```csharp
[Fact]
public void BattleInstance_ShouldGenerateFrameWithIncrementingVersion()
{
    // Arrange
    var battle = CreateTestBattle();
    
    // Act
    var frame1 = battle.GenerateFrameTick();
    var frame2 = battle.GenerateFrameTick();
    
    // Assert
    Assert.Equal(1, frame1.Version);
    Assert.Equal(2, frame2.Version);
}

[Fact]
public void BattleFrameBuffer_ShouldReturnDeltaFrames()
{
    // Arrange
    var buffer = new BattleFrameBuffer();
    var frames = Enumerable.Range(1, 10)
        .Select(v => new FrameTick { Version = v })
        .ToList();
    
    foreach (var frame in frames)
    {
        buffer.AddFrame(frame);
    }
    
    // Act
    var delta = buffer.GetFrames(3, 7);
    
    // Assert
    Assert.Equal(5, delta.Count);
    Assert.Equal(3, delta[0].Version);
    Assert.Equal(7, delta[4].Version);
}
```

### 集成测试示例

```typescript
describe("BattleFrameReceiver", () => {
  it("should handle out-of-order frames", async () => {
    const receiver = new BattleFrameReceiver(mockConnection, "battle-123");
    const appliedFrames: number[] = [];
    
    receiver.setCallbacks({
      onFrameApplied: (frame) => appliedFrames.push(frame.version)
    });
    
    // 接收乱序的帧
    receiver.onFrameReceived({ version: 1, /* ... */ });
    receiver.onFrameReceived({ version: 3, /* ... */ }); // 跳过 2
    receiver.onFrameReceived({ version: 2, /* ... */ }); // 补充 2
    
    // 验证按顺序应用
    expect(appliedFrames).toEqual([1, 2, 3]);
  });
});
```

---

## 📝 总结

本实现指南提供了：

✅ **服务端战斗实例扩展**: 添加帧生成、缓冲和版本管理  
✅ **帧广播服务**: 后台服务定时广播帧  
✅ **SignalR Hub**: 连接管理、订阅和同步  
✅ **客户端帧接收器**: 版本处理、缺口检测和补发  
✅ **连接管理**: 重连、同步和错误处理  
✅ **性能优化**: 批量发送和客户端节流  
✅ **测试方案**: 单元测试和集成测试示例

遵循本指南实现，可以构建一个**低延迟、高可靠性**的实时战斗帧推送系统。

---

**文档状态**: ✅ 完成  
**最后更新**: 2025年10月21日
