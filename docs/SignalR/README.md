# SignalR 推送系统设计文档

欢迎查阅 BlazorIdle 项目的 SignalR 推送系统设计方案。

---

## ⚠️ 设计版本说明

本目录包含两个版本的设计文档：

### **版本 2.0（推荐）- 实时帧推送系统**

基于用户需求更新的最新设计，采用固定频率帧广播机制：

| 文档 | 说明 | 阅读时间 |
|------|------|----------|
| [实时帧推送设计方案.md](./实时帧推送设计方案.md) | **核心设计文档** - 完整的帧推送系统架构 | 60分钟 |
| [战斗帧广播系统实现指南.md](./战斗帧广播系统实现指南.md) | 服务端和客户端详细实现指南 | 50分钟 |
| [前端渲染策略与时间同步.md](./前端渲染策略与时间同步.md) | 前端渲染、插值和时间同步策略 | 40分钟 |

**核心特性**：
- ✅ 持续 SignalR 事件流（无轮询降级）
- ✅ 5-10Hz 固定频率帧广播
- ✅ 版本号机制处理乱序/丢包
- ✅ 快照 + 增量补发
- ✅ 前端插值/外推渲染
- ✅ 低延迟 (< 200ms)

### **版本 1.0（已过时）- CombatSegment 聚合系统**

原始设计，基于事件聚合推送：

| 文档 | 说明 | 状态 |
|------|------|------|
| [SignalR设计总览.md](./SignalR设计总览.md) | 原始系统整体架构 | ⚠️ 已过时 |
| [Phase1-基础架构设计.md](./Phase1-基础架构设计.md) | SignalR 基础设施搭建 | ⚠️ 已过时 |
| [Phase2-战斗事件集成.md](./Phase2-战斗事件集成.md) | CombatSegment 推送方案 | ⚠️ 已过时 |
| [Phase3-扩展性设计.md](./Phase3-扩展性设计.md) | 通用事件框架 | ⚠️ 已过时 |

**注意**：版本 1.0 的设计因以下问题被替代：
- ❌ 包含轮询降级（不再需要）
- ❌ CombatSegment 延迟过高
- ❌ 不满足低延迟实时更新需求

---

## 🎯 设计目标（版本 2.0）

### 核心价值

1. **实时性**: 帧推送延迟 < 200ms，5-10Hz 固定频率
2. **可靠性**: 版本号机制确保消息顺序，支持丢包恢复
3. **低延迟**: 前端插值/外推实现流畅渲染
4. **高性能**: 异步广播不阻塞战斗计算
5. **易维护**: 清晰的架构和完整的文档

---

## 📖 快速开始（版本 2.0）

### 推荐阅读顺序

1. **首先阅读** [实时帧推送设计方案.md](./实时帧推送设计方案.md)
   - 了解整体架构
   - 理解帧类型（FrameTick、KeyEvent、Snapshot）
   - 掌握版本机制

2. **然后学习** [战斗帧广播系统实现指南.md](./战斗帧广播系统实现指南.md)
   - 服务端战斗实例扩展
   - 帧广播服务实现
   - SignalR Hub 设计
   - 客户端帧接收器

3. **最后参考** [前端渲染策略与时间同步.md](./前端渲染策略与时间同步.md)
   - 时间同步算法
   - 插值与外推
   - 平滑纠正
   - 演出节奏控制

### 快速参考

**核心概念**：
```
FrameTick (5-10Hz)        → 持续的战斗状态更新
KeyEvent (即时)           → 重要战斗事件（怪物死亡、掉落等）
Snapshot (定期/按需)      → 完整状态快照（用于恢复）
Version (单调递增)        → 消息顺序保证
```

**关键流程**：
```
1. 战斗执行 → 更新状态
2. 帧广播器 → 定时生成 FrameTick
3. SignalR Hub → 推送到客户端 group
4. 客户端接收 → 版本检查 → 应用/补发
5. 前端渲染 → 插值/外推 → 平滑显示
```

---

## 🔄 版本对比

### 从版本 1.0 到 2.0 的主要变更

| 方面 | 版本 1.0（旧） | 版本 2.0（新） |
|------|---------------|---------------|
| **推送机制** | CombatSegment 聚合（5秒或200事件） | FrameTick 固定频率（5-10Hz） |
| **延迟** | 500ms - 5000ms | < 200ms |
| **降级策略** | SignalR 失败 → 轮询 API | SignalR 失败 → 重连（无轮询） |
| **消息顺序** | 无版本号，依赖 SignalR 保证 | 版本号机制，支持乱序/丢包处理 |
| **状态恢复** | 客户端轮询完整状态 | 快照 + 增量补发 |
| **前端渲染** | 直接显示聚合数据 | 插值/外推 + 平滑纠正 |
| **关键事件** | 聚合在 Segment 中 | 即时独立推送 |

### 为什么要更新设计？

**原设计的问题**：
1. ❌ **延迟过高**: CombatSegment 聚合导致 500ms - 5秒延迟
2. ❌ **轮询降级**: 后续不需要轮询功能，SignalR 应该是唯一通道
3. ❌ **无序处理**: 缺少版本号机制，难以处理网络乱序/丢包
4. ❌ **渲染不平滑**: 前端直接显示聚合数据，无法实现流畅动画

**新设计的优势**：
1. ✅ **低延迟**: 固定频率推送，100-200ms 间隔
2. ✅ **纯 SignalR**: 移除轮询降级，连接失败直接重连
3. ✅ **可靠传输**: 版本号 + 补发 + 快照机制
4. ✅ **流畅渲染**: 插值/外推算法，60 FPS 平滑动画

---

## 📖 原版本阅读指南（参考）

### 快速开始

如果您想快速了解系统设计，建议按以下顺序阅读：

1. **阅读 [SignalR设计总览.md](./SignalR设计总览.md)**（⚠️ 版本 1.0，已过时）
   - 了解整体架构
   - 掌握核心概念
   - 熟悉技术选型

2. **浏览 [Phase1-基础架构设计.md](./Phase1-基础架构设计.md) 的架构图**
   - 理解模块划分
   - 了解组件职责

3. **查看 [Phase2-战斗事件集成.md](./Phase2-战斗事件集成.md) 的事件流程**
   - 理解事件如何从战斗系统流转到客户端

---

## 🏗️ 系统架构概览（版本 2.0）

### 核心组件

```
┌─────────────────────────────────────────────────────────┐
│  Blazor WebAssembly Client                              │
│  ┌────────────────────────────────────────────────┐     │
│  │  BattleFrameReceiver                           │     │
│  │  - 版本管理 (lastVersion)                      │     │
│  │  - 缺口检测与补发请求                          │     │
│  └──────────────────┬─────────────────────────────┘     │
│  ┌──────────────────▼─────────────────────────────┐     │
│  │  BattleRenderer                                │     │
│  │  - 时间同步                                    │     │
│  │  - 插值/外推渲染                               │     │
│  │  - 平滑纠正                                    │     │
│  └────────────────────────────────────────────────┘     │
└────────────────────┬─────────────────────────────────────┘
                     │ SignalR WebSocket (无轮询降级)
┌────────────────────▼─────────────────────────────────────┐
│  ASP.NET Core Server                                     │
│  ┌────────────────────────────────────────────────┐     │
│  │  BattleHub (SignalR Hub)                       │     │
│  │  - Battle Group 管理                           │     │
│  │  - 版本同步 (SyncBattleState)                  │     │
│  └──────────────────┬─────────────────────────────┘     │
│  ┌──────────────────▼─────────────────────────────┐     │
│  │  BattleFrameBroadcaster                        │     │
│  │  - 固定频率广播（5-10Hz）                      │     │
│  │  - 帧缓冲与版本管理                            │     │
│  └──────────────────┬─────────────────────────────┘     │
│  ┌──────────────────▼─────────────────────────────┐     │
│  │  BattleInstance (Domain)                       │     │
│  │  - 生成 FrameTick                              │     │
│  │  - 产生 KeyEvent                               │     │
│  │  - 生成 Snapshot                               │     │
│  └────────────────────────────────────────────────┘     │
└──────────────────────────────────────────────────────────┘
```

### 数据流程

```
1. [Domain] BattleInstance 执行战斗逻辑
   └─> 更新状态（HP、资源、Buff等）
   
2. [Infrastructure] BattleFrameBroadcaster 定时触发
   └─> 调用 BattleInstance.GenerateFrameTick()
   
3. [Domain] 生成 FrameTick (version++)
   └─> 包含当前状态快照 + 窗口聚合数据
   
4. [Infrastructure] 缓存帧到 BattleFrameBuffer
   └─> 用于后续补发请求
   
5. [SignalR] BattleHub 推送到 Battle Group
   └─> 所有订阅该战斗的客户端
   
6. [Client] BattleFrameReceiver 接收并处理
   ├─> 版本检查：是否有缺口？
   ├─> 缓存乱序帧
   └─> 请求补发或快照
   
7. [Client] BattleRenderer 插值渲染
   └─> 时间同步 + 平滑动画
```

---

## 🚀 实施建议

### 分阶段实施

**阶段 1：核心基础（2-3周）**
- [ ] 实现 BattleInstance 帧生成逻辑
- [ ] 实现 BattleFrameBuffer 缓冲管理
- [ ] 实现 BattleFrameBroadcaster 后台服务
- [ ] 实现 BattleHub 基本连接管理

**阶段 2：版本机制（1-2周）**
- [ ] 客户端 BattleFrameReceiver 版本管理
- [ ] 服务端补发逻辑 (SyncBattleState)
- [ ] 快照生成与应用
- [ ] 测试乱序/丢包场景

**阶段 3：前端渲染（1-2周）**
- [ ] 时间同步算法
- [ ] 插值/外推渲染
- [ ] 平滑纠正策略
- [ ] 演出节奏控制

**阶段 4：优化与监控（1周）**
- [ ] 性能监控指标
- [ ] 自适应频率调整
- [ ] 前台/后台切换
- [ ] 压力测试

**总计：5-8周**

---

## 📊 关键技术决策

### 1. 为什么选择固定频率推送？

**对比方案**：
- ❌ 按事件推送：难以保证延迟稳定性
- ❌ CombatSegment 聚合：延迟过高
- ✅ **固定频率帧**：延迟可控，易于前端渲染

**优势**：
- 延迟可预测（100-200ms）
- 前端易于插值
- 带宽可控

### 2. 为什么需要版本号？

**问题场景**：
```
正常顺序：v1 → v2 → v3
网络乱序：v1 → v3 → v2
网络丢包：v1 → v3 (缺 v2)
```

**解决方案**：
- 每帧分配单调递增版本号
- 客户端维护 lastVersion
- 检测缺口 → 请求补发
- 缺口过大 → 请求快照

### 3. 为什么移除轮询降级？

**原因**：
1. 后续前端不再需要轮询功能
2. SignalR 应该是唯一的实时通道
3. 简化架构，降低维护成本
4. 连接失败直接重连或提示用户

**重连策略**：
```
失败 → 等待 0s → 重试
失败 → 等待 2s → 重试
失败 → 等待 5s → 重试
失败 → 等待 10s → 重试
失败 → 等待 20s → 重试
失败 → 显示连接失败对话框
```

### 4. 为什么需要插值/外推？

**问题**：
```
推送频率：8Hz (每 125ms)
渲染频率：60 FPS (每 16ms)

如果直接显示推送数据 → 卡顿
```

**解决方案**：
- **插值**：在两帧之间平滑过渡
- **外推**：下一帧未到达时预测
- **纠正**：权威值到达时平滑对齐

**效果**：
- 60 FPS 流畅渲染
- 延迟感知降低
- 动画自然平滑

---

## 💡 常见问题

### Q1: 如何处理网络波动导致的帧乱序？

**A**: 使用版本号机制：
```typescript
if (frame.version === lastVersion + 1) {
  // 正常顺序，直接应用
  applyFrame(frame);
} else if (frame.version > lastVersion + 1) {
  // 检测到缺口，缓存当前帧，请求补发
  bufferFrame(frame);
  requestDelta(lastVersion + 1, frame.version - 1);
} else {
  // 重复或过时的帧，丢弃
  discard(frame);
}
```

### Q2: 如何平衡推送频率和带宽？

**A**: 动态调整策略：
- 前台高性能：10Hz
- 前台正常：8Hz
- 后台或低性能：2Hz
- 根据设备性能和网络状况实时调整

### Q3: 如何保证插值渲染的准确性？

**A**: 使用时间同步：
```typescript
// 校准服务器时间偏移
calibrateTime(frame.serverTime);

// 渲染时使用服务器时间
const serverTime = getServerTime();
const targetTime = serverTime - interpolationDelay;

// 在两帧之间插值
renderInterpolated(fromFrame, toFrame, targetTime);
```

### Q4: 如何测试版本号机制？

**A**: 模拟网络异常：
```typescript
// 单元测试
it("should handle missing frames", () => {
  receiver.onFrame({ version: 1 });
  receiver.onFrame({ version: 3 }); // 跳过 2
  
  expect(requestDelta).toHaveBeenCalledWith(2, 2);
});

// 集成测试：注入网络延迟
connection.simulateDelay(100, 300); // 100-300ms 随机延迟
connection.simulatePacketLoss(0.05); // 5% 丢包率
```

---

## 📝 后续工作

### 已完成
- ✅ 完整的设计文档
- ✅ 架构设计
- ✅ 实现指南
- ✅ 前端渲染策略

### 待实施
- [ ] 服务端代码实现
- [ ] 客户端代码实现
- [ ] 单元测试
- [ ] 集成测试
- [ ] 性能测试
- [ ] 文档完善

---

## 📞 获取帮助

如有疑问或需要帮助，请：

1. 查阅对应的详细文档
2. 查看代码示例和注释
3. 查阅整合设计总结文档（docs/整合设计总结.txt）
4. 在项目 Issue 中提问

---

## 📄 文档版本历史

| 版本 | 日期 | 变更说明 |
|------|------|---------|
| 2.0 | 2025-10-21 | 完全重新设计：固定频率帧推送 + 版本机制 + 插值渲染 |
| 1.0 | 2025-10 | 初始版本：CombatSegment 聚合推送 + 轮询降级 |

---

**当前版本**: 2.0  
**文档状态**: ✅ 完成  
**最后更新**: 2025年10月21日

---

**🎉 开始使用版本 2.0 设计！**

推荐从 [实时帧推送设计方案.md](./实时帧推送设计方案.md) 开始阅读。
