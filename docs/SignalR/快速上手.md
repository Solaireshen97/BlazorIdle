# SignalR 系统设计 - 快速上手指南

**5分钟了解 SignalR 推送系统设计**

---

## 🎯 这是什么？

一个为 BlazorIdle 项目设计的**实时推送系统**，让玩家能够**即时**看到战斗伤害、装备掉落、活动完成等游戏事件。

---

## ✨ 核心特性

- ⚡ **实时推送** - 战斗数据即时显示，无需刷新
- 🔌 **自动重连** - 网络断开自动恢复
- 📦 **批量优化** - 聚合推送，性能优秀
- 🎨 **易于扩展** - 新增事件类型只需3步
- 🛡️ **最小侵入** - 几乎不改现有代码

---

## 🏗️ 架构一览

```
客户端 (Blazor)
    ↕ WebSocket (SignalR)
游戏 Hub
    ↕
消息分发器
    ↕
事件总线
    ↕
战斗系统 → 发布事件
```

---

## 📚 文档结构

```
docs/SignalR/
├── README.md                    ← 从这里开始
├── SignalR设计总览.md           ← 整体架构（15分钟）
├── Phase1-基础架构设计.md       ← 基础设施（30分钟）
├── Phase2-战斗事件集成.md       ← 战斗推送（40分钟）
├── Phase3-扩展性设计.md         ← 扩展框架（35分钟）
└── 集成说明.md                  ← 与现有代码集成
```

---

## 🚀 三分钟理解核心概念

### 1. 领域事件 (Domain Event)

**是什么**: 游戏中发生的重要事情

**示例**:
```csharp
// 战斗结束了
new BattleEndedEvent {
    BattleId = ...,
    Result = "Victory",
    Gold = 100,
    Exp = 50
}
```

---

### 2. 事件总线 (Event Bus)

**是什么**: 消息中转站

**工作流程**:
```
战斗系统 --发布--> 事件总线 --分发--> SignalR分发器
                            └-------> 其他订阅者
```

**使用**:
```csharp
// 发布事件
_eventBus.Publish(new BattleEndedEvent { ... });

// 订阅事件
_eventBus.Subscribe<BattleEndedEvent>(async e => {
    // 处理事件
});
```

---

### 3. SignalR 推送

**是什么**: 实时通信通道

**客户端接收**:
```csharp
// Blazor 客户端
connection.On<BattleResult>("OnBattleEnded", result => {
    // 更新UI显示战斗结果
    DisplayBattleResult(result);
});
```

---

## 💡 新增事件只需3步

### 步骤 1: 定义事件

```csharp
public sealed record ItemDroppedEvent : INotificationEvent
{
    public Guid EventId { get; init; }
    public DateTime OccurredAtUtc { get; init; }
    public string EventType => "ItemDropped";
    public Guid? CharacterId { get; init; }
    
    public string ItemName { get; init; }
    public int Quantity { get; init; }
    
    public NotificationPriority Priority => NotificationPriority.High;
    
    public object ToClientMessage() => new 
    { 
        itemName = ItemName, 
        quantity = Quantity 
    };
}
```

---

### 步骤 2: 发布事件

```csharp
// 在战斗结束时
_eventBus.Publish(new ItemDroppedEvent {
    EventId = Guid.NewGuid(),
    OccurredAtUtc = DateTime.UtcNow,
    CharacterId = characterId,
    ItemName = "魔法剑",
    Quantity = 1
});
```

---

### 步骤 3: 客户端接收

```csharp
// Blazor 客户端
connection.On<ItemDrop>("OnItemDropped", item => {
    ShowNotification($"获得物品: {item.ItemName} x{item.Quantity}");
});
```

**完成！** 物品掉落会自动推送到玩家客户端。

---

## 📈 实施时间表

### 2周 - Phase 1: 基础设施
- 事件总线
- SignalR Hub
- 消息分发器

**交付**: 能连接，能推送，但无实际业务事件

---

### 2-3周 - Phase 2: 战斗推送
- 战斗开始/结束事件
- 实时伤害统计
- 客户端UI集成

**交付**: 战斗数据实时显示

---

### 1-2周 - Phase 3: 扩展完善
- 优先级系统
- 监控面板
- 其他事件类型

**交付**: 完整的推送系统

---

## 🔍 关键优化

### Segment 聚合推送

**问题**: 战斗中每秒产生数百个伤害事件

**解决**:
```
200个原子事件 → 聚合为1个Segment → 推送1次
```

**效果**: 推送频率降低 99%，性能提升显著

---

### 优先级队列

**问题**: 所有事件同等对待，可能拥堵

**解决**:
```
Critical  → 立即推送（角色死亡、升级）
High      → 优先推送（战斗结束、装备获得）
Normal    → 正常推送（战斗段更新）
Low       → 可节流（金币变化）
```

---

### 批量发送

**问题**: 每个消息单独发送，开销大

**解决**:
```
收集 50ms 内的消息 → 批量发送
```

**效果**: 网络开销降低 50%+

---

## 🎨 设计亮点

### 1. 最小化修改现有代码

**Domain 层**（核心战斗逻辑）:
```csharp
// 仅添加一个委托
public Action<CombatSegment>? OnSegmentFlushed { get; set; }
```

**Application 层**:
```csharp
// 注入事件总线，注册回调
rb.Collector.OnSegmentFlushed = seg => _eventBus.Publish(...);
```

**就这么简单！** 不破坏任何现有逻辑。

---

### 2. 统一事件模型

所有事件都实现同一接口：
```csharp
public interface INotificationEvent : IDomainEvent
{
    NotificationPriority Priority { get; }
    object ToClientMessage();
}
```

**好处**:
- ✅ 自动推送（订阅 `INotificationEvent` 即可）
- ✅ 统一处理（无需为每个事件类型写代码）
- ✅ 易于扩展（新增事件只需实现接口）

---

### 3. 向后兼容

即使 SignalR 不可用：
```
✅ 客户端回退到轮询 API
✅ 现有功能继续工作
✅ 无崩溃，无错误
```

---

## 📊 预期性能

| 指标 | 目标 |
|------|------|
| 推送延迟 | < 500ms (P99) |
| 战斗性能影响 | < 5% |
| 并发连接 | > 1000 |
| 内存占用 | < 500MB (1000连接) |

---

## 🛠️ 技术栈

- **SignalR** - 实时通信
- **WebSocket** - 首选传输协议
- **Channel<T>** - 异步队列
- **ASP.NET Core** - 服务端
- **Blazor WebAssembly** - 客户端

---

## 📞 快速链接

- 📖 [完整设计总览](./SignalR设计总览.md)
- 🏗️ [Phase 1: 基础架构](./Phase1-基础架构设计.md)
- ⚔️ [Phase 2: 战斗集成](./Phase2-战斗事件集成.md)
- 🚀 [Phase 3: 扩展性](./Phase3-扩展性设计.md)
- 🔗 [集成说明](./集成说明.md)

---

## ✅ 下一步

1. **阅读** [SignalR设计总览.md](./SignalR设计总览.md) 了解完整架构
2. **深入** [Phase1-基础架构设计.md](./Phase1-基础架构设计.md) 开始实施
3. **参考** 代码示例开始编码

---

## 💬 常见问题

**Q: 会不会影响现有功能？**  
A: 不会。设计最小化侵入，现有代码几乎无修改。

**Q: 实施难度大吗？**  
A: 不大。文档详细，代码示例完整，遵循现有架构。

**Q: 性能影响多大？**  
A: 很小。异步执行，批量优化，预计 < 5% 影响。

**Q: 可以分阶段实施吗？**  
A: 可以。三个 Phase 独立，可分别交付。

**Q: 未来如何扩展？**  
A: 简单。新增事件只需实现接口，3步完成。

---

## 🎉 开始吧！

准备好了吗？让我们为 BlazorIdle 打造一个**实时、高效、可扩展**的推送系统！

👉 **[开始阅读完整设计文档](./README.md)**
