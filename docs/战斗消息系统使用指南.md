# 战斗消息系统使用指南

**版本**: 1.0  
**日期**: 2025-10-14  
**状态**: 已完成

---

## 📋 概述

战斗消息系统是一个可配置的事件通知系统，用于向前端实时传输战斗过程中的详细信息，包括攻击开始、造成伤害、受到伤害等事件，并通过配置文件管理消息模板，支持灵活的国际化和自定义。

---

## 🎯 功能特性

### 核心功能

1. **攻击开始事件** - 显示"角色 XX 开始攻击 XX"
2. **伤害造成事件** - 显示"角色对 XX 造成 XX 伤害（暴击）"
3. **伤害接收事件** - 显示"角色受到来自 XX 的 XX 伤害"
4. **敌人攻击事件** - 显示"敌人 XX 开始攻击玩家"

### 设计特点

- **配置化消息模板** - 所有消息格式存储在配置文件中，不硬编码
- **可扩展性** - 易于添加新的事件类型和消息模板
- **开关控制** - 每种事件类型都可以独立启用或禁用
- **国际化支持** - 消息模板可以根据语言配置更改
- **性能优化** - 可选的事件节流和批处理支持

---

## 📖 使用方法

### 配置消息模板

在 `appsettings.json` 中配置战斗消息：

```json
{
  "BattleMessages": {
    "AttackStartedTemplate": "{attacker} 开始攻击 {target}",
    "DamageDealtTemplate": "{attacker} 对 {target} 造成 {damage} 点伤害{critSuffix}",
    "CritSuffix": "（暴击）",
    "DamageReceivedTemplate": "{target} 受到来自 {attacker} 的 {damage} 点伤害",
    "EnemyAttackStartedTemplate": "{attacker} 开始攻击 {target}",
    "EnableAttackStartedEvent": true,
    "EnableDamageDealtEvent": true,
    "EnableDamageReceivedEvent": true,
    "EnableEnemyAttackStartedEvent": true,
    "PlayerName": "玩家",
    "MaxMessageHistory": 100
  }
}
```

### 模板参数说明

#### 攻击开始模板参数
- `{attacker}` - 攻击者名称
- `{target}` - 目标名称

#### 伤害造成模板参数
- `{attacker}` - 攻击者名称
- `{target}` - 目标名称
- `{damage}` - 伤害值
- `{critSuffix}` - 暴击后缀（仅在暴击时显示）

#### 伤害接收模板参数
- `{target}` - 受伤者名称
- `{attacker}` - 攻击者名称
- `{damage}` - 伤害值

### 启用/禁用事件

在 `appsettings.json` 的 `SignalR.Notification` 节中控制事件通知：

```json
{
  "SignalR": {
    "Notification": {
      "EnableAttackStartedNotification": true,
      "EnableEnemyAttackStartedNotification": true,
      "EnableDamageReceivedNotification": true,
      "EnableDamageAppliedNotification": false
    }
  }
}
```

**注意**: 
- `BattleMessages` 中的 `Enable*Event` 控制是否生成消息
- `SignalR.Notification` 中的 `Enable*Notification` 控制是否发送到前端
- 两者都需要启用才能在前端显示事件

---

## 🔧 事件类型详解

### 1. AttackStartedEventDto

**触发时机**: 玩家开始攻击敌人时

**属性**:
```csharp
public sealed class AttackStartedEventDto : BattleEventDto
{
    public string AttackerName { get; set; }   // 攻击者名称
    public string TargetName { get; set; }      // 目标名称
    public string Message { get; set; }         // 格式化的消息
}
```

**示例消息**: "玩家 开始攻击 史莱姆"

### 2. DamageAppliedEventDto

**触发时机**: 玩家对敌人造成伤害时

**属性**:
```csharp
public sealed class DamageAppliedEventDto : BattleEventDto
{
    public string Source { get; set; }          // 伤害来源（如 "basic_attack"）
    public int Damage { get; set; }             // 伤害值
    public bool IsCrit { get; set; }            // 是否暴击
    public int TargetCurrentHp { get; set; }    // 目标当前血量
    public int TargetMaxHp { get; set; }        // 目标最大血量
    public string AttackerName { get; set; }    // 攻击者名称
    public string TargetName { get; set; }      // 目标名称
    public string Message { get; set; }         // 格式化的消息
}
```

**示例消息**: 
- 普通攻击: "玩家 对 哥布林 造成 150 点伤害"
- 暴击攻击: "玩家 对 哥布林 造成 300 点伤害（暴击）"

### 3. DamageReceivedEventDto

**触发时机**: 玩家受到敌人攻击时

**属性**:
```csharp
public sealed class DamageReceivedEventDto : BattleEventDto
{
    public string AttackerName { get; set; }    // 攻击者名称
    public string TargetName { get; set; }      // 受伤者名称
    public int Damage { get; set; }             // 伤害值
    public int TargetCurrentHp { get; set; }    // 目标当前血量
    public int TargetMaxHp { get; set; }        // 目标最大血量
    public string Message { get; set; }         // 格式化的消息
}
```

**示例消息**: "玩家 受到来自 哥布林 的 50 点伤害"

### 4. AttackStartedEventDto (敌人攻击)

**触发时机**: 敌人开始攻击玩家时

**EventType**: "EnemyAttackStarted"

**示例消息**: "哥布林 开始攻击 玩家"

---

## 🎨 前端集成示例

### 订阅战斗事件

```csharp
@inject BattleSignalRService SignalRService

// 订阅所有战斗事件
SignalRService.OnBattleEvent((battleId, eventData) =>
{
    if (eventData is AttackStartedEventDto attackEvent)
    {
        DisplayBattleLog(attackEvent.Message);
    }
    else if (eventData is DamageAppliedEventDto damageEvent)
    {
        DisplayBattleLog(damageEvent.Message);
        UpdateHealthBar(damageEvent.TargetCurrentHp, damageEvent.TargetMaxHp);
    }
    else if (eventData is DamageReceivedEventDto receivedEvent)
    {
        DisplayBattleLog(receivedEvent.Message);
        UpdatePlayerHealth(receivedEvent.TargetCurrentHp, receivedEvent.TargetMaxHp);
    }
});
```

### 显示战斗日志

```csharp
private List<string> _battleLog = new();

private void DisplayBattleLog(string message)
{
    _battleLog.Add($"[{DateTime.Now:HH:mm:ss}] {message}");
    
    // 限制日志数量
    if (_battleLog.Count > 100)
    {
        _battleLog.RemoveAt(0);
    }
    
    StateHasChanged();
}
```

### UI 示例

```razor
<div class="battle-log">
    <h4>战斗日志</h4>
    <div class="log-content">
        @foreach (var log in _battleLog.TakeLast(20).Reverse())
        {
            <div class="log-entry">@log</div>
        }
    </div>
</div>
```

---

## 🔍 高级配置

### 自定义消息模板

可以根据需求自定义消息格式：

```json
{
  "BattleMessages": {
    "AttackStartedTemplate": "⚔️ {attacker} → {target}",
    "DamageDealtTemplate": "💥 {attacker} 对 {target} 造成 {damage} 伤害{critSuffix}",
    "CritSuffix": " ⭐",
    "DamageReceivedTemplate": "🛡️ {target} 承受 {damage} 伤害 ← {attacker}"
  }
}
```

### 国际化支持

可以为不同语言创建不同的配置文件：

**appsettings.zh-CN.json** (中文)
```json
{
  "BattleMessages": {
    "PlayerName": "玩家",
    "AttackStartedTemplate": "{attacker} 开始攻击 {target}"
  }
}
```

**appsettings.en.json** (英文)
```json
{
  "BattleMessages": {
    "PlayerName": "Player",
    "AttackStartedTemplate": "{attacker} attacks {target}"
  }
}
```

### 性能优化

对于高频战斗事件，可以启用节流：

```json
{
  "SignalR": {
    "Performance": {
      "EnableThrottling": true,
      "ThrottleWindowMs": 1000
    }
  }
}
```

---

## 📊 测试

系统包含完整的单元测试和集成测试：

### 单元测试 (9个)
- 消息模板格式化测试
- 暴击后缀测试
- 事件DTO属性测试
- 配置读取测试

### 集成测试 (4个)
- 攻击开始事件触发测试
- 伤害应用事件触发测试
- 敌人攻击事件触发测试
- 事件开关功能测试

运行测试：
```bash
dotnet test --filter "FullyQualifiedName~BattleMessage"
```

---

## 🚀 扩展指南

### 添加新的事件类型

1. **创建事件DTO**
   
   在 `BlazorIdle.Shared/Models/BattleNotifications.cs` 中添加：
   ```csharp
   public sealed class SkillCastEventDto : BattleEventDto
   {
       public string CasterName { get; set; } = "";
       public string SkillName { get; set; } = "";
       public string Message { get; set; } = "";
   }
   ```

2. **添加配置选项**
   
   在 `BattleMessageOptions.cs` 中添加：
   ```csharp
   public string SkillCastTemplate { get; set; } = "{caster} 施放了 {skill}";
   public bool EnableSkillCastEvent { get; set; } = true;
   ```

3. **添加格式化方法**
   
   在 `BattleMessageFormatter.cs` 中添加：
   ```csharp
   public string FormatSkillCast(string casterName, string skillName)
   {
       return _options.SkillCastTemplate
           .Replace("{caster}", casterName)
           .Replace("{skill}", skillName);
   }
   ```

4. **触发事件**
   
   在相应的战斗逻辑中添加事件发送代码。

5. **更新配置文件**
   
   在 `appsettings.json` 中添加配置。

---

## 💡 最佳实践

1. **消息简洁性** - 保持消息简短明了，适合在战斗日志中显示
2. **性能考虑** - 高频事件可以考虑启用节流或批处理
3. **可读性** - 使用清晰的占位符名称，便于理解和维护
4. **测试覆盖** - 为新增的事件类型添加单元测试和集成测试
5. **向后兼容** - 添加新配置项时提供合理的默认值

---

## 🐛 故障排除

### 消息不显示

1. 检查 `BattleMessages` 中的 `Enable*Event` 是否为 `true`
2. 检查 `SignalR.Notification` 中的 `Enable*Notification` 是否为 `true`
3. 检查 SignalR 连接是否正常
4. 查看服务器日志确认事件是否被触发

### 消息格式错误

1. 确认模板中的占位符名称正确（区分大小写）
2. 检查配置文件的JSON格式是否正确
3. 验证配置是否被正确加载

### 性能问题

1. 考虑启用事件节流
2. 限制前端显示的消息历史数量
3. 对于高频事件，可以临时禁用某些不重要的事件类型

---

## 📚 相关文档

- [SignalR扩展开发指南](./SignalR扩展开发指南.md)
- [战斗系统设计文档](./战斗系统Phase4完成报告.md)
- [活动计划快速开始](./活动计划快速开始.md)

---

## 📝 更新日志

### v1.0 (2025-10-14)
- ✅ 实现基础战斗消息系统
- ✅ 支持攻击开始、伤害造成、伤害接收事件
- ✅ 配置化消息模板
- ✅ 完整的测试覆盖
- ✅ 文档编写完成
