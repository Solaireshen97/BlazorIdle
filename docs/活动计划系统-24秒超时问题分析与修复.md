# 活动计划系统 24 秒超时问题分析与修复

## 问题描述

在活动计划系统中，当战斗活动超过约 24 秒时，任务会直接卡住，无法继续执行。这导致长时间战斗的活动计划无法正常完成。

## 根本原因分析

### 1. 不当使用 `Task.Run()` 包装异步方法

**问题代码位置**：`ActivityCoordinator.cs`

```csharp
// 原代码 - 第 62 行
_ = Task.Run(() => TryStartPlanAsync(plan.Id, CancellationToken.None));

// 原代码 - 第 143 行
_ = Task.Run(() => TryStartPlanAsync(nextId.Value, ct), ct);
```

**问题分析**：

1. **线程池饥饿（Thread Pool Starvation）**
   - `Task.Run()` 会在线程池中调度一个新任务
   - `TryStartPlanAsync()` 是一个异步方法，内部有多个 `await` 操作
   - 当使用 `Task.Run()` 包装异步方法时，会占用一个线程池线程等待异步操作完成
   - 在高并发或长时间运行的场景下，可能导致线程池资源耗尽

2. **异步上下文丢失**
   - `Task.Run()` 在线程池线程上执行，可能丢失原有的同步上下文
   - `TryStartPlanAsync()` 内部使用 `IServiceScopeFactory` 创建作用域
   - 作用域服务的生命周期管理可能受到影响

3. **取消令牌不一致**
   - 第 62 行使用 `CancellationToken.None`，无法取消
   - 第 143 行使用传入的 `ct`，但两处行为不一致

### 2. 执行流程中的潜在死锁

**执行流程**：

```
CreatePlan() 
  → slot.StartPlan(planId)
  → Task.Run(() => TryStartPlanAsync(planId))
      → executor.StartAsync(plan)  // 异步，需要 await
          → 创建 ServiceScope
          → 获取 ICharacterRepository (Scoped)
          → await characters.GetAsync()
          → _battleCoordinator.Start()
```

**死锁场景**：

1. 多个计划同时启动时，`Task.Run()` 在线程池中排队
2. 线程池线程被占用等待数据库或其他 I/O 操作
3. 新的计划无法获得线程池线程来启动
4. 形成死锁或长时间阻塞

### 3. 与后台服务的协调问题

系统中有两个后台服务以不同频率运行：

- **ActivityHostedService**：每 1 秒推进一次活动计划
- **StepBattleHostedService**：每 50 毫秒推进一次战斗模拟

当战斗超过 24 秒时，可能出现以下问题：

1. `ActivityHostedService` 检查计划完成状态（1 秒间隔）
2. `StepBattleHostedService` 推进战斗（50 毫秒间隔）
3. 如果启动下一个计划时发生阻塞，整个槽位的计划队列将停滞

## 修复方案

### 1. 移除不必要的 `Task.Run()` 包装

**修改前**：
```csharp
_ = Task.Run(() => TryStartPlanAsync(plan.Id, CancellationToken.None));
```

**修改后**：
```csharp
// 直接调用异步方法，不使用 Task.Run 避免线程池饥饿
_ = TryStartPlanAsync(plan.Id, CancellationToken.None);
```

**原理**：

- 异步方法本身就会返回一个 `Task`
- 不需要在线程池中额外调度
- 直接使用 `_` 丢弃返回值表示"fire-and-forget"
- 异步操作会在后台继续执行，不会阻塞调用线程

### 2. 改进取消令牌传播

在 `AdvancePlanAsync` 中启动下一个计划时：

**修改前**：
```csharp
await TryStartPlanAsync(nextId.Value, ct);
```

**修改后**：
```csharp
// 不等待下一个计划的启动，让后台服务处理
_ = TryStartPlanAsync(nextId.Value, ct);
```

**原理**：

- 避免在推进过程中同步等待新计划启动
- 新计划的启动由后台服务异步处理
- 减少阻塞时间，提高响应性

### 3. 添加日志记录

添加详细的日志记录，便于诊断问题：

```csharp
_logger.LogError(ex, "Failed to start activity plan {PlanId} (Type: {Type}, Character: {CharacterId})", 
    planId, plan.Type, plan.CharacterId);

_logger.LogInformation("Starting next queued plan {NextPlanId} after failed plan {PlanId}", 
    nextId.Value, planId);
```

## 为什么修复有效

### 1. 避免线程池饥饿

- 不再使用 `Task.Run()` 创建额外的线程池任务
- 异步操作通过状态机高效执行，不占用线程
- 系统可以处理更多并发活动计划

### 2. 保持异步上下文

- 直接调用异步方法保持了调用上下文
- 服务作用域正确管理
- 避免了上下文切换导致的问题

### 3. 改善执行流程

```
修复前流程（可能阻塞）：
CreatePlan → Task.Run(阻塞线程池) → TryStartPlanAsync → await → 阻塞

修复后流程（非阻塞）：
CreatePlan → TryStartPlanAsync（异步继续） → 立即返回 → 后台完成
```

## 配置建议

### 1. 推进间隔配置

在 `appsettings.json` 中可以调整推进间隔：

```json
{
  "Activity": {
    "AdvanceIntervalSeconds": 1.0,  // 活动推进间隔（秒）
    "PruneIntervalMinutes": 10.0    // 清理间隔（分钟）
  }
}
```

**调优建议**：

- 对于长时间战斗（> 1 分钟），可以适当增加推进间隔到 2-5 秒
- 对于短时间活动，保持 1 秒的推进间隔即可

### 2. 战斗推进配置

```json
{
  "Combat": {
    "EnablePeriodicRewards": true,
    "RewardFlushIntervalSeconds": 10.0
  }
}
```

## 测试验证

### 1. 单元测试场景

创建以下测试场景验证修复：

```csharp
[Fact]
public async Task LongBattle_ShouldNotHang()
{
    // 安排：创建一个 60 秒的战斗计划
    var plan = coordinator.CreatePlan(
        characterId, 
        slotIndex: 0,
        ActivityType.Combat,
        new DurationLimit(60.0),
        payloadJson
    );
    
    // 行动：等待 30 秒
    await Task.Delay(TimeSpan.FromSeconds(30));
    
    // 断言：计划应该仍在运行，不应卡住
    var status = coordinator.GetPlan(plan.Id);
    Assert.Equal(ActivityState.Running, status.State);
}
```

### 2. 集成测试场景

测试多个计划的衔接：

```csharp
[Fact]
public async Task MultipleSequentialBattles_ShouldComplete()
{
    // 创建 3 个战斗计划，每个 30 秒
    coordinator.CreatePlan(..., new DurationLimit(30.0), ...);
    coordinator.CreatePlan(..., new DurationLimit(30.0), ...);
    coordinator.CreatePlan(..., new DurationLimit(30.0), ...);
    
    // 等待 100 秒（足够完成所有战斗）
    await Task.Delay(TimeSpan.FromSeconds(100));
    
    // 验证所有计划都已完成
    var slots = coordinator.GetCharacterSlots(characterId);
    Assert.True(slots[0].IsIdle);
}
```

### 3. 压力测试

```csharp
[Fact]
public async Task ConcurrentBattles_ShouldNotCauseThreadStarvation()
{
    // 在 5 个角色上同时启动 15 个战斗（每个角色 3 个槽位）
    for (int i = 0; i < 5; i++)
    {
        var charId = Guid.NewGuid();
        for (int slot = 0; slot < 3; slot++)
        {
            coordinator.CreatePlan(charId, slot, ...);
        }
    }
    
    // 系统应该能够处理而不崩溃
    await Task.Delay(TimeSpan.FromSeconds(10));
    
    // 验证所有战斗都在推进
    Assert.True(true); // 如果到达这里，说明系统没有死锁
}
```

## 监控和诊断

### 1. 关键指标

监控以下指标以发现潜在问题：

- **活动推进延迟**：`AdvanceAllAsync()` 的执行时间
- **计划启动失败率**：`TryStartPlanAsync()` 的异常率
- **平均战斗时长**：识别异常长的战斗
- **线程池使用率**：确保不会耗尽

### 2. 日志分析

关键日志消息：

```
[Error] Failed to start activity plan {PlanId} ...
[Information] Starting next queued plan {NextPlanId} ...
[Error] Error advancing activity plan {PlanId} ...
```

如果频繁出现这些日志，需要进一步调查：

1. 数据库连接问题
2. 服务作用域生命周期问题
3. 战斗协调器状态异常

## 最佳实践

### 1. 异步编程

- ✅ 直接调用异步方法，不使用 `Task.Run()` 包装
- ✅ 使用 `_` 丢弃不需要等待的 Task
- ❌ 不要使用 `Task.Run()` 包装已经是异步的方法
- ❌ 不要在异步方法中使用 `.Wait()` 或 `.Result`

### 2. 取消令牌

- ✅ 在整个异步调用链中传播 `CancellationToken`
- ✅ 为长时间运行的操作使用有意义的取消令牌
- ❌ 避免使用 `CancellationToken.None` 除非确实不需要取消

### 3. 错误处理

- ✅ 在异步操作中捕获并记录异常
- ✅ 为 fire-and-forget 任务添加错误处理
- ✅ 使用结构化日志记录便于诊断

## 总结

**问题根源**：不当使用 `Task.Run()` 包装异步方法导致线程池饥饿和潜在死锁。

**修复方法**：移除 `Task.Run()` 包装，直接调用异步方法，改善异步流程。

**预期效果**：
- ✅ 支持任意时长的战斗活动（不再有 24 秒限制）
- ✅ 减少线程池压力，提高并发性能
- ✅ 改善系统响应性和稳定性
- ✅ 更好的错误诊断能力

**适用范围**：所有活动类型（战斗、采集、制作等）
