# BlazorIdle 数据库操作优化实施方案 - 中篇：业务模块集成

**项目**: BlazorIdle 服务端数据库操作优化  
**阶段**: 中篇 - 业务模块集成  
**工作量**: 5-7 工作日  
**优先级**: P0（最高）  
**文档版本**: 1.0

---

## 📋 目录

1. [中篇概述](#中篇概述)
2. [Phase 5: 战斗快照批量持久化](#phase-5-战斗快照批量持久化)
3. [Phase 6: 角色状态批量更新](#phase-6-角色状态批量更新)
4. [Phase 7: 活动计划批量持久化](#phase-7-活动计划批量持久化)
5. [Phase 8: 装备操作批量持久化](#phase-8-装备操作批量持久化)
6. [中篇总结与验收](#中篇总结与验收)

---

## 中篇概述

### 目标

中篇聚焦于**业务模块集成**，将批量持久化机制应用到实际业务场景：

1. ✅ 战斗快照：从每500ms保存改为批量保存（5秒）
2. ✅ 角色状态：从心跳立即更新改为批量更新（30秒）
3. ✅ 活动计划：状态变更延迟保存（10秒）
4. ✅ 装备操作：支持批量和立即保存混合模式

### 前置条件

- ✅ 上篇已完成：配置系统、持久化管理器、批量刷新服务
- ✅ 所有上篇的单元测试通过
- ✅ 基础设施已验收

### 关键产出

- 📦 修改后的 `StepBattleSnapshotService.cs`
- 📦 修改后的 `CharactersController.cs`
- 📦 修改后的 `ActivityPlanRepository.cs`
- 📦 修改后的 `GearInstanceRepository.cs`
- 📄 业务模块集成测试报告
- 📄 性能对比报告

---

## Phase 5: 战斗快照批量持久化

**工作量**: 2 天  
**优先级**: P0  
**预期性能提升**: 数据库写入频率降低 90%

### 5.1 现状分析

**当前实现** (`StepBattleSnapshotService.cs`)：

```csharp
// 当前：每500ms检查并立即保存
if ((DateTime.UtcNow - lastSnapAt).TotalMilliseconds >= 500)
{
    foreach (var id in _coordinator.InternalIdsSnapshot())
    {
        if (_coordinator.TryGet(id, out var rb) && rb is not null && !rb.Completed)
        {
            if (!SnapshotThrottler.ShouldSkip(...))
            {
                await _snapshot.SaveAsync(rb, stoppingToken);  // ⚠️ 立即保存
            }
        }
    }
}
```

**问题**：
- 高并发时（10个战斗）= 20次/秒数据库写入
- 每个快照独立保存，无批量处理

### 5.2 优化方案

#### 方案设计

```
原流程: 检查 → 立即SaveAsync → 数据库写入
新流程: 检查 → MarkDirty → 内存缓存 → (5秒后) BatchFlush → 批量数据库写入
```

**特殊情况**：
- 战斗完成时：立即保存（`ImmediateCondition: "BattleComplete"`）
- 服务器关闭时：通过优雅关闭机制批量保存

### 5.3 实施步骤

#### Step 5.1: 修改战斗快照服务

**文件**: `BlazorIdle.Server/Application/Battles/Step/StepBattleSnapshotService.cs`

**修改点**：

1. 注入 `IPersistenceManager`
2. 将 `SaveAsync` 改为标记脏数据
3. 战斗完成时立即保存

```csharp
// 在类顶部添加新的依赖
public sealed class StepBattleSnapshotService
{
    private readonly IServiceScopeFactory _scopeFactory;
    private readonly IPersistenceManager _persistenceManager;  // ⬅️ 新增
    
    public StepBattleSnapshotService(
        IServiceScopeFactory scopeFactory,
        IPersistenceManager persistenceManager)  // ⬅️ 新增参数
    {
        _scopeFactory = scopeFactory;
        _persistenceManager = persistenceManager;
    }

    // === 修改 SaveAsync 方法 ===
    
    /// <summary>
    /// 保存战斗快照（使用批量持久化）
    /// </summary>
    public async Task SaveAsync(RunningBattle rb, CancellationToken ct = default)
    {
        // 构建快照DTO（与原来一致）
        var dto = new StepBattleSnapshotDto(
            rb.Id,
            rb.CharacterId,
            (int)rb.Profession,
            rb.EnemyId,
            rb.EnemyCount,
            rb.Seed,
            rb.TargetDurationSeconds,
            rb.Clock.CurrentTime,
            rb.Segments.ToList()
        );

        var json = JsonSerializer.Serialize(dto);

        using var scope = _scopeFactory.CreateScope();
        var db = scope.ServiceProvider.GetRequiredService<GameDbContext>();

        // 查询或创建快照记录
        var row = await db.Set<RunningBattleSnapshotRecord>()
            .FirstOrDefaultAsync(x => x.StepBattleId == rb.Id, ct);

        if (row is null)
        {
            row = new RunningBattleSnapshotRecord
            {
                Id = Guid.NewGuid(),
                StepBattleId = rb.Id,
                CharacterId = rb.CharacterId,
                Profession = (int)rb.Profession,
                EnemyId = rb.EnemyId,
                EnemyCount = rb.EnemyCount,
                Seed = rb.Seed.ToString(),
                TargetSeconds = rb.TargetDurationSeconds,
                SimulatedSeconds = rb.Clock.CurrentTime,
                UpdatedAtUtc = DateTime.UtcNow,
                SnapshotJson = json
            };
            db.Set<RunningBattleSnapshotRecord>().Add(row);
            
            // ⬇️ 新增：立即保存新创建的快照（首次）
            await DatabaseRetryPolicy.SaveChangesWithRetryAsync(db, ct);
        }
        else
        {
            // 更新现有快照
            row.CharacterId = rb.CharacterId;
            row.Profession = (int)rb.Profession;
            row.EnemyId = rb.EnemyId;
            row.EnemyCount = rb.EnemyCount;
            row.Seed = rb.Seed.ToString();
            row.TargetSeconds = rb.TargetDurationSeconds;
            row.SimulatedSeconds = rb.Clock.CurrentTime;
            row.UpdatedAtUtc = DateTime.UtcNow;
            row.SnapshotJson = json;

            // ⬇️ 新增：标记为脏，延迟保存（通过批量持久化）
            var condition = rb.Completed ? "BattleComplete" : null;
            _persistenceManager.MarkDirty(row, "BattleSnapshot", condition);
            
            // ⬇️ 如果战斗完成，立即保存
            if (rb.Completed)
            {
                await _persistenceManager.SaveImmediatelyAsync(row, "BattleSnapshot", ct);
            }
        }
    }

    /// <summary>
    /// 删除战斗快照（保持立即删除）
    /// </summary>
    public async Task DeleteAsync(Guid stepBattleId, CancellationToken ct = default)
    {
        using var scope = _scopeFactory.CreateScope();
        var db = scope.ServiceProvider.GetRequiredService<GameDbContext>();
        
        var row = await db.Set<RunningBattleSnapshotRecord>()
            .FirstOrDefaultAsync(x => x.StepBattleId == stepBattleId, ct);
        
        if (row is not null)
        {
            db.Remove(row);
            // ⬇️ 删除操作保持立即保存
            await DatabaseRetryPolicy.SaveChangesWithRetryAsync(db, ct);
        }
    }

    // RecoverAllAsync 方法保持不变
}
```

#### Step 5.2: 更新宿主服务

**文件**: `BlazorIdle.Server/Application/Battles/Step/StepBattleHostedService.cs`

**修改点**：

1. 移除手动的定时保存逻辑（现在由 BatchFlushHostedService 处理）
2. 优雅关闭逻辑保持，但依赖批量持久化的最终刷新

```csharp
// 在 ExecuteAsync 的主循环中，简化快照保存逻辑

// === 原代码（移除） ===
/*
if ((DateTime.UtcNow - lastSnapAt).TotalMilliseconds >= 500)
{
    lastSnapAt = DateTime.UtcNow;
    foreach (var id in _coordinator.InternalIdsSnapshot())
    {
        if (_coordinator.TryGet(id, out var rb) && rb is not null && !rb.Completed)
        {
            if (!SnapshotThrottler.ShouldSkip(...))
            {
                try { await _snapshot.SaveAsync(rb, stoppingToken); }
                catch (Exception ex) { _logger.LogDebug(ex, "Save snapshot failed for {Id}", rb.Id); }
            }
        }
        else if (rb is not null && rb.Completed)
        {
            try { await _snapshot.DeleteAsync(rb.Id, stoppingToken); } 
            catch { }
        }
    }
}
*/

// === 新代码（简化） ===
// 定期检查战斗快照，但不再手动保存（由批量持久化处理）
if ((DateTime.UtcNow - lastSnapAt).TotalMilliseconds >= 5000)  // 改为5秒检查一次
{
    lastSnapAt = DateTime.UtcNow;
    foreach (var id in _coordinator.InternalIdsSnapshot())
    {
        if (_coordinator.TryGet(id, out var rb) && rb is not null)
        {
            if (!rb.Completed)
            {
                // 标记需要保存快照（实际保存由 BatchFlushHostedService 处理）
                if (!SnapshotThrottler.ShouldSkip(rb.Id, rb.Clock.CurrentTime, SnapshotIntervalSimSeconds))
                {
                    try 
                    { 
                        // ⬇️ 新增：仅构建快照，不立即保存
                        await _snapshot.SaveAsync(rb, stoppingToken); 
                    }
                    catch (Exception ex) 
                    { 
                        _logger.LogDebug(ex, "Mark snapshot dirty failed for {Id}", rb.Id); 
                    }
                }
            }
            else
            {
                // 战斗完成，立即删除快照（在 SaveAsync 中已处理立即保存）
                try { await _snapshot.DeleteAsync(rb.Id, stoppingToken); } 
                catch { }
            }
        }
    }
}

// === 优雅关闭方法保持不变 ===
// SaveAllRunningBattleSnapshotsAsync 方法保持，但内部会通过批量持久化处理
```

### 5.4 单元测试

**文件**: `tests/BlazorIdle.Tests/Application/Battles/Step/StepBattleSnapshotServiceTests.cs`

```csharp
public class StepBattleSnapshotServiceBatchTests
{
    [Fact]
    public async Task SaveAsync_InProgress_ShouldMarkDirty()
    {
        // Arrange
        var persistenceManagerMock = new Mock<IPersistenceManager>();
        var service = CreateService(persistenceManagerMock.Object);
        var rb = CreateRunningBattle(completed: false);

        // Act
        await service.SaveAsync(rb, CancellationToken.None);

        // Assert
        persistenceManagerMock.Verify(
            m => m.MarkDirty(
                It.IsAny<RunningBattleSnapshotRecord>(),
                "BattleSnapshot",
                null),
            Times.Once);
    }

    [Fact]
    public async Task SaveAsync_Completed_ShouldSaveImmediately()
    {
        // Arrange
        var persistenceManagerMock = new Mock<IPersistenceManager>();
        var service = CreateService(persistenceManagerMock.Object);
        var rb = CreateRunningBattle(completed: true);

        // Act
        await service.SaveAsync(rb, CancellationToken.None);

        // Assert
        persistenceManagerMock.Verify(
            m => m.SaveImmediatelyAsync(
                It.IsAny<RunningBattleSnapshotRecord>(),
                "BattleSnapshot",
                It.IsAny<CancellationToken>()),
            Times.Once);
    }

    // 更多测试用例...
}
```

### 5.5 性能测试

**测试场景**：10个并发战斗，运行5分钟

**预期结果**：

| 指标 | 优化前 | 优化后 | 改善 |
|------|--------|--------|------|
| 数据库写入频率 | 20次/秒 | 2次/秒 | ↓ 90% |
| 快照保存延迟 | 500ms | 5秒 | +10倍（可接受） |
| 数据库锁等待 | 偶发 | 极少 | 大幅降低 |

### 5.6 验收标准

- [ ] 战斗进行中的快照通过批量持久化保存
- [ ] 战斗完成时快照立即保存
- [ ] 数据库写入频率降低≥90%
- [ ] 所有现有功能测试通过
- [ ] 新增单元测试覆盖率≥95%
- [ ] 性能测试达到预期目标

---

## Phase 6: 角色状态批量更新

**工作量**: 1.5 天  
**优先级**: P0  
**预期性能提升**: 数据库写入频率降低 95%

### 6.1 现状分析

**当前实现** (`CharactersController.cs`)：

```csharp
[HttpGet("{id}")]
public async Task<IActionResult> GetCharacter(Guid id)
{
    // ...获取角色...
    
    // ⚠️ 每次心跳（5-10秒）立即更新
    if (character.LastSeenAtUtc.HasValue)
    {
        character.LastSeenAtUtc = DateTime.UtcNow;
        await DatabaseRetryPolicy.SaveChangesWithRetryAsync(_db);  // ⚠️ 立即保存
    }
    
    return Ok(...);
}
```

**问题**：
- 10个在线玩家 = 1-2次/秒数据库写入
- 心跳仅更新时间戳，不需要实时持久化

### 6.2 优化方案

#### 方案设计

```
原流程: 心跳请求 → 更新时间戳 → 立即SaveChanges
新流程: 心跳请求 → 更新时间戳（内存） → MarkDirty → (30秒后) BatchFlush
```

**关键要点**：
- 心跳更新不立即保存
- 30秒批量更新所有在线角色状态
- 角色创建/删除等关键操作保持立即保存

### 6.3 实施步骤

#### Step 6.1: 修改角色控制器

**文件**: `BlazorIdle.Server/Api/CharactersController.cs`

```csharp
public class CharactersController : ControllerBase
{
    private readonly GameDbContext _db;
    private readonly IPersistenceManager _persistenceManager;  // ⬅️ 新增
    // ...其他依赖...

    public CharactersController(
        GameDbContext db,
        IPersistenceManager persistenceManager,  // ⬅️ 新增参数
        // ...其他参数...
        )
    {
        _db = db;
        _persistenceManager = persistenceManager;
        // ...
    }

    /// <summary>
    /// 获取角色信息（包含心跳更新）
    /// </summary>
    [HttpGet("{id}")]
    public async Task<IActionResult> GetCharacter(Guid id)
    {
        var character = await _db.Characters
            .FirstOrDefaultAsync(c => c.Id == id);

        if (character == null)
        {
            return NotFound(new { message = "角色不存在" });
        }

        // 离线结算逻辑（保持不变）
        if (character.LastSeenAtUtc.HasValue)
        {
            var offlineSeconds = (DateTime.UtcNow - character.LastSeenAtUtc.Value).TotalSeconds;
            
            if (offlineSeconds >= _offlineOptions.OfflineDetectionSeconds)
            {
                await _offlineSettlementService.CheckAndSettleAsync(id);
                character = await _db.Characters.FirstOrDefaultAsync(c => c.Id == id);
                if (character == null) return NotFound();
            }
        }

        // ⬇️ 修改：心跳更新改为批量持久化
        character.LastSeenAtUtc = DateTime.UtcNow;
        _persistenceManager.MarkDirty(character, "CharacterStatus");
        // ⚠️ 移除：await DatabaseRetryPolicy.SaveChangesWithRetryAsync(_db);

        return Ok(new
        {
            character.Id,
            character.Name,
            // ...其他字段...
            timestamp = character.LastSeenAtUtc
        });
    }

    /// <summary>
    /// 创建角色（保持立即保存）
    /// </summary>
    [HttpPost]
    public async Task<IActionResult> CreateCharacter([FromBody] CreateCharacterDto dto)
    {
        // ...验证逻辑...

        var c = new Character
        {
            Id = Guid.NewGuid(),
            UserId = userId,
            // ...其他字段...
        };

        _db.Characters.Add(c);
        // ⬇️ 保持立即保存（关键操作）
        await DatabaseRetryPolicy.SaveChangesWithRetryAsync(_db);
        
        return Ok(new { c.Id, c.Name, c.RosterOrder });
    }

    /// <summary>
    /// 删除角色（保持立即保存）
    /// </summary>
    [HttpDelete("{id}")]
    public async Task<IActionResult> DeleteCharacter(Guid id)
    {
        // ...验证和删除逻辑...
        
        _db.Characters.Remove(character);
        // ⬇️ 保持立即保存（关键操作）
        await DatabaseRetryPolicy.SaveChangesWithRetryAsync(_db);
        
        return Ok(new { message = "角色删除成功" });
    }

    /// <summary>
    /// 更新角色排序（可延迟保存）
    /// </summary>
    [HttpPut("{id}/roster-order")]
    public async Task<IActionResult> UpdateRosterOrder(Guid id, [FromBody] UpdateRosterOrderDto dto)
    {
        // ...验证逻辑...

        character.RosterOrder = dto.RosterOrder;
        
        // ⬇️ 修改：改为批量持久化（非关键操作）
        _persistenceManager.MarkDirty(character, "CharacterStatus");
        // ⚠️ 移除：await DatabaseRetryPolicy.SaveChangesWithRetryAsync(_db);
        
        return Ok(new { message = "角色顺序调整成功" });
    }
}
```

#### Step 6.2: 处理EF Core追踪问题

**问题**：`MarkDirty` 的实体可能不在当前 DbContext 的追踪中

**解决方案**：在 `PersistenceManager` 中处理实体附加

```csharp
// 在 PersistenceManager.SaveCategoryEntriesAsync 中已处理：

foreach (var entry in entries)
{
    var entityEntry = db.Entry(entry.Entity);
    if (entityEntry.State == EntityState.Detached)
    {
        db.Attach(entry.Entity);          // 附加到上下文
        entityEntry.State = EntityState.Modified;  // 标记为已修改
    }
}
```

### 6.4 单元测试

**文件**: `tests/BlazorIdle.Tests/Api/CharactersControllerBatchTests.cs`

```csharp
public class CharactersControllerBatchTests
{
    [Fact]
    public async Task GetCharacter_Heartbeat_ShouldMarkDirty()
    {
        // Arrange
        var persistenceManagerMock = new Mock<IPersistenceManager>();
        var controller = CreateController(persistenceManagerMock.Object);
        var characterId = Guid.NewGuid();

        // Act
        await controller.GetCharacter(characterId);

        // Assert
        persistenceManagerMock.Verify(
            m => m.MarkDirty(
                It.IsAny<Character>(),
                "CharacterStatus",
                null),
            Times.Once);
    }

    [Fact]
    public async Task CreateCharacter_ShouldSaveImmediately()
    {
        // Arrange
        var controller = CreateController();
        var dto = new CreateCharacterDto { Name = "TestChar" };

        // Act
        await controller.CreateCharacter(dto);

        // Assert
        // 验证数据库中存在角色
        var character = await _db.Characters.FirstOrDefaultAsync(c => c.Name == "TestChar");
        Assert.NotNull(character);
    }

    // 更多测试用例...
}
```

### 6.5 性能测试

**测试场景**：10个在线玩家，每5秒心跳一次，运行5分钟

**预期结果**：

| 指标 | 优化前 | 优化后 | 改善 |
|------|--------|--------|------|
| 数据库写入频率 | 2次/秒 | 0.1次/秒 | ↓ 95% |
| 心跳响应延迟 | 10ms | 5ms | ↓ 50% |
| 角色状态更新延迟 | 实时 | 30秒 | +30秒（可接受） |

### 6.6 验收标准

- [ ] 心跳更新不立即保存到数据库
- [ ] 角色状态定期批量更新（30秒）
- [ ] 角色创建/删除等关键操作保持立即保存
- [ ] 数据库写入频率降低≥95%
- [ ] 所有现有功能测试通过
- [ ] 新增单元测试覆盖率≥95%

---

## Phase 7: 活动计划批量持久化

**工作量**: 1 天  
**优先级**: P1  
**预期性能提升**: 数据库写入频率降低 80%

### 7.1 现状分析

**当前实现** (`ActivityPlanRepository.cs`)：

```csharp
public async Task UpdateAsync(ActivityPlan plan, CancellationToken ct = default)
{
    _db.ActivityPlans.Update(plan);
    await DatabaseRetryPolicy.SaveChangesWithRetryAsync(_db, ct);  // ⚠️ 立即保存
}
```

**问题**：
- 活动状态变更（Running → Completed）立即保存
- 高频活动切换时数据库压力大

### 7.2 优化方案

```
原流程: 状态变更 → UpdateAsync → 立即SaveChanges
新流程: 状态变更 → UpdateAsync → MarkDirty → (10秒后) BatchFlush
```

**特殊情况**：
- 活动创建：立即保存
- 活动删除：立即保存
- 状态变更：延迟保存

### 7.3 实施步骤

#### Step 7.1: 修改活动计划仓储

**文件**: `BlazorIdle.Server/Infrastructure/Persistence/Repositories/ActivityPlanRepository.cs`

```csharp
public class ActivityPlanRepository : IActivityPlanRepository
{
    private readonly GameDbContext _db;
    private readonly IPersistenceManager _persistenceManager;  // ⬅️ 新增

    public ActivityPlanRepository(
        GameDbContext db,
        IPersistenceManager persistenceManager)  // ⬅️ 新增参数
    {
        _db = db;
        _persistenceManager = persistenceManager;
    }

    /// <summary>
    /// 创建活动计划（保持立即保存）
    /// </summary>
    public async Task AddAsync(ActivityPlan plan, CancellationToken ct = default)
    {
        _db.ActivityPlans.Add(plan);
        // ⬇️ 保持立即保存（关键操作）
        await Persistence.DatabaseRetryPolicy.SaveChangesWithRetryAsync(_db, ct);
    }

    /// <summary>
    /// 更新活动计划（改为批量持久化）
    /// </summary>
    public async Task UpdateAsync(ActivityPlan plan, CancellationToken ct = default)
    {
        _db.ActivityPlans.Update(plan);
        
        // ⬇️ 修改：改为批量持久化
        _persistenceManager.MarkDirty(plan, "ActivityPlan");
        
        // ⚠️ 移除：await Persistence.DatabaseRetryPolicy.SaveChangesWithRetryAsync(_db, ct);
        
        // 注意：方法签名保持 async Task，以保持接口兼容性
        await Task.CompletedTask;
    }

    /// <summary>
    /// 删除活动计划（保持立即保存）
    /// </summary>
    public async Task DeleteAsync(Guid id, CancellationToken ct = default)
    {
        var plan = await _db.ActivityPlans.FirstOrDefaultAsync(p => p.Id == id, ct);
        if (plan != null)
        {
            _db.ActivityPlans.Remove(plan);
            // ⬇️ 保持立即保存（关键操作）
            await Persistence.DatabaseRetryPolicy.SaveChangesWithRetryAsync(_db, ct);
        }
    }

    // 其他查询方法保持不变
}
```

### 7.4 单元测试

```csharp
public class ActivityPlanRepositoryBatchTests
{
    [Fact]
    public async Task UpdateAsync_ShouldMarkDirty()
    {
        // Arrange
        var persistenceManagerMock = new Mock<IPersistenceManager>();
        var repo = CreateRepository(persistenceManagerMock.Object);
        var plan = new ActivityPlan { Id = Guid.NewGuid(), State = ActivityState.Running };

        // Act
        await repo.UpdateAsync(plan);

        // Assert
        persistenceManagerMock.Verify(
            m => m.MarkDirty(plan, "ActivityPlan", null),
            Times.Once);
    }

    // 更多测试用例...
}
```

### 7.5 验收标准

- [ ] 活动计划状态更新不立即保存
- [ ] 活动计划定期批量更新（10秒）
- [ ] 活动创建/删除保持立即保存
- [ ] 数据库写入频率降低≥80%
- [ ] 所有现有功能测试通过

---

## Phase 8: 装备操作批量持久化

**工作量**: 0.5 天  
**优先级**: P1  
**预期性能提升**: 批量操作性能提升 N倍

### 8.1 现状分析

**当前实现** (`GearInstanceRepository.cs`)：

```csharp
public async Task CreateBatchAsync(IEnumerable<GearInstance> instances, CancellationToken ct = default)
{
    var now = DateTime.UtcNow;
    foreach (var instance in instances)
    {
        instance.UpdatedAt = now;
    }
    _db.GearInstances.AddRange(instances);
    await _db.SaveChangesAsync(ct);  // ✅ 已经是批量保存
}

public async Task UpdateAsync(GearInstance instance, CancellationToken ct = default)
{
    instance.UpdatedAt = DateTime.UtcNow;
    _db.GearInstances.Update(instance);
    await _db.SaveChangesAsync(ct);  // ⚠️ 立即保存
}
```

**问题**：
- 单个装备操作立即保存
- 批量创建已优化，无需修改

### 8.2 优化方案

```
单个更新: MarkDirty → 延迟保存（5秒）
关键操作（购买、分解）: SaveImmediately
```

### 8.3 实施步骤

#### Step 8.1: 修改装备仓储

**文件**: `BlazorIdle.Server/Infrastructure/Persistence/Repositories/GearInstanceRepository.cs`

```csharp
public class GearInstanceRepository : IGearInstanceRepository
{
    private readonly GameDbContext _db;
    private readonly IPersistenceManager _persistenceManager;  // ⬅️ 新增

    public GearInstanceRepository(
        GameDbContext db,
        IPersistenceManager persistenceManager)
    {
        _db = db;
        _persistenceManager = persistenceManager;
    }

    /// <summary>
    /// 创建单个装备（改为立即+批量混合模式）
    /// </summary>
    public async Task CreateAsync(GearInstance instance, CancellationToken ct = default)
    {
        instance.UpdatedAt = DateTime.UtcNow;
        _db.GearInstances.Add(instance);
        
        // ⬇️ 关键操作，立即保存
        await _persistenceManager.SaveImmediatelyAsync(instance, "Equipment", ct);
    }

    /// <summary>
    /// 更新装备（改为批量持久化）
    /// </summary>
    public async Task UpdateAsync(GearInstance instance, string? operation = null, CancellationToken ct = default)
    {
        instance.UpdatedAt = DateTime.UtcNow;
        _db.GearInstances.Update(instance);
        
        // ⬇️ 修改：延迟保存或立即保存（根据操作类型）
        if (operation != null && IsImmediateOperation(operation))
        {
            await _persistenceManager.SaveImmediatelyAsync(instance, "Equipment", ct);
        }
        else
        {
            _persistenceManager.MarkDirty(instance, "Equipment", operation);
            await Task.CompletedTask;
        }
    }

    /// <summary>
    /// 批量创建（保持现有实现，已优化）
    /// </summary>
    public async Task CreateBatchAsync(IEnumerable<GearInstance> instances, CancellationToken ct = default)
    {
        var now = DateTime.UtcNow;
        foreach (var instance in instances)
        {
            instance.UpdatedAt = now;
        }
        _db.GearInstances.AddRange(instances);
        await _db.SaveChangesAsync(ct);  // ✅ 保持批量保存
    }

    /// <summary>
    /// 删除装备（保持立即保存）
    /// </summary>
    public async Task DeleteAsync(Guid id, CancellationToken ct = default)
    {
        var instance = await _db.GearInstances.FirstOrDefaultAsync(g => g.Id == id, ct);
        if (instance != null)
        {
            _db.GearInstances.Remove(instance);
            await _db.SaveChangesAsync(ct);  // ⬇️ 保持立即保存
        }
    }

    // === 私有辅助方法 ===

    private static bool IsImmediateOperation(string operation)
    {
        // 根据配置判断是否需要立即保存
        return operation is "Purchase" or "Disenchant" or "Reforge";
    }
}
```

#### Step 8.2: 更新接口

**文件**: `BlazorIdle.Server/Application/Abstractions/IGearInstanceRepository.cs`

```csharp
public interface IGearInstanceRepository
{
    // ...现有方法...
    
    /// <summary>
    /// 更新装备实例
    /// </summary>
    /// <param name="instance">装备实例</param>
    /// <param name="operation">操作类型（可选，如 "Purchase", "Disenchant"）</param>
    /// <param name="ct">取消令牌</param>
    Task UpdateAsync(GearInstance instance, string? operation = null, CancellationToken ct = default);  // ⬅️ 新增 operation 参数
}
```

### 8.4 验收标准

- [ ] 装备穿脱等常规操作延迟保存
- [ ] 购买、分解等关键操作立即保存
- [ ] 批量创建装备性能保持（已优化）
- [ ] 所有现有功能测试通过

---

## 中篇总结与验收

### 完成情况检查清单

#### Phase 5: 战斗快照 ✅
- [ ] 战斗进行中的快照批量保存
- [ ] 战斗完成时快照立即保存
- [ ] 数据库写入频率降低≥90%
- [ ] 单元测试通过
- [ ] 性能测试达标

#### Phase 6: 角色状态 ✅
- [ ] 心跳更新不立即保存
- [ ] 角色状态定期批量更新
- [ ] 关键操作保持立即保存
- [ ] 数据库写入频率降低≥95%
- [ ] 单元测试通过

#### Phase 7: 活动计划 ✅
- [ ] 活动状态更新延迟保存
- [ ] 活动创建/删除立即保存
- [ ] 数据库写入频率降低≥80%
- [ ] 单元测试通过

#### Phase 8: 装备操作 ✅
- [ ] 常规操作延迟保存
- [ ] 关键操作立即保存
- [ ] 批量操作性能保持
- [ ] 单元测试通过

### 综合性能测试

**测试场景**：10个在线玩家，各有1个战斗，运行10分钟

**预期结果**：

| 指标 | 优化前 | 优化后 | 改善 |
|------|--------|--------|------|
| 总数据库写入频率 | 22次/秒 | 2次/秒 | ↓ 91% |
| 战斗快照写入 | 20次/秒 | 2次/秒 | ↓ 90% |
| 角色状态写入 | 2次/秒 | 0.1次/秒 | ↓ 95% |
| 活动计划写入 | 0.5次/秒 | 0.1次/秒 | ↓ 80% |
| 数据库锁等待 | 偶发 | 极少 | 大幅降低 |

### 文档交付

- [ ] **中篇实施总结.md** - 记录实施过程和经验
- [ ] **业务模块集成指南.md** - 其他模块集成参考
- [ ] **性能对比报告.md** - 详细的性能测试数据

### 下一步行动

中篇完成后，可以进入**下篇**：优雅关闭增强与最终优化，包括：
- 优雅关闭时批量更新所有角色为离线状态
- 性能调优和监控增强
- 配置参数调优
- 最终验收和文档完善

---

**文档版本**: 1.0  
**创建日期**: 2025-10-17  
**预计完成**: 中篇实施需 5-7 工作日  
**状态**: 📗 实施方案完成，待执行
