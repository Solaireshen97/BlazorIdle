# 战斗循环优化实施方案

## 文档信息
- **版本**: 1.0
- **日期**: 2025-10-14
- **作者**: 战斗系统优化团队
- **状态**: 实施方案设计

---

## 目录
1. [总体策略](#总体策略)
2. [上篇：基础优化（核心功能）](#上篇基础优化核心功能)
3. [中篇：扩展优化（配置化与增强）](#中篇扩展优化配置化与增强)
4. [下篇：前端集成（实时反馈）](#下篇前端集成实时反馈)
5. [实施时间表](#实施时间表)
6. [验收标准](#验收标准)

---

## 总体策略

### 分阶段原则

本优化方案遵循"最小修改、渐进增强"原则，分为三个阶段：

```
上篇（基础）: 核心战斗循环优化
    ↓
中篇（扩展）: 配置化与职业差异化
    ↓
下篇（前端）: 用户界面与实时反馈
```

### 实施优先级

| 优先级 | 功能 | 影响范围 | 实施阶段 |
|-------|------|---------|---------|
| P0 | 攻击初始延迟 | 高 | 上篇 |
| P0 | 刷新等待暂停 | 高 | 上篇 |
| P1 | 目标选择一致性 | 中 | 上篇 |
| P2 | 特殊轨道配置 | 中 | 中篇 |
| P2 | 职业差异化 | 低 | 中篇 |
| P3 | 前端进度推送 | 低 | 下篇 |

---

## 上篇：基础优化（核心功能）

### 目标
- 修复攻击立即触发的问题
- 实现刷新等待时的攻击暂停
- 保证攻击和技能的目标一致性

### 工作量估算
- **开发时间**: 2-3 天
- **测试时间**: 1-2 天
- **总计**: 3-5 天

---

### 任务 1.1: 修改攻击轨道初始化

**目标**: 让第一次攻击在完整间隔后触发

#### 修改文件
`BlazorIdle.Server/Domain/Combat/Engine/BattleEngine.cs`

#### 具体修改

**位置**: 构造函数中轨道初始化部分（约第157-158行）

**当前代码**:
```csharp
var attackTrack = new TrackState(TrackType.Attack, Battle.AttackIntervalSeconds, 0);
var specialTrack = new TrackState(TrackType.Special, Battle.SpecialIntervalSeconds, Battle.SpecialIntervalSeconds);
```

**修改为**:
```csharp
// 攻击轨道从完整间隔开始，避免战斗开始时立即攻击
var attackTrack = new TrackState(TrackType.Attack, Battle.AttackIntervalSeconds, Battle.AttackIntervalSeconds);

// 特殊轨道保持现有行为（或根据需求也可以从0开始）
var specialTrack = new TrackState(TrackType.Special, Battle.SpecialIntervalSeconds, Battle.SpecialIntervalSeconds);
```

#### 理由
- `TrackState` 构造函数的第三个参数是 `nextTriggerAt`
- 设置为 `attackInterval` 意味着第一次触发在战斗开始后 `attackInterval` 秒
- 这样玩家会有"读秒-攻击"的直观感受

#### 影响分析
- ✅ 所有新战斗会延迟第一次攻击
- ✅ 第一轮攻击的伤害会推迟 `attackInterval` 秒
- ⚠️ 需要确认是否影响 DPS 计算（如果有）
- ⚠️ 需要更新相关测试用例

#### 测试点
1. 创建新战斗，验证第一次攻击在 `attackInterval` 后触发
2. 验证后续攻击间隔正常
3. 验证离线战斗快进的兼容性
4. 验证战斗状态恢复的兼容性

---

### 任务 1.2: 实现刷新等待时的轨道暂停

**目标**: 怪物全部死亡进入刷新等待时，暂停玩家攻击轨道

#### 修改文件
`BlazorIdle.Server/Domain/Combat/Engine/BattleEngine.cs`

#### 具体修改

**位置1**: `TryScheduleNextWaveIfCleared` 方法（约第247-278行）

**在现有的 `ResetAttackProgress()` 调用后添加**:

```csharp
private void TryScheduleNextWaveIfCleared()
{
    if (!IsWaveCleared()) return;

    if (_provider is null)
    {
        FinalizeNowFromLastKill();
        return;
    }

    if (_waitingSpawn) return;

    if (_provider.TryAdvance(out var nextGroup, out var runCompleted) && nextGroup is not null)
    {
        var delay = Math.Max(0.0, _provider.GetRespawnDelaySeconds(runJustCompleted: runCompleted));
        _pendingNextGroup = nextGroup;
        _pendingSpawnAt = Clock.CurrentTime + delay;
        _waitingSpawn = true;

        // ===== 新增：暂停玩家轨道 =====
        PausePlayerTracks("spawn_wait");
        // =============================

        if (runCompleted) Collector.OnTag("dungeon_run_complete", 1);
        Collector.OnTag("spawn_scheduled", 1);
    }
    else
    {
        FinalizeNowFromLastKill();
    }
}
```

**位置2**: 新增 `PausePlayerTracks` 方法

```csharp
/// <summary>
/// 暂停玩家轨道（类似玩家死亡的机制）
/// 用于刷新等待期间暂停攻击和特殊轨道
/// </summary>
/// <param name="reason">暂停原因，用于日志记录</param>
private void PausePlayerTracks(string reason)
{
    const double FAR_FUTURE = 1e10;
    
    foreach (var track in Context.Tracks)
    {
        // 检查是否应该暂停此轨道
        // 攻击轨道总是暂停
        // 特殊轨道根据职业配置决定（上篇先全部暂停，中篇实现配置）
        bool shouldPause = track.TrackType == TrackType.Attack || 
                          track.TrackType == TrackType.Special;
        
        if (shouldPause && track.NextTriggerAt < FAR_FUTURE)
        {
            track.NextTriggerAt = FAR_FUTURE;
            Collector.OnTag($"track_paused:{track.TrackType}", 1);
        }
    }
    
    Collector.OnTag($"tracks_paused:{reason}", 1);
}
```

**位置3**: `TryPerformPendingSpawn` 方法（约第317-346行）

**在现有逻辑后添加恢复轨道的代码**:

```csharp
private void TryPerformPendingSpawn()
{
    if (_waitingSpawn && _pendingSpawnAt.HasValue && _pendingNextGroup is not null && 
        Clock.CurrentTime + 1e-9 >= _pendingSpawnAt.Value)
    {
        Context.ResetEncounterGroup(_pendingNextGroup);
        Context.RefreshPrimaryEncounter();

        _pendingNextGroup = null;
        _pendingSpawnAt = null;
        _waitingSpawn = false;

        ClearDeathMarks();

        var oldEnemyCount = Context.EnemyCombatants.Count;
        Context.EnemyCombatants.Clear();
        Collector.OnTag("wave_transition_enemy_cleared", oldEnemyCount);
        
        InitializeEnemyAttacks(Context.EncounterGroup!, Clock.CurrentTime);
        InitializeEnemySkills(Context.EncounterGroup!);

        // ===== 新增：恢复玩家轨道 =====
        ResumePlayerTracks();
        // =============================

        Collector.OnTag("spawn_performed", 1);
        Collector.OnTag("wave_transition_enemy_reinitialized", Context.EnemyCombatants.Count);
    }
}
```

**位置4**: 新增 `ResumePlayerTracks` 方法

```csharp
/// <summary>
/// 恢复玩家轨道（类似玩家复活的机制）
/// 用于新怪物出现后恢复攻击和特殊轨道
/// </summary>
private void ResumePlayerTracks()
{
    const double FAR_FUTURE = 1e10;
    double resumeTime = Clock.CurrentTime;
    
    foreach (var track in Context.Tracks)
    {
        // 检查轨道是否处于暂停状态
        if (track.NextTriggerAt > FAR_FUTURE / 2)
        {
            // 从完整间隔开始（符合"从0开始计算进度"的需求）
            track.NextTriggerAt = resumeTime + track.CurrentInterval;
            
            // 重新调度事件
            if (track.TrackType == TrackType.Attack)
            {
                Scheduler.Schedule(new AttackTickEvent(track.NextTriggerAt, track));
            }
            else if (track.TrackType == TrackType.Special)
            {
                Scheduler.Schedule(new SpecialPulseEvent(track.NextTriggerAt, track));
            }
            
            Collector.OnTag($"track_resumed:{track.TrackType}", 1);
        }
    }
    
    Collector.OnTag("tracks_resumed:spawn_complete", 1);
}
```

#### 理由
- 复用玩家死亡/复活的成熟机制
- 使用 `FAR_FUTURE` 确保暂停期间事件不会触发
- 恢复时从完整间隔开始，符合"从0开始"的需求
- 通过标签记录暂停/恢复事件，便于调试和统计

#### 影响分析
- ✅ 刷新等待期间不会浪费计算资源执行无效攻击
- ✅ 用户体验更加合理
- ⚠️ 需要确保不与玩家死亡逻辑冲突
- ⚠️ 需要处理"玩家死亡期间怪物刷新"的边缘情况

#### 测试点
1. 持续模式战斗，验证怪物死亡后攻击暂停
2. 验证新怪物出现后攻击恢复
3. 验证刷新延迟为0时的行为
4. 验证玩家死亡期间怪物刷新的情况
5. 验证多波次快速切换的场景

---

### 任务 1.3: 实现攻击和技能的目标一致性

**目标**: 同一轮攻击中，普通攻击和技能使用同一个目标

#### 修改文件
`BlazorIdle.Server/Domain/Combat/BattleContext.cs`
`BlazorIdle.Server/Domain/Combat/AttackTickEvent.cs`

#### 具体修改

**步骤1**: 在 `BattleContext` 中添加当前目标字段

**文件**: `BattleContext.cs`

```csharp
public class BattleContext
{
    // ... 现有字段 ...
    
    /// <summary>
    /// 当前攻击目标（用于保证攻击和技能使用同一目标）
    /// 在每次攻击事件中设置，在技能施放时使用
    /// </summary>
    public Combatants.ICombatant? CurrentAttackTarget { get; set; }
    
    // ... 其余代码 ...
}
```

**步骤2**: 在 `AttackTickEvent` 中设置当前目标

**文件**: `AttackTickEvent.cs`（约第38-56行）

**当前代码**:
```csharp
// Phase 2: 使用 TargetSelector 选择目标（如果有 EncounterGroup）
Combatants.ICombatant? target = null;
if (context.EncounterGroup != null)
{
    var candidates = context.EncounterGroup.All
        .Select((enc, idx) => new Combatants.EnemyCombatant($"enemy_{idx}", enc))
        .ToList<Combatants.ICombatant>();
    
    target = context.TargetSelector.SelectTarget(candidates);
}

// 如果没有可选目标，跳过本次攻击
if (target == null && context.Encounter == null)
{
    Track.NextTriggerAt = ExecuteAt + Track.CurrentInterval;
    context.Scheduler.Schedule(new AttackTickEvent(Track.NextTriggerAt, Track));
    return;
}
```

**修改为**:
```csharp
// Phase 2: 使用 TargetSelector 选择目标（如果有 EncounterGroup）
Combatants.ICombatant? target = null;
if (context.EncounterGroup != null)
{
    var candidates = context.EncounterGroup.All
        .Select((enc, idx) => new Combatants.EnemyCombatant($"enemy_{idx}", enc))
        .ToList<Combatants.ICombatant>();
    
    target = context.TargetSelector.SelectTarget(candidates);
}

// 如果没有可选目标，跳过本次攻击
if (target == null && context.Encounter == null)
{
    Track.NextTriggerAt = ExecuteAt + Track.CurrentInterval;
    context.Scheduler.Schedule(new AttackTickEvent(Track.NextTriggerAt, Track));
    return;
}

// ===== 新增：设置当前攻击目标，供技能使用 =====
context.CurrentAttackTarget = target;
// =============================================
```

**步骤3**: 在技能施放后清除当前目标（可选，防止状态泄漏）

**在 `AttackTickEvent.Execute` 方法末尾（约第98行后）添加**:

```csharp
// 清除当前攻击目标，避免状态泄漏
context.CurrentAttackTarget = null;
```

**步骤4**: 修改技能施放逻辑以使用当前目标

**注意**: 这部分需要查看 `AutoCastEngine.TryAutoCast` 的实现。如果该方法内部进行目标选择，需要修改为优先使用 `context.CurrentAttackTarget`。

**建议的修改方向**（需要查看具体实现）:
```csharp
// 在 AutoCastEngine.TryAutoCast 或技能执行逻辑中
public void TryAutoCast(BattleContext context, double currentTime)
{
    // ... 技能选择逻辑 ...
    
    // 选择目标时优先使用当前攻击目标
    ICombatant? target = context.CurrentAttackTarget ?? SelectTarget(context);
    
    // ... 技能施放逻辑 ...
}
```

#### 理由
- 通过上下文共享目标，确保攻击和技能的一致性
- 不改变现有的目标选择逻辑（TargetSelector）
- 向后兼容：如果 `CurrentAttackTarget` 为空，技能可以自行选择目标

#### 影响分析
- ✅ 攻击和技能会攻击同一目标
- ✅ 不影响单目标战斗（向后兼容）
- ⚠️ 需要确认技能施放逻辑的实现位置
- ⚠️ 需要处理目标死亡后的情况

#### 测试点
1. 多怪物战斗，验证攻击和技能攻击同一目标
2. 验证目标死亡后下次攻击选择新目标
3. 验证单目标战斗的兼容性
4. 验证技能未触发时不影响后续攻击

---

### 任务 1.4: 边缘情况处理

**目标**: 处理各种边缘情况，确保系统稳定

#### 场景1: 玩家死亡期间怪物刷新

**问题**: 玩家死亡时轨道被暂停，但怪物刷新可能在复活前发生

**解决方案**: 在 `TryPerformPendingSpawn` 中检查玩家状态

```csharp
private void TryPerformPendingSpawn()
{
    // ... 现有刷新逻辑 ...
    
    // 只有在玩家存活时才恢复轨道
    if (Context.Player.CanAct())
    {
        ResumePlayerTracks();
    }
    else
    {
        // 玩家死亡中，标记刷新已完成但不恢复轨道
        // 等待 PlayerReviveEvent 恢复
        Collector.OnTag("spawn_completed_while_player_dead", 1);
    }
}
```

**同时修改 `PlayerReviveEvent`**: 在复活时检查是否有怪物

```csharp
public void Execute(BattleContext context)
{
    // ... 现有复活逻辑 ...
    
    // 只有在有怪物时才恢复轨道
    if (context.EncounterGroup != null && context.EncounterGroup.PrimaryAlive() != null)
    {
        // 恢复玩家轨道
        foreach (var track in context.Tracks)
        {
            // ... 恢复逻辑 ...
        }
    }
    else
    {
        // 没有怪物，保持暂停状态
        context.SegmentCollector.OnTag("revive_with_no_enemies", 1);
    }
    
    // ... 恢复怪物攻击 ...
}
```

#### 场景2: 刷新延迟为0

**问题**: 如果刷新延迟为0，可能导致状态不一致

**解决方案**: 在 `PausePlayerTracks` 和 `ResumePlayerTracks` 中处理

```csharp
private void PausePlayerTracks(string reason)
{
    // 如果刷新延迟为0，直接跳过暂停（因为会立即恢复）
    if (_pendingSpawnAt.HasValue && 
        Math.Abs(_pendingSpawnAt.Value - Clock.CurrentTime) < 1e-6)
    {
        Collector.OnTag("pause_skipped:immediate_spawn", 1);
        return;
    }
    
    // ... 暂停逻辑 ...
}
```

#### 场景3: 多波次快速切换

**问题**: 快速切换波次可能导致事件重复调度

**解决方案**: 在 `ResumePlayerTracks` 中检查事件是否已调度

```csharp
private void ResumePlayerTracks()
{
    // ... 恢复逻辑 ...
    
    foreach (var track in Context.Tracks)
    {
        if (track.NextTriggerAt > FAR_FUTURE / 2)
        {
            track.NextTriggerAt = resumeTime + track.CurrentInterval;
            
            // 只有在事件队列中没有相同类型的事件时才调度
            // 注意: EventScheduler 可能没有提供查询接口
            // 如果有重复调度的风险，可以在事件执行时检查 NextTriggerAt
            if (track.TrackType == TrackType.Attack)
            {
                Scheduler.Schedule(new AttackTickEvent(track.NextTriggerAt, track));
            }
            // ...
        }
    }
}
```

#### 测试点
1. 玩家死亡期间怪物刷新，复活后行为正常
2. 刷新延迟为0时不会出现状态不一致
3. 多波次快速切换不会重复调度事件
4. 所有边缘情况都有日志标签记录

---

### 上篇总结

**完成标志**:
- ✅ 战斗开始时攻击延迟完整间隔
- ✅ 刷新等待时攻击暂停
- ✅ 新怪物出现时攻击恢复
- ✅ 攻击和技能使用同一目标
- ✅ 边缘情况处理完善
- ✅ 所有测试用例通过

**交付物**:
1. 修改后的 `BattleEngine.cs`
2. 修改后的 `BattleContext.cs`
3. 修改后的 `AttackTickEvent.cs`
4. 新增的单元测试
5. 上篇实施报告

---

## 中篇：扩展优化（配置化与增强）

### 目标
- 实现特殊轨道的配置化暂停行为
- 支持职业差异化配置
- 优化特殊轨道的初始行为

### 工作量估算
- **开发时间**: 1-2 天
- **测试时间**: 1 天
- **总计**: 2-3 天

---

### 任务 2.1: 添加特殊轨道配置接口

**目标**: 在职业模块中添加特殊轨道暂停行为的配置

#### 修改文件
`BlazorIdle.Server/Domain/Combat/Professions/IProfessionModule.cs`

#### 具体修改

**在接口中添加新属性**:

```csharp
public interface IProfessionModule
{
    // ... 现有成员 ...
    
    /// <summary>
    /// 特殊轨道是否在无怪物（等待刷新）时暂停
    /// true: 跟随攻击轨道暂停（默认行为）
    /// false: 持续触发，不受怪物存在影响
    /// </summary>
    bool PauseSpecialWhenNoEnemies { get; }
    
    /// <summary>
    /// 特殊轨道的初始延迟行为
    /// true: 战斗开始后立即触发（从0开始）
    /// false: 等待完整间隔后触发（从 specialInterval 开始）
    /// </summary>
    bool SpecialStartsImmediately { get; }
}
```

#### 理由
- 提供职业差异化的配置能力
- 例如：战士的怒气积累可能需要持续触发，不受怪物影响
- 某些职业的特殊机制可能需要战斗开始时立即激活

---

### 任务 2.2: 实现基础职业模块的默认配置

**目标**: 为所有职业提供默认配置，保持向后兼容

#### 修改文件
`BlazorIdle.Server/Domain/Combat/Professions/BaseProfessionModule.cs`

#### 具体修改

```csharp
public abstract class BaseProfessionModule : IProfessionModule
{
    // ... 现有成员 ...
    
    /// <summary>
    /// 默认行为：特殊轨道在无怪物时暂停
    /// 子类可以重写此属性以实现不同的行为
    /// </summary>
    public virtual bool PauseSpecialWhenNoEnemies => true;
    
    /// <summary>
    /// 默认行为：特殊轨道等待完整间隔后触发
    /// 子类可以重写此属性以实现立即触发
    /// </summary>
    public virtual bool SpecialStartsImmediately => false;
}
```

#### 理由
- 提供合理的默认值
- 保持向后兼容性
- 职业可以选择性地重写这些属性

---

### 任务 2.3: 修改战斗引擎以使用配置

**目标**: 在战斗引擎中应用职业配置

#### 修改文件
`BlazorIdle.Server/Domain/Combat/Engine/BattleEngine.cs`

#### 具体修改

**位置1**: 修改特殊轨道的初始化（构造函数中）

```csharp
// 根据职业配置决定特殊轨道的初始延迟
var specialInitialDelay = professionModule.SpecialStartsImmediately 
    ? 0.0 
    : Battle.SpecialIntervalSeconds;

var specialTrack = new TrackState(
    TrackType.Special, 
    Battle.SpecialIntervalSeconds, 
    specialInitialDelay
);
```

**位置2**: 修改 `PausePlayerTracks` 方法

```csharp
private void PausePlayerTracks(string reason)
{
    const double FAR_FUTURE = 1e10;
    
    foreach (var track in Context.Tracks)
    {
        bool shouldPause = false;
        
        // 攻击轨道总是暂停
        if (track.TrackType == TrackType.Attack)
        {
            shouldPause = true;
        }
        // 特殊轨道根据职业配置决定
        else if (track.TrackType == TrackType.Special)
        {
            shouldPause = Context.ProfessionModule.PauseSpecialWhenNoEnemies;
        }
        
        if (shouldPause && track.NextTriggerAt < FAR_FUTURE)
        {
            track.NextTriggerAt = FAR_FUTURE;
            Collector.OnTag($"track_paused:{track.TrackType}", 1);
        }
    }
    
    Collector.OnTag($"tracks_paused:{reason}", 1);
}
```

**位置3**: 修改 `ResumePlayerTracks` 方法

```csharp
private void ResumePlayerTracks()
{
    const double FAR_FUTURE = 1e10;
    double resumeTime = Clock.CurrentTime;
    
    foreach (var track in Context.Tracks)
    {
        // 检查轨道是否处于暂停状态
        if (track.NextTriggerAt > FAR_FUTURE / 2)
        {
            // 根据轨道类型决定恢复策略
            double resumeDelay;
            
            if (track.TrackType == TrackType.Special && 
                Context.ProfessionModule.SpecialStartsImmediately)
            {
                // 特殊轨道如果配置为立即触发，恢复时也立即触发
                resumeDelay = 0.0;
            }
            else
            {
                // 默认从完整间隔开始
                resumeDelay = track.CurrentInterval;
            }
            
            track.NextTriggerAt = resumeTime + resumeDelay;
            
            // 重新调度事件
            if (track.TrackType == TrackType.Attack)
            {
                Scheduler.Schedule(new AttackTickEvent(track.NextTriggerAt, track));
            }
            else if (track.TrackType == TrackType.Special)
            {
                Scheduler.Schedule(new SpecialPulseEvent(track.NextTriggerAt, track));
            }
            
            Collector.OnTag($"track_resumed:{track.TrackType}", 1);
        }
    }
    
    Collector.OnTag("tracks_resumed:spawn_complete", 1);
}
```

#### 理由
- 根据职业配置灵活控制特殊轨道行为
- 保持代码的可扩展性
- 不同职业可以有不同的战斗节奏

---

### 任务 2.4: 为特定职业实现自定义配置

**目标**: 示例如何为特定职业自定义配置

#### 示例文件
假设有 `WarriorModule.cs` 和 `MageModule.cs`

#### 战士示例（特殊轨道持续触发）

```csharp
public class WarriorModule : BaseProfessionModule
{
    // ... 现有成员 ...
    
    /// <summary>
    /// 战士的特殊轨道（怒气积累）在无怪物时也持续触发
    /// 体现战士"战斗专注"的职业特性
    /// </summary>
    public override bool PauseSpecialWhenNoEnemies => false;
    
    /// <summary>
    /// 战士的特殊轨道战斗开始时立即触发
    /// </summary>
    public override bool SpecialStartsImmediately => true;
}
```

#### 法师示例（特殊轨道跟随暂停）

```csharp
public class MageModule : BaseProfessionModule
{
    // ... 现有成员 ...
    
    /// <summary>
    /// 法师的特殊轨道在无怪物时暂停（默认行为）
    /// 体现法师需要"目标"来施展法术的特性
    /// </summary>
    public override bool PauseSpecialWhenNoEnemies => true;
    
    /// <summary>
    /// 法师的特殊轨道等待间隔后触发（默认行为）
    /// </summary>
    public override bool SpecialStartsImmediately => false;
}
```

#### 理由
- 展示如何利用配置实现职业差异化
- 提供清晰的示例供其他职业参考
- 通过注释说明设计意图

---

### 任务 2.5: 更新玩家死亡/复活逻辑

**目标**: 确保特殊轨道在玩家死亡时也正确暂停（不受职业配置影响）

#### 修改文件
`BlazorIdle.Server/Domain/Combat/PlayerDeathEvent.cs`
`BlazorIdle.Server/Domain/Combat/PlayerReviveEvent.cs`

#### 具体修改

**PlayerDeathEvent**: 已经正确暂停所有轨道，无需修改

**PlayerReviveEvent**: 确保恢复时考虑职业配置

```csharp
public void Execute(BattleContext context)
{
    var player = context.Player;
    
    // 执行复活
    player.Revive(ExecuteAt);
    
    // 恢复所有玩家轨道
    foreach (var track in context.Tracks)
    {
        // 根据轨道类型和职业配置决定恢复延迟
        double resumeDelay;
        
        if (track.TrackType == TrackType.Special && 
            context.ProfessionModule.SpecialStartsImmediately)
        {
            resumeDelay = 0.0;
        }
        else
        {
            resumeDelay = track.CurrentInterval;
        }
        
        track.NextTriggerAt = ExecuteAt + resumeDelay;
        
        // 重新调度对应的事件
        if (track.TrackType == TrackType.Attack)
        {
            context.Scheduler.Schedule(new AttackTickEvent(track.NextTriggerAt, track));
        }
        else if (track.TrackType == TrackType.Special)
        {
            context.Scheduler.Schedule(new SpecialPulseEvent(track.NextTriggerAt, track));
        }
    }
    
    // ... 恢复怪物攻击 ...
}
```

#### 理由
- 玩家死亡时所有轨道都应该暂停（不受职业配置影响）
- 复活时根据职业配置恢复，保持一致性
- 符合"玩家死亡时攻击和特殊进度都应该停止"的需求

---

### 中篇总结

**完成标志**:
- ✅ 职业模块支持特殊轨道配置
- ✅ 战斗引擎应用职业配置
- ✅ 提供了示例职业配置
- ✅ 玩家死亡/复活考虑职业配置
- ✅ 所有测试用例通过

**交付物**:
1. 修改后的 `IProfessionModule.cs`
2. 修改后的 `BaseProfessionModule.cs`
3. 修改后的 `BattleEngine.cs`
4. 修改后的 `PlayerReviveEvent.cs`
5. 示例职业配置
6. 中篇实施报告

---

## 下篇：前端集成（实时反馈）

### 目标
- 实现进度重置的前端推送
- 优化前端进度条显示
- 提供实时的用户反馈

### 工作量估算
- **开发时间**: 1-2 天
- **测试时间**: 0.5-1 天
- **总计**: 1.5-3 天

---

### 任务 3.1: 定义进度重置事件 DTO

**目标**: 创建用于前端推送的事件数据结构

#### 新建文件
`BlazorIdle.Shared/Models/TrackProgressResetEventDto.cs`

#### 具体实现

```csharp
namespace BlazorIdle.Shared.Models;

/// <summary>
/// 轨道进度重置事件
/// 用于通知前端攻击/特殊轨道的进度被重置
/// </summary>
public class TrackProgressResetEventDto
{
    /// <summary>
    /// 战斗 ID
    /// </summary>
    public Guid BattleId { get; set; }
    
    /// <summary>
    /// 事件时间（战斗时间）
    /// </summary>
    public double EventTime { get; set; }
    
    /// <summary>
    /// 事件类型（固定为 "TrackProgressReset"）
    /// </summary>
    public string EventType { get; set; } = "TrackProgressReset";
    
    /// <summary>
    /// 重置的轨道类型列表
    /// 例如: ["Attack", "Special"]
    /// </summary>
    public List<string> TrackTypes { get; set; } = new();
    
    /// <summary>
    /// 重置原因
    /// 例如: "SpawnWait", "TargetSwitch", "PlayerDeath", "PlayerRevive"
    /// </summary>
    public string ResetReason { get; set; } = string.Empty;
    
    /// <summary>
    /// 新的下次触发时间（可选）
    /// 用于前端立即更新显示
    /// </summary>
    public Dictionary<string, double>? NewTriggerTimes { get; set; }
}
```

#### 理由
- 提供结构化的事件数据
- 包含足够的信息供前端处理
- 向后兼容（可选字段）

---

### 任务 3.2: 在后端发送进度重置事件

**目标**: 在适当的时机发送 SignalR 推送

#### 修改文件
`BlazorIdle.Server/Domain/Combat/Engine/BattleEngine.cs`

#### 具体修改

**修改 `PausePlayerTracks` 方法**:

```csharp
private void PausePlayerTracks(string reason)
{
    const double FAR_FUTURE = 1e10;
    var pausedTracks = new List<string>();
    
    foreach (var track in Context.Tracks)
    {
        bool shouldPause = track.TrackType == TrackType.Attack || 
                          (track.TrackType == TrackType.Special && 
                           Context.ProfessionModule.PauseSpecialWhenNoEnemies);
        
        if (shouldPause && track.NextTriggerAt < FAR_FUTURE)
        {
            track.NextTriggerAt = FAR_FUTURE;
            pausedTracks.Add(track.TrackType.ToString());
            Collector.OnTag($"track_paused:{track.TrackType}", 1);
        }
    }
    
    Collector.OnTag($"tracks_paused:{reason}", 1);
    
    // ===== 发送前端推送 =====
    if (Context.NotificationService?.IsAvailable == true && pausedTracks.Count > 0)
    {
        var resetEvent = new BlazorIdle.Shared.Models.TrackProgressResetEventDto
        {
            BattleId = Context.Battle.Id,
            EventTime = Clock.CurrentTime,
            TrackTypes = pausedTracks,
            ResetReason = reason
        };
        _ = Context.NotificationService.NotifyEventAsync(Context.Battle.Id, resetEvent);
    }
    // =======================
}
```

**修改 `ResumePlayerTracks` 方法**:

```csharp
private void ResumePlayerTracks()
{
    const double FAR_FUTURE = 1e10;
    double resumeTime = Clock.CurrentTime;
    var resumedTracks = new List<string>();
    var newTriggerTimes = new Dictionary<string, double>();
    
    foreach (var track in Context.Tracks)
    {
        if (track.NextTriggerAt > FAR_FUTURE / 2)
        {
            double resumeDelay = track.TrackType == TrackType.Special && 
                                Context.ProfessionModule.SpecialStartsImmediately
                ? 0.0 
                : track.CurrentInterval;
            
            track.NextTriggerAt = resumeTime + resumeDelay;
            resumedTracks.Add(track.TrackType.ToString());
            newTriggerTimes[track.TrackType.ToString()] = track.NextTriggerAt;
            
            // 重新调度事件
            if (track.TrackType == TrackType.Attack)
            {
                Scheduler.Schedule(new AttackTickEvent(track.NextTriggerAt, track));
            }
            else if (track.TrackType == TrackType.Special)
            {
                Scheduler.Schedule(new SpecialPulseEvent(track.NextTriggerAt, track));
            }
            
            Collector.OnTag($"track_resumed:{track.TrackType}", 1);
        }
    }
    
    Collector.OnTag("tracks_resumed:spawn_complete", 1);
    
    // ===== 发送前端推送 =====
    if (Context.NotificationService?.IsAvailable == true && resumedTracks.Count > 0)
    {
        var resetEvent = new BlazorIdle.Shared.Models.TrackProgressResetEventDto
        {
            BattleId = Context.Battle.Id,
            EventTime = resumeTime,
            TrackTypes = resumedTracks,
            ResetReason = "spawn_complete",
            NewTriggerTimes = newTriggerTimes
        };
        _ = Context.NotificationService.NotifyEventAsync(Context.Battle.Id, resetEvent);
    }
    // =======================
}
```

#### 理由
- 实时通知前端进度变化
- 提供详细的事件信息
- 前端可以立即更新显示

---

### 任务 3.3: 前端处理进度重置事件

**目标**: 前端接收并处理进度重置事件

#### 修改文件
`BlazorIdle/Pages/Characters.razor`

#### 具体修改

**步骤1**: 添加事件处理方法

```csharp
private void HandleTrackProgressReset(TrackProgressResetEventDto resetEvent)
{
    // 根据重置原因更新 UI 状态
    if (resetEvent.ResetReason == "SpawnWait")
    {
        // 显示"等待刷新"状态
        _isWaitingForSpawn = true;
    }
    else if (resetEvent.ResetReason == "spawn_complete")
    {
        // 清除"等待刷新"状态
        _isWaitingForSpawn = false;
        
        // 如果提供了新的触发时间，更新追踪变量
        if (resetEvent.NewTriggerTimes != null)
        {
            foreach (var kvp in resetEvent.NewTriggerTimes)
            {
                if (kvp.Key == "Attack")
                {
                    // 重置攻击进度追踪
                    _planPrevNextAttackAt = kvp.Value;
                    _planAttackInterval = 0;  // 清除间隔，等待下次计算
                    _planLastUpdateTime = DateTime.UtcNow;
                }
                else if (kvp.Key == "Special")
                {
                    // 重置特殊进度追踪
                    _planPrevNextSpecialAt = kvp.Value;
                    _planSpecialInterval = 0;
                    _planLastUpdateTime = DateTime.UtcNow;
                }
            }
        }
    }
    
    // 立即刷新 UI
    InvokeAsync(StateHasChanged);
}
```

**步骤2**: 在 SignalR 连接中注册事件处理器

```csharp
// 在现有的 SignalR 连接逻辑中添加
hubConnection.On<TrackProgressResetEventDto>("ReceiveEvent", evt =>
{
    if (evt.EventType == "TrackProgressReset")
    {
        HandleTrackProgressReset(evt);
    }
    // ... 其他事件处理 ...
});
```

**步骤3**: 在 UI 中显示等待状态

```razor
@if (_isWaitingForSpawn)
{
    <div class="alert alert-info">
        <i class="fas fa-hourglass-half"></i>
        等待怪物刷新...
    </div>
}
```

#### 理由
- 提供实时的视觉反馈
- 改善用户体验
- 利用现有的 SignalR 基础设施

---

### 任务 3.4: 优化前端进度条显示逻辑

**目标**: 处理特殊情况下的进度条显示

#### 修改文件
`BlazorIdle/Pages/Characters.razor`

#### 具体修改

**在 `CalculateSmoothProgress` 方法中添加特殊处理**:

```csharp
private double CalculateSmoothProgress(
    double currentTime, 
    double nextTriggerAt, 
    double interval, 
    DateTime lastUpdateTime)
{
    // 等待刷新时，显示进度为0
    if (_isWaitingForSpawn)
    {
        return 0.0;
    }
    
    // 如果没有有效的攻击间隔，使用简单的二元判断
    if (interval <= 0)
    {
        return currentTime >= nextTriggerAt ? 1.0 : 0.0;
    }

    // 计算上次攻击时间
    double lastTriggerAt = nextTriggerAt - interval;

    // 计算基于服务器时间的进度
    double serverProgress = (currentTime - lastTriggerAt) / interval;

    // 添加客户端时间插值以实现平滑动画
    double clientElapsedSeconds = 
        (DateTime.UtcNow - lastUpdateTime).TotalSeconds;
    double interpolatedProgress = 
        serverProgress + (clientElapsedSeconds / interval);

    // 限制在 0 到 1 之间
    return Math.Clamp(interpolatedProgress, 0.0, 1.0);
}
```

#### 理由
- 等待刷新时进度条显示为0，符合"暂停"的语义
- 保持现有的平滑进度逻辑
- 提供清晰的视觉反馈

---

### 下篇总结

**完成标志**:
- ✅ 定义了进度重置事件 DTO
- ✅ 后端发送进度重置推送
- ✅ 前端接收并处理事件
- ✅ 优化了进度条显示逻辑
- ✅ 提供了实时的用户反馈
- ✅ 所有测试用例通过

**交付物**:
1. 新增的 `TrackProgressResetEventDto.cs`
2. 修改后的 `BattleEngine.cs`
3. 修改后的 `Characters.razor`
4. 前端样式更新（如果需要）
5. 下篇实施报告

---

## 实施时间表

### 总体时间线

```
Week 1:
  Day 1-3: 上篇实施（核心功能）
  Day 4-5: 上篇测试与修复
  
Week 2:
  Day 1-2: 中篇实施（配置化）
  Day 3: 中篇测试与修复
  Day 4-5: 下篇实施（前端集成）
  
Week 3:
  Day 1: 下篇测试与修复
  Day 2-3: 集成测试与性能测试
  Day 4: 文档完善与交付准备
  Day 5: 最终验收
```

### 里程碑

| 里程碑 | 完成时间 | 交付物 |
|-------|---------|--------|
| M1: 上篇完成 | Week 1 结束 | 核心功能实现 + 测试报告 |
| M2: 中篇完成 | Week 2 Day 3 | 配置化实现 + 测试报告 |
| M3: 下篇完成 | Week 2 结束 | 前端集成 + 测试报告 |
| M4: 集成测试 | Week 3 Day 3 | 完整测试报告 |
| M5: 最终交付 | Week 3 Day 5 | 完整交付包 + 验收文档 |

---

## 验收标准

### 功能验收

#### 上篇验收标准

1. **攻击初始延迟**
   - [ ] 战斗开始时，第一次攻击在完整攻击间隔后触发
   - [ ] 验证方法：创建战斗，检查第一次攻击事件的 ExecuteAt
   - [ ] 预期值：ExecuteAt == attackInterval

2. **刷新等待暂停**
   - [ ] 怪物全部死亡后，攻击事件不再触发
   - [ ] 验证方法：持续模式战斗，怪物死亡后检查事件队列
   - [ ] 预期：攻击轨道的 NextTriggerAt > 1e9

3. **刷新后恢复**
   - [ ] 新怪物出现后，攻击从完整间隔开始
   - [ ] 验证方法：检查刷新后第一次攻击的时间
   - [ ] 预期：NextTriggerAt == spawnTime + attackInterval

4. **目标一致性**
   - [ ] 攻击和技能攻击同一目标
   - [ ] 验证方法：多怪物战斗，检查攻击和技能的目标 ID
   - [ ] 预期：targetId 相同

5. **边缘情况**
   - [ ] 玩家死亡期间怪物刷新，复活后行为正常
   - [ ] 刷新延迟为0时，系统稳定
   - [ ] 多波次快速切换，无重复事件

#### 中篇验收标准

1. **职业配置生效**
   - [ ] 不同职业的特殊轨道暂停行为符合配置
   - [ ] 验证方法：测试战士（不暂停）和法师（暂停）
   - [ ] 预期：战士特殊轨道在无怪物时继续触发

2. **特殊轨道初始行为**
   - [ ] 根据职业配置，特殊轨道可以立即触发或延迟触发
   - [ ] 验证方法：检查第一次特殊事件的 ExecuteAt
   - [ ] 预期：符合 SpecialStartsImmediately 配置

3. **玩家死亡统一**
   - [ ] 所有轨道在玩家死亡时暂停（不受职业配置影响）
   - [ ] 复活后根据职业配置恢复
   - [ ] 验证方法：玩家死亡-复活流程测试

#### 下篇验收标准

1. **前端事件接收**
   - [ ] 前端能接收到进度重置事件
   - [ ] 验证方法：SignalR 日志 + 前端控制台
   - [ ] 预期：收到 TrackProgressResetEventDto

2. **进度条显示**
   - [ ] 等待刷新时进度条显示为0或特殊状态
   - [ ] 刷新后进度条重新开始增长
   - [ ] 验证方法：手动测试 + 截图

3. **用户反馈**
   - [ ] 显示"等待刷新"提示
   - [ ] 进度条变化平滑自然
   - [ ] 验证方法：用户体验测试

### 性能验收

1. **CPU 使用**
   - [ ] 战斗计算 CPU 使用无明显增加
   - [ ] 预期：增幅 < 5%

2. **内存使用**
   - [ ] 内存占用无明显增加
   - [ ] 预期：增幅 < 1MB

3. **网络开销**
   - [ ] SignalR 推送不影响整体网络性能
   - [ ] 预期：每次重置 < 1KB 数据

### 兼容性验收

1. **现有战斗**
   - [ ] 现有单目标战斗不受影响
   - [ ] 地城战斗正常工作
   - [ ] 离线战斗正常工作

2. **测试用例**
   - [ ] 所有现有测试用例通过（或合理更新）
   - [ ] 新增测试用例覆盖新功能

### 代码质量验收

1. **代码风格**
   - [ ] 符合现有代码风格
   - [ ] 命名规范一致
   - [ ] 注释清晰完整

2. **可维护性**
   - [ ] 代码逻辑清晰
   - [ ] 易于扩展
   - [ ] 无明显技术债务

---

## 风险应对

### 高风险项

1. **离线战斗兼容性**
   - 风险：初始延迟可能影响离线计算
   - 应对：详细测试离线快进，必要时添加兼容性代码

2. **性能影响**
   - 风险：事件调度增加可能影响性能
   - 应对：性能测试，优化关键路径

3. **前端兼容性**
   - 风险：SignalR 推送可能在某些环境不稳定
   - 应对：添加降级方案，支持轮询模式

### 中风险项

1. **职业配置复杂度**
   - 风险：配置选项过多导致混乱
   - 应对：提供清晰的文档和示例

2. **目标选择逻辑**
   - 风险：目标锁定可能影响战斗策略
   - 应对：可配置的目标锁定策略

---

## 总结

本实施方案将战斗循环优化分为三个渐进式阶段：

1. **上篇**: 解决核心问题，提供基础功能
2. **中篇**: 增强灵活性，支持职业差异化
3. **下篇**: 改善用户体验，提供实时反馈

每个阶段都有明确的目标、详细的实施步骤和完整的验收标准。按照此方案实施，可以确保修改的最小化、功能的完整性和系统的稳定性。
