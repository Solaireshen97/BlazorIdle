# 活动计划系统修复 - 操作指南

## 修复内容概述

本次修复解决了活动计划系统的两个核心问题：

### 问题1：战斗在一定时间后卡住不动

**症状**：
- 创建一个 Continuous 模式的战斗计划，设置60秒时长
- 战斗开始正常，但在某个时间点后停止推进
- 前端进度条不再更新，但计划状态仍然是 "Running"
- 计划永远不会完成，队列中的下一个计划也无法启动

**原因**：
- Continuous 模式的战斗引擎本身不会自动完成（设计如此）
- 活动计划系统的完成检测逻辑没有正确处理这种情况
- 导致即使达到了时间限制，计划也不会被标记为完成

**修复**：
- 改进了 `CombatActivityExecutor.CheckCompletionAsync` 的逻辑
- 现在会检查活动计划的限制条件（时间/计数），而不仅仅依赖战斗引擎的完成标志

### 问题2：创建第二个任务时与第一个任务并发执行

**症状**：
- 在槽位0创建计划A（60秒），立即开始执行
- 在计划A执行过程中，再次在槽位0创建计划B（60秒）
- 预期：计划B应该排队等待A完成
- 实际：两个计划同时执行，两个进度条同时推进

**原因**：
- 多个线程同时访问和修改槽位状态（创建线程、后台推进线程等）
- 缺少同步机制保护槽位的状态转换
- 可能出现竞态条件，导致队列中的计划被提前启动

**修复**：
- 为每个槽位添加了 `SemaphoreSlim` 锁
- 所有槽位状态修改操作都在锁的保护下进行
- 确保同一时刻只有一个线程可以修改槽位状态

## 如何验证修复

### 验证1：Continuous 模式 + Duration 限制

```
前端操作：
1. 创建或选择一个角色
2. 在活动计划管理面板中：
   - 选择槽位0
   - 限制类型：时长(秒)
   - 时长：60秒
   - 战斗模式：Continuous
   - 敌人：任意
3. 点击"添加到槽位"

预期结果：
- 计划立即开始执行，状态变为 "▶️运行"
- 进度条开始增长（模拟时间从0增长到60）
- 60秒后，计划自动完成，状态变为 "✅完成"
- 槽位变为空闲状态
```

### 验证2：顺序执行

```
前端操作：
1. 在槽位0快速创建3个计划：
   - 计划A：Duration 30秒
   - 计划B：Duration 30秒  
   - 计划C：Duration 30秒

预期结果：
- 创建后立即：
  * 计划A：▶️运行中，进度0%
  * 计划B：⏳待定，在队列中
  * 计划C：⏳待定，在队列中
  
- 30秒后：
  * 计划A：✅完成
  * 计划B：▶️运行中，进度0%（刚开始）
  * 计划C：⏳待定，在队列中
  
- 60秒后：
  * 计划A：✅完成
  * 计划B：✅完成
  * 计划C：▶️运行中，进度0%（刚开始）
  
- 90秒后：
  * 计划A：✅完成
  * 计划B：✅完成
  * 计划C：✅完成
  * 槽位空闲
```

### 验证3：多槽位并发（这是正常行为）

```
前端操作：
1. 在槽位0创建计划A（60秒）
2. 在槽位1创建计划B（60秒）
3. 在槽位2创建计划C（60秒）

预期结果：
- 3个计划同时执行（因为在不同槽位）
- 3个进度条同时增长
- 约60秒后，3个计划同时完成
```

## 支持的使用模式

### 模式1：限定时间的连续战斗

```json
{
  "limitType": "duration",
  "limitValue": 120,
  "payload": {
    "mode": "continuous",
    "enemyId": "dummy"
  }
}
```

**用途**：挂机刷怪，自动在2分钟后停止

### 模式2：击杀指定数量

```json
{
  "limitType": "count",
  "limitValue": 100,
  "payload": {
    "mode": "continuous",
    "enemyId": "dummy"
  }
}
```

**用途**：完成"击杀100个训练假人"任务

### 模式3：无限战斗（需手动停止）

```json
{
  "limitType": "infinite",
  "payload": {
    "mode": "continuous",
    "enemyId": "dummy"
  }
}
```

**用途**：真正的挂机，需要玩家手动点击"取消"按钮停止

### 模式4：标准时长战斗

```json
{
  "limitType": "duration",
  "limitValue": 60,
  "payload": {
    "mode": "duration",
    "enemyId": "dummy"
  }
}
```

**用途**：传统的定时战斗，战斗引擎会在60秒后自动完成

## 前端UI建议

### 创建计划时的提示

在前端可以添加以下提示信息：

```
战斗模式说明：
- Duration：标准战斗，到达设定时间后自动结束
- Continuous：连续战斗，会持续刷新敌人
  * 配合"时长"限制：自动在设定时间后结束
  * 配合"计数"限制：自动在击杀数量后结束
  * 配合"无限"限制：需要手动停止
```

### 进度显示

```typescript
function calculateProgress(plan) {
  if (plan.limitType === 'duration') {
    // 时长限制：显示时间进度
    const progress = plan.progress.simulatedSeconds / plan.limitValue;
    return Math.min(100, progress * 100);
  } else if (plan.limitType === 'count') {
    // 计数限制：显示击杀进度
    const progress = plan.progress.completedCount / plan.limitValue;
    return Math.min(100, progress * 100);
  } else if (plan.limitType === 'infinite') {
    // 无限限制：显示已运行时间（无进度条）
    return `已运行 ${Math.floor(plan.progress.simulatedSeconds)}秒`;
  }
  return 0;
}
```

### 队列显示

```html
<!-- 当前执行的计划 -->
<div class="current-plan">
  ▶️ Continuous 战斗 - 60/120秒 (50%)
  <button>取消</button>
</div>

<!-- 队列中的计划 -->
<div class="queued-plans">
  <div>⏳ Duration 战斗 - 30秒 <button>移除</button></div>
  <div>⏳ Continuous 战斗 - 100击杀 <button>移除</button></div>
</div>

<!-- 空闲槽位 -->
<div class="idle-slot">
  空闲 - 可创建新计划
</div>
```

## 性能影响

### 正常使用场景

- **角色数**：100个
- **每角色槽位**：3个
- **总槽位数**：300个

**资源消耗**：
- 内存：约14KB（300个锁）
- CPU：可忽略（锁操作微秒级）
- 网络：无额外消耗

### 高负载场景

- **角色数**：1000个
- **每角色槽位**：5个
- **总槽位数**：5000个

**资源消耗**：
- 内存：约240KB（5000个锁）
- CPU：仍然可忽略
- 网络：无额外消耗

**结论**：修复不会带来明显的性能影响

## 常见问题

### Q1：为什么 Continuous 模式需要设置时长限制？

A：Continuous 模式本身不会自动停止（这是设计特性，用于实现真正的挂机）。如果你希望它自动停止，需要设置限制：
- Duration 限制：在指定时间后停止
- Count 限制：在击杀指定数量后停止
- Infinite 限制：需要手动停止

### Q2：如果我设置了60秒的 Continuous 战斗，为什么进度条不动了？

A：请先检查：
1. 是否开启了"自动刷新"（建议每2秒刷新一次）
2. 后端服务是否正常运行（检查 `ActivityHostedService` 和 `StepBattleHostedService`）
3. 浏览器控制台是否有错误信息

### Q3：我创建了3个计划，但它们同时执行了？

A：请检查是否创建在了**同一个槽位**：
- 同一槽位的计划会顺序执行
- 不同槽位的计划会并发执行

### Q4：我的计划卡在 "Running" 状态，永远不会完成？

A：这正是本次修复要解决的问题。修复后：
- Continuous 模式会正确检查限制条件
- 达到限制后会自动标记为完成
- 下一个计划会自动启动

如果修复后仍然出现此问题，请检查：
1. 代码是否已更新到最新版本
2. 服务器是否已重启（应用新代码）

## 相关配置

在 `appsettings.json` 中：

```json
{
  "Activity": {
    "AdvanceIntervalSeconds": 1.0,     // 活动推进间隔（每秒检查一次）
    "PruneIntervalMinutes": 10.0,      // 清理已完成计划的间隔
    "SlotsPerCharacter": 3             // 每个角色的槽位数量
  },
  "Combat": {
    "RewardFlushIntervalSeconds": 10.0,  // 边打边发的奖励间隔
    "EnablePeriodicRewards": true        // 是否启用周期性奖励
  }
}
```

**建议配置**：
- `AdvanceIntervalSeconds`：1.0（不建议改小，避免过度消耗CPU）
- `SlotsPerCharacter`：3（可根据需要调整为3-5）

## 升级步骤

如果你是从旧版本升级，请按以下步骤操作：

1. **备份数据**（可选）
   ```bash
   # 备份数据库（如果使用 SQLite）
   cp app.db app.db.backup
   ```

2. **更新代码**
   ```bash
   git pull origin master
   ```

3. **重新编译**
   ```bash
   dotnet build
   ```

4. **重启服务**
   ```bash
   # 停止旧服务
   # 启动新服务
   dotnet run
   ```

5. **验证修复**
   - 按照上述验证步骤测试

6. **清理旧数据**（可选）
   - 如果有卡住的计划，可以手动取消它们
   - 或者等待自动清理（默认10分钟）

## 反馈与支持

如果遇到问题，请提供以下信息：

1. **现象描述**：详细描述问题
2. **复现步骤**：如何触发问题
3. **日志信息**：服务器端日志（`ActivityCoordinator` 和 `CombatActivityExecutor`）
4. **计划详情**：计划ID、类型、限制、载荷等

可以通过以下方式查看日志：

```bash
# 查看 ActivityHostedService 日志
grep "ActivityHostedService" logs/app.log

# 查看活动推进日志
grep "Advancing activity plan" logs/app.log

# 查看计划完成日志
grep "completed\|completed" logs/app.log
```

## 技术细节

如果你是开发者，想了解更多技术细节，请参考：

- `docs/活动计划系统-并发和完成检测修复.md`：详细的技术分析
- `docs/活动计划系统-24秒超时问题分析与修复.md`：之前的修复文档
- `整合设计总结.txt`：系统整体设计文档
