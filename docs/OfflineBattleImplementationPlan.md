# ç¦»çº¿æˆ˜æ–—ç³»ç»Ÿå®æ–½æ–¹æ¡ˆ

**æ–‡æ¡£ç‰ˆæœ¬**: 1.0  
**åˆ›å»ºæ—¥æœŸ**: 2025å¹´1æœˆ  
**ç›®æ ‡**: å®ç°å®Œæ•´çš„ç¦»çº¿æˆ˜æ–—æ”¶ç›Šè®¡ç®—ä¸è‡ªåŠ¨è¡”æ¥æ´»åŠ¨è®¡åˆ’åŠŸèƒ½

---

## ğŸ“‹ ç›®å½•

1. [éœ€æ±‚æ¦‚è¿°](#éœ€æ±‚æ¦‚è¿°)
2. [å½“å‰å®ç°çŠ¶æ€åˆ†æ](#å½“å‰å®ç°çŠ¶æ€åˆ†æ)
3. [ç¼ºå¤±ç»„ä»¶æ¸…å•](#ç¼ºå¤±ç»„ä»¶æ¸…å•)
4. [è¯¦ç»†å®æ–½æ–¹æ¡ˆ](#è¯¦ç»†å®æ–½æ–¹æ¡ˆ)
5. [æ•°æ®åº“å˜æ›´](#æ•°æ®åº“å˜æ›´)
6. [APIè®¾è®¡](#apiè®¾è®¡)
7. [å‰ç«¯é›†æˆæ–¹æ¡ˆ](#å‰ç«¯é›†æˆæ–¹æ¡ˆ)
8. [æµ‹è¯•éªŒè¯è®¡åˆ’](#æµ‹è¯•éªŒè¯è®¡åˆ’)
9. [é£é™©ä¸æ³¨æ„äº‹é¡¹](#é£é™©ä¸æ³¨æ„äº‹é¡¹)

---

## éœ€æ±‚æ¦‚è¿°

### æ ¸å¿ƒåŠŸèƒ½

ç”¨æˆ·åœ¨çº¿æ—¶ï¼š
1. åˆ›å»ºæ´»åŠ¨è®¡åˆ’ï¼ˆå¦‚1å°æ—¶æˆ˜æ–—ä»»åŠ¡ï¼‰
2. å¯åŠ¨æ´»åŠ¨è®¡åˆ’ï¼Œå¼€å§‹æˆ˜æ–—
3. å¯éšæ—¶ä¸‹çº¿æˆ–å…³é—­ç½‘é¡µ

ç”¨æˆ·ç¦»çº¿æœŸé—´ï¼š
1. ç³»ç»Ÿè®°å½•ç¦»çº¿æ—¶é—´ç‚¹
2. ä¿å­˜å½“å‰æ´»åŠ¨è®¡åˆ’çŠ¶æ€

ç”¨æˆ·å†æ¬¡ä¸Šçº¿æ—¶ï¼š
1. æ£€æµ‹ç¦»çº¿æ—¶é•¿ï¼ˆä¸Šé™12å°æ—¶ï¼‰
2. **è‡ªåŠ¨è§¦å‘ç¦»çº¿å¿«è¿›æ¨¡æ‹Ÿ**ï¼Œè®¡ç®—ç¦»çº¿æœŸé—´æ”¶ç›Š
3. å±•ç¤ºç¦»çº¿ç»“ç®—ç•Œé¢ï¼ˆæ—¶é•¿ã€é‡‘å¸ã€ç»éªŒã€ç‰©å“ï¼‰
4. å°†æ”¶ç›Šå‘æ”¾åˆ°è§’è‰²
5. å¦‚æœæ´»åŠ¨è®¡åˆ’æœªå®Œæˆï¼Œè‡ªåŠ¨ç»§ç»­æ‰§è¡Œå‰©ä½™ä»»åŠ¡
6. å¦‚æœæ´»åŠ¨è®¡åˆ’å·²å®Œæˆï¼Œè‡ªåŠ¨å¯åŠ¨ä¸‹ä¸€ä¸ªå¾…æ‰§è¡Œçš„è®¡åˆ’

### è®¾è®¡åŸåˆ™

æ ¹æ®`æ•´åˆè®¾è®¡æ€»ç»“.txt`ç¬¬9ç« èŠ‚ï¼š
- **ä¸€è‡´æ€§**ï¼šç¦»çº¿ä½¿ç”¨ä¸åœ¨çº¿ç›¸åŒçš„äº‹ä»¶è°ƒåº¦ç®—æ³•
- **ä¸Šé™æ§åˆ¶**ï¼šç¦»çº¿æ”¶ç›Šæœ€å¤šè®¡ç®—12å°æ—¶ï¼ˆå¯é…ç½®ï¼‰
- **å¿«è¿›æ¨¡æ‹Ÿ**ï¼šä½¿ç”¨`OfflineFastForwardEngine`å¿«é€Ÿæ¨è¿›æ—¶é—´
- **èšåˆä¼˜åŒ–**ï¼šç”Ÿæˆ`CombatSegment`è€Œéé€äº‹ä»¶å­˜å‚¨
- **è‡ªåŠ¨è¡”æ¥**ï¼šå½“å‰è®¡åˆ’å®Œæˆâ†’æŸ¥æ‰¾ä¸‹ä¸€ä¸ªPendingâ†’å¯åŠ¨

---

## å½“å‰å®ç°çŠ¶æ€åˆ†æ

### âœ… å·²å®ç°çš„ç»„ä»¶

#### 1. ActivityPlan æ¨¡å‹ (å®Œæ•´)
- **ä½ç½®**: `BlazorIdle.Server/Domain/Activities/ActivityPlan.cs`
- **åŠŸèƒ½**:
  - æ´»åŠ¨è®¡åˆ’å®ä½“ï¼ˆCombatã€Dungeonï¼‰
  - é™åˆ¶ç±»å‹ï¼ˆDurationã€Infiniteï¼‰
  - çŠ¶æ€æœºï¼ˆPending â†’ Running â†’ Completed/Cancelledï¼‰
  - æ§½ä½ç´¢å¼•ï¼ˆ0-4ï¼Œé¢„ç•™å¤šæ§½ä½æ”¯æŒï¼‰
  - æ‰§è¡Œæ—¶é•¿è¿½è¸ªï¼ˆ`ExecutedSeconds`ï¼‰
- **çŠ¶æ€**: âœ… å®Œæ•´å®ç°

#### 2. ActivityPlanService (å®Œæ•´)
- **ä½ç½®**: `BlazorIdle.Server/Application/Activities/ActivityPlanService.cs`
- **åŠŸèƒ½**:
  - åˆ›å»ºæ´»åŠ¨è®¡åˆ’
  - å¯åŠ¨/åœæ­¢/å–æ¶ˆè®¡åˆ’
  - ä¸`StepBattleCoordinator`é›†æˆ
  - è‡ªåŠ¨å¯åŠ¨é€»è¾‘ï¼ˆé¦–ä¸ªè®¡åˆ’è‡ªåŠ¨å¯åŠ¨ï¼‰
  - è¿›åº¦æ›´æ–°ä¸é™åˆ¶æ£€æŸ¥
- **çŠ¶æ€**: âœ… å®Œæ•´å®ç°

#### 3. OfflineSettlementService (åŸºç¡€ç‰ˆæœ¬)
- **ä½ç½®**: `BlazorIdle.Server/Application/Battles/Offline/Offline.cs`
- **åŠŸèƒ½**:
  - åŸºç¡€ç¦»çº¿æ¨¡æ‹Ÿï¼ˆSimulateAsyncï¼‰
  - ä½¿ç”¨`BattleSimulator`è¿›è¡Œå¿«è¿›
  - ç»æµè®¡ç®—ï¼ˆé‡‘å¸ã€ç»éªŒã€æ‰è½ï¼‰
  - æ”¯æŒå¤šç§æ¨¡å¼ï¼ˆcontinuousã€dungeonï¼‰
- **é™åˆ¶**: 
  - âš ï¸ **æœªé›†æˆåˆ°ç”¨æˆ·ç™»å½•æµç¨‹**
  - âš ï¸ **æœªè®°å½•è§’è‰²ç¦»çº¿æ—¶é—´**
  - âš ï¸ **æœªè‡ªåŠ¨è§¦å‘ç¦»çº¿ç»“ç®—**
  - âš ï¸ **æœªæ¢å¤æ´»åŠ¨è®¡åˆ’çŠ¶æ€**
- **çŠ¶æ€**: ğŸŸ¡ éƒ¨åˆ†å®ç°

#### 4. OfflineController (åŸºç¡€API)
- **ä½ç½®**: `BlazorIdle.Server/Api/OfflineController.cs`
- **åŠŸèƒ½**:
  - æä¾›æ‰‹åŠ¨ç¦»çº¿ç»“ç®—æ¥å£
  - `POST /api/offline/settle` ç«¯ç‚¹
- **é™åˆ¶**: 
  - âš ï¸ ä»…æ”¯æŒæ‰‹åŠ¨è°ƒç”¨
  - âš ï¸ æœªè‡ªåŠ¨åœ¨ç™»å½•æ—¶è§¦å‘
- **çŠ¶æ€**: ğŸŸ¡ éƒ¨åˆ†å®ç°

#### 5. Character å®ä½“ï¼ˆå·²æ‰©å±•ï¼‰
- **ä½ç½®**: `BlazorIdle.Server/Domain/Characters/Character.cs`
- **åŠŸèƒ½**:
  - åŒ…å«ç¦»çº¿è¿½è¸ªå­—æ®µï¼š
    - `LastSeenAtUtc`: æœ€è¿‘åœ¨çº¿æ—¶é—´
    - `LastOfflineSettledAtUtc`: æœ€è¿‘ç¦»çº¿ç»“ç®—æ—¶é—´
- **çŠ¶æ€**: âœ… å­—æ®µå·²æ·»åŠ 

### âŒ ç¼ºå¤±çš„æ ¸å¿ƒç»„ä»¶

#### 1. OfflineFastForwardEngine (å®Œå…¨ç¼ºå¤±)
æ ¹æ®è®¾è®¡æ–‡æ¡£ï¼Œéœ€è¦ä¸€ä¸ªä¸“é—¨çš„å¼•æ“ç”¨äºç¦»çº¿å¿«è¿›ï¼š
- å¤ç”¨`EventScheduler`è¿›è¡Œäº‹ä»¶è°ƒåº¦
- æ”¯æŒæ—¶é—´è·³è·ƒï¼ˆæ— éœ€é€å¸§è®¡ç®—ï¼‰
- ç”Ÿæˆèšåˆçš„`CombatSegment`
- ä¸`ActivityPlan`çŠ¶æ€åŒæ­¥

#### 2. è‡ªåŠ¨ç¦»çº¿æ£€æµ‹ä¸ç»“ç®—æœºåˆ¶ (å®Œå…¨ç¼ºå¤±)
- ç™»å½•æ—¶è‡ªåŠ¨æ£€æµ‹ç¦»çº¿æ—¶é•¿
- è§¦å‘ç¦»çº¿ç»“ç®—æµç¨‹
- æ¢å¤æ´»åŠ¨è®¡åˆ’çŠ¶æ€

#### 3. æ´»åŠ¨è®¡åˆ’è‡ªåŠ¨è¡”æ¥ (éƒ¨åˆ†å®ç°)
- å½“å‰æœ‰`TryStartNextPendingPlanAsync`æ–¹æ³•
- âš ï¸ ä½†æœªä¸ç¦»çº¿ç»“ç®—é›†æˆ
- âš ï¸ æœªå¤„ç†ç¦»çº¿æœŸé—´è®¡åˆ’å®Œæˆçš„æƒ…å†µ

#### 4. ç¦»çº¿ç»“ç®—ç»“æœæŒä¹…åŒ– (å®Œå…¨ç¼ºå¤±)
- ç¦»çº¿æ”¶ç›Šè®°å½•ï¼ˆç”¨äºå®¡è®¡å’Œå›é¡¾ï¼‰
- å†å²ç¦»çº¿ç»“ç®—è®°å½•

#### 5. å‰ç«¯ç¦»çº¿ç»“ç®—ç•Œé¢ (å®Œå…¨ç¼ºå¤±)
- ç¦»çº¿æ—¶é•¿å±•ç¤º
- æ”¶ç›Šè¯¦æƒ…ï¼ˆé‡‘å¸ã€ç»éªŒã€ç‰©å“ï¼‰
- æ®µæ‘˜è¦æŸ¥çœ‹

---

## ç¼ºå¤±ç»„ä»¶æ¸…å•

### åç«¯ç»„ä»¶

| ç»„ä»¶ | ä¼˜å…ˆçº§ | çŠ¶æ€ | æè¿° |
|------|--------|------|------|
| `OfflineFastForwardEngine` | ğŸ”´ é«˜ | âŒ ç¼ºå¤± | ä¸“ç”¨ç¦»çº¿å¿«è¿›å¼•æ“ï¼Œå¤ç”¨EventScheduler |
| `OfflineSettlementRecord` å®ä½“ | ğŸŸ¡ ä¸­ | âŒ ç¼ºå¤± | ç¦»çº¿ç»“ç®—è®°å½•è¡¨ï¼ˆå®¡è®¡ç”¨ï¼‰ |
| `IOfflineSettlementRepository` | ğŸŸ¡ ä¸­ | âŒ ç¼ºå¤± | ç¦»çº¿ç»“ç®—è®°å½•ä»“å‚¨æ¥å£ |
| `LoginOfflineCheckService` | ğŸ”´ é«˜ | âŒ ç¼ºå¤± | ç™»å½•æ—¶è‡ªåŠ¨æ£€æµ‹å¹¶è§¦å‘ç¦»çº¿ç»“ç®— |
| æ´»åŠ¨è®¡åˆ’å¿«ç…§æ¢å¤é€»è¾‘ | ğŸ”´ é«˜ | âŒ ç¼ºå¤± | æ¢å¤ç¦»çº¿å‰çš„æ´»åŠ¨è®¡åˆ’çŠ¶æ€ |
| æ´»åŠ¨è®¡åˆ’è‡ªåŠ¨è¡”æ¥å®Œå–„ | ğŸ”´ é«˜ | ğŸŸ¡ éƒ¨åˆ† | å¤„ç†ç¦»çº¿æœŸé—´è®¡åˆ’å®Œæˆçš„æƒ…å†µ |
| ç¦»çº¿æ—¶é•¿ä¸Šé™é…ç½® | ğŸŸ¢ ä½ | âŒ ç¼ºå¤± | 12å°æ—¶ä¸Šé™ï¼ˆå¯é…ç½®ï¼‰ |

### å‰ç«¯ç»„ä»¶

| ç»„ä»¶ | ä¼˜å…ˆçº§ | çŠ¶æ€ | æè¿° |
|------|--------|------|------|
| `OfflineSettlementDialog` ç»„ä»¶ | ğŸ”´ é«˜ | âŒ ç¼ºå¤± | ç¦»çº¿ç»“ç®—å¼¹çª— |
| ç¦»çº¿æ”¶ç›Šå±•ç¤ºç•Œé¢ | ğŸ”´ é«˜ | âŒ ç¼ºå¤± | é‡‘å¸ã€ç»éªŒã€ç‰©å“è¯¦æƒ… |
| ç¦»çº¿æ®µæ‘˜è¦æŸ¥çœ‹ | ğŸŸ¡ ä¸­ | âŒ ç¼ºå¤± | æŸ¥çœ‹ç¦»çº¿æˆ˜æ–—è¯¦ç»†æ•°æ® |
| ApiClient ç¦»çº¿APIé›†æˆ | ğŸ”´ é«˜ | âŒ ç¼ºå¤± | è°ƒç”¨ç¦»çº¿ç»“ç®—API |

### APIç«¯ç‚¹

| ç«¯ç‚¹ | ä¼˜å…ˆçº§ | çŠ¶æ€ | æè¿° |
|------|--------|------|------|
| `GET /api/offline/check` | ğŸ”´ é«˜ | âŒ ç¼ºå¤± | æ£€æŸ¥æ˜¯å¦æœ‰å¾…ç»“ç®—çš„ç¦»çº¿æ—¶é—´ |
| `POST /api/offline/apply-settlement` | ğŸ”´ é«˜ | âŒ ç¼ºå¤± | åº”ç”¨ç¦»çº¿ç»“ç®—å¹¶å‘æ”¾æ”¶ç›Š |
| `GET /api/offline/history` | ğŸŸ¡ ä¸­ | âŒ ç¼ºå¤± | è·å–å†å²ç¦»çº¿ç»“ç®—è®°å½• |

---

## è¯¦ç»†å®æ–½æ–¹æ¡ˆ

### Phase 1: æ ¸å¿ƒç¦»çº¿å¼•æ“ï¼ˆæœ€å…³é”®ï¼‰

#### Step 1.1: åˆ›å»º OfflineFastForwardEngine

**ä½ç½®**: `BlazorIdle.Server/Application/Battles/Offline/OfflineFastForwardEngine.cs`

**åŠŸèƒ½è®¾è®¡**:
```csharp
public class OfflineFastForwardEngine
{
    private readonly BattleSimulator _simulator;
    
    public OfflineFastForwardEngine(BattleSimulator simulator)
    {
        _simulator = simulator;
    }
    
    /// <summary>
    /// å¿«è¿›æ¨¡æ‹Ÿç¦»çº¿æœŸé—´çš„æ´»åŠ¨è®¡åˆ’æ‰§è¡Œ
    /// </summary>
    public OfflineFastForwardResult FastForward(
        Character character,
        ActivityPlan plan,
        double offlineSeconds,
        double maxCapSeconds = 43200) // 12å°æ—¶é»˜è®¤ä¸Šé™
    {
        // 1. è®¡ç®—å®é™…æ¨¡æ‹Ÿæ—¶é•¿
        var cappedSeconds = Math.Min(offlineSeconds, maxCapSeconds);
        
        // 2. è®¡ç®—è®¡åˆ’å‰©ä½™æ—¶é•¿
        var remainingSeconds = CalculateRemainingSeconds(plan, cappedSeconds);
        
        // 3. ä½¿ç”¨ BattleSimulator å¿«è¿›
        var result = SimulatePlan(character, plan, remainingSeconds);
        
        // 4. æ›´æ–°è®¡åˆ’çŠ¶æ€
        var updatedPlan = UpdatePlanState(plan, remainingSeconds);
        
        // 5. è¿”å›ç»“æœ
        return new OfflineFastForwardResult
        {
            CharacterId = character.Id,
            PlanId = plan.Id,
            SimulatedSeconds = remainingSeconds,
            PlanCompleted = updatedPlan.IsLimitReached(),
            TotalDamage = result.TotalDamage,
            TotalKills = result.TotalKills,
            Gold = result.Gold,
            Exp = result.Exp,
            Loot = result.Loot,
            Segments = result.Segments,
            UpdatedExecutedSeconds = updatedPlan.ExecutedSeconds
        };
    }
    
    private double CalculateRemainingSeconds(ActivityPlan plan, double availableSeconds)
    {
        if (plan.LimitType == LimitType.Infinite)
        {
            return availableSeconds;
        }
        
        if (plan.LimitType == LimitType.Duration && plan.LimitValue.HasValue)
        {
            var remaining = plan.LimitValue.Value - plan.ExecutedSeconds;
            return Math.Min(remaining, availableSeconds);
        }
        
        return availableSeconds;
    }
    
    private SimulationResult SimulatePlan(
        Character character, 
        ActivityPlan plan, 
        double seconds)
    {
        // æ ¹æ®è®¡åˆ’ç±»å‹æ„å»ºé…ç½®
        var config = BuildBattleConfig(character, plan, seconds);
        
        // ä½¿ç”¨ BattleSimulator æ‰§è¡Œå¿«è¿›
        var rb = _simulator.CreateRunningBattle(config, seconds);
        rb.FastForwardTo(seconds);
        
        // èšåˆç»“æœ
        return AggregateResults(rb);
    }
}

public class OfflineFastForwardResult
{
    public Guid CharacterId { get; set; }
    public Guid PlanId { get; set; }
    public double SimulatedSeconds { get; set; }
    public bool PlanCompleted { get; set; }
    public long TotalDamage { get; set; }
    public int TotalKills { get; set; }
    public long Gold { get; set; }
    public long Exp { get; set; }
    public Dictionary<string, double> Loot { get; set; } = new();
    public List<CombatSegment> Segments { get; set; } = new();
    public double UpdatedExecutedSeconds { get; set; }
}
```

**å®ç°è¦ç‚¹**:
1. å¤ç”¨ç°æœ‰çš„`BattleSimulator`å’Œ`RunningBattle`
2. æ”¯æŒè®¡åˆ’é™åˆ¶è®¡ç®—ï¼ˆDuration vs Infiniteï¼‰
3. è¿”å›è¯¦ç»†çš„æ¨¡æ‹Ÿç»“æœå’Œæ›´æ–°åçš„è®¡åˆ’çŠ¶æ€
4. ç”Ÿæˆèšåˆçš„`CombatSegment`ç”¨äºå›é¡¾

---

#### Step 1.2: å®Œå–„ OfflineSettlementService

**ä½ç½®**: `BlazorIdle.Server/Application/Battles/Offline/Offline.cs`ï¼ˆæ‰©å±•ï¼‰

**æ–°å¢æ–¹æ³•**:
```csharp
public class OfflineSettlementService
{
    private readonly ICharacterRepository _characters;
    private readonly IActivityPlanRepository _plans;
    private readonly BattleSimulator _simulator;
    private readonly OfflineFastForwardEngine _engine;
    private readonly IRewardGrantService _rewards;
    
    /// <summary>
    /// ç”¨æˆ·ç™»å½•æ—¶è‡ªåŠ¨æ£€æµ‹å¹¶ç»“ç®—ç¦»çº¿æ”¶ç›Š
    /// </summary>
    public async Task<OfflineCheckResult> CheckAndSettleAsync(
        Guid characterId,
        CancellationToken ct = default)
    {
        var character = await _characters.GetAsync(characterId, ct);
        if (character is null)
            throw new InvalidOperationException("Character not found");
        
        // 1. è®¡ç®—ç¦»çº¿æ—¶é•¿
        var offlineSeconds = CalculateOfflineDuration(character);
        if (offlineSeconds <= 0)
        {
            return new OfflineCheckResult
            {
                HasOfflineTime = false,
                OfflineSeconds = 0
            };
        }
        
        // 2. æŸ¥æ‰¾ç¦»çº¿æ—¶æ­£åœ¨è¿è¡Œçš„è®¡åˆ’
        var runningPlan = await _plans.GetRunningPlanAsync(characterId, ct);
        if (runningPlan is null)
        {
            // æ²¡æœ‰æ´»åŠ¨è®¡åˆ’ï¼Œä»…æ›´æ–°LastSeenAt
            character.LastSeenAtUtc = DateTime.UtcNow;
            await _characters.UpdateAsync(character, ct);
            
            return new OfflineCheckResult
            {
                HasOfflineTime = true,
                OfflineSeconds = offlineSeconds,
                HasRunningPlan = false
            };
        }
        
        // 3. ä½¿ç”¨ OfflineFastForwardEngine å¿«è¿›æ¨¡æ‹Ÿ
        var result = _engine.FastForward(character, runningPlan, offlineSeconds);
        
        // 4. æ›´æ–°è®¡åˆ’æ‰§è¡Œæ—¶é•¿å’ŒçŠ¶æ€
        runningPlan.ExecutedSeconds = result.UpdatedExecutedSeconds;
        if (result.PlanCompleted)
        {
            runningPlan.State = ActivityState.Completed;
            runningPlan.CompletedAt = DateTime.UtcNow;
        }
        await _plans.UpdateAsync(runningPlan, ct);
        
        // 5. å‘æ”¾å¥–åŠ±ï¼ˆæš‚ä¸å®é™…ä¿®æ”¹è§’è‰²Gold/Expï¼Œç­‰å‰ç«¯ç¡®è®¤åè°ƒç”¨applyæ¥å£ï¼‰
        
        // 6. æ›´æ–°è§’è‰²æ—¶é—´æˆ³
        character.LastSeenAtUtc = DateTime.UtcNow;
        character.LastOfflineSettledAtUtc = DateTime.UtcNow;
        await _characters.UpdateAsync(character, ct);
        
        // 7. å¦‚æœè®¡åˆ’å®Œæˆï¼Œå°è¯•å¯åŠ¨ä¸‹ä¸€ä¸ª
        if (result.PlanCompleted)
        {
            var nextPlan = await TryStartNextPendingPlanAsync(characterId, ct);
            return new OfflineCheckResult
            {
                HasOfflineTime = true,
                OfflineSeconds = offlineSeconds,
                HasRunningPlan = true,
                Settlement = result,
                PlanCompleted = true,
                NextPlanStarted = nextPlan is not null,
                NextPlanId = nextPlan?.Id
            };
        }
        
        return new OfflineCheckResult
        {
            HasOfflineTime = true,
            OfflineSeconds = offlineSeconds,
            HasRunningPlan = true,
            Settlement = result,
            PlanCompleted = false
        };
    }
    
    /// <summary>
    /// åº”ç”¨ç¦»çº¿ç»“ç®—ï¼Œå®é™…å‘æ”¾æ”¶ç›Š
    /// </summary>
    public async Task ApplySettlementAsync(
        Guid characterId,
        OfflineFastForwardResult settlement,
        CancellationToken ct = default)
    {
        var character = await _characters.GetAsync(characterId, ct);
        if (character is null)
            throw new InvalidOperationException("Character not found");
        
        // å‘æ”¾é‡‘å¸å’Œç»éªŒ
        character.Gold += settlement.Gold;
        character.Experience += settlement.Exp;
        await _characters.UpdateAsync(character, ct);
        
        // å‘æ”¾ç‰©å“ï¼ˆå¦‚æœæœ‰èƒŒåŒ…ç³»ç»Ÿï¼‰
        if (settlement.Loot.Any())
        {
            await _rewards.GrantItemsAsync(characterId, settlement.Loot, ct);
        }
    }
    
    private double CalculateOfflineDuration(Character character)
    {
        if (!character.LastSeenAtUtc.HasValue)
            return 0;
        
        var now = DateTime.UtcNow;
        var lastSeen = character.LastSeenAtUtc.Value;
        return (now - lastSeen).TotalSeconds;
    }
    
    private async Task<ActivityPlan?> TryStartNextPendingPlanAsync(
        Guid characterId,
        CancellationToken ct)
    {
        // æŸ¥æ‰¾ä¸‹ä¸€ä¸ªPendingçŠ¶æ€çš„è®¡åˆ’
        var pendingPlans = await _plans.GetPendingPlansAsync(characterId, ct);
        var nextPlan = pendingPlans
            .OrderBy(p => p.SlotIndex)
            .ThenBy(p => p.CreatedAt)
            .FirstOrDefault();
        
        if (nextPlan is null)
            return null;
        
        // å¯åŠ¨è®¡åˆ’ï¼ˆéœ€è¦è°ƒç”¨ActivityPlanServiceï¼‰
        // æ³¨æ„ï¼šè¿™é‡Œéœ€è¦æ³¨å…¥ActivityPlanServiceæˆ–é‡æ„ä»£ç é¿å…å¾ªç¯ä¾èµ–
        
        return nextPlan;
    }
}

public class OfflineCheckResult
{
    public bool HasOfflineTime { get; set; }
    public double OfflineSeconds { get; set; }
    public bool HasRunningPlan { get; set; }
    public OfflineFastForwardResult? Settlement { get; set; }
    public bool PlanCompleted { get; set; }
    public bool NextPlanStarted { get; set; }
    public Guid? NextPlanId { get; set; }
}
```

**å®ç°è¦ç‚¹**:
1. è‡ªåŠ¨æ£€æµ‹ç¦»çº¿æ—¶é•¿ï¼ˆåŸºäº`LastSeenAtUtc`ï¼‰
2. æŸ¥æ‰¾ç¦»çº¿æ—¶çš„è¿è¡Œè®¡åˆ’
3. è°ƒç”¨`OfflineFastForwardEngine`è¿›è¡Œå¿«è¿›
4. æ›´æ–°è®¡åˆ’çŠ¶æ€ï¼ˆExecutedSecondsã€Completedï¼‰
5. æ”¯æŒä¸¤é˜¶æ®µæäº¤ï¼ˆå…ˆè¿”å›ç»“ç®—ç»“æœï¼Œå‰ç«¯ç¡®è®¤åå†å‘æ”¾ï¼‰
6. è‡ªåŠ¨è¡”æ¥ä¸‹ä¸€ä¸ªè®¡åˆ’

---

### Phase 2: å¿ƒè·³ä¸ç¦»çº¿è¿½è¸ª

#### Step 2.1: æ·»åŠ å¿ƒè·³æ›´æ–°æœºåˆ¶

**ä½ç½®**: `BlazorIdle.Server/Api/CharactersController.cs`ï¼ˆæ–°å¢ç«¯ç‚¹ï¼‰

**æ–°å¢ç«¯ç‚¹**:
```csharp
[HttpPost("{characterId}/heartbeat")]
public async Task<ActionResult> UpdateHeartbeat(
    Guid characterId,
    CancellationToken ct = default)
{
    var character = await _characters.GetAsync(characterId, ct);
    if (character is null)
        return NotFound();
    
    character.LastSeenAtUtc = DateTime.UtcNow;
    await _characters.UpdateAsync(character, ct);
    
    return Ok();
}
```

**å‰ç«¯é›†æˆ**:
- åœ¨`Characters.razor`é¡µé¢åŠ è½½æ—¶è°ƒç”¨
- å®šæœŸå¿ƒè·³ï¼ˆå¯é€‰ï¼Œå¦‚æ¯5åˆ†é’Ÿï¼‰
- é¡µé¢å¸è½½æ—¶è°ƒç”¨

---

#### Step 2.2: ç™»å½•æ—¶ç¦»çº¿æ£€æµ‹

**ä½ç½®**: `BlazorIdle.Server/Api/OfflineController.cs`ï¼ˆæ‰©å±•ï¼‰

**æ–°å¢ç«¯ç‚¹**:
```csharp
[HttpGet("check")]
public async Task<ActionResult<OfflineCheckResult>> CheckOffline(
    [FromQuery] Guid characterId,
    CancellationToken ct = default)
{
    try
    {
        var result = await _offline.CheckAndSettleAsync(characterId, ct);
        return Ok(result);
    }
    catch (InvalidOperationException ex)
    {
        return NotFound(new { error = ex.Message });
    }
}

[HttpPost("apply")]
public async Task<ActionResult> ApplySettlement(
    [FromBody] ApplySettlementRequest request,
    CancellationToken ct = default)
{
    try
    {
        await _offline.ApplySettlementAsync(
            request.CharacterId,
            request.Settlement,
            ct);
        return Ok();
    }
    catch (InvalidOperationException ex)
    {
        return NotFound(new { error = ex.Message });
    }
}

public record ApplySettlementRequest(
    Guid CharacterId,
    OfflineFastForwardResult Settlement
);
```

---

### Phase 3: æ´»åŠ¨è®¡åˆ’è‡ªåŠ¨è¡”æ¥å®Œå–„

#### Step 3.1: ä¼˜åŒ– ActivityPlanService

**ä½ç½®**: `BlazorIdle.Server/Application/Activities/ActivityPlanService.cs`

**æ–°å¢/ä¿®æ”¹æ–¹æ³•**:
```csharp
/// <summary>
/// å°è¯•å¯åŠ¨ä¸‹ä¸€ä¸ªå¾…æ‰§è¡Œçš„è®¡åˆ’ï¼ˆå…¬å¼€æ–¹æ³•ï¼Œä¾›ç¦»çº¿ç»“ç®—è°ƒç”¨ï¼‰
/// </summary>
public async Task<ActivityPlan?> TryStartNextPendingPlanAsync(
    Guid characterId,
    CancellationToken ct = default)
{
    // æ£€æŸ¥æ˜¯å¦æœ‰æ­£åœ¨è¿è¡Œçš„è®¡åˆ’
    var runningPlan = await _plans.GetRunningPlanAsync(characterId, ct);
    if (runningPlan is not null)
        return null; // å·²æœ‰è¿è¡Œä¸­çš„è®¡åˆ’
    
    // æŸ¥æ‰¾ä¸‹ä¸€ä¸ªPendingè®¡åˆ’
    var pendingPlans = await _plans.GetByCharacterIdAsync(characterId, ct);
    var nextPlan = pendingPlans
        .Where(p => p.State == ActivityState.Pending)
        .OrderBy(p => p.SlotIndex)
        .ThenBy(p => p.CreatedAt)
        .FirstOrDefault();
    
    if (nextPlan is null)
        return null;
    
    // å¯åŠ¨è®¡åˆ’
    try
    {
        await StartPlanAsync(nextPlan.Id, ct);
        return nextPlan;
    }
    catch (Exception)
    {
        return null;
    }
}
```

---

### Phase 4: å¯é€‰å¢å¼ºåŠŸèƒ½

#### Step 4.1: ç¦»çº¿ç»“ç®—è®°å½•ï¼ˆå®¡è®¡ç”¨ï¼‰

**ä½ç½®**: `BlazorIdle.Server/Domain/Offline/OfflineSettlementRecord.cs`ï¼ˆæ–°å¢ï¼‰

**å®ä½“è®¾è®¡**:
```csharp
public class OfflineSettlementRecord
{
    public Guid Id { get; set; }
    public Guid CharacterId { get; set; }
    public Guid? ActivityPlanId { get; set; }
    public DateTime OfflineStartAt { get; set; }
    public DateTime OfflineEndAt { get; set; }
    public double OfflineSeconds { get; set; }
    public double SimulatedSeconds { get; set; }
    public long GoldEarned { get; set; }
    public long ExpEarned { get; set; }
    public string LootJson { get; set; } = "{}";
    public DateTime SettledAt { get; set; }
}
```

**ç”¨é€”**:
- è®°å½•æ¯æ¬¡ç¦»çº¿ç»“ç®—
- ç”¨äºç©å®¶æŸ¥è¯¢å†å²æ”¶ç›Š
- é˜²ä½œå¼Šå®¡è®¡

---

#### Step 4.2: ç¦»çº¿æ—¶é•¿ä¸Šé™é…ç½®

**ä½ç½®**: `appsettings.json`

**é…ç½®é¡¹**:
```json
{
  "Offline": {
    "MaxOfflineSeconds": 43200,  // 12å°æ—¶
    "EnableAutoSettlement": true,
    "RequireManualConfirm": true  // æ˜¯å¦éœ€è¦å‰ç«¯ç¡®è®¤æ‰å‘æ”¾
  }
}
```

---

## æ•°æ®åº“å˜æ›´

### Migration: æ·»åŠ ç¦»çº¿ç»“ç®—è®°å½•è¡¨ï¼ˆå¯é€‰ï¼‰

**è¿ç§»åç§°**: `AddOfflineSettlementRecords`

**SQL**:
```sql
CREATE TABLE OfflineSettlementRecords (
    Id TEXT PRIMARY KEY,
    CharacterId TEXT NOT NULL,
    ActivityPlanId TEXT,
    OfflineStartAt TEXT NOT NULL,
    OfflineEndAt TEXT NOT NULL,
    OfflineSeconds REAL NOT NULL,
    SimulatedSeconds REAL NOT NULL,
    GoldEarned INTEGER NOT NULL,
    ExpEarned INTEGER NOT NULL,
    LootJson TEXT NOT NULL,
    SettledAt TEXT NOT NULL,
    FOREIGN KEY (CharacterId) REFERENCES Characters(Id)
);

CREATE INDEX IX_OfflineSettlementRecords_CharacterId 
    ON OfflineSettlementRecords(CharacterId);
```

---

## APIè®¾è®¡

### æ–°å¢ç«¯ç‚¹æ±‡æ€»

| ç«¯ç‚¹ | æ–¹æ³• | æè¿° |
|------|------|------|
| `/api/offline/check` | GET | æ£€æŸ¥è§’è‰²æ˜¯å¦æœ‰ç¦»çº¿æ—¶é—´ï¼Œè¿”å›ç»“ç®—é¢„è§ˆ |
| `/api/offline/apply` | POST | åº”ç”¨ç¦»çº¿ç»“ç®—ï¼Œå®é™…å‘æ”¾æ”¶ç›Š |
| `/api/characters/{id}/heartbeat` | POST | æ›´æ–°è§’è‰²å¿ƒè·³ï¼Œè®°å½•åœ¨çº¿æ—¶é—´ |
| `/api/offline/history` | GET | è·å–å†å²ç¦»çº¿ç»“ç®—è®°å½•ï¼ˆå¯é€‰ï¼‰ |

### è¯·æ±‚/å“åº”ç¤ºä¾‹

#### GET /api/offline/check?characterId={id}

**å“åº”**:
```json
{
  "hasOfflineTime": true,
  "offlineSeconds": 7200,
  "hasRunningPlan": true,
  "settlement": {
    "characterId": "xxx",
    "planId": "yyy",
    "simulatedSeconds": 3600,
    "planCompleted": true,
    "totalDamage": 1500000,
    "totalKills": 150,
    "gold": 5000,
    "exp": 8000,
    "loot": {
      "iron_ore": 25.5,
      "health_potion": 3.2
    },
    "updatedExecutedSeconds": 3600
  },
  "planCompleted": true,
  "nextPlanStarted": true,
  "nextPlanId": "zzz"
}
```

#### POST /api/offline/apply

**è¯·æ±‚ä½“**:
```json
{
  "characterId": "xxx",
  "settlement": { /* OfflineFastForwardResult */ }
}
```

**å“åº”**:
```json
{
  "success": true
}
```

---

## å‰ç«¯é›†æˆæ–¹æ¡ˆ

### Step 1: ApiClient æ‰©å±•

**ä½ç½®**: `BlazorIdle/Services/ApiClient.cs`

**æ–°å¢æ–¹æ³•**:
```csharp
// æ£€æŸ¥ç¦»çº¿æ”¶ç›Š
public Task<OfflineCheckResult?> CheckOfflineAsync(
    Guid characterId, 
    CancellationToken ct = default)
{
    SetAuthHeader();
    return _http.GetFromJsonAsync<OfflineCheckResult>(
        $"/api/offline/check?characterId={characterId}", 
        ct);
}

// åº”ç”¨ç¦»çº¿ç»“ç®—
public async Task ApplyOfflineSettlementAsync(
    Guid characterId,
    OfflineFastForwardResult settlement,
    CancellationToken ct = default)
{
    SetAuthHeader();
    var request = new ApplySettlementRequest(characterId, settlement);
    var resp = await _http.PostAsJsonAsync("/api/offline/apply", request, ct);
    resp.EnsureSuccessStatusCode();
}

// æ›´æ–°å¿ƒè·³
public async Task UpdateHeartbeatAsync(
    Guid characterId,
    CancellationToken ct = default)
{
    SetAuthHeader();
    var resp = await _http.PostAsync(
        $"/api/characters/{characterId}/heartbeat", 
        null, 
        ct);
    resp.EnsureSuccessStatusCode();
}
```

---

### Step 2: åˆ›å»ºç¦»çº¿ç»“ç®—å¼¹çª—ç»„ä»¶

**ä½ç½®**: `BlazorIdle/Components/OfflineSettlementDialog.razor`ï¼ˆæ–°å»ºï¼‰

**ç»„ä»¶åŠŸèƒ½**:
1. æ˜¾ç¤ºç¦»çº¿æ—¶é•¿ï¼ˆå¦‚"ç¦»çº¿2å°æ—¶15åˆ†é’Ÿ"ï¼‰
2. å±•ç¤ºæ”¶ç›Šç»Ÿè®¡ï¼š
   - é‡‘å¸: +5000
   - ç»éªŒ: +8000
   - å‡»è´¥æ•Œäºº: 150
3. ç‰©å“æ‰è½åˆ—è¡¨
4. "ç¡®è®¤é¢†å–"æŒ‰é’®
5. å¯é€‰ï¼š"æŸ¥çœ‹è¯¦æƒ…"å±•å¼€æ®µæ‘˜è¦

**ä¼ªä»£ç **:
```razor
@if (showDialog && result != null)
{
    <div class="offline-dialog">
        <h2>æ¬¢è¿å›æ¥ï¼</h2>
        <p>ç¦»çº¿æœŸé—´è·å¾—äº†ä»¥ä¸‹æ”¶ç›Šï¼š</p>
        
        <div class="offline-duration">
            ç¦»çº¿æ—¶é•¿: @FormatDuration(result.OfflineSeconds)
        </div>
        
        <div class="offline-rewards">
            <div>é‡‘å¸: +@result.Settlement.Gold</div>
            <div>ç»éªŒ: +@result.Settlement.Exp</div>
            <div>å‡»æ€: @result.Settlement.TotalKills</div>
        </div>
        
        @if (result.Settlement.Loot.Any())
        {
            <div class="offline-loot">
                <h3>ç‰©å“æ‰è½</h3>
                @foreach (var item in result.Settlement.Loot)
                {
                    <div>@item.Key: @item.Value.ToString("F1")</div>
                }
            </div>
        }
        
        <button @onclick="ClaimRewards">ç¡®è®¤é¢†å–</button>
        
        @if (result.PlanCompleted && result.NextPlanStarted)
        {
            <p class="auto-continue">
                æ´»åŠ¨è®¡åˆ’å·²å®Œæˆï¼Œå·²è‡ªåŠ¨å¼€å§‹ä¸‹ä¸€ä¸ªè®¡åˆ’
            </p>
        }
    </div>
}

@code {
    [Parameter] public OfflineCheckResult? Result { get; set; }
    [Parameter] public EventCallback OnClaimed { get; set; }
    
    private bool showDialog = false;
    
    protected override void OnParametersSet()
    {
        showDialog = Result?.HasOfflineTime == true;
    }
    
    private async Task ClaimRewards()
    {
        // è°ƒç”¨APIåº”ç”¨ç»“ç®—
        await OnClaimed.InvokeAsync();
        showDialog = false;
    }
    
    private string FormatDuration(double seconds)
    {
        var ts = TimeSpan.FromSeconds(seconds);
        return $"{ts.Hours}å°æ—¶{ts.Minutes}åˆ†é’Ÿ";
    }
}
```

---

### Step 3: åœ¨ Characters.razor ä¸­é›†æˆ

**ä½ç½®**: `BlazorIdle/Pages/Characters.razor`

**ä¿®æ”¹è¦ç‚¹**:
```csharp
protected override async Task OnInitializedAsync()
{
    await base.OnInitializedAsync();
    
    // åŠ è½½è§’è‰²åˆ—è¡¨...
    
    // å¦‚æœæœ‰é€‰ä¸­çš„è§’è‰²ï¼Œæ£€æŸ¥ç¦»çº¿æ”¶ç›Š
    if (selectedCharacter != null)
    {
        await CheckOfflineRewardsAsync(selectedCharacter.Id);
    }
}

private async Task CheckOfflineRewardsAsync(Guid characterId)
{
    try
    {
        // 1. æ›´æ–°å¿ƒè·³
        await apiClient.UpdateHeartbeatAsync(characterId);
        
        // 2. æ£€æŸ¥ç¦»çº¿æ”¶ç›Š
        var offlineResult = await apiClient.CheckOfflineAsync(characterId);
        
        if (offlineResult?.HasOfflineTime == true && 
            offlineResult.Settlement != null)
        {
            // 3. æ˜¾ç¤ºç¦»çº¿ç»“ç®—å¼¹çª—
            showOfflineDialog = true;
            offlineCheckResult = offlineResult;
        }
    }
    catch (Exception ex)
    {
        Console.WriteLine($"ç¦»çº¿æ£€æŸ¥å¤±è´¥: {ex.Message}");
    }
}

private async Task ApplyOfflineSettlement()
{
    if (offlineCheckResult?.Settlement == null)
        return;
    
    try
    {
        // åº”ç”¨ç¦»çº¿ç»“ç®—
        await apiClient.ApplyOfflineSettlementAsync(
            selectedCharacter.Id,
            offlineCheckResult.Settlement
        );
        
        // åˆ·æ–°è§’è‰²æ•°æ®
        await RefreshCharacterAsync();
        
        showOfflineDialog = false;
    }
    catch (Exception ex)
    {
        errorMessage = $"é¢†å–å¤±è´¥: {ex.Message}";
    }
}
```

---

## æµ‹è¯•éªŒè¯è®¡åˆ’

### å•å…ƒæµ‹è¯•

#### 1. OfflineFastForwardEngine æµ‹è¯•
- âœ… æµ‹è¯•ç¦»çº¿æ—¶é•¿ä¸Šé™ï¼ˆ12å°æ—¶ï¼‰
- âœ… æµ‹è¯•è®¡åˆ’å‰©ä½™æ—¶é•¿è®¡ç®—ï¼ˆDuration vs Infiniteï¼‰
- âœ… æµ‹è¯•å¿«è¿›æ¨¡æ‹Ÿç»“æœèšåˆ
- âœ… æµ‹è¯•è®¡åˆ’å®ŒæˆçŠ¶æ€åˆ¤æ–­

#### 2. OfflineSettlementService æµ‹è¯•
- âœ… æµ‹è¯•æ— ç¦»çº¿æ—¶é—´åœºæ™¯
- âœ… æµ‹è¯•æœ‰ç¦»çº¿æ—¶é—´ä½†æ— è¿è¡Œè®¡åˆ’
- âœ… æµ‹è¯•æœ‰ç¦»çº¿æ—¶é—´ä¸”æœ‰è¿è¡Œè®¡åˆ’
- âœ… æµ‹è¯•è®¡åˆ’å®Œæˆåè‡ªåŠ¨è¡”æ¥
- âœ… æµ‹è¯•æ”¶ç›Šåº”ç”¨é€»è¾‘

#### 3. ActivityPlanService æµ‹è¯•
- âœ… æµ‹è¯•è‡ªåŠ¨è¡”æ¥é€»è¾‘
- âœ… æµ‹è¯•å¤šä¸ªPendingè®¡åˆ’çš„ä¼˜å…ˆçº§

### é›†æˆæµ‹è¯•

#### åœºæ™¯1: åŸºç¡€ç¦»çº¿æµç¨‹
1. åˆ›å»ºè§’è‰²
2. åˆ›å»º1å°æ—¶æˆ˜æ–—è®¡åˆ’
3. å¯åŠ¨è®¡åˆ’
4. æ¨¡æ‹Ÿç¦»çº¿2å°æ—¶ï¼ˆä¿®æ”¹LastSeenAtUtcï¼‰
5. è°ƒç”¨ç¦»çº¿æ£€æŸ¥API
6. éªŒè¯è¿”å›ç»“æœï¼ˆåº”è¯¥åªè®¡ç®—1å°æ—¶ï¼Œå› ä¸ºè®¡åˆ’å·²å®Œæˆï¼‰
7. åº”ç”¨ç¦»çº¿ç»“ç®—
8. éªŒè¯è§’è‰²é‡‘å¸ã€ç»éªŒå¢åŠ 

#### åœºæ™¯2: è®¡åˆ’æœªå®Œæˆç»§ç»­æ‰§è¡Œ
1. åˆ›å»ºè§’è‰²
2. åˆ›å»º3å°æ—¶æˆ˜æ–—è®¡åˆ’
3. å¯åŠ¨è®¡åˆ’ï¼ˆå·²æ‰§è¡Œ0.5å°æ—¶ï¼‰
4. æ¨¡æ‹Ÿç¦»çº¿1å°æ—¶
5. è°ƒç”¨ç¦»çº¿æ£€æŸ¥API
6. éªŒè¯ï¼šExecutedSeconds = 1.5å°æ—¶ï¼Œè®¡åˆ’ä»Running

#### åœºæ™¯3: è‡ªåŠ¨è¡”æ¥ä¸‹ä¸€ä¸ªè®¡åˆ’
1. åˆ›å»ºè§’è‰²
2. åˆ›å»ºä¸¤ä¸ªè®¡åˆ’ï¼š
   - Plan1: 1å°æ—¶æˆ˜æ–—ï¼ˆSlot 0ï¼‰
   - Plan2: 2å°æ—¶æˆ˜æ–—ï¼ˆSlot 1ï¼ŒPendingï¼‰
3. å¯åŠ¨Plan1
4. æ¨¡æ‹Ÿç¦»çº¿2å°æ—¶
5. è°ƒç”¨ç¦»çº¿æ£€æŸ¥API
6. éªŒè¯ï¼š
   - Plan1å·²å®Œæˆ
   - Plan2å·²è‡ªåŠ¨å¯åŠ¨
   - è¿”å›ç»“æœåŒ…å«NextPlanStarted=true

### æ‰‹åŠ¨æµ‹è¯•

#### å‰ç«¯é›†æˆæµ‹è¯•
1. ç™»å½•æ¸¸æˆ
2. åˆ›å»ºè§’è‰²å’Œæˆ˜æ–—è®¡åˆ’
3. å…³é—­æµè§ˆå™¨
4. ç­‰å¾…5åˆ†é’Ÿ
5. é‡æ–°ç™»å½•
6. éªŒè¯ï¼š
   - æ˜¾ç¤ºç¦»çº¿ç»“ç®—å¼¹çª—
   - æ”¶ç›Šæ•°æ®æ­£ç¡®
   - ç‚¹å‡»"ç¡®è®¤é¢†å–"åè§’è‰²æ•°æ®æ›´æ–°

---

## é£é™©ä¸æ³¨æ„äº‹é¡¹

### é«˜é£é™©é¡¹

#### 1. æ—¶é—´åŒæ­¥é—®é¢˜
**é£é™©**: æœåŠ¡å™¨æ—¶é—´ä¸å®¢æˆ·ç«¯æ—¶é—´ä¸ä¸€è‡´å¯èƒ½å¯¼è‡´è®¡ç®—é”™è¯¯
**ç¼“è§£**:
- æ‰€æœ‰æ—¶é—´æˆ³ä½¿ç”¨UTC
- æœåŠ¡ç«¯æƒå¨ï¼ˆä¸ä¿¡ä»»å®¢æˆ·ç«¯æ—¶é—´ï¼‰

#### 2. å¹¶å‘é—®é¢˜
**é£é™©**: ç”¨æˆ·å¿«é€Ÿå¤šæ¬¡è°ƒç”¨ç¦»çº¿æ£€æŸ¥APIå¯èƒ½å¯¼è‡´é‡å¤å‘æ”¾
**ç¼“è§£**:
- ä½¿ç”¨äº‹åŠ¡ä¿è¯åŸå­æ€§
- æ·»åŠ åˆ†å¸ƒå¼é”ï¼ˆå¦‚æœå¤šå®ä¾‹éƒ¨ç½²ï¼‰
- æ£€æŸ¥`LastOfflineSettledAtUtc`é˜²æ­¢çŸ­æ—¶é—´å†…é‡å¤ç»“ç®—

#### 3. æ€§èƒ½é—®é¢˜
**é£é™©**: 12å°æ—¶çš„å¿«è¿›æ¨¡æ‹Ÿå¯èƒ½è€—æ—¶è¾ƒé•¿
**ç¼“è§£**:
- ä½¿ç”¨`BattleSimulator`çš„å¿«è¿›åŠŸèƒ½ï¼ˆå·²ä¼˜åŒ–ï¼‰
- è®¾ç½®åˆç†çš„è¶…æ—¶æ—¶é—´
- è€ƒè™‘å¼‚æ­¥å¤„ç†ï¼ˆå¤æ‚åœºæ™¯ï¼‰

### ä¸­é£é™©é¡¹

#### 4. æ•°æ®ä¸€è‡´æ€§
**é£é™©**: ç¦»çº¿ç»“ç®—è¿‡ç¨‹ä¸­è§’è‰²æ•°æ®è¢«å…¶ä»–æ“ä½œä¿®æ”¹
**ç¼“è§£**:
- ä½¿ç”¨æ•°æ®åº“äº‹åŠ¡
- ä¹è§‚é”æˆ–ç‰ˆæœ¬å·æœºåˆ¶

#### 5. æ¸¸æˆå¹³è¡¡
**é£é™©**: ç¦»çº¿æ”¶ç›Šè¿‡é«˜å¯èƒ½å¯¼è‡´ç©å®¶ä¸åœ¨çº¿ä¹Ÿèƒ½å¿«é€Ÿå‡çº§
**ç¼“è§£**:
- 12å°æ—¶ä¸Šé™é™åˆ¶
- å¯é…ç½®çš„æ”¶ç›Šè¡°å‡ç³»æ•°ï¼ˆæœªæ¥æ‰©å±•ï¼‰

### ä½é£é™©é¡¹

#### 6. UI/UX ä½“éªŒ
**é£é™©**: ç¦»çº¿å¼¹çª—å¯èƒ½æ‰“æ–­ç”¨æˆ·æ“ä½œ
**ç¼“è§£**:
- å…è®¸ç”¨æˆ·å…³é—­å¼¹çª—ç¨åæŸ¥çœ‹
- æä¾›"ä¸å†æç¤º"é€‰é¡¹

---

## å®æ–½ä¼˜å…ˆçº§å»ºè®®

### Phase 1 (æ ¸å¿ƒåŠŸèƒ½ï¼Œå¿…é¡»å®ç°)
1. âœ… `OfflineFastForwardEngine` å®ç°
2. âœ… `OfflineSettlementService.CheckAndSettleAsync` å®ç°
3. âœ… `GET /api/offline/check` ç«¯ç‚¹
4. âœ… `POST /api/offline/apply` ç«¯ç‚¹
5. âœ… å‰ç«¯ç¦»çº¿ç»“ç®—å¼¹çª—ç»„ä»¶
6. âœ… Characters.razor é›†æˆç¦»çº¿æ£€æŸ¥é€»è¾‘

### Phase 2 (å¢å¼ºåŠŸèƒ½ï¼Œæ¨èå®ç°)
7. âœ… å¿ƒè·³æœºåˆ¶ï¼ˆ`POST /api/characters/{id}/heartbeat`ï¼‰
8. âœ… æ´»åŠ¨è®¡åˆ’è‡ªåŠ¨è¡”æ¥å®Œå–„
9. âœ… ç¦»çº¿æ—¶é•¿ä¸Šé™é…ç½®

### Phase 3 (å¯é€‰åŠŸèƒ½ï¼Œåç»­æ‰©å±•)
10. â­• ç¦»çº¿ç»“ç®—è®°å½•è¡¨ï¼ˆå®¡è®¡ç”¨ï¼‰
11. â­• å†å²ç»“ç®—è®°å½•æŸ¥è¯¢API
12. â­• ç¦»çº¿æ®µæ‘˜è¦è¯¦ç»†æŸ¥çœ‹
13. â­• æ”¶ç›Šè¡°å‡æœºåˆ¶ï¼ˆé˜²æ­¢è¿‡åº¦æŒ‚æœºï¼‰

---

## æ€»ç»“

æœ¬å®æ–½æ–¹æ¡ˆåŸºäºç°æœ‰ä»£ç ï¼ˆ`ActivityPlan`ã€`BattleSimulator`ã€`OfflineSettlementService`ï¼‰æä¾›äº†å®Œæ•´çš„ç¦»çº¿æˆ˜æ–—ç³»ç»Ÿè®¾è®¡ã€‚

### æ ¸å¿ƒå®ç°è·¯å¾„ï¼š
1. **æ–°å¢** `OfflineFastForwardEngine` å°è£…ç¦»çº¿å¿«è¿›é€»è¾‘
2. **æ‰©å±•** `OfflineSettlementService` æ”¯æŒç™»å½•æ—¶è‡ªåŠ¨ç»“ç®—
3. **æ–°å¢** ç¦»çº¿æ£€æŸ¥ä¸åº”ç”¨APIç«¯ç‚¹
4. **å®Œå–„** æ´»åŠ¨è®¡åˆ’è‡ªåŠ¨è¡”æ¥æœºåˆ¶
5. **æ–°å»º** å‰ç«¯ç¦»çº¿ç»“ç®—å¼¹çª—ç»„ä»¶

### å…³é”®è®¾è®¡åŸåˆ™ï¼š
- âœ… å¤ç”¨ç°æœ‰çš„äº‹ä»¶è°ƒåº¦ä¸æˆ˜æ–—æ¨¡æ‹Ÿç³»ç»Ÿ
- âœ… ä¿æŒåœ¨çº¿/ç¦»çº¿é€»è¾‘ä¸€è‡´æ€§
- âœ… æ”¯æŒæ´»åŠ¨è®¡åˆ’çš„çŠ¶æ€æ¢å¤ä¸è‡ªåŠ¨è¡”æ¥
- âœ… ä¸¤é˜¶æ®µæäº¤æ¨¡å¼ï¼ˆé¢„è§ˆâ†’ç¡®è®¤â†’å‘æ”¾ï¼‰
- âœ… ç¦»çº¿æ—¶é•¿ä¸Šé™ä¿æŠ¤æ¸¸æˆå¹³è¡¡

### é¢„ä¼°å·¥ä½œé‡ï¼š
- **åç«¯æ ¸å¿ƒåŠŸèƒ½**: 2-3å¤©
- **å‰ç«¯é›†æˆ**: 1-2å¤©
- **æµ‹è¯•ä¸è°ƒä¼˜**: 1-2å¤©
- **æ€»è®¡**: 4-7å¤©

---

**æ–‡æ¡£ç»“æŸ**
