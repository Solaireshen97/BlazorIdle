# BlazorIdle 渐进式重构方案（中篇）：实施步骤与路线图

**文档版本**: 1.0  
**生成日期**: 2025年10月  
**状态**: 规划文档  
**目标**: 制定从基础版本出发的渐进式实施路线图

---

## 📋 目录

1. [总体实施策略](#总体实施策略)
2. [阶段划分与时间规划](#阶段划分与时间规划)
3. [Step 1: 数据访问层重构](#step-1-数据访问层重构)
4. [Step 2: 缓存系统完善](#step-2-缓存系统完善)
5. [Step 3: SignalR架构重构](#step-3-signalr架构重构)
6. [Step 4: 配置管理系统](#step-4-配置管理系统)
7. [Step 5: 事件溯源与快照](#step-5-事件溯源与快照)
8. [Step 6: 领域事件总线](#step-6-领域事件总线)
9. [Step 7: 监控与诊断](#step-7-监控与诊断)
10. [里程碑与验收标准](#里程碑与验收标准)

---

## 总体实施策略

### 核心理念

```
🎯 稳定基础优先
   先建立稳定的基础设施，再添加功能

🎯 渐进式推进
   每个步骤独立可测试，可回滚

🎯 保持系统可用
   新旧系统并行，平滑切换

🎯 最小化影响
   优先重构基础设施，不改动核心战斗逻辑
```

---

### 实施原则

#### 1. 从基础版本概念出发
```
起点：
✅ 核心战斗引擎完整（EventScheduler, TrackState）
✅ 基础资源与技能系统
✅ 简单的数据库访问
✅ 基础的前端展示

不包含：
❌ 复杂的装备系统
❌ 离线收益
❌ 活动计划
❌ 复杂的 SignalR 推送
```

---

#### 2. 分层重构
```
Layer 1: 持久化层（数据库访问）
Layer 2: 缓存层
Layer 3: 通信层（SignalR）
Layer 4: 配置层
Layer 5: 事件溯源层
Layer 6: 应用层集成
```

---

#### 3. 验证优先
```
每完成一个步骤：
✅ 单元测试通过
✅ 集成测试通过
✅ 性能测试通过
✅ 文档更新完成
```

---

## 阶段划分与时间规划

### 总览

```
Step 0: 准备工作                    [1周]
Step 1: 数据访问层重构              [2-3周]
Step 2: 缓存系统完善                [1-2周]
Step 3: SignalR架构重构             [2-3周]
Step 4: 配置管理系统                [1-2周]
Step 5: 事件溯源与快照              [2周]
Step 6: 领域事件总线                [1周]
Step 7: 监控与诊断                  [1周]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
总计：                              [11-16周，约3-4个月]
```

---

### 甘特图

```
阶段                     周
                    1  2  3  4  5  6  7  8  9  10 11 12 13 14 15 16
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Step 0  准备        █░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
Step 1  数据层      ░███░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
Step 2  缓存        ░░░░██░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
Step 3  SignalR     ░░░░░░███░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
Step 4  配置        ░░░░░░░░░██░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
Step 5  事件溯源    ░░░░░░░░░░░██░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
Step 6  事件总线    ░░░░░░░░░░░░░█░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
Step 7  监控        ░░░░░░░░░░░░░░█░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
                        └─────────────┘
                        核心基础设施 (3-4个月)
```

---

## Step 0: 准备工作

### 目标
建立重构的基础环境和工具链

### 时间
**1周**

---

### 任务清单

#### 0.1 代码审计与分析
```
📋 完整的代码库审查
📋 识别所有 DbContext 使用点
📋 识别所有 SignalR Hub 调用点
📋 识别配置读取位置
📋 生成依赖关系图
```

#### 0.2 测试基础设施
```
📋 建立单元测试框架（如 xUnit）
📋 建立集成测试框架
📋 建立性能测试基准
📋 配置 CI/CD 流水线
```

#### 0.3 文档准备
```
📋 建立重构日志模板
📋 准备技术决策记录（ADR）模板
📋 准备测试用例模板
📋 建立知识库结构
```

#### 0.4 分支策略
```
📋 创建 refactor/infrastructure 主分支
📋 为每个 Step 创建子分支
📋 设置代码审查流程
📋 配置分支保护规则
```

---

### 交付物
```
✅ 代码分析报告
✅ 测试框架就绪
✅ 文档模板就绪
✅ Git 分支结构完成
```

---

## Step 1: 数据访问层重构

### 目标
建立统一的数据访问抽象，解耦业务逻辑与数据库

### 时间
**2-3周**

---

### 核心组件

#### 1.1 Repository 模式
**文件**: `Infrastructure/Persistence/IRepository.cs`

**接口定义**（概念示例）:
```csharp
// 不包含具体代码，仅说明方向
interface IRepository<T>
{
    Task<T> GetByIdAsync(id);
    Task<IEnumerable<T>> GetAllAsync();
    Task AddAsync(T entity);
    Task UpdateAsync(T entity);
    Task DeleteAsync(id);
    IQueryable<T> Query(); // 支持复杂查询
}
```

**职责**:
- 封装 DbContext 操作
- 提供通用 CRUD 接口
- 支持查询构建
- 异步操作支持

---

#### 1.2 Unit of Work 模式
**文件**: `Infrastructure/Persistence/IUnitOfWork.cs`

**接口定义**（概念示例）:
```csharp
interface IUnitOfWork
{
    IRepository<Character> Characters { get; }
    IRepository<Battle> Battles { get; }
    IRepository<Equipment> Equipments { get; }
    // ... 其他仓储
    
    Task<int> SaveChangesAsync();
    Task BeginTransactionAsync();
    Task CommitTransactionAsync();
    Task RollbackTransactionAsync();
}
```

**职责**:
- 管理事务边界
- 协调多个仓储
- 保证数据一致性

---

#### 1.3 查询服务（读写分离）
**文件**: `Infrastructure/Persistence/IQueryService.cs`

**方向**:
- 分离读操作（Query）与写操作（Command）
- 读操作可使用只读 DbContext
- 优化查询性能
- 支持复杂查询（Specification Pattern）

---

### 实施步骤

#### 阶段 1.1：抽象层建立（第1周）
```
📋 定义 IRepository<T> 接口
📋 定义 IUnitOfWork 接口
📋 定义 IQueryService 接口
📋 编写接口文档和使用说明
```

#### 阶段 1.2：实现基础功能（第1周）
```
📋 实现 Repository<T> 基类
📋 实现 UnitOfWork 类
📋 实现 QueryService 类
📋 配置依赖注入
```

#### 阶段 1.3：迁移现有代码（第2周）
```
📋 迁移 Character 相关操作
📋 迁移 Battle 相关操作
📋 迁移 Equipment 相关操作
📋 迁移 User 相关操作
```

#### 阶段 1.4：测试与优化（第2周）
```
📋 编写单元测试（覆盖率 > 80%）
📋 编写集成测试
📋 性能基准测试
📋 优化查询（解决 N+1 问题）
```

---

### 验收标准
```
✅ 所有 DbContext 直接使用已移除
✅ 单元测试覆盖率 > 80%
✅ 集成测试全部通过
✅ 性能无退化（查询时间 < 基准值）
✅ 文档完整
```

---

## Step 2: 缓存系统完善

### 目标
建立多层缓存架构，减少数据库压力，提升响应速度

### 时间
**1-2周**

---

### 核心组件

#### 2.1 缓存抽象层
**文件**: `Infrastructure/Caching/ICacheService.cs`

**接口定义**（概念示例）:
```csharp
interface ICacheService
{
    Task<T> GetAsync<T>(string key);
    Task SetAsync<T>(string key, T value, TimeSpan? expiry);
    Task RemoveAsync(string key);
    Task<bool> ExistsAsync(string key);
    Task InvalidateByPatternAsync(string pattern);
}
```

---

#### 2.2 多层缓存实现

##### L1 缓存：内存缓存（进程内）
**实现**: `MemoryCacheService`
- 使用 IMemoryCache
- 快速访问
- 进程重启失效
- 适合：热点数据、配置数据

##### L2 缓存：分布式缓存（可选）
**实现**: `DistributedCacheService`
- 使用 IDistributedCache（Redis 等）
- 跨进程共享
- 持久化可选
- 适合：用户会话、跨服务数据

---

#### 2.3 缓存策略

##### 失效策略
```
⏰ 时间过期（TTL）
   - 配置数据：长期（1小时+）
   - 用户数据：中期（15分钟）
   - 战斗数据：短期（5分钟）

🔗 依赖失效
   - 配置更新 → 失效所有相关缓存
   - 用户数据变更 → 失效用户相关缓存
   - 装备变更 → 失效角色缓存
```

##### 缓存预热
```
🔥 启动预热
   - 加载技能配置
   - 加载装备定义
   - 加载敌人数据
   - 加载常用查询结果
```

##### 防穿透/击穿/雪崩
```
🛡️ 布隆过滤器（防穿透）
🛡️ 互斥锁（防击穿）
🛡️ 随机过期时间（防雪崩）
```

---

### 实施步骤

#### 阶段 2.1：抽象层与 L1 缓存（第1周）
```
📋 定义 ICacheService 接口
📋 实现 MemoryCacheService
📋 配置依赖注入
📋 编写单元测试
```

#### 阶段 2.2：缓存策略实施（第1周）
```
📋 实现失效机制
📋 实现预热服务
📋 实现防穿透机制
📋 集成到现有服务
```

#### 阶段 2.3：应用到关键路径（第2周）
```
📋 缓存技能配置
📋 缓存装备定义
📋 缓存敌人数据
📋 缓存角色基础信息
```

#### 阶段 2.4：监控与优化（第2周）
```
📋 添加缓存命中率统计
📋 添加失效日志
📋 性能测试
📋 调优参数（TTL、大小限制）
```

---

### 验收标准
```
✅ 缓存抽象层完成
✅ L1 内存缓存运行稳定
✅ 配置数据 100% 缓存
✅ 缓存命中率 > 80%
✅ 响应时间下降 > 30%
✅ 监控指标可查看
```

---

## Step 3: SignalR架构重构

### 目标
建立清晰的消息推送架构，统一 SignalR 使用方式

### 时间
**2-3周**

---

### 核心组件

#### 3.1 消息分发器
**文件**: `Infrastructure/SignalR/IMessageDispatcher.cs`

**职责**:
- 统一消息推送入口
- 支持单播、广播、组播
- 批量推送优化
- 消息队列缓冲

**接口概念**:
```csharp
interface IMessageDispatcher
{
    Task SendToUserAsync(userId, message);
    Task SendToGroupAsync(groupId, message);
    Task BroadcastAsync(message);
    Task SendBatchAsync(userIds, message);
}
```

---

#### 3.2 连接管理器
**文件**: `Infrastructure/SignalR/ConnectionManager.cs`

**职责**:
- 管理用户连接
- 用户 ID 与 ConnectionId 映射
- 连接生命周期事件
- 重连处理

---

#### 3.3 订阅注册表
**文件**: `Infrastructure/SignalR/SubscriptionRegistry.cs`

**职责**:
- 管理用户订阅关系
- 自动加入/离开组
- 权限验证
- 订阅状态持久化（可选）

---

### 消息类型定义

#### 战斗相关
```
📨 BattleStarted - 战斗开始
📨 BattleProgress - 战斗进度更新
📨 BattleSegment - 战斗片段完成
📨 BattleEnded - 战斗结束
```

#### 角色相关
```
📨 CharacterUpdated - 角色数据更新
📨 EquipmentChanged - 装备变更
📨 LevelUp - 升级
📨 StatsChanged - 属性变更
```

#### 系统相关
```
📨 ConfigUpdated - 配置更新
📨 MaintenanceNotice - 维护通知
📨 SystemMessage - 系统消息
```

---

### 实施步骤

#### 阶段 3.1：架构设计与抽象（第1周）
```
📋 定义 IMessageDispatcher 接口
📋 定义消息类型体系
📋 设计连接管理机制
📋 设计订阅模式
```

#### 阶段 3.2：核心组件实现（第1周）
```
📋 实现 MessageDispatcher
📋 实现 ConnectionManager
📋 实现 SubscriptionRegistry
📋 集成到 Hub
```

#### 阶段 3.3：迁移现有推送（第2周）
```
📋 迁移战斗相关推送
📋 迁移角色相关推送
📋 迁移系统通知
📋 清理旧代码
```

#### 阶段 3.4：优化与测试（第2周）
```
📋 批量推送优化
📋 重连机制测试
📋 压力测试（模拟 100+ 连接）
📋 文档完善
```

---

### 验收标准
```
✅ Hub 职责清晰，不含业务逻辑
✅ 消息推送统一通过 Dispatcher
✅ 连接管理稳定，支持重连
✅ 订阅机制工作正常
✅ 压力测试通过（100 并发连接）
✅ 前端集成无问题
```

---

## Step 4: 配置管理系统

### 目标
实现数据驱动，支持配置热更新和版本化

### 时间
**1-2周**

---

### 核心组件

#### 4.1 配置存储
**文件**: `Infrastructure/Configuration/IConfigStore.cs`

**职责**:
- 加载配置文件（JSON/DB）
- 配置版本管理
- 配置缓存
- 热更新通知

---

#### 4.2 配置类型

##### 技能配置
```json
{
  "skillId": "warrior_charge",
  "name": "冲锋",
  "cooldown": 10,
  "resourceCost": {"rage": 20},
  "damage": {"base": 100, "apRatio": 1.5}
}
```

##### 装备配置
```json
{
  "itemId": "sword_001",
  "name": "铁剑",
  "tier": "T1",
  "stats": {"attack": 10, "critChance": 0.05}
}
```

##### 敌人配置
```json
{
  "enemyId": "goblin",
  "name": "哥布林",
  "level": 1,
  "hp": 100,
  "attack": 10,
  "loot": [...]
}
```

---

#### 4.3 配置验证
**文件**: `Infrastructure/Configuration/ConfigValidator.cs`

**验证项**:
- 必填字段检查
- 数值范围验证
- 引用完整性（ID 存在性）
- 循环依赖检测
- 数据一致性

---

### 实施步骤

#### 阶段 4.1：配置框架搭建（第1周）
```
📋 定义 IConfigStore 接口
📋 实现 JSON 配置加载器
📋 实现配置缓存
📋 实现热更新机制
```

#### 阶段 4.2：配置验证器（第1周）
```
📋 实现 ConfigValidator
📋 添加验证规则
📋 集成到加载流程
📋 错误报告机制
```

#### 阶段 4.3：迁移现有配置（第2周）
```
📋 迁移技能配置
📋 迁移装备配置
📋 迁移敌人配置
📋 移除硬编码数据
```

#### 阶段 4.4：热更新测试（第2周）
```
📋 测试配置更新流程
📋 测试版本回滚
📋 测试配置验证
📋 文档与示例
```

---

### 验收标准
```
✅ 配置统一存储在 JSON 文件
✅ 配置加载与缓存正常
✅ 热更新机制工作（无需重启）
✅ 配置验证捕获错误
✅ 文档完整，包含配置示例
```

---

## Step 5: 事件溯源与快照

### 目标
实现事件存储，支持离线收益和数据回溯

### 时间
**2周**

---

### 核心概念

#### 事件溯源（Event Sourcing）
```
理念：存储状态变化（事件），而非最终状态

优点：
✅ 完整的审计日志
✅ 可重放和回溯
✅ 支持离线收益计算
✅ 数据不丢失
```

---

#### 快照（Snapshot）
```
理念：定期保存完整状态，减少重放成本

策略：
⏰ 定时快照（每 N 分钟）
📊 阈值快照（事件数 > N）
🎯 关键点快照（战斗结束、升级）
```

---

### 核心组件

#### 5.1 事件存储
**文件**: `Infrastructure/EventSourcing/IEventStore.cs`

**接口概念**:
```csharp
interface IEventStore
{
    Task AppendAsync(DomainEvent event);
    Task<IEnumerable<DomainEvent>> GetEventsAsync(entityId, fromVersion);
    Task<Snapshot> GetLatestSnapshotAsync(entityId);
    Task SaveSnapshotAsync(Snapshot snapshot);
}
```

---

#### 5.2 领域事件定义

##### 战斗事件
```
- BattleStartedEvent
- AttackHitEvent
- SkillCastEvent
- BuffAppliedEvent
- EnemyDefeatedEvent
- BattleEndedEvent
```

##### 角色事件
```
- CharacterCreatedEvent
- ExperienceGainedEvent
- LevelUpEvent
- EquipmentChangedEvent
- StatsChangedEvent
```

---

### 实施步骤

#### 阶段 5.1：事件基础设施（第1周）
```
📋 定义 DomainEvent 基类
📋 实现 IEventStore 接口
📋 实现事件序列化
📋 数据库表设计与迁移
```

#### 阶段 5.2：快照机制（第1周）
```
📋 定义 Snapshot 结构
📋 实现快照保存逻辑
📋 实现快照加载逻辑
📋 定义快照策略
```

#### 阶段 5.3：集成到战斗系统（第2周）
```
📋 战斗事件记录
📋 战斗快照生成
📋 战斗状态恢复
📋 测试事件重放
```

#### 阶段 5.4：验证与优化（第2周）
```
📋 重放准确性验证
📋 性能测试（大量事件）
📋 存储优化（压缩、归档）
📋 文档与示例
```

---

### 验收标准
```
✅ 事件存储功能完整
✅ 快照机制工作正常
✅ 战斗事件完整记录
✅ 状态重放准确性 100%
✅ 为离线收益打下基础
```

---

## Step 6: 领域事件总线

### 目标
解耦模块间通信，实现异步事件处理

### 时间
**1周**

---

### 核心组件

#### 6.1 事件总线
**文件**: `Infrastructure/Events/IDomainEventBus.cs`

**接口概念**:
```csharp
interface IDomainEventBus
{
    Task PublishAsync<TEvent>(TEvent domainEvent);
    void Subscribe<TEvent>(IEventHandler<TEvent> handler);
}
```

---

#### 6.2 事件处理器
**接口概念**:
```csharp
interface IEventHandler<TEvent>
{
    Task HandleAsync(TEvent domainEvent);
}
```

---

### 应用场景

#### 战斗结束后
```
发布: BattleEndedEvent
处理器:
  → 经验结算处理器
  → 掉落物品处理器
  → 任务进度处理器
  → 成就检查处理器
```

#### 角色升级后
```
发布: LevelUpEvent
处理器:
  → 属性重算处理器
  → 新技能解锁处理器
  → 前端通知处理器
```

---

### 实施步骤

#### 阶段 6.1：事件总线实现（3天）
```
📋 实现 DomainEventBus
📋 实现事件分发机制
📋 支持多个处理器
📋 异步处理支持
```

#### 阶段 6.2：集成到现有模块（2天）
```
📋 集成到战斗系统
📋 集成到角色系统
📋 集成到装备系统
📋 移除直接调用
```

#### 阶段 6.3：测试与文档（2天）
```
📋 单元测试
📋 集成测试
📋 性能测试
📋 使用文档
```

---

### 验收标准
```
✅ 事件总线功能完整
✅ 多处理器正常工作
✅ 异步处理稳定
✅ 模块解耦明显
```

---

## Step 7: 监控与诊断

### 目标
建立监控体系，便于性能分析和问题定位

### 时间
**1周**

---

### 核心组件

#### 7.1 指标收集
**文件**: `Infrastructure/Monitoring/IMetricsCollector.cs`

**指标类型**:
```
📊 业务指标
   - 战斗次数
   - 掉落物品统计
   - 经济流入流出

📊 性能指标
   - API 响应时间
   - 数据库查询时间
   - 缓存命中率

📊 系统指标
   - 内存使用
   - CPU 占用
   - 活跃连接数
```

---

#### 7.2 健康检查
**文件**: `Infrastructure/Monitoring/HealthCheckService.cs`

**检查项**:
```
✅ 数据库连接
✅ 缓存服务
✅ SignalR Hub
✅ 配置加载
```

---

### 实施步骤

#### 阶段 7.1：监控基础（3天）
```
📋 实现 IMetricsCollector
📋 集成到关键路径
📋 实现 HealthCheck
📋 暴露监控端点
```

#### 阶段 7.2：可视化（2天）
```
📋 添加监控页面
📋 实时指标展示
📋 历史数据图表
📋 告警规则（可选）
```

#### 阶段 7.3：文档与部署（2天）
```
📋 监控使用文档
📋 告警配置文档
📋 运维手册
📋 部署指南
```

---

### 验收标准
```
✅ 核心指标可采集
✅ 健康检查正常
✅ 监控页面可访问
✅ 文档完整
```

---

## 里程碑与验收标准

### Milestone 1: 基础设施稳定（第7周）
```
✅ 数据访问层统一（Repository + UnitOfWork）
✅ 缓存系统完善（多层缓存 + 预热）
✅ SignalR 架构清晰（Dispatcher + Manager）

验收：
- 所有单元测试通过
- 集成测试通过
- 性能基准测试通过
- 文档完整
```

---

### Milestone 2: 核心能力增强（第11周）
```
✅ 配置管理系统可用（热更新 + 验证）
✅ 事件溯源基础完成（Event Store + Snapshot）
✅ 领域事件总线运行（解耦模块）

验收：
- 配置热更新无需重启
- 事件重放准确性 100%
- 模块解耦，可独立测试
```

---

### Milestone 3: 监控就绪（第12周）
```
✅ 监控系统上线（指标收集 + 健康检查）
✅ 可视化页面可用
✅ 运维文档齐全

验收：
- 核心指标可查看
- 健康检查正常
- 运维手册完整
```

---

## 下一步

完成上述基础设施重构后，项目将具备：
```
✅ 稳定的数据访问层
✅ 高效的缓存系统
✅ 清晰的 SignalR 架构
✅ 灵活的配置管理
✅ 完整的事件溯源
✅ 可扩展的事件总线
✅ 完善的监控体系
```

详见**下篇文档**，将制定功能完善与集成策略。

---

**文档完成时间**: 2025年10月  
**建议阅读**: 继续阅读《渐进式重构方案（下）》了解功能实施计划
