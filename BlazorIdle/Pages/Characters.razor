@page "/"
@using BlazorIdle.Services
@using BlazorIdle.Shared.Models
@using BlazorIdle.Client.Services
@using BlazorIdle.Components
@inject ApiClient Api
@inject AuthService AuthService
@inject NavigationManager Navigation
@inject IJSRuntime JS
@implements IDisposable

<!-- 离线结算弹窗 -->
<OfflineSettlementDialog Result="@offlineCheckResult" OnClaim="@CloseOfflineSettlement" />

@if (!isAuthenticated)
{
    <p>正在检查登录状态...</p>
}
else
{
<h3>角色 & 战斗测试</h3>

<!-- 用户信息显示 -->
@if (currentUser is not null)
{
    <div class="panel" style="background: #f8f9fa; padding: 12px; margin-bottom: 12px;">
        <h5>👤 当前用户: @currentUser.Username</h5>
        <p style="margin: 4px 0;">角色数量: @userCharacters.Count / 5</p>
        @if (!string.IsNullOrEmpty(userMessage))
        {
            <div class="alert alert-info" style="margin: 8px 0;">@userMessage</div>
        }
    </div>
}

<!-- 0) 角色列表 -->
@if (userCharacters.Count > 0)
{
    <div class="panel">
        <h4>我的角色列表</h4>
        <div class="character-list" style="display: flex; gap: 12px; flex-wrap: wrap;">
            @foreach (var character in userCharacters)
            {
                var isSelected = selectedCharacter?.Id == character.Id;
                var cardClass = isSelected ? "character-card selected" : "character-card";
                <div class="@cardClass" @onclick="() => SelectCharacter(character)" style="cursor: pointer; border: 2px solid @(isSelected ? "#007bff" : "#ddd"); padding: 12px; border-radius: 8px; min-width: 200px;">
                    <h5 style="margin: 0 0 8px 0;">@character.Name @(isSelected ? "✓" : "")</h5>
                    <div><b>职业:</b> @character.Profession</div>
                    <div><b>等级:</b> @character.Level</div>
                    <div><b>顺序:</b> #@(character.RosterOrder + 1)</div>
                    <div style="font-size: 0.85em; color: #666; margin-top: 4px;">ID: @character.Id.ToString().Substring(0, 8)...</div>
                </div>
            }
        </div>
    </div>
}

<!-- 1) 创建角色 -->
<div class="panel">
    <h4>1. 创建角色</h4>
    <input @bind="newName" placeholder="角色名" />
    <select @bind="selectedProfession">
        @foreach (var p in Enum.GetValues<Profession>())
        {
            <option value="@p">@p</option>
        }
    </select>
    <button @onclick="CreateCharacter" disabled="@(isBusy || userCharacters.Count >= 5)">
        @(userCharacters.Count >= 5 ? "已达上限" : "创建")
    </button>
    @if (userCharacters.Count >= 5)
    {
        <p style="color: #dc3545;">已达到角色数量上限（最多5个角色）</p>
    }
    @if (lastCreated is not null)
    {
        <p>已创建: @lastCreated.Name (@lastCreated.Id)</p>
        <button class="btn btn-sm" @onclick="ResetBattleState" disabled="@isBusy">重置战斗状态</button>
    }
</div>

<!-- 1.5) 背包界面 -->
@if (lastCreated is not null)
{
    <InventoryPanel CharacterId="@lastCreated.Id" CharacterName="@lastCreated.Name" />
}

<!-- 2) 同步战斗 -->
@if (lastCreated is not null)
{
    <div class="panel">
        <h4>2. 发起战斗（同步一次性）</h4>
        时长(s): <input type="number" min="1" max="120" @bind="battleSeconds" style="width:80px" />
        敌人:
        <select @bind="selectedEnemyId" style="width:240px">
            @if (enemies?.Count > 0)
            {
                @foreach (var e in enemies)
                {
                    <option value="@e.Id">@e.Name (@e.Id)</option>
                }
            }
            else
            {
                <option value="dummy">Training Dummy (dummy)</option>
                <option value="tank">Armored Golem (tank)</option>
                <option value="magebane">Magebane Warden (magebane)</option>
                <option value="paper">Paper Slime (paper)</option>
            }
        </select>

        <button @onclick="StartBattle" disabled="@(!CanStartBattle)">开始战斗</button>
        @if (currentBattleId != Guid.Empty)
        {
            <p>当前 BattleId: @currentBattleId</p>
        }
    </div>
}

@if (currentBattleId != Guid.Empty || summary is not null)
{
    <div class="panel">
        <h4>3. 战斗结果@(battleInProgress ? "（进行中/轮询）" : "")</h4>
        <p>
            总伤害: @summary?.TotalDamage |
            时长: @summary?.DurationSeconds s |
            DPS: @summary?.Dps |
            段数: @summary?.SegmentCount
        </p>
        @if (summary is not null)
        {
            <p>Attack间隔: @summary.AttackIntervalSeconds | Special间隔: @summary.SpecialIntervalSeconds</p>
        }

        <div style="display:flex;gap:8px;flex-wrap:wrap;">
            <button class="btn btn-outline-secondary" @onclick="ForceRefresh" disabled="@(isBusy || battleInProgress)">手动刷新</button>
            <button class="btn btn-outline-primary" @onclick="LoadSegments" disabled="@(isBusy || segmentsLoading)">加载段详情</button>
            @if (summary is not null)
            {
                <button class="btn btn-success" @onclick="ReplayThisBattle">回放此战斗（Step）</button>
            }
        </div>

        @if (segmentsLoading)
        {
            <p>加载段数据中...</p>
        }
        @if (segments is null)
        {
            <p>（尚未加载段数据）</p>
        }
        @if (segments?.Count > 0)
        {
            <table class="table">
                <thead>
                    <tr>
                        <th>#</th>
                        <th>Start-End</th>
                        <th>Events</th>
                        <th>Damage</th>
                        <th>Sources</th>
                        <th>Resources</th>
                    </tr>
                </thead>
                <tbody>
                    @for (int i = 0; i < segments.Count; i++)
                    {
                        var s = segments[i];
                        <tr>
                            <td>@i</td>
                            <td>@s.StartTime - @s.EndTime</td>
                            <td>@s.EventCount</td>
                            <td>@s.TotalDamage</td>
                            <td>
                                @foreach (var kv in s.DamageBySource)
                                {
                                    <span>@kv.Key:@kv.Value </span>
                                }
                            </td>
                            <td>
                                @foreach (var kv in s.ResourceFlow)
                                {
                                    <span>@kv.Key:@(kv.Value >= 0 ? "+" : "")@kv.Value </span>
                                }
                            </td>
                        </tr>
                    }
                </tbody>
            </table>
        }
    </div>
}

<!-- 4) 活动计划管理 -->
@if (lastCreated is not null)
{
    <div class="panel" style="margin-top: 18px;">
        <h4>4. 活动计划管理</h4>

        <div class="row" style="gap:12px; align-items:end; margin-bottom: 12px;">
            <div>
                <label>活动类型</label>
                <select class="form-control" style="width:160px" @bind="planActivityType">
                    <option value="combat">战斗 (Combat)</option>
                    <option value="dungeon">地下城 (Dungeon)</option>
                </select>
            </div>
            <div>
                <label>限制类型</label>
                <select class="form-control" style="width:160px" @bind="planLimitType">
                    <option value="duration">时长限制</option>
                    <option value="infinite">无限制</option>
                </select>
            </div>
            <div>
                <label>时长(秒)</label>
                <input type="number" min="1" step="1" class="form-control" style="width:120px" @bind="planLimitValue" disabled="@(planLimitType != "duration")" />
            </div>
            <div>
                <label>槽位</label>
                <input type="number" min="0" max="4" step="1" class="form-control" style="width:80px" @bind="planSlotIndex" />
            </div>

            @if (planActivityType == "combat")
            {
                <div>
                    <label>敌人</label>
                    <select class="form-control" style="width:240px" @bind="selectedEnemyId">
                        @if (enemies?.Count > 0)
                        {
                            @foreach (var e in enemies)
                            {
                                <option value="@e.Id">@e.Name (@e.Id)</option>
                            }
                        }
                        else
                        {
                            <option value="dummy">Training Dummy (dummy)</option>
                            <option value="tank">Armored Golem (tank)</option>
                            <option value="magebane">Magebane Warden (magebane)</option>
                            <option value="paper">Paper Slime (paper)</option>
                        }
                    </select>
                </div>
                <div>
                    <label>敌人数</label>
                    <input type="number" min="1" step="1" class="form-control" style="width:100px" @bind="planEnemyCount" />
                </div>
            }
            else
            {
                <div>
                    <label>地下城ID</label>
                    <input class="form-control" style="width:200px" @bind="planDungeonId" placeholder="intro_cave" />
                </div>
                <div class="form-check" style="display:flex;align-items:center;gap:6px; margin-top: 20px;">
                    <input class="form-check-input" type="checkbox" id="chkDungeonLoop" @bind="planDungeonLoop" />
                    <label class="form-check-label" for="chkDungeonLoop">循环模式</label>
                </div>
            }

            <div>
                <label>Seed(可选)</label>
                <input class="form-control" style="width:160px" @bind="planSeedInput" />
            </div>
            <div style="display:flex;gap:8px;">
                <button class="btn btn-primary" @onclick="CreateActivityPlanAsync" disabled="@isBusy">创建计划</button>
                <button class="btn btn-outline-secondary" @onclick="RefreshPlansAsync" disabled="@isBusy">刷新列表</button>
            </div>
        </div>

        @if (!string.IsNullOrWhiteSpace(planError))
        {
            <div class="alert alert-danger">@planError</div>
        }

        @if (characterPlans?.Count > 0)
        {
            <div class="card" style="padding: 12px;">
                <h5>活动计划列表 (@characterPlans.Count)</h5>
                <table class="table table-sm table-striped">
                    <thead>
                        <tr>
                            <th>ID</th>
                            <th>类型</th>
                            <th>状态</th>
                            <th>槽位</th>
                            <th>限制</th>
                            <th>执行时长</th>
                            <th>BattleId</th>
                            <th>操作</th>
                        </tr>
                    </thead>
                    <tbody>
                        @foreach (var plan in characterPlans.OrderBy(p => p.SlotIndex).ThenBy(p => p.CreatedAt))
                        {
                            var typeName = plan.Type == 1 ? "战斗" : plan.Type == 2 ? "地下城" : "未知";
                            var stateName = plan.State == 0 ? "待执行" : plan.State == 1 ? "执行中" : plan.State == 2 ? "已完成" : plan.State == 3 ? "已取消" : plan.State == 4 ? "已暂停" : "未知";
                            var stateClass = plan.State == 0 ? "text-warning" : plan.State == 1 ? "text-success" : plan.State == 2 ? "text-secondary" : plan.State == 3 ? "text-muted" : plan.State == 4 ? "text-info" : "text-muted";
                            var limitText = plan.LimitType == 2 ? "无限制" : $"{plan.LimitValue:F0}秒";
                            <tr>
                                <td><small>@plan.Id.ToString().Substring(0, 8)...</small></td>
                                <td>@typeName</td>
                                <td class="@stateClass"><b>@stateName</b></td>
                                <td>@plan.SlotIndex</td>
                                <td>@limitText</td>
                                <td>@plan.ExecutedSeconds.ToString("F0")秒</td>
                                <td>
                                    @if (plan.BattleId.HasValue)
                                    {
                                        <small>@plan.BattleId.Value.ToString().Substring(0, 8)...</small>
                                    }
                                    else
                                    {
                                        <span>-</span>
                                    }
                                </td>
                                <td>
                                    @if (plan.State == 1) // Running
                                    {
                                        <button class="btn btn-sm btn-warning" @onclick="() => StopPlanAsync(plan.Id)" disabled="@isBusy">停止</button>
                                        @if (plan.BattleId.HasValue)
                                        {
                                            <button class="btn btn-sm btn-info" @onclick="() => ViewPlanBattleAsync(plan.BattleId.Value)" disabled="@isBusy">查看战斗</button>
                                        }
                                    }
                                    else if (plan.State == 0) // Pending
                                    {
                                        <button class="btn btn-sm btn-danger" @onclick="() => CancelPlanAsync(plan.Id)" disabled="@isBusy">取消</button>
                                    }
                                    else if (plan.State == 4) // Paused
                                    {
                                        <button class="btn btn-sm btn-success" @onclick="() => ResumePlanAsync(plan.Id)" disabled="@isBusy">恢复</button>
                                        <button class="btn btn-sm btn-danger" @onclick="() => CancelPlanAsync(plan.Id)" disabled="@isBusy">取消</button>
                                    }
                                    else if (plan.State == 2 || plan.State == 3) // Completed or Cancelled
                                    {
                                        <button class="btn btn-sm btn-outline-secondary" @onclick="() => DeletePlanAsync(plan.Id)" disabled="@isBusy">删除</button>
                                    }
                                </td>
                            </tr>
                        }
                    </tbody>
                </table>
            </div>
        }
        else if (characterPlans is not null)
        {
            <div class="alert alert-info">该角色暂无活动计划</div>
        }

        @if (currentPlanBattle is not null)
        {
            <div class="card" style="padding: 12px; margin-top: 12px;">
                <h5>当前计划战斗状态</h5>
                <div class="row">
                    <div class="col-md-3"><b>BattleId:</b> @currentPlanBattle.Id</div>
                    <div class="col-md-3"><b>SimSec:</b> @currentPlanBattle.SimulatedSeconds.ToString("0.00")</div>
                    <div class="col-md-2"><b>DPS:</b> @currentPlanBattle.Dps.ToString("0.00")</div>
                    <div class="col-md-2"><b>Segments:</b> @currentPlanBattle.SegmentCount</div>
                    <div class="col-md-2"><b>Completed:</b> @(currentPlanBattle.Completed ? "Yes" : "No")</div>
                </div>
                <div class="row" style="margin-top:6px">
                    <div class="col-md-4"><b>Mode:</b> @(currentPlanBattle.Mode ?? "duration")</div>
                    <div class="col-md-4"><b>Gold:</b> @currentPlanBattle.Gold, <b>Exp:</b> @currentPlanBattle.Exp</div>
                </div>
                    <!-- 战斗实况：使用新组件 -->
                    <div style="margin-top: 16px; padding-top: 12px; border-top: 1px solid #ddd;">
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px; margin-bottom: 16px;">
                            <!-- 玩家状态面板 -->
                            <PlayerStatusPanel 
                                CharacterName="@(selectedCharacter?.Name ?? "角色")"
                                Profession="@currentPlanBattle.Profession"
                                CurrentHp="@((int)(currentPlanBattle.PlayerMaxHp * currentPlanBattle.PlayerHpPercent))"
                                MaxHp="@currentPlanBattle.PlayerMaxHp"
                                HpPercent="@currentPlanBattle.PlayerHpPercent"
                                BattleDurationSeconds="@currentPlanBattle.SimulatedSeconds"
                                ShowAttackProgress="true"
                                NextAttackAt="@currentPlanBattle.NextAttackAt"
                                NextSpecialAt="@currentPlanBattle.NextSpecialAt"
                                CurrentTime="@currentPlanBattle.CurrentTime"
                                AttackProgress="@(CalculateSmoothProgress(currentPlanBattle.CurrentTime, currentPlanBattle.NextAttackAt ?? 0, _planAttackInterval, _planLastUpdateTime))"
                                SpecialProgress="@(CalculateSmoothProgress(currentPlanBattle.CurrentTime, currentPlanBattle.NextSpecialAt ?? 0, _planSpecialInterval, _planLastUpdateTime))" />
                            
                            <!-- 怪物状态面板 -->
                            <MonsterStatusPanel 
                                Enemies="@currentPlanBattle.Enemies"
                                ModeInfo="@GetPlanModeInfo(currentPlanBattle)"
                                MaxOtherEnemies="2" />
                        </div>
                        
                        <!-- Buff状态栏（Step 3） -->
                        @if (currentPlanBattle.PlayerBuffs != null && currentPlanBattle.PlayerBuffs.Count > 0)
                        {
                            <BuffBarPanel 
                                Buffs="@currentPlanBattle.PlayerBuffs.Where(b => !b.IsDebuff).ToList()"
                                IsDebuffBar="false"
                                ShowBuffNames="false" />
                        }
                        
                        @if (currentPlanBattle.PlayerBuffs != null && currentPlanBattle.PlayerBuffs.Any(b => b.IsDebuff))
                        {
                            <BuffBarPanel 
                                Buffs="@currentPlanBattle.PlayerBuffs.Where(b => b.IsDebuff).ToList()"
                                IsDebuffBar="true"
                                ShowBuffNames="false" />
                        }
                        
                        <!-- 地下城进度面板（仅地下城模式） -->
                        @if (currentPlanBattle.Mode == "dungeonsingle" || currentPlanBattle.Mode == "dungeonloop")
                        {
                            <DungeonProgressPanel 
                                DungeonName="@(currentPlanBattle.DungeonId ?? "未知地下城")"
                                WaveIndex="@currentPlanBattle.WaveIndex"
                                TotalWaves="@GetTotalWaves(currentPlanBattle.DungeonId)"
                                RunCount="@currentPlanBattle.RunCount"
                                IsBossWave="@IsBossWave(currentPlanBattle.WaveIndex)"
                                EnemyCount="@(currentPlanBattle.Enemies?.Count ?? 0)"
                                Gold="@currentPlanBattle.Gold"
                                Exp="@currentPlanBattle.Exp" />
                        }
                    </div>
            </div>
        }
    
    </div>
}

<!-- 5) 异步 Step 战斗（调试 - 保留原功能） -->
@if (lastCreated is not null)
{
    <div class="panel" style="margin-top: 18px;">
        <h4>5. 异步 Step 战斗（调试）</h4>

        <div class="row" style="gap:12px; align-items:end;">
            <div>
                <label>模式</label>
                <select class="form-control" style="width:160px" @bind="stepMode">
                    <option value="duration">Duration（按时长）</option>
                    <option value="continuous">Continuous（持续同怪）</option>
                    <option value="dungeonsingle">Dungeon（单次）</option>
                    <option value="dungeonloop">Dungeon Loop（循环）</option>
                </select>
            </div>
            <div>
                <label>时长(s)</label>
                <input type="number" min="1" step="1" class="form-control" style="width:100px" @bind="stepSeconds" disabled="@(stepMode != "duration")" />
            </div>
            <div>
                <label>敌人数</label>
                <input type="number" min="1" step="1" class="form-control" style="width:100px" @bind="stepEnemyCount" disabled="@(IsDungeonMode)" />
            </div>
            <div>
                <label>Seed(可选)</label>
                <input class="form-control" style="width:160px" @bind="stepSeedInput" />
            </div>
            <div>
                <label>敌人</label>
                <select class="form-control" style="width:240px" @bind="selectedEnemyId" disabled="@(IsDungeonMode)">
                    @if (enemies?.Count > 0)
                    {
                        @foreach (var e in enemies)
                        {
                            <option value="@e.Id">@e.Name (@e.Id)</option>
                        }
                    }
                    else
                    {
                        <option value="dummy">Training Dummy (dummy)</option>
                        <option value="tank">Armored Golem (tank)</option>
                        <option value="magebane">Magebane Warden (magebane)</option>
                        <option value="paper">Paper Slime (paper)</option>
                    }
                </select>
            </div>
            <div>
                <label>DungeonId</label>
                <input class="form-control" style="width:200px" @bind="stepDungeonId" placeholder="intro_cave" disabled="@(stepMode == "duration" || stepMode == "continuous")" />
            </div>
            <div>
                <label>掉落模式</label>
                <select class="form-control" style="width:140px" @bind="stepDropMode">
                    <option value="expected">expected</option>
                    <option value="sampled">sampled</option>
                </select>
            </div>
            <div>
                <label>状态轮询(ms)</label>
                <input type="number" min="100" step="100" class="form-control" style="width:120px" @bind="stepPollMs" />
            </div>
            <div>
                <label>调试轮询(ms)</label>
                <input type="number" min="200" step="100" class="form-control" style="width:120px" @bind="stepDebugPollMs" />
            </div>
            <div style="display:flex;gap:8px;flex-wrap:wrap;">
                <button class="btn btn-primary" @onclick="StartStepBattle" disabled="@isBusy">Start Step</button>
                <button class="btn btn-secondary" @onclick="StopStepPolling" disabled="@(!stepIsPolling)">Stop Poll</button>
                <button class="btn btn-outline-danger" @onclick="ResetStep" disabled="@isBusy">Reset</button>
                <button class="btn btn-success" @onclick="StopAndSaveAsync" disabled="@(!stepBattleId.HasValue)">Stop &amp; Save</button>
                <button class="btn btn-outline-info" @onclick="RefreshRuntimeDebug" disabled="@(!stepBattleId.HasValue)">刷新运行态</button>
                <div class="form-check" style="display:flex;align-items:center;gap:6px;">
                    <input class="form-check-input" type="checkbox" id="chkAutoDbg" @bind="stepAutoDebug" @bind:after="OnAutoDebugChanged" />
                    <label class="form-check-label" for="chkAutoDbg">自动刷新运行态</label>
                </div>
            </div>
        </div>

        @if (!string.IsNullOrWhiteSpace(stepError))
        {
            <div class="alert alert-danger" style="margin-top:8px">@stepError</div>
        }

        @if (stepStatus is not null)
        {
            <div class="card" style="padding: 12px; margin-top: 12px;">
                <h5>Status</h5>
                <div class="row">
                    <div class="col-md-3"><b>BattleId:</b> @stepBattleId</div>
                    <div class="col-md-3"><b>SimSec:</b> @stepStatus.SimulatedSeconds.ToString("0.00")</div>
                    <div class="col-md-2"><b>DPS:</b> @stepStatus.Dps.ToString("0.00")</div>
                    <div class="col-md-2"><b>Segments:</b> @stepStatus.SegmentCount</div>
                    <div class="col-md-2"><b>Completed:</b> @(stepStatus.Completed ? "Yes" : "No")</div>
                </div>
                <div class="row">
                    <div class="col-md-4"><b>Seed:</b> @stepStatus.Seed</div>
                    <div class="col-md-4"><b>SeedIdx:</b> @stepStatus.SeedIndexStart - @stepStatus.SeedIndexEnd</div>
                    <div class="col-md-2"><b>Killed:</b> @(stepStatus.Killed ? "Yes" : "No")</div>
                    <div class="col-md-2"><b>KillTime:</b> @(stepStatus.KillTimeSeconds?.ToString("0.00") ?? "-")</div>
                </div>
                <div class="row" style="margin-top:6px">
                    <div class="col-md-4"><b>Mode:</b> @(stepStatus.Mode ?? "duration")</div>
                    <div class="col-md-4"><b>Wave:</b> @(stepStatus.WaveIndex?.ToString() ?? "-")</div>
                    <div class="col-md-4"><b>RunCount:</b> @(stepStatus.RunCount?.ToString() ?? "0")</div>
                </div>
                @if (stepStatus.PersistedBattleId is not null)
                {
                    <div class="row" style="margin-top:6px">
                        <div class="col-md-12">
                            <b>Persisted BattleId:</b> @stepStatus.PersistedBattleId
                            <button class="btn btn-sm btn-outline-primary" @onclick="() => OpenSummary(stepStatus.PersistedBattleId!.Value)">打开摘要</button>
                        </div>
                    </div>
                }
                
                <!-- 战斗实况：使用新组件 -->
                <div style="margin-top: 16px; padding-top: 12px; border-top: 1px solid #ddd;">
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px; margin-bottom: 16px;">
                        <!-- 玩家状态面板 -->
                        <PlayerStatusPanel 
                            CharacterName="@(selectedCharacter?.Name ?? "角色")"
                            Profession="@stepStatus.Profession"
                            CurrentHp="@((int)(stepStatus.PlayerMaxHp * stepStatus.PlayerHpPercent))"
                            MaxHp="@stepStatus.PlayerMaxHp"
                            HpPercent="@stepStatus.PlayerHpPercent"
                            BattleDurationSeconds="@stepStatus.SimulatedSeconds"
                            ShowAttackProgress="true"
                            NextAttackAt="@stepStatus.NextAttackAt"
                            NextSpecialAt="@stepStatus.NextSpecialAt"
                            CurrentTime="@stepStatus.CurrentTime"
                            AttackProgress="@(CalculateSmoothProgress(stepStatus.CurrentTime, stepStatus.NextAttackAt ?? 0, _stepAttackInterval, _stepLastUpdateTime))"
                            SpecialProgress="@(CalculateSmoothProgress(stepStatus.CurrentTime, stepStatus.NextSpecialAt ?? 0, _stepSpecialInterval, _stepLastUpdateTime))" />
                        
                        <!-- 怪物状态面板 -->
                        <MonsterStatusPanel 
                            Enemies="@stepStatus.Enemies"
                            ModeInfo="@GetStepModeInfo(stepStatus)"
                            MaxOtherEnemies="4" />
                    </div>
                    
                    <!-- Buff状态栏（Step 3） -->
                    @if (stepStatus.PlayerBuffs != null && stepStatus.PlayerBuffs.Count > 0)
                    {
                        <BuffBarPanel 
                            Buffs="@stepStatus.PlayerBuffs.Where(b => !b.IsDebuff).ToList()"
                            IsDebuffBar="false"
                            ShowBuffNames="false" />
                    }
                    
                    @if (stepStatus.PlayerBuffs != null && stepStatus.PlayerBuffs.Any(b => b.IsDebuff))
                    {
                        <BuffBarPanel 
                            Buffs="@stepStatus.PlayerBuffs.Where(b => b.IsDebuff).ToList()"
                            IsDebuffBar="true"
                            ShowBuffNames="false" />
                    }
                    
                    <!-- 地下城进度面板（仅地下城模式） -->
                    @if (stepStatus.Mode == "dungeonsingle" || stepStatus.Mode == "dungeonloop")
                    {
                        <DungeonProgressPanel 
                            DungeonName="@(stepStatus.DungeonId ?? "未知地下城")"
                            WaveIndex="@stepStatus.WaveIndex"
                            TotalWaves="@GetTotalWaves(stepStatus.DungeonId)"
                            RunCount="@stepStatus.RunCount"
                            IsBossWave="@IsBossWave(stepStatus.WaveIndex)"
                            EnemyCount="@(stepStatus.Enemies?.Count ?? 0)"
                            Gold="@stepStatus.Gold"
                            Exp="@stepStatus.Exp" />
                    }
                </div>
            </div>

            <div class="card" style="padding: 12px; margin-top: 12px;">
                <h5>收益</h5>
                <div><b>DropMode:</b> @stepDropMode</div>
                <div><b>Gold:</b> @stepStatus.Gold, <b>Exp:</b> @stepStatus.Exp</div>
                @if ((stepStatus.DropMode ?? stepDropMode) == "expected")
                {
                    <div>
                        <b>Loot (expected):</b>
                        <ul>
                            @foreach (var kv in stepStatus.LootExpected.OrderByDescending(kv => kv.Value))
                            {
                                <li>@kv.Key: @kv.Value.ToString("0.##")</li>
                            }
                        </ul>
                    </div>
                }
                else
                {
                    <div>
                        <b>Loot (sampled):</b>
                        <ul>
                            @foreach (var kv in stepStatus.LootSampled.OrderByDescending(kv => kv.Value))
                            {
                                <li>@kv.Key: @kv.Value</li>
                            }
                        </ul>
                    </div>
                }
            </div>

            <div class="card" style="padding: 12px; margin-top: 12px;">
                <h5>Segments (@stepSegments.Count)</h5>
                <table class="table table-sm table-striped">
                    <thead>
                        <tr>
                            <th>#</th>
                            <th>Time</th>
                            <th>Events</th>
                            <th>Total</th>
                            <th>Top Source</th>
                            <th>Phys/Magic/True</th>
                        </tr>
                    </thead>
                    <tbody>
                        @foreach (var s in stepSegments)
                        {
                            var topSrc = s.DamageBySource.OrderByDescending(kv => kv.Value).FirstOrDefault();
                            var phys = s.DamageByType.TryGetValue("physical", out var pv) ? pv : 0;
                            var magic = s.DamageByType.TryGetValue("magic", out var mv) ? mv : 0;
                            var tru = s.DamageByType.TryGetValue("true", out var tv) ? tv : 0;
                            <tr>
                                <td>@s.Index</td>
                                <td>@s.StartTime.ToString("0.00") - @s.EndTime.ToString("0.00")</td>
                                <td>@s.EventCount</td>
                                <td>@s.TotalDamage</td>
                                <td>@(string.IsNullOrEmpty(topSrc.Key) ? "-" : $"{topSrc.Key}:{topSrc.Value}")</td>
                                <td>@phys / @magic / @tru</td>
                            </tr>
                        }
                    </tbody>
                </table>
            </div>

            <div class="card" style="padding: 12px; margin-top: 12px;">
                <h5>Runtime Debug</h5>
                @if (stepDebug is null)
                {
                    <div><i>点击“刷新运行态”或勾选“自动刷新运行态”查看。</i></div>
                }
                else
                {
                    <div class="row">
                        <div class="col-md-3"><b>Now:</b> @stepDebug.Now.ToString("0.00")</div>
                        <div class="col-md-3"><b>RNG Index:</b> @stepDebug.RngIndex</div>
                        <div class="col-md-3"><b>Scheduler:</b> @stepDebug.SchedulerCount</div>
                        <div class="col-md-3"><b>Enemy:</b> @stepDebug.Encounter.EnemyId (@stepDebug.Encounter.CurrentHp/@stepDebug.Encounter.EnemyMaxHp)</div>
                    </div>

                    <div class="row" style="margin-top:6px">
                        <div class="col-md-4"><b>SegmentStart:</b> @stepDebug.Collector.SegmentStart.ToString("0.00")</div>
                        <div class="col-md-4"><b>LastEventTime:</b> @stepDebug.Collector.LastEventTime.ToString("0.00")</div>
                        <div class="col-md-4"><b>EventCount:</b> @stepDebug.Collector.EventCount</div>
                    </div>

                    <h6 style="margin-top:10px">Tracks</h6>
                    <table class="table table-sm table-striped">
                        <thead><tr><th>Type</th><th>Base</th><th>Haste</th><th>Current</th><th>Next</th></tr></thead>
                        <tbody>
                            @foreach (var t in stepDebug.Tracks)
                            {
                                <tr>
                                    <td>@t.Type</td>
                                    <td>@t.BaseInterval.ToString("0.00")</td>
                                    <td>@t.HasteFactor.ToString("0.00")</td>
                                    <td>@t.CurrentInterval.ToString("0.00")</td>
                                    <td>@t.NextTriggerAt.ToString("0.00")</td>
                                </tr>
                            }
                        </tbody>
                    </table>

                    <h6>Resources</h6>
                    @if (stepDebug.Resources?.Count > 0)
                    {
                        <table class="table table-sm table-bordered" style="max-width:400px">
                            <thead><tr><th>Id</th><th>Current</th><th>Max</th></tr></thead>
                            <tbody>
                                @foreach (var kv in stepDebug.Resources)
                                {
                                    <tr><td>@kv.Key</td><td>@kv.Value.Current</td><td>@kv.Value.Max</td></tr>
                                }
                            </tbody>
                        </table>
                    }
                    else
                    {
                        <div><i>(无资源快照或未命中 rage/focus)</i></div>
                    }

                    <h6>Buffs (@stepDebug.Buffs.Count)</h6>
                    <table class="table table-sm table-striped">
                        <thead><tr><th>Id</th><th>Stacks</th><th>Expire</th><th>NextTick</th><th>TickIntv</th><th>HasteSnap</th><th>BasePerStack</th><th>Type</th><th>DmgType</th></tr></thead>
                        <tbody>
                            @foreach (var b in stepDebug.Buffs.OrderBy(x => x.Id))
                            {
                                <tr>
                                    <td>@b.Id</td>
                                    <td>@b.Stacks</td>
                                    <td>@b.ExpiresAt.ToString("0.00")</td>
                                    <td>@(b.NextTickAt?.ToString("0.00") ?? "-")</td>
                                    <td>@b.TickIntervalSeconds.ToString("0.00")</td>
                                    <td>@b.HasteSnapshot.ToString("0.00")</td>
                                    <td>@b.TickBasePerStack.ToString("0")</td>
                                    <td>@b.PeriodicType</td>
                                    <td>@b.PeriodicDamageType</td>
                                </tr>
                            }
                        </tbody>
                    </table>

                    <h6>Skills (@(stepDebug.AutoCast?.Skills?.Count ?? 0))</h6>
                    <div><b>GCDUntil:</b> @stepDebug.AutoCast.GlobalCooldownUntil.ToString("0.00") | <b>IsCasting:</b> @(stepDebug.AutoCast.IsCasting ? "Yes" : "No") | <b>CastingUntil:</b> @stepDebug.AutoCast.CastingUntil.ToString("0.00")</div>
                    <table class="table table-sm table-striped">
                        <thead><tr><th>Id</th><th>Prio</th><th>Charges</th><th>NextCharge</th><th>NextAvail</th><th>CD</th><th>Cast</th><th>GCD</th><th>OffGCD</th><th>Cost</th><th>DMGType</th></tr></thead>
                        <tbody>
                            @foreach (var s in stepDebug.AutoCast.Skills.OrderBy(x => x.Priority))
                            {
                                <tr>
                                    <td>@s.Id</td>
                                    <td>@s.Priority</td>
                                    <td>@s.Charges/@s.MaxCharges</td>
                                    <td>@(s.NextChargeReadyAt?.ToString("0.00") ?? "-")</td>
                                    <td>@s.NextAvailableTime.ToString("0.00")</td>
                                    <td>@s.CooldownSeconds.ToString("0.00")</td>
                                    <td>@s.CastTimeSeconds.ToString("0.00")</td>
                                    <td>@s.GcdSeconds.ToString("0.00")</td>
                                    <td>@(s.OffGcd ? "Y" : "N")</td>
                                    <td>@(s.CostResourceId is null ? "-" : $"{s.CostResourceId}:{s.CostAmount}")</td>
                                    <td>@s.DamageType</td>
                                </tr>
                            }
                        </tbody>
                    </table>
                }
            </div>
        }
    </div>
}

@if (lastCreated is not null)
{
    <div class="panel" style="margin-top: 18px;">
        <h4>6. 批量模拟器</h4>

        <div class="row" style="gap:12px; align-items:end;">
            <div>
                <label>模式</label>
                <select class="form-control" style="width:140px" @bind="simMode">
                    <option value="Kills">按击杀数</option>
                    <option value="Hours">按小时数</option>
                </select>
            </div>
            <div>
                <label>@(simMode == SimulateMode.Kills ? "击杀数" : "小时数")</label>
                <input type="number" min="1" step="1" class="form-control" style="width:140px" @bind="simValue" />
            </div>
            <div>
                <label>样本时长(s)</label>
                <input type="number" min="1" step="1" class="form-control" style="width:140px" @bind="simSampleSeconds" />
            </div>
            <div>
                <label>敌人数</label>
                <input type="number" min="1" step="1" class="form-control" style="width:120px" @bind="simEnemyCount" />
            </div>
            <div>
                <label>敌人</label>
                <select class="form-control" style="width:240px" @bind="selectedEnemyId">
                    @if (enemies?.Count > 0)
                    {
                        @foreach (var e in enemies)
                        {
                            <option value="@e.Id">@e.Name (@e.Id)</option>
                        }
                    }
                    else
                    {
                        <option value="dummy">Training Dummy (dummy)</option>
                        <option value="tank">Armored Golem (tank)</option>
                        <option value="magebane">Magebane Warden (magebane)</option>
                        <option value="paper">Paper Slime (paper)</option>
                    }
                </select>
            </div>
            <div>
                <label>Seed(可选)</label>
                <input class="form-control" style="width:200px" @bind="simSeedInput" />
            </div>
            <div style="display:flex;gap:8px;">
                <button class="btn btn-primary" @onclick="RunSimAsync" disabled="@isBusy">开始模拟</button>
            </div>
        </div>

        @if (!string.IsNullOrWhiteSpace(simError))
        {
            <div class="alert alert-danger" style="margin-top:8px">@simError</div>
        }

        @if (simResult is not null)
        {
            <div class="card" style="padding: 12px; margin-top: 12px;">
                <h5>结果摘要</h5>
                <div class="row">
                    <div class="col-md-3"><b>总时长(s):</b> @simResult.TotalSimulatedSeconds.ToString("0.00")</div>
                    <div class="col-md-3"><b>总伤害:</b> @simResult.TotalDamage</div>
                    <div class="col-md-3"><b>平均 DPS:</b> @simResult.AvgDps.ToString("0.00")</div>
                    <div class="col-md-3"><b>样本数:</b> @simResult.Runs</div>
                </div>
                <div class="row">
                    <div class="col-md-3"><b>总击杀:</b> @simResult.TotalKills</div>
                    <div class="col-md-3"><b>每小时击杀:</b> @simResult.KillsPerHour.ToString("0.00")</div>
                    <div class="col-md-3"><b>TTK 平均:</b> @(simResult.AvgTtk?.ToString("0.00") ?? "-")</div>
                    <div class="col-md-3">
                        <b>TTK P50/P90/P95/P99:</b>
                        @(simResult.TtkP50?.ToString("0.00") ?? "-") /
                        @(simResult.TtkP90?.ToString("0.00") ?? "-") /
                        @(simResult.TtkP95?.ToString("0.00") ?? "-") /
                        @(simResult.TtkP99?.ToString("0.00") ?? "-")
                    </div>
                </div>
            </div>
        }
    </div>
}
}

@code {
    // ====== 认证状态 ======
    private bool isAuthenticated = false;
    private UserInfoDto? currentUser;
    private List<UserCharacterDto> userCharacters = new();
    private UserCharacterDto? selectedCharacter;
    private string userMessage = "";

    // ====== 离线战斗 ======
    private OfflineCheckResult? offlineCheckResult;
    private DateTime lastHeartbeatUpdate = DateTime.MinValue;

    // ====== 创建/同步战斗 ======
    protected override async Task OnInitializedAsync()
    {
        try
        {
            // 检查登录状态
            await AuthService.InitializeAsync();
            if (!AuthService.IsAuthenticated)
            {
                Navigation.NavigateTo("/login", replace: true);
                return;
            }

            isAuthenticated = true;

            // 加载当前用户信息和角色列表
            await LoadUserDataAsync();

            try { enemies = await Api.GetEnemiesAsync() ?? new(); }
            catch (ApiAuthException)
            {
                // 认证错误已在API客户端中处理，只需导航到登录页
                Navigation.NavigateTo("/login", replace: true);
                return;
            }
            catch { enemies = new(); }
        }
        catch (Exception ex)
        {
            userMessage = $"初始化失败: {ex.Message}";
        }
    }

    async Task LoadUserDataAsync()
    {
        try
        {
            currentUser = await Api.GetCurrentUserAsync();
            if (currentUser is not null)
            {
                userCharacters = currentUser.Characters.OrderBy(c => c.RosterOrder).ToList();
                
                // 如果有角色，默认选中第一个
                if (userCharacters.Count > 0 && selectedCharacter is null)
                {
                    selectedCharacter = userCharacters[0];
                    // 用选中的角色作为 lastCreated 以便其他功能使用
                    lastCreated = new CharacterCreated(selectedCharacter.Id, selectedCharacter.Name);
                    
                    // 检查离线收益（会触发 RefreshPlansAsync）
                    await CheckOfflineRewardsAsync();
                }
                // 如果已经有选中的角色，刷新其计划列表
                else if (selectedCharacter is not null && lastCreated is not null)
                {
                    await RefreshPlansAsync();
                }
                
                userMessage = $"欢迎回来！你有 {userCharacters.Count} 个角色。";
            }
            else
            {
                // 用户数据不存在，可能是数据库被重置
                await AuthService.LogoutAsync();
                Navigation.NavigateTo("/login", replace: true);
                return;
            }
        }
        catch (Exception ex)
        {
            // 根据错误类型处理
            if (ex.Message.Contains("404") || ex.Message.Contains("401") || ex.Message.Contains("Unauthorized"))
            {
                // 用户不存在或未授权，执行自动登出
                await AuthService.LogoutAsync();
                Navigation.NavigateTo("/login", replace: true);
                return;
            }

            userMessage = $"加载用户数据失败: {ex.Message}";
        }
    }

    /// <summary>
    /// 检查离线收益（在角色加载时自动调用）
    /// 注意：现在心跳更新会自动触发离线检测和结算
    /// </summary>
    private async Task CheckOfflineRewardsAsync()
    {
        if (selectedCharacter is null) return;

        try
        {
            // 更新心跳时间（会自动触发离线检测和结算）
            var heartbeatResponse = await Api.UpdateHeartbeatAsync(selectedCharacter.Id);
            
            // 刷新计划列表（无论是否有离线时间都需要刷新以获取运行中的计划）
            await RefreshPlansAsync();
            
            // 如果心跳响应中包含离线结算结果，显示弹窗
            if (heartbeatResponse?.OfflineSettlement != null && heartbeatResponse.OfflineSettlement.HasOfflineTime)
            {
                offlineCheckResult = heartbeatResponse.OfflineSettlement;
                
                // 重新加载用户数据以更新金币和经验显示（因为收益已自动应用）
                await LoadUserDataAsync();
                
                // 再次刷新计划列表以获取最新状态
                await RefreshPlansAsync();
                
                // 如果计划未完成且下一个计划已启动，重新开始轮询
                if (heartbeatResponse.OfflineSettlement.NextPlanStarted && heartbeatResponse.OfflineSettlement.NextPlanId.HasValue)
                {
                    var nextPlan = characterPlans?.FirstOrDefault(p => p.Id == heartbeatResponse.OfflineSettlement.NextPlanId.Value);
                    if (nextPlan?.BattleId.HasValue == true)
                    {
                        _ = StartPlanPollingAsync(nextPlan.BattleId.Value);
                    }
                }
                // 如果计划未完成但没有启动下一个计划，检查当前运行中的计划
                else if (!heartbeatResponse.OfflineSettlement.PlanCompleted && heartbeatResponse.OfflineSettlement.HasRunningPlan)
                {
                    var runningPlan = characterPlans?.FirstOrDefault(p => p.State == 1); // State=1 is Running
                    if (runningPlan?.BattleId.HasValue == true)
                    {
                        _ = StartPlanPollingAsync(runningPlan.BattleId.Value);
                    }
                }
                
                await InvokeAsync(StateHasChanged);
            }
        }
        catch (Exception ex)
        {
            userMessage = $"检查离线收益失败: {ex.Message}";
        }
    }

    /// <summary>
    /// 关闭离线结算弹窗（收益已自动应用，不需要手动领取）
    /// </summary>
    private async Task CloseOfflineSettlement()
    {
        // 清除离线结算结果，关闭弹窗
        offlineCheckResult = null;
        await InvokeAsync(StateHasChanged);
    }

    /// <summary>
    /// 更新心跳时间（如果需要）
    /// 在计划任务刷新时也会调用，实现每2秒更新一次
    /// 注意：心跳更新会自动触发离线检测和结算
    /// </summary>
    private async Task UpdateHeartbeatIfNeededAsync()
    {
        if (selectedCharacter is null) return;

        // 每2秒更新一次心跳
        var now = DateTime.UtcNow;
        if ((now - lastHeartbeatUpdate).TotalSeconds < 2)
            return;

        try
        {
            var heartbeatResponse = await Api.UpdateHeartbeatAsync(selectedCharacter.Id);
            lastHeartbeatUpdate = now;
            
            // 如果心跳响应中包含离线结算结果（首次检测到离线），显示弹窗
            if (heartbeatResponse?.OfflineSettlement != null && 
                heartbeatResponse.OfflineSettlement.HasOfflineTime &&
                offlineCheckResult == null) // 避免重复弹窗
            {
                offlineCheckResult = heartbeatResponse.OfflineSettlement;
                
                // 重新加载用户数据以更新金币和经验显示
                await LoadUserDataAsync();
                
                // 刷新计划列表
                await RefreshPlansAsync();
                
                // 如果计划未完成且下一个计划已启动，重新开始轮询
                if (heartbeatResponse.OfflineSettlement.NextPlanStarted && heartbeatResponse.OfflineSettlement.NextPlanId.HasValue)
                {
                    var nextPlan = characterPlans?.FirstOrDefault(p => p.Id == heartbeatResponse.OfflineSettlement.NextPlanId.Value);
                    if (nextPlan?.BattleId.HasValue == true)
                    {
                        _ = StartPlanPollingAsync(nextPlan.BattleId.Value);
                    }
                }
                // 如果计划未完成但没有启动下一个计划，检查当前运行中的计划
                else if (!heartbeatResponse.OfflineSettlement.PlanCompleted && heartbeatResponse.OfflineSettlement.HasRunningPlan)
                {
                    var runningPlan = characterPlans?.FirstOrDefault(p => p.State == 1); // State=1 is Running
                    if (runningPlan?.BattleId.HasValue == true)
                    {
                        _ = StartPlanPollingAsync(runningPlan.BattleId.Value);
                    }
                }
                
                await InvokeAsync(StateHasChanged);
            }
        }
        catch
        {
            // 心跳更新失败不影响主流程
        }
    }

    void SelectCharacter(UserCharacterDto character)
    {
        selectedCharacter = character;
        lastCreated = new CharacterCreated(character.Id, character.Name);
        
        // 停止当前角色的所有轮询
        StopPlanPolling();
        currentPlanBattle = null;
        characterPlans = null;
        
        ResetBattleState();
        StateHasChanged();
        
        // 加载新角色的计划
        _ = RefreshPlansAsync();
    }

    string newName = "TestWarrior";
    Profession selectedProfession = Profession.Warrior;

    List<ApiClient.EnemyDto> enemies = new();
    string selectedEnemyId = "dummy";

    bool isBusy;
    bool battleInProgress;
    bool segmentsLoading;
    CharacterCreated? lastCreated;
    Guid currentBattleId;
    double battleSeconds = 10;
    BattleSummaryResponse? summary;
    List<BattleSegmentDto>? segments;
    System.Timers.Timer? pollTimer;

    bool CanStartBattle => !isBusy && lastCreated is not null && !battleInProgress;

    async Task CreateCharacter()
    {
        try 
        { 
            isBusy = true;
            
            // 检查是否已达上限
            if (userCharacters.Count >= 5)
            {
                userMessage = "已达到角色数量上限（最多5个角色）";
                return;
            }
            
            lastCreated = await Api.CreateCharacterAsync(newName, selectedProfession);
            
            // 重新加载用户角色列表
            await LoadUserDataAsync();
            
            // 选中新创建的角色
            var newChar = userCharacters.FirstOrDefault(c => c.Id == lastCreated.Id);
            if (newChar is not null)
            {
                selectedCharacter = newChar;
                userMessage = $"角色 {newChar.Name} 创建成功！";
            }
            
            ResetBattleState();
            await RefreshPlansAsync();  // 加载角色的活动计划
        }
        catch (Exception ex)
        {
            userMessage = $"创建角色失败: {ex.Message}";
        }
        finally { isBusy = false; }
    }

    void ResetBattleState()
    {
        battleInProgress = false;
        currentBattleId = Guid.Empty;
        summary = null;
        segments = null;
        StopPolling();
        StateHasChanged();
    }

    async Task StartBattle()
    {
        if (!CanStartBattle || lastCreated is null) return;
        try
        {
            isBusy = true; battleInProgress = true; summary = null; segments = null;
            var resp = await Api.StartBattleAsync(lastCreated.Id, battleSeconds, enemyId: selectedEnemyId);
            currentBattleId = resp.BattleId;
            await RefreshSummary();
            await LoadSegments();
            battleInProgress = false;
        }
        finally { isBusy = false; StateHasChanged(); }
    }

    void StartPolling()
    {
        StopPolling();
        pollTimer = new System.Timers.Timer(1500);
        pollTimer.Elapsed += async (_, _) => await InvokeAsync(async () => { await RefreshSummary(); StateHasChanged(); });
        pollTimer.AutoReset = true; pollTimer.Start();
    }

    void StopPolling() { pollTimer?.Stop(); pollTimer?.Dispose(); pollTimer = null; }

    async Task RefreshSummary() { if (currentBattleId == Guid.Empty) return; summary = await Api.GetBattleSummaryAsync(currentBattleId); }

    async Task LoadSegments()
    {
        if (currentBattleId == Guid.Empty) return;
        try { segmentsLoading = true; segments = await Api.GetBattleSegmentsAsync(currentBattleId); }
        finally { segmentsLoading = false; }
    }

    async Task ForceRefresh() { if (battleInProgress) return; try { isBusy = true; await RefreshSummary(); } finally { isBusy = false; } }

    async Task ReplayThisBattle()
    {
        if (summary is null || lastCreated is null) return;
        try
        {
            isBusy = true;
            var start = await Api.StartReplayStepBattleAsync(summary.Id, seconds: summary.DurationSeconds, enemyCount: 1);
            stepBattleId = start.BattleId;
            _stepSinceIndex = 0;
            stepSegments.Clear(); stepAggBySource.Clear(); stepAggByType.Clear();
            stepStatus = null; stepDebug = null;
            _ = StartStepPollingAsync();
        }
        catch (Exception ex)
        {
            stepError = $"回放启动失败: {ex.Message}";
        }
        finally { isBusy = false; }
    }

    // ====== Step 战斗（含运行态调试）======
    Guid? stepBattleId;
    string stepMode = "duration";     // duration | continuous | dungeonsingle | dungeonloop
    bool IsDungeonMode => stepMode == "dungeonsingle" || stepMode == "dungeonloop";
    string stepDungeonId = "intro_cave";

    double stepSeconds = 20;
    int stepEnemyCount = 1;
    string? stepSeedInput = null;
    int stepPollMs = 500;

    // 新：掉落模式（透传到 /status）
    string stepDropMode = "expected"; // expected | sampled

    StepStatusResponse? stepStatus;
    List<StepBattleSegmentDto> stepSegments = new();
    Dictionary<string, int> stepAggBySource = new();
    Dictionary<string, int> stepAggByType = new();

    bool stepIsPolling;
    int _stepSinceIndex = 0;
    string? stepError;
    
    // 攻击进度平滑化追踪变量（步进战斗）
    double _stepAttackInterval = 0;
    double _stepSpecialInterval = 0;
    double? _stepPrevNextAttackAt = null;
    double? _stepPrevNextSpecialAt = null;
    DateTime _stepLastUpdateTime = DateTime.UtcNow;

    StepBattleDebugDto? stepDebug;
    bool stepAutoDebug = false;
    int stepDebugPollMs = 1000;

    async Task StartStepBattle()
    {
        stepError = null;
        if (lastCreated is null) { stepError = "请先创建角色"; return; }
        if (stepSeconds <= 0) stepSeconds = 1;
        if (stepEnemyCount < 1) stepEnemyCount = 1;

        try
        {
            isBusy = true;
            ulong? seed = null;
            if (ulong.TryParse(stepSeedInput, out var seedVal)) seed = seedVal;

            var secondsToSend = stepMode == "duration" ? stepSeconds : Math.Max(1, stepSeconds); // 非 duration 仅占位
            string? enemyToSend = IsDungeonMode ? null : selectedEnemyId;
            int enemyCountToSend = IsDungeonMode ? 0 : stepEnemyCount;

            var resp = await Api.StartStepBattleAsync(
                characterId: lastCreated!.Id,
                seconds: secondsToSend,
                enemyId: enemyToSend,
                enemyCount: enemyCountToSend <= 0 ? 1 : enemyCountToSend,
                seed: seed,
                mode: stepMode,
                dungeonId: IsDungeonMode ? stepDungeonId : null
            );

            stepBattleId = resp.BattleId;
            _stepSinceIndex = 0; stepSegments.Clear(); stepAggBySource.Clear(); stepAggByType.Clear(); stepStatus = null; stepDebug = null;
            _ = StartStepPollingAsync();
            if (stepAutoDebug) _ = StartDebugAutoPollingAsync();
            await InvokeAsync(StateHasChanged);
        }
        catch (Exception ex) { stepError = $"StartStep 异常: {ex.Message}"; }
        finally { isBusy = false; }
    }

    async Task StartStepPollingAsync()
    {
        if (stepBattleId is null) return;
        
        // 使用统一的轮询协调器
        stepIsPolling = true;
        GetPollingCoordinator().StartStepBattlePolling(stepBattleId.Value, stepPollMs);
        
        await InvokeAsync(StateHasChanged);
    }

    async Task PollStepOnceAsync(CancellationToken ct)
    {
        if (stepBattleId is null) return;
        var s = await Api.GetStepBattleStatusAsync(stepBattleId.Value, stepDropMode, ct);
        if (s is not null)
        {
            // 更新攻击间隔追踪
            UpdateProgressTracking(
                ref _stepAttackInterval, 
                ref _stepPrevNextAttackAt, 
                s.NextAttackAt,
                ref _stepLastUpdateTime);
            
            UpdateProgressTracking(
                ref _stepSpecialInterval, 
                ref _stepPrevNextSpecialAt, 
                s.NextSpecialAt,
                ref _stepLastUpdateTime);
            
            stepStatus = s;
        }

        var segList = await Api.GetStepBattleSegmentsAsync(stepBattleId.Value, _stepSinceIndex, ct);
        if (segList is { Count: > 0 })
        {
            foreach (var seg in segList)
            {
                stepSegments.Add(seg);
                foreach (var kv in seg.DamageBySource)
                {
                    if (!stepAggBySource.ContainsKey(kv.Key)) stepAggBySource[kv.Key] = 0;
                    stepAggBySource[kv.Key] += kv.Value;
                }
                foreach (var kv in seg.DamageByType)
                {
                    if (!stepAggByType.ContainsKey(kv.Key)) stepAggByType[kv.Key] = 0;
                    stepAggByType[kv.Key] += kv.Value;
                }
            }
            _stepSinceIndex = stepSegments.Count;
        }
    }

    void StopStepPolling() 
    { 
        // 使用统一的轮询协调器
        GetPollingCoordinator().StopStepBattlePolling();
        stepIsPolling = false;
        StateHasChanged(); 
    }

    void ResetStep()
    {
        StopStepPolling(); StopDebugAutoPolling();
        stepBattleId = null; stepStatus = null; stepSegments.Clear(); stepAggBySource.Clear(); stepAggByType.Clear(); stepDebug = null; stepError = null; _stepSinceIndex = 0;
        StateHasChanged();
    }

    void OnAutoDebugChanged()
    {
        if (stepAutoDebug) _ = StartDebugAutoPollingAsync();
        else StopDebugAutoPolling();
    }

    async Task StopAndSaveAsync()
    {
        if (stepBattleId is null) return;
        try
        {
            var resp = await Api.StopStepBattleAsync(stepBattleId.Value);
            StopStepPolling(); StopDebugAutoPolling();
            if (stepStatus is not null) stepStatus.PersistedBattleId = resp.PersistedBattleId;
            await InvokeAsync(StateHasChanged);
        }
        catch (Exception ex) { stepError = $"Stop & Save 异常: {ex.Message}"; }
    }

    async Task RefreshRuntimeDebug()
    {
        if (stepBattleId is null) return;
        try { stepDebug = await Api.GetStepBattleDebugAsync(stepBattleId.Value); await InvokeAsync(StateHasChanged); }
        catch (Exception ex) { stepError = $"Debug 异常: {ex.Message}"; }
    }

    async Task StartDebugAutoPollingAsync()
    {
        if (stepBattleId is null) return;
        
        // 使用统一的轮询协调器
        GetPollingCoordinator().StartDebugPolling(stepDebugPollMs);
        
        await Task.CompletedTask;
    }
    
    void StopDebugAutoPolling() 
    { 
        // 使用统一的轮询协调器
        GetPollingCoordinator().StopDebugPolling();
    }

    async Task OpenSummary(Guid id) { var url = $"/api/battles/{id}/summary"; await JS.InvokeVoidAsync("open", url, "_blank"); }

    public void Dispose() 
    { 
        StopPolling(); 
        StopStepPolling(); 
        StopDebugAutoPolling(); 
        StopPlanPolling();
        _pollingCoordinator?.Dispose();
    }

    // ====== 活动计划管理 ======
    string planActivityType = "combat";  // combat | dungeon
    string planLimitType = "duration";   // duration | infinite
    double planLimitValue = 300;
    int planSlotIndex = 0;
    int planEnemyCount = 1;
    string planDungeonId = "intro_cave";
    bool planDungeonLoop = false;
    string? planSeedInput = null;
    string? planError = null;

    List<ActivityPlanDto>? characterPlans;
    StepStatusResponse? currentPlanBattle;
    bool planIsPolling;
    
    // 攻击进度平滑化追踪变量（计划战斗）
    double _planAttackInterval = 0;
    double _planSpecialInterval = 0;
    double? _planPrevNextAttackAt = null;
    double? _planPrevNextSpecialAt = null;
    DateTime _planLastUpdateTime = DateTime.UtcNow;

    async Task CreateActivityPlanAsync()
    {
        planError = null;
        if (lastCreated is null) { planError = "请先创建角色"; return; }

        try
        {
            isBusy = true;
            ulong? seed = null;
            if (ulong.TryParse(planSeedInput, out var seedVal)) seed = seedVal;

            ActivityPlanDto plan;
            if (planActivityType == "combat")
            {
                plan = await Api.CreateCombatPlanAsync(
                    characterId: lastCreated.Id,
                    slotIndex: planSlotIndex,
                    limitType: planLimitType,
                    limitValue: planLimitType == "duration" ? planLimitValue : null,
                    enemyId: selectedEnemyId,
                    enemyCount: planEnemyCount,
                    seed: seed
                );
            }
            else
            {
                plan = await Api.CreateDungeonPlanAsync(
                    characterId: lastCreated.Id,
                    slotIndex: planSlotIndex,
                    limitType: planLimitType,
                    limitValue: planLimitType == "duration" ? planLimitValue : null,
                    dungeonId: planDungeonId,
                    loop: planDungeonLoop,
                    seed: seed
                );
            }

            await RefreshPlansAsync();

            // 如果创建的计划自动启动了（State=1），开始轮询战斗状态
            if (plan.State == 1 && plan.BattleId.HasValue)
            {
                _ = StartPlanPollingAsync(plan.BattleId.Value);
            }
        }
        catch (Exception ex)
        {
            planError = $"创建计划失败: {ex.Message}";
        }
        finally
        {
            isBusy = false;
        }
    }

    async Task RefreshPlansAsync()
    {
        if (lastCreated is null) return;
        try
        {
            characterPlans = await Api.GetCharacterPlansAsync(lastCreated.Id);
            
            // 查找正在运行的计划并获取其战斗状态
            // State: 0=Pending, 1=Running, 2=Completed, 3=Cancelled, 4=Paused
            var runningPlan = characterPlans?.FirstOrDefault(p => p.State == 1);
            if (runningPlan?.BattleId.HasValue == true)
            {
                if (!planIsPolling)
                {
                    _ = StartPlanPollingAsync(runningPlan.BattleId.Value);
                }
            }
            else
            {
                StopPlanPolling();
                currentPlanBattle = null;
            }
        }
        catch (Exception ex)
        {
            planError = $"刷新计划列表失败: {ex.Message}";
        }
    }

    async Task StopPlanAsync(Guid planId)
    {
        try
        {
            isBusy = true;
            var success = await Api.StopPlanAsync(planId);
            if (success)
            {
                await RefreshPlansAsync();
            }
            else
            {
                planError = "停止计划失败";
            }
        }
        catch (Exception ex)
        {
            planError = $"停止计划异常: {ex.Message}";
        }
        finally
        {
            isBusy = false;
        }
    }

    async Task CancelPlanAsync(Guid planId)
    {
        try
        {
            isBusy = true;
            var success = await Api.CancelPlanAsync(planId);
            if (success)
            {
                await RefreshPlansAsync();
            }
            else
            {
                planError = "取消计划失败";
            }
        }
        catch (Exception ex)
        {
            planError = $"取消计划异常: {ex.Message}";
        }
        finally
        {
            isBusy = false;
        }
    }

    async Task DeletePlanAsync(Guid planId)
    {
        try
        {
            isBusy = true;
            var success = await Api.DeletePlanAsync(planId);
            if (success)
            {
                await RefreshPlansAsync();
            }
            else
            {
                planError = "删除计划失败";
            }
        }
        catch (Exception ex)
        {
            planError = $"删除计划异常: {ex.Message}";
        }
        finally
        {
            isBusy = false;
        }
    }

    async Task ResumePlanAsync(Guid planId)
    {
        try
        {
            isBusy = true;
            var response = await Api.ResumePlanAsync(planId);
            if (response != null)
            {
                await RefreshPlansAsync();
                
                // 如果计划恢复成功并且有战斗ID，开始轮询
                if (response.Resumed && response.BattleId.HasValue)
                {
                    _ = StartPlanPollingAsync(response.BattleId.Value);
                }
            }
            else
            {
                planError = "恢复计划失败";
            }
        }
        catch (Exception ex)
        {
            planError = $"恢复计划异常: {ex.Message}";
        }
        finally
        {
            isBusy = false;
        }
    }

    async Task ViewPlanBattleAsync(Guid battleId)
    {
        try
        {
            currentPlanBattle = await Api.GetStepBattleStatusAsync(battleId, "sampled");
            if (!planIsPolling)
            {
                _ = StartPlanPollingAsync(battleId);
            }
        }
        catch (Exception ex)
        {
            planError = $"查看战斗失败: {ex.Message}";
        }
    }

    async Task StartPlanPollingAsync(Guid battleId)
    {
        // 使用统一的轮询协调器
        planIsPolling = true;
        GetPollingCoordinator().StartPlanBattlePolling(battleId, 2000);
        
        await InvokeAsync(StateHasChanged);
    }

    void StopPlanPolling()
    {
        // 使用统一的轮询协调器
        GetPollingCoordinator().StopPlanBattlePolling();
        planIsPolling = false;
    }

    // 批量模拟器
    SimulateMode simMode = SimulateMode.Kills;
    double simValue = 10;
    double simSampleSeconds = 20;
    int simEnemyCount = 1;
    string? simSeedInput;
    SimulateResponse? simResult;
    string? simError;

    async Task RunSimAsync()
    {
        simError = null;
        simResult = null;
        if (lastCreated is null) { simError = "请先创建角色"; return; }
        if (simValue <= 0) { simError = "值必须大于 0"; return; }
        try
        {
            isBusy = true;
            ulong? seed = null;
            if (ulong.TryParse(simSeedInput, out var sv)) seed = sv;
            var req = new SimulateRequest
            {
                CharacterId = lastCreated.Id,
                EnemyId = selectedEnemyId,
                EnemyCount = simEnemyCount,
                Mode = simMode,
                Value = simValue,
                SampleSeconds = simSampleSeconds,
                Seed = seed
            };
            simResult = await Api.SimulateAsync(req);
        }
        catch (Exception ex)
        {
            simError = $"模拟失败: {ex.Message}";
        }
        finally
        {
            isBusy = false;
            StateHasChanged();
        }
    }

    // ====== 攻击进度平滑化计算 ======
    /// <summary>
    /// 更新攻击间隔追踪信息
    /// </summary>
    /// <param name="interval">攻击间隔引用</param>
    /// <param name="prevNextTriggerAt">上次的下次触发时间引用</param>
    /// <param name="currentNextTriggerAt">当前的下次触发时间</param>
    /// <param name="lastUpdateTime">最后更新时间引用</param>
    private void UpdateProgressTracking(ref double interval, ref double? prevNextTriggerAt, double? currentNextTriggerAt, ref DateTime lastUpdateTime)
    {
        // 更新最后更新时间
        lastUpdateTime = DateTime.UtcNow;

        // 如果当前没有下次触发时间，重置状态
        if (!currentNextTriggerAt.HasValue)
        {
            interval = 0;
            prevNextTriggerAt = null;
            return;
        }

        // 如果有上次的触发时间，且当前触发时间大于上次（说明攻击已触发，进入下一个周期）
        // 则计算攻击间隔
        if (prevNextTriggerAt.HasValue && currentNextTriggerAt.Value > prevNextTriggerAt.Value)
        {
            double calculatedInterval = currentNextTriggerAt.Value - prevNextTriggerAt.Value;
            // 只有当间隔合理时才更新（避免异常值）
            if (calculatedInterval > 0.1 && calculatedInterval < 100)
            {
                interval = calculatedInterval;
            }
        }

        // 更新上次的触发时间
        prevNextTriggerAt = currentNextTriggerAt.Value;
    }

    /// <summary>
    /// 计算平滑的攻击进度百分比
    /// </summary>
    /// <param name="currentTime">服务器当前战斗时间</param>
    /// <param name="nextTriggerAt">下次触发时间</param>
    /// <param name="interval">攻击间隔（从追踪变量获取）</param>
    /// <param name="lastUpdateTime">上次服务器更新的客户端时间</param>
    /// <returns>0.0 到 1.0 之间的进度值</returns>
    private double CalculateSmoothProgress(double currentTime, double nextTriggerAt, double interval, DateTime lastUpdateTime)
    {
        // 如果没有有效的攻击间隔，使用简单的二元判断
        if (interval <= 0)
        {
            return currentTime >= nextTriggerAt ? 1.0 : 0.0;
        }

        // 计算上次攻击时间
        double lastTriggerAt = nextTriggerAt - interval;

        // 计算基于服务器时间的进度
        double serverProgress = (currentTime - lastTriggerAt) / interval;

        // 添加客户端时间插值以实现平滑动画
        double clientElapsedSeconds = (DateTime.UtcNow - lastUpdateTime).TotalSeconds;
        double interpolatedProgress = serverProgress + (clientElapsedSeconds / interval);

        // 限制在 0 到 1 之间
        return Math.Clamp(interpolatedProgress, 0.0, 1.0);
    }

    // ====== 统一轮询协调器 (BattlePollingCoordinator) ======
    /// <summary>
    /// 统一管理所有战斗相关的轮询任务，包括：
    /// - Step战斗状态轮询
    /// - 活动计划战斗轮询
    /// - Debug信息轮询
    /// - 进度条动画定时器
    /// </summary>
    private class BattlePollingCoordinator : IDisposable
    {
        private readonly Characters _parent;
        private CancellationTokenSource? _mainCts;
        private System.Threading.Timer? _animationTimer;
        private bool _isPolling;
        
        // 轮询状态跟踪
        private bool _stepBattleActive;
        private bool _planBattleActive;
        private bool _debugPollingActive;
        
        // 轮询间隔配置（毫秒）
        private int _stepPollInterval = 500;
        private int _planPollInterval = 2000;
        private int _debugPollInterval = 1000;
        private const int AnimationInterval = 100;

        public BattlePollingCoordinator(Characters parent)
        {
            _parent = parent;
        }

        /// <summary>
        /// 启动Step战斗轮询
        /// </summary>
        public void StartStepBattlePolling(Guid battleId, int pollIntervalMs = 500)
        {
            _stepBattleActive = true;
            _stepPollInterval = pollIntervalMs;
            EnsurePollingStarted();
        }

        /// <summary>
        /// 停止Step战斗轮询
        /// </summary>
        public void StopStepBattlePolling()
        {
            _stepBattleActive = false;
            CheckStopPolling();
        }

        /// <summary>
        /// 启动活动计划战斗轮询
        /// </summary>
        public void StartPlanBattlePolling(Guid battleId, int pollIntervalMs = 2000)
        {
            _planBattleActive = true;
            _planPollInterval = pollIntervalMs;
            EnsurePollingStarted();
        }

        /// <summary>
        /// 停止活动计划战斗轮询
        /// </summary>
        public void StopPlanBattlePolling()
        {
            _planBattleActive = false;
            CheckStopPolling();
        }

        /// <summary>
        /// 启动Debug信息轮询
        /// </summary>
        public void StartDebugPolling(int pollIntervalMs = 1000)
        {
            _debugPollingActive = true;
            _debugPollInterval = pollIntervalMs;
            EnsurePollingStarted();
        }

        /// <summary>
        /// 停止Debug信息轮询
        /// </summary>
        public void StopDebugPolling()
        {
            _debugPollingActive = false;
            CheckStopPolling();
        }

        /// <summary>
        /// 确保轮询任务已启动
        /// </summary>
        private void EnsurePollingStarted()
        {
            if (_isPolling) return;

            _mainCts?.Cancel();
            _mainCts = new CancellationTokenSource();
            _isPolling = true;

            // 启动统一的轮询任务
            _ = RunPollingLoopAsync(_mainCts.Token);

            // 启动进度条动画定时器
            StartAnimationTimer();
        }

        /// <summary>
        /// 检查是否需要停止轮询
        /// </summary>
        private void CheckStopPolling()
        {
            if (!_stepBattleActive && !_planBattleActive && !_debugPollingActive)
            {
                StopAll();
            }
        }

        /// <summary>
        /// 统一的轮询循环
        /// </summary>
        private async Task RunPollingLoopAsync(CancellationToken ct)
        {
            // 跟踪每个任务的下次执行时间
            DateTime nextStepPoll = DateTime.UtcNow;
            DateTime nextPlanPoll = DateTime.UtcNow;
            DateTime nextDebugPoll = DateTime.UtcNow;

            try
            {
                while (!ct.IsCancellationRequested)
                {
                    var now = DateTime.UtcNow;
                    var tasks = new List<Task>();

                    // Step战斗状态轮询
                    if (_stepBattleActive && now >= nextStepPoll)
                    {
                        nextStepPoll = now.AddMilliseconds(_stepPollInterval);
                        tasks.Add(Task.Run(async () =>
                        {
                            try
                            {
                                await _parent.PollStepOnceAsync(ct);
                                await _parent.InvokeAsync(_parent.StateHasChanged);
                                
                                // 检查战斗是否完成
                                if (_parent.stepStatus?.Completed == true && 
                                    _parent.stepMode != "continuous" && 
                                    _parent.stepMode != "dungeonloop")
                                {
                                    StopStepBattlePolling();
                                }
                            }
                            catch (Exception ex) when (ex is not TaskCanceledException)
                            {
                                _parent.stepError = $"轮询异常: {ex.Message}";
                            }
                        }, ct));
                    }

                    // 活动计划战斗轮询
                    if (_planBattleActive && now >= nextPlanPoll)
                    {
                        nextPlanPoll = now.AddMilliseconds(_planPollInterval);
                        tasks.Add(Task.Run(async () =>
                        {
                            try
                            {
                                await _parent.PollPlanBattleOnceAsync(ct);
                                await _parent.InvokeAsync(_parent.StateHasChanged);
                            }
                            catch (Exception) { }
                        }, ct));
                    }

                    // Debug信息轮询
                    if (_debugPollingActive && now >= nextDebugPoll)
                    {
                        nextDebugPoll = now.AddMilliseconds(_debugPollInterval);
                        tasks.Add(Task.Run(async () =>
                        {
                            try
                            {
                                await _parent.RefreshRuntimeDebug();
                                
                                // 检查战斗是否完成
                                if (_parent.stepStatus?.Completed == true && 
                                    _parent.stepMode != "continuous" && 
                                    _parent.stepMode != "dungeonloop")
                                {
                                    StopDebugPolling();
                                }
                            }
                            catch (Exception ex) when (ex is not TaskCanceledException)
                            {
                                _parent.stepError = $"Debug 轮询异常: {ex.Message}";
                            }
                        }, ct));
                    }

                    // 等待所有任务完成
                    if (tasks.Count > 0)
                    {
                        await Task.WhenAll(tasks);
                    }

                    // 计算下一次轮询的等待时间
                    var nextPoll = new[] { nextStepPoll, nextPlanPoll, nextDebugPoll }
                        .Where(t => (t == nextStepPoll && _stepBattleActive) ||
                                   (t == nextPlanPoll && _planBattleActive) ||
                                   (t == nextDebugPoll && _debugPollingActive))
                        .DefaultIfEmpty(DateTime.UtcNow.AddSeconds(1))
                        .Min();

                    var delay = (int)Math.Max(50, (nextPoll - DateTime.UtcNow).TotalMilliseconds);
                    await Task.Delay(delay, ct);
                }
            }
            catch (TaskCanceledException) { }
            finally
            {
                _isPolling = false;
            }
        }

        /// <summary>
        /// 启动进度条动画定时器
        /// </summary>
        private void StartAnimationTimer()
        {
            if (_animationTimer != null) return;

            _animationTimer = new System.Threading.Timer(_ =>
            {
                _parent.InvokeAsync(_parent.StateHasChanged);
            }, null, TimeSpan.FromMilliseconds(AnimationInterval), TimeSpan.FromMilliseconds(AnimationInterval));
        }

        /// <summary>
        /// 停止进度条动画定时器
        /// </summary>
        private void StopAnimationTimer()
        {
            _animationTimer?.Dispose();
            _animationTimer = null;
        }

        /// <summary>
        /// 停止所有轮询任务
        /// </summary>
        public void StopAll()
        {
            _stepBattleActive = false;
            _planBattleActive = false;
            _debugPollingActive = false;
            
            _mainCts?.Cancel();
            _isPolling = false;
            
            StopAnimationTimer();
        }

        public void Dispose()
        {
            StopAll();
            _mainCts?.Dispose();
        }
    }

    // 轮询协调器实例
    private BattlePollingCoordinator? _pollingCoordinator;

    /// <summary>
    /// 获取或创建轮询协调器
    /// </summary>
    private BattlePollingCoordinator GetPollingCoordinator()
    {
        return _pollingCoordinator ??= new BattlePollingCoordinator(this);
    }

    /// <summary>
    /// 活动计划战斗轮询的单次执行
    /// </summary>
    private async Task PollPlanBattleOnceAsync(CancellationToken ct)
    {
        var runningPlan = characterPlans?.FirstOrDefault(p => p.State == 1);
        if (runningPlan?.BattleId == null) return;

        var newBattleStatus = await Api.GetStepBattleStatusAsync(runningPlan.BattleId.Value, "sampled", ct);
        
        // 更新攻击间隔追踪
        if (newBattleStatus != null)
        {
            UpdateProgressTracking(
                ref _planAttackInterval, 
                ref _planPrevNextAttackAt, 
                newBattleStatus.NextAttackAt,
                ref _planLastUpdateTime);
            
            UpdateProgressTracking(
                ref _planSpecialInterval, 
                ref _planPrevNextSpecialAt, 
                newBattleStatus.NextSpecialAt,
                ref _planLastUpdateTime);
            
            currentPlanBattle = newBattleStatus;
        }
        
        // 同时刷新计划列表以获取最新的ExecutedSeconds
        if (lastCreated is not null)
        {
            characterPlans = await Api.GetCharacterPlansAsync(lastCreated.Id);
        }
        
        // 更新心跳时间（每次刷新计划状态时）
        await UpdateHeartbeatIfNeededAsync();
    }
    
    // ========== 新增：UI 组件辅助方法 ==========
    
    /// <summary>
    /// 获取 Step 战斗的模式信息文本
    /// </summary>
    private string? GetStepModeInfo(StepStatusResponse status)
    {
        if (status.Mode == "dungeonsingle" || status.Mode == "dungeonloop")
        {
            return $"[波次: {status.WaveIndex ?? 1} | 轮次: {status.RunCount ?? 0} | 怪物数: {status.Enemies?.Count ?? 0}]";
        }
        else if (status.Enemies?.Count > 0)
        {
            return $"[怪物数: {status.Enemies.Count}]";
        }
        return null;
    }
    
    /// <summary>
    /// 获取活动计划战斗的模式信息文本
    /// </summary>
    private string? GetPlanModeInfo(StepStatusResponse status)
    {
        if (status.Mode == "dungeonsingle" || status.Mode == "dungeonloop")
        {
            return $"[波次: {status.WaveIndex ?? 1} | 轮次: {status.RunCount ?? 0} | 怪物数: {status.Enemies?.Count ?? 0}]";
        }
        else if (status.Enemies?.Count > 0)
        {
            return $"[怪物数: {status.Enemies.Count}]";
        }
        return null;
    }
    
    /// <summary>
    /// 获取地下城的总波次数（硬编码，后续可从API获取）
    /// </summary>
    private int? GetTotalWaves(string? dungeonId)
    {
        // 暂时返回固定值，后续可以从地下城配置中获取
        if (string.IsNullOrEmpty(dungeonId)) return null;
        return dungeonId switch
        {
            "goblin_hideout" => 5,
            "forest_temple" => 7,
            _ => 5 // 默认5波
        };
    }
    
    /// <summary>
    /// 判断是否为Boss波次（简单判断：最后一波）
    /// </summary>
    private bool IsBossWave(int? waveIndex)
    {
        // 简单判断：如果已知总波次，判断是否为最后一波
        // 这里暂时硬编码，后续可以从地下城配置获取
        if (!waveIndex.HasValue) return false;
        return waveIndex.Value >= 5; // 假设第5波及以后可能是Boss
    }
}