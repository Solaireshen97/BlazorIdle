@page "/"
@using BlazorIdle.Shared.Models
@using BlazorIdle.Client.Services
@inject ApiClient Api
@inject IJSRuntime JS
@implements IDisposable

<h3>角色 & 战斗测试</h3>

<!-- 1) 创建角色 -->
<div class="panel">
    <h4>1. 创建角色</h4>
    <input @bind="newName" placeholder="角色名" />
    <select @bind="selectedProfession">
        @foreach (var p in Enum.GetValues<Profession>())
        {
            <option value="@p">@p</option>
        }
    </select>
    <button @onclick="CreateCharacter" disabled="@isBusy">创建</button>
    @if (lastCreated is not null)
    {
        <p>已创建: @lastCreated.Name (@lastCreated.Id)</p>
        <button class="btn btn-sm" @onclick="ResetBattleState" disabled="@isBusy">重置战斗状态</button>
    }
</div>

<!-- 2) 同步战斗 -->
@if (lastCreated is not null)
{
    <div class="panel">
        <h4>2. 发起战斗（同步一次性）</h4>
        时长(s): <input type="number" min="1" max="120" @bind="battleSeconds" style="width:80px" />
        敌人:
        <select @bind="selectedEnemyId" style="width:200px">
            @foreach (var e in enemyOptions)
            {
                <option value="@e.Id">@e.Name (@e.Id)</option>
            }
        </select>

        <button @onclick="StartBattle" disabled="@(!CanStartBattle)">开始战斗</button>
        @if (currentBattleId != Guid.Empty)
        {
            <p>当前 BattleId: @currentBattleId</p>
        }
    </div>
}

@if (currentBattleId != Guid.Empty || summary is not null)
{
    <div class="panel">
        <h4>3. 战斗结果@(battleInProgress ? "（进行中/轮询）" : "")</h4>
        <p>
            总伤害: @summary?.TotalDamage |
            时长: @summary?.DurationSeconds s |
            DPS: @summary?.Dps |
            段数: @summary?.SegmentCount
        </p>
        @if (summary is not null)
        {
            <p>Attack间隔: @summary.AttackIntervalSeconds | Special间隔: @summary.SpecialIntervalSeconds</p>
        }

        <button @onclick="ForceRefresh" disabled="@(isBusy || battleInProgress)">手动刷新</button>
        <button @onclick="LoadSegments" disabled="@(isBusy || segmentsLoading)">加载段详情</button>

        @if (segmentsLoading)
        {
            <p>加载段数据中...</p>
        }
        @if (segments is null)
        {
            <p>（尚未加载段数据）</p>
        }
        @if (segments?.Count > 0)
        {
            <table class="table">
                <thead>
                    <tr>
                        <th>#</th>
                        <th>Start-End</th>
                        <th>Events</th>
                        <th>Damage</th>
                        <th>Sources</th>
                        <th>Resources</th>
                    </tr>
                </thead>
                <tbody>
                    @for (int i = 0; i < segments.Count; i++)
                    {
                        var s = segments[i];
                        <tr>
                            <td>@i</td>
                            <td>@s.StartTime - @s.EndTime</td>
                            <td>@s.EventCount</td>
                            <td>@s.TotalDamage</td>
                            <td>
                                @foreach (var kv in s.DamageBySource)
                                {
                                    <span>@kv.Key:@kv.Value </span>
                                }
                            </td>
                            <td>
                                @foreach (var kv in s.ResourceFlow)
                                {
                                    <span>@kv.Key:@(kv.Value >= 0 ? "+" : "")@kv.Value </span>
                                }
                            </td>
                        </tr>
                    }
                </tbody>
            </table>
        }
    </div>
}

<!-- 4) 异步 Step 战斗（含运行态调试） -->
@if (lastCreated is not null)
{
    <div class="panel" style="margin-top: 18px;">
        <h4>4. 异步 Step 战斗（调试）</h4>

        <div class="row" style="gap:12px; align-items:end;">
            <div>
                <label>时长(s)</label>
                <input type="number" min="1" step="1" class="form-control" style="width:100px" @bind="stepSeconds" />
            </div>
            <div>
                <label>敌人数</label>
                <input type="number" min="1" step="1" class="form-control" style="width:100px" @bind="stepEnemyCount" />
            </div>
            <div>
                <label>Seed(可选)</label>
                <input class="form-control" style="width:160px" @bind="stepSeedInput" />
            </div>
            <div>
                <label>状态轮询(ms)</label>
                <input type="number" min="100" step="100" class="form-control" style="width:120px" @bind="stepPollMs" />
            </div>
            <div>
                <label>调试轮询(ms)</label>
                <input type="number" min="200" step="100" class="form-control" style="width:120px" @bind="stepDebugPollMs" />
            </div>
            <div style="display:flex;gap:8px;flex-wrap:wrap;">
                <button class="btn btn-primary" @onclick="StartStepBattle" disabled="@isBusy">Start Step</button>
                <button class="btn btn-secondary" @onclick="StopStepPolling" disabled="@(!stepIsPolling)">Stop Poll</button>
                <button class="btn btn-outline-danger" @onclick="ResetStep" disabled="@isBusy">Reset</button>
                <button class="btn btn-success" @onclick="StopAndSaveAsync" disabled="@(!stepBattleId.HasValue)">Stop &amp; Save</button>
                <button class="btn btn-outline-info" @onclick="RefreshRuntimeDebug" disabled="@(!stepBattleId.HasValue)">刷新运行态</button>
                <div class="form-check" style="display:flex;align-items:center;gap:6px;">
                    <input class="form-check-input" type="checkbox" id="chkAutoDbg"
                           @bind="stepAutoDebug"
                           @bind:after="OnAutoDebugChanged" />
                    <label class="form-check-label" for="chkAutoDbg">自动刷新运行态</label>
                </div>
            </div>
        </div>

        @if (!string.IsNullOrWhiteSpace(stepError))
        {
            <div class="alert alert-danger" style="margin-top:8px">@stepError</div>
        }

        @if (stepStatus is not null)
        {
            <div class="card" style="padding: 12px; margin-top: 12px;">
                <h5>Status</h5>
                <div class="row">
                    <div class="col-md-3"><b>BattleId:</b> @stepBattleId</div>
                    <div class="col-md-3"><b>SimSec:</b> @stepStatus.SimulatedSeconds.ToString("0.00")</div>
                    <div class="col-md-2"><b>DPS:</b> @stepStatus.Dps.ToString("0.00")</div>
                    <div class="col-md-2"><b>Segments:</b> @stepStatus.SegmentCount</div>
                    <div class="col-md-2"><b>Completed:</b> @(stepStatus.Completed ? "Yes" : "No")</div>
                </div>
                <div class="row">
                    <div class="col-md-4"><b>Seed:</b> @stepStatus.Seed</div>
                    <div class="col-md-4"><b>SeedIdx:</b> @stepStatus.SeedIndexStart - @stepStatus.SeedIndexEnd</div>
                    <div class="col-md-2"><b>Killed:</b> @(stepStatus.Killed ? "Yes" : "No")</div>
                    <div class="col-md-2"><b>KillTime:</b> @(stepStatus.KillTimeSeconds?.ToString("0.00") ?? "-")</div>
                </div>
                @if (stepStatus.PersistedBattleId is not null)
                {
                    <div class="row" style="margin-top:6px">
                        <div class="col-md-12">
                            <b>Persisted BattleId:</b> @stepStatus.PersistedBattleId
                            <button class="btn btn-sm btn-outline-primary" @onclick="() => OpenSummary(stepStatus.PersistedBattleId!.Value)">打开摘要</button>
                        </div>
                    </div>
                }
            </div>

            <div class="card" style="padding: 12px; margin-top: 12px;">
                <h5>Segments (@stepSegments.Count)</h5>
                <table class="table table-sm table-striped">
                    <thead>
                        <tr>
                            <th>#</th>
                            <th>Time</th>
                            <th>Events</th>
                            <th>Total</th>
                            <th>Top Source</th>
                            <th>Phys/Magic/True</th>
                        </tr>
                    </thead>
                    <tbody>
                        @foreach (var s in stepSegments)
                        {
                            var topSrc = s.DamageBySource.OrderByDescending(kv => kv.Value).FirstOrDefault();
                            var phys = s.DamageByType.TryGetValue("physical", out var pv) ? pv : 0;
                            var magic = s.DamageByType.TryGetValue("magic", out var mv) ? mv : 0;
                            var tru = s.DamageByType.TryGetValue("true", out var tv) ? tv : 0;
                            <tr>
                                <td>@s.Index</td>
                                <td>@s.StartTime.ToString("0.00") - @s.EndTime.ToString("0.00")</td>
                                <td>@s.EventCount</td>
                                <td>@s.TotalDamage</td>
                                <td>@(string.IsNullOrEmpty(topSrc.Key) ? "-" : $"{topSrc.Key}:{topSrc.Value}")</td>
                                <td>@phys / @magic / @tru</td>
                            </tr>
                        }
                    </tbody>
                </table>
            </div>

            <div class="card" style="padding: 12px; margin-top: 12px;">
                <h5>Runtime Debug</h5>
                @if (stepDebug is null)
                {
                    <div><i>点击“刷新运行态”或勾选“自动刷新运行态”查看。</i></div>
                }
                else
                {
                    <div class="row">
                        <div class="col-md-3"><b>Now:</b> @stepDebug.Now.ToString("0.00")</div>
                        <div class="col-md-3"><b>RNG Index:</b> @stepDebug.RngIndex</div>
                        <div class="col-md-3"><b>Scheduler:</b> @stepDebug.SchedulerCount</div>
                        <div class="col-md-3"><b>Enemy:</b> @stepDebug.Encounter.EnemyId (@stepDebug.Encounter.CurrentHp/@stepDebug.Encounter.EnemyMaxHp)</div>
                    </div>

                    <div class="row" style="margin-top:6px">
                        <div class="col-md-4"><b>SegmentStart:</b> @stepDebug.Collector.SegmentStart.ToString("0.00")</div>
                        <div class="col-md-4"><b>LastEventTime:</b> @stepDebug.Collector.LastEventTime.ToString("0.00")</div>
                        <div class="col-md-4"><b>EventCount:</b> @stepDebug.Collector.EventCount</div>
                    </div>

                    <h6 style="margin-top:10px">Tracks</h6>
                    <table class="table table-sm table-striped">
                        <thead><tr><th>Type</th><th>Base</th><th>Haste</th><th>Current</th><th>Next</th></tr></thead>
                        <tbody>
                            @foreach (var t in stepDebug.Tracks)
                            {
                                <tr>
                                    <td>@t.Type</td>
                                    <td>@t.BaseInterval.ToString("0.00")</td>
                                    <td>@t.HasteFactor.ToString("0.00")</td>
                                    <td>@t.CurrentInterval.ToString("0.00")</td>
                                    <td>@t.NextTriggerAt.ToString("0.00")</td>
                                </tr>
                            }
                        </tbody>
                    </table>

                    <h6>Resources</h6>
                    @if (stepDebug.Resources?.Count > 0)
                    {
                        <table class="table table-sm table-bordered" style="max-width:400px">
                            <thead><tr><th>Id</th><th>Current</th><th>Max</th></tr></thead>
                            <tbody>
                                @foreach (var kv in stepDebug.Resources)
                                {
                                    <tr><td>@kv.Key</td><td>@kv.Value.Current</td><td>@kv.Value.Max</td></tr>
                                }
                            </tbody>
                        </table>
                    }
                    else
                    {
                        <div><i>(无资源快照或未命中 rage/focus)</i></div>
                    }

                    <h6>Buffs (@stepDebug.Buffs.Count)</h6>
                    <table class="table table-sm table-striped">
                        <thead><tr><th>Id</th><th>Stacks</th><th>Expire</th><th>NextTick</th><th>TickIntv</th><th>HasteSnap</th><th>BasePerStack</th><th>Type</th><th>DmgType</th></tr></thead>
                        <tbody>
                            @foreach (var b in stepDebug.Buffs.OrderBy(x => x.Id))
                            {
                                <tr>
                                    <td>@b.Id</td>
                                    <td>@b.Stacks</td>
                                    <td>@b.ExpiresAt.ToString("0.00")</td>
                                    <td>@(b.NextTickAt?.ToString("0.00") ?? "-")</td>
                                    <td>@b.TickIntervalSeconds.ToString("0.00")</td>
                                    <td>@b.HasteSnapshot.ToString("0.00")</td>
                                    <td>@b.TickBasePerStack.ToString("0")</td>
                                    <td>@b.PeriodicType</td>
                                    <td>@b.PeriodicDamageType</td>
                                </tr>
                            }
                        </tbody>
                    </table>

                    <h6>Skills (@(stepDebug.AutoCast?.Skills?.Count ?? 0))</h6>
                    <div><b>GCDUntil:</b> @stepDebug.AutoCast.GlobalCooldownUntil.ToString("0.00") | <b>IsCasting:</b> @(stepDebug.AutoCast.IsCasting ? "Yes" : "No") | <b>CastingUntil:</b> @stepDebug.AutoCast.CastingUntil.ToString("0.00")</div>
                    <table class="table table-sm table-striped">
                        <thead><tr><th>Id</th><th>Prio</th><th>Charges</th><th>NextCharge</th><th>NextAvail</th><th>CD</th><th>Cast</th><th>GCD</th><th>OffGCD</th><th>Cost</th><th>DMGType</th></tr></thead>
                        <tbody>
                            @foreach (var s in stepDebug.AutoCast.Skills.OrderBy(x => x.Priority))
                            {
                                <tr>
                                    <td>@s.Id</td>
                                    <td>@s.Priority</td>
                                    <td>@s.Charges/@s.MaxCharges</td>
                                    <td>@(s.NextChargeReadyAt?.ToString("0.00") ?? "-")</td>
                                    <td>@s.NextAvailableTime.ToString("0.00")</td>
                                    <td>@s.CooldownSeconds.ToString("0.00")</td>
                                    <td>@s.CastTimeSeconds.ToString("0.00")</td>
                                    <td>@s.GcdSeconds.ToString("0.00")</td>
                                    <td>@(s.OffGcd ? "Y" : "N")</td>
                                    <td>@(s.CostResourceId is null ? "-" : $"{s.CostResourceId}:{s.CostAmount}")</td>
                                    <td>@s.DamageType</td>
                                </tr>
                            }
                        </tbody>
                    </table>
                }
            </div>
        }
    </div>
}

@code {
    // ====== 创建/同步战斗 ======
    string newName = "TestWarrior";
    Profession selectedProfession = Profession.Warrior;

    private record EnemyOption(string Id, string Name);
    readonly EnemyOption[] enemyOptions = new[]
    {
        new EnemyOption("dummy", "Training Dummy"),
        new EnemyOption("tank", "Armored Golem"),
        new EnemyOption("magebane", "Magebane Warden"),
        new EnemyOption("paper", "Paper Slime"),
    };
    string selectedEnemyId = "dummy";

    bool isBusy;
    bool battleInProgress;
    bool segmentsLoading;
    CharacterCreated? lastCreated;
    Guid currentBattleId;
    double battleSeconds = 10;
    BattleSummaryDto? summary;
    List<BattleSegmentDto>? segments;
    System.Timers.Timer? pollTimer;

    bool CanStartBattle => !isBusy && lastCreated is not null && !battleInProgress;

    async Task CreateCharacter()
    {
        try
        {
            isBusy = true;
            lastCreated = await Api.CreateCharacterAsync(newName, selectedProfession);
            ResetBattleState();
        }
        finally { isBusy = false; }
    }

    void ResetBattleState()
    {
        battleInProgress = false;
        currentBattleId = Guid.Empty;
        summary = null;
        segments = null;
        StopPolling();
        StateHasChanged();
    }

    async Task StartBattle()
    {
        if (!CanStartBattle || lastCreated is null) return;
        try
        {
            isBusy = true;
            battleInProgress = true;
            summary = null;
            segments = null;

            var resp = await Api.StartBattleAsync(lastCreated.Id, battleSeconds, enemyId: selectedEnemyId);
            currentBattleId = resp.BattleId;

            await RefreshSummary();
            await LoadSegments();
            battleInProgress = false;
        }
        finally
        {
            isBusy = false;
            StateHasChanged();
        }
    }

    void StartPolling()
    {
        StopPolling();
        pollTimer = new System.Timers.Timer(1500);
        pollTimer.Elapsed += async (_, _) => await InvokeAsync(async () =>
        {
            await RefreshSummary();
            StateHasChanged();
        });
        pollTimer.AutoReset = true;
        pollTimer.Start();
    }

    void StopPolling()
    {
        pollTimer?.Stop();
        pollTimer?.Dispose();
        pollTimer = null;
    }

    async Task RefreshSummary()
    {
        if (currentBattleId == Guid.Empty) return;
        summary = await Api.GetBattleSummaryAsync(currentBattleId);
    }

    async Task LoadSegments()
    {
        if (currentBattleId == Guid.Empty) return;
        try
        {
            segmentsLoading = true;
            segments = await Api.GetBattleSegmentsAsync(currentBattleId);
        }
        finally { segmentsLoading = false; }
    }

    async Task ForceRefresh()
    {
        if (battleInProgress) return;
        try { isBusy = true; await RefreshSummary(); }
        finally { isBusy = false; }
    }

    // ====== Step 战斗（含运行态调试）======
    Guid? stepBattleId;
    double stepSeconds = 20;
    int stepEnemyCount = 1;
    string? stepSeedInput = null;
    int stepPollMs = 500;

    StepBattleStatusDto? stepStatus;
    List<StepBattleSegmentDto> stepSegments = new();
    Dictionary<string, int> stepAggBySource = new();
    Dictionary<string, int> stepAggByType = new();

    CancellationTokenSource? _stepPollCts;
    bool stepIsPolling;
    int _stepSinceIndex = 0;
    string? stepError;

    // debug
    StepBattleDebugDto? stepDebug;
    bool stepAutoDebug = false;
    int stepDebugPollMs = 1000;
    CancellationTokenSource? _stepDebugCts;

    async Task StartStepBattle()
    {
        stepError = null;
        if (lastCreated is null) { stepError = "请先创建角色"; return; }
        if (stepSeconds <= 0) stepSeconds = 1;
        if (stepEnemyCount < 1) stepEnemyCount = 1;

        try
        {
            isBusy = true;

            ulong? seed = null;
            if (ulong.TryParse(stepSeedInput, out var seedVal))
                seed = seedVal;

            var resp = await Api.StartStepBattleAsync(
                lastCreated!.Id,
                seconds: stepSeconds,
                enemyId: selectedEnemyId,
                enemyCount: stepEnemyCount,
                seed: seed);

            stepBattleId = resp.BattleId;
            _stepSinceIndex = 0;
            stepSegments.Clear();
            stepAggBySource.Clear();
            stepAggByType.Clear();
            stepStatus = null;
            stepDebug = null;

            _ = StartStepPollingAsync();
            if (stepAutoDebug) _ = StartDebugAutoPollingAsync();
            await InvokeAsync(StateHasChanged);
        }
        catch (Exception ex)
        {
            stepError = $"StartStep 异常: {ex.Message}";
        }
        finally { isBusy = false; }
    }

    async Task StartStepPollingAsync()
    {
        if (stepBattleId is null) return;
        _stepPollCts?.Cancel();
        _stepPollCts = new CancellationTokenSource();
        stepIsPolling = true;

        try
        {
            while (!_stepPollCts.IsCancellationRequested)
            {
                await PollStepOnceAsync(_stepPollCts.Token);
                await InvokeAsync(StateHasChanged);
                if (stepStatus?.Completed == true) break;
                await Task.Delay(stepPollMs, _stepPollCts.Token);
            }
        }
        catch (TaskCanceledException) { }
        catch (Exception ex) { stepError = $"轮询异常: {ex.Message}"; }
        finally
        {
            stepIsPolling = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    async Task PollStepOnceAsync(CancellationToken ct)
    {
        if (stepBattleId is null) return;

        var s = await Api.GetStepBattleStatusAsync(stepBattleId.Value, ct);
        if (s is not null) stepStatus = s;

        var segList = await Api.GetStepBattleSegmentsAsync(stepBattleId.Value, _stepSinceIndex, ct);
        if (segList is { Count: > 0 })
        {
            foreach (var seg in segList)
            {
                stepSegments.Add(seg);
                foreach (var kv in seg.DamageBySource)
                {
                    if (!stepAggBySource.ContainsKey(kv.Key)) stepAggBySource[kv.Key] = 0;
                    stepAggBySource[kv.Key] += kv.Value;
                }
                foreach (var kv in seg.DamageByType)
                {
                    if (!stepAggByType.ContainsKey(kv.Key)) stepAggByType[kv.Key] = 0;
                    stepAggByType[kv.Key] += kv.Value;
                }
            }
            _stepSinceIndex = stepSegments.Count;
        }
    }

    void StopStepPolling()
    {
        _stepPollCts?.Cancel();
        stepIsPolling = false;
        StateHasChanged();
    }

    void ResetStep()
    {
        StopStepPolling();
        StopDebugAutoPolling();
        stepBattleId = null;
        stepStatus = null;
        stepSegments.Clear();
        stepAggBySource.Clear();
        stepAggByType.Clear();
        stepDebug = null;
        stepError = null;
        _stepSinceIndex = 0;
        StateHasChanged();
    }
    void OnAutoDebugChanged()
    {
        if (stepAutoDebug)
        {
            // fire-and-forget，不阻塞 UI
            _ = StartDebugAutoPollingAsync();
        }
        else
        {
            StopDebugAutoPolling();
        }
    }
    async Task StopAndSaveAsync()
    {
        if (stepBattleId is null) return;
        try
        {
            var resp = await Api.StopStepBattleAsync(stepBattleId.Value);
            StopStepPolling();
            StopDebugAutoPolling();
            if (stepStatus is not null)
                stepStatus.PersistedBattleId = resp.PersistedBattleId;
            await InvokeAsync(StateHasChanged);
        }
        catch (Exception ex)
        {
            stepError = $"Stop & Save 异常: {ex.Message}";
        }
    }

    async Task RefreshRuntimeDebug()
    {
        if (stepBattleId is null) return;
        try
        {
            stepDebug = await Api.GetStepBattleDebugAsync(stepBattleId.Value);
            await InvokeAsync(StateHasChanged);
        }
        catch (Exception ex)
        {
            stepError = $"Debug 异常: {ex.Message}";
        }
    }

    void ToggleAutoDebug(ChangeEventArgs e)
    {
        if (stepAutoDebug)
        {
            // 启动后台轮询（fire-and-forget，不阻塞 UI）
            _ = StartDebugAutoPollingAsync();
        }
        else
        {
            StopDebugAutoPolling();
        }
    }

    async Task StartDebugAutoPollingAsync()
    {
        if (stepBattleId is null) return;
        _stepDebugCts?.Cancel();
        _stepDebugCts = new CancellationTokenSource();
        try
        {
            while (!_stepDebugCts.IsCancellationRequested)
            {
                await RefreshRuntimeDebug();
                if (stepStatus?.Completed == true) break;
                await Task.Delay(stepDebugPollMs, _stepDebugCts.Token);
            }
        }
        catch (TaskCanceledException) { }
        catch (Exception ex) { stepError = $"Debug 轮询异常: {ex.Message}"; }
    }

    void StopDebugAutoPolling()
    {
        _stepDebugCts?.Cancel();
    }

    async Task OpenSummary(Guid id)
    {
        var url = $"/api/battles/{id}/summary";
        await JS.InvokeVoidAsync("open", url, "_blank");
    }

    public void Dispose()
    {
        StopPolling();
        StopStepPolling();
        StopDebugAutoPolling();
    }
}