@page "/"
@using BlazorIdle.Shared.Models
@using BlazorIdle.Client.Services
@inject ApiClient Api
@implements IDisposable

<h3>角色 & 战斗测试</h3>

<div class="panel">
    <h4>1. 创建角色</h4>
    <input @bind="newName" placeholder="角色名" />
    <select @bind="selectedProfession">
        @foreach (var p in Enum.GetValues<Profession>())
        {
            <option value="@p">@p</option>
        }
    </select>
    <button @onclick="CreateCharacter" disabled="@isBusy">创建</button>
    @if (lastCreated is not null)
    {
        <p>已创建: @lastCreated.Name (@lastCreated.Id)</p>
        <button class="btn btn-sm" @onclick="ResetBattleState" disabled="@isBusy">重置战斗状态</button>
    }
</div>

@if (lastCreated is not null)
{
    <div class="panel">
        <h4>2. 发起战斗（同步一次性）</h4>
        时长(s):
        <input type="number" min="1" max="120" @bind="battleSeconds" style="width:80px" />

        <!-- 新增：选择敌人 -->
        敌人:
        <select @bind="selectedEnemyId" style="width:200px">
            @foreach (var e in enemyOptions)
            {
                <option value="@e.Id">@e.Name (@e.Id)</option>
            }
        </select>

        <button @onclick="StartBattle" disabled="@(!CanStartBattle)">开始战斗</button>
        @if (currentBattleId != Guid.Empty)
        {
            <p>当前 BattleId: @currentBattleId</p>
        }
        @if (!battleInProgress && currentBattleId != Guid.Empty)
        {
            <button class="btn btn-sm" @onclick="StartAnotherBattle" disabled="@isBusy">
                再次战斗
            </button>
        }
    </div>
}

@if (currentBattleId != Guid.Empty || summary is not null)
{
    <div class="panel">
        <h4>3. 战斗结果@(battleInProgress ? "（进行中/轮询）" : "")</h4>
        <p>
            总伤害: @summary?.TotalDamage |
            时长: @summary?.DurationSeconds s |
            DPS: @summary?.Dps |
            段数: @summary?.SegmentCount|
            @if (summary is not null)
            {
            <p>Attack间隔: @summary.AttackIntervalSeconds | Special间隔: @summary.SpecialIntervalSeconds</p>
        }
        </p>

        <p>DEBUG isBusy=@isBusy battleInProgress=@battleInProgress segmentsLoading=@segmentsLoading</p>
        <button @onclick="ForceRefresh" disabled="@(isBusy || battleInProgress)">手动刷新</button>
        <button @onclick="LoadSegments" disabled="@(isBusy || segmentsLoading)">加载段详情</button>

        @if (segmentsLoading)
        {
            <p>加载段数据中...</p>
        }
        @if (segments is null)
        {
            <p>（尚未加载段数据）</p>
        }
        @if (segments?.Count > 0)
        {
            <table class="table">
                <thead>
                    <tr>
                        <th>#</th>
                        <th>Start-End</th>
                        <th>Events</th>
                        <th>Damage</th>
                        <th>Sources</th>
                        <th>Resources</th>
                    </tr>
                </thead>
                <tbody>
                    @for (int i = 0; i < segments.Count; i++)
                    {
                        var s = segments[i];
                        <tr>
                            <td>@i</td>
                            <td>@s.StartTime - @s.EndTime</td>
                            <td>@s.EventCount</td>
                            <td>@s.TotalDamage</td>
                            <td>
                                @foreach (var kv in s.DamageBySource)
                                {
                                    <span>@kv.Key:@kv.Value </span>
                                }
                            </td>
                            <td>
                                @foreach (var kv in s.ResourceFlow)
                                {
                                    <span>@kv.Key:@(kv.Value >= 0 ? "+" : "")@kv.Value </span>
                                }
                            </td>
                        </tr>
                    }
                </tbody>
            </table>
        }
    </div>
}

@if (lastCreated is not null)
{
    <div class="panel" style="margin-top: 18px;">
        <h4>4. 异步 Step 战斗（调试最小版）</h4>

        <div class="row" style="gap:12px; align-items:end;">
            <div>
                <label>时长(s)</label>
                <input type="number" min="1" step="1" class="form-control" style="width:100px" @bind="stepSeconds" />
            </div>
            <div>
                <label>敌人数</label>
                <input type="number" min="1" step="1" class="form-control" style="width:100px" @bind="stepEnemyCount" />
            </div>
            <div>
                <label>Seed(可选)</label>
                <input class="form-control" style="width:160px" @bind="stepSeedInput" />
            </div>
            <div>
                <label>轮询(ms)</label>
                <input type="number" min="100" step="100" class="form-control" style="width:120px" @bind="stepPollMs" />
            </div>
            <div style="display:flex;gap:8px;">
                <button class="btn btn-primary" @onclick="StartStepBattle" disabled="@isBusy">Start Step</button>
                <button class="btn btn-secondary" @onclick="StopStepPolling" disabled="@(!stepIsPolling)">Stop Poll</button>
                <button class="btn btn-outline-danger" @onclick="ResetStep" disabled="@isBusy">Reset</button>
                <button class="btn btn-success" @onclick="StopAndSaveAsync" disabled="@(!stepBattleId.HasValue)">Stop &amp; Save</button>
            </div>
        </div>

        <div style="margin-top:8px;color:#666;">
            <small>说明：使用 /api/battles/step/* 接口，后台每帧推进。前端按间隔轮询状态与增量段。</small>
        </div>

        @if (!string.IsNullOrWhiteSpace(stepError))
        {
            <div class="alert alert-danger" style="margin-top:8px">@stepError</div>
        }

        @if (stepStatus is not null)
        {
            <div class="card" style="padding: 12px; margin-top: 12px;">
                <h5>Status</h5>
                <div class="row">
                    <div class="col-md-3"><b>BattleId:</b> @stepBattleId</div>
                    <div class="col-md-3"><b>SimSec:</b> @stepStatus.SimulatedSeconds.ToString("0.00")</div>
                    <div class="col-md-2"><b>DPS:</b> @stepStatus.Dps.ToString("0.00")</div>
                    <div class="col-md-2"><b>Segments:</b> @stepStatus.SegmentCount</div>
                    <div class="col-md-2"><b>Completed:</b> @(stepStatus.Completed ? "Yes" : "No")</div>
                </div>
                <div class="row">
                    <div class="col-md-4"><b>Seed:</b> @stepStatus.Seed</div>
                    <div class="col-md-4"><b>SeedIdx:</b> @stepStatus.SeedIndexStart - @stepStatus.SeedIndexEnd</div>
                    <div class="col-md-2"><b>Killed:</b> @(stepStatus.Killed ? "Yes" : "No")</div>
                    <div class="col-md-2"><b>KillTime:</b> @(stepStatus.KillTimeSeconds?.ToString("0.00") ?? "-")</div>
                </div>
                @if (stepStatus.PersistedBattleId is not null)
                {
                    <div class="row" style="margin-top:6px">
                        <div class="col-md-12">
                            <b>Persisted BattleId:</b> @stepStatus.PersistedBattleId
                            <button class="btn btn-sm btn-outline-primary" @onclick="() => OpenSummary(stepStatus.PersistedBattleId!.Value)">打开摘要</button>
                        </div>
                    </div>
                }
            </div>

            <div class="card" style="padding: 12px; margin-top: 12px;">
                <h5>Segments (@stepSegments.Count)</h5>
                <table class="table table-sm table-striped">
                    <thead>
                        <tr>
                            <th>#</th>
                            <th>Time</th>
                            <th>Events</th>
                            <th>Total</th>
                            <th>Top Source</th>
                            <th>Phys/Magic/True</th>
                        </tr>
                    </thead>
                    <tbody>
                        @foreach (var s in stepSegments)
                        {
                            var topSrc = s.DamageBySource.OrderByDescending(kv => kv.Value).FirstOrDefault();
                            var phys = s.DamageByType.TryGetValue("physical", out var pv) ? pv : 0;
                            var magic = s.DamageByType.TryGetValue("magic", out var mv) ? mv : 0;
                            var tru = s.DamageByType.TryGetValue("true", out var tv) ? tv : 0;
                            <tr>
                                <td>@s.Index</td>
                                <td>@s.StartTime.ToString("0.00") - @s.EndTime.ToString("0.00")</td>
                                <td>@s.EventCount</td>
                                <td>@s.TotalDamage</td>
                                <td>@(string.IsNullOrEmpty(topSrc.Key) ? "-" : $"{topSrc.Key}:{topSrc.Value}")</td>
                                <td>@phys / @magic / @tru</td>
                            </tr>
                        }
                    </tbody>
                </table>
            </div>

            <div class="card" style="padding: 12px; margin-top: 12px;">
                <h5>Aggregates</h5>
                <div class="row">
                    <div class="col-md-6">
                        <b>DamageBySource (sum across segments)</b>
                        <table class="table table-sm table-bordered">
                            <thead><tr><th>Source</th><th>Damage</th></tr></thead>
                            <tbody>
                                @foreach (var kv in stepAggBySource.OrderByDescending(x => x.Value))
                                {
                                    <tr><td>@kv.Key</td><td>@kv.Value</td></tr>
                                }
                            </tbody>
                        </table>
                    </div>
                    <div class="col-md-6">
                        <b>DamageByType (sum across segments)</b>
                        <table class="table table-sm table-bordered">
                            <thead><tr><th>Type</th><th>Damage</th></tr></thead>
                            <tbody>
                                <tr><td>physical</td><td>@(stepAggByType.TryGetValue("physical", out var p) ? p : 0)</td></tr>
                                <tr><td>magic</td><td>@(stepAggByType.TryGetValue("magic", out var m) ? m : 0)</td></tr>
                                <tr><td>true</td><td>@(stepAggByType.TryGetValue("true", out var t) ? t : 0)</td></tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        }
    </div>
}

@code {
    string newName = "TestWarrior";
    Profession selectedProfession = Profession.Warrior; // 默认值

    // 新增：敌人选项和当前选择（为快速测试，先用前端静态列表；后续可改为从后端拉取）
    private record EnemyOption(string Id, string Name);
    readonly EnemyOption[] enemyOptions = new[]
    {
        new EnemyOption("dummy", "Training Dummy"),
        new EnemyOption("tank", "Armored Golem"),
        new EnemyOption("magebane", "Magebane Warden"),
        new EnemyOption("paper", "Paper Slime"),
    };
    string selectedEnemyId = "dummy";

    bool isBusy;
    bool battleInProgress;
    bool segmentsLoading;
    CharacterCreated? lastCreated;
    Guid currentBattleId;
    double battleSeconds = 10;
    BattleSummaryDto? summary;
    List<BattleSegmentDto>? segments;
    System.Timers.Timer? pollTimer;

    bool CanStartBattle => !isBusy && lastCreated is not null && !battleInProgress;

    async Task CreateCharacter()
    {
        try
        {
            isBusy = true;
            lastCreated = await Api.CreateCharacterAsync(newName, selectedProfession);
            ResetBattleState(); // 创建时顺便清空旧战斗状态
        }
        finally
        {
            isBusy = false;
        }
    }

    void ResetBattleState()
    {
        battleInProgress = false;
        currentBattleId = Guid.Empty;
        summary = null;
        segments = null;
        StopPolling();
        StateHasChanged();
    }

    async Task StartBattle()
    {
        if (!CanStartBattle || lastCreated is null) return;
        try
        {
            isBusy = true;
            battleInProgress = true;
            summary = null;
            segments = null;

            // 传入所选敌人
            var resp = await Api.StartBattleAsync(lastCreated.Id, battleSeconds, enemyId: selectedEnemyId);
            currentBattleId = resp.BattleId;

            await RefreshSummary();
            await LoadSegments();
            battleInProgress = false;
        }
        finally
        {
            isBusy = false;
            StateHasChanged();
        }
    }

    async Task StartAnotherBattle()
    {
        ResetBattleState();
        await StartBattle();
    }

    void StartPolling()
    {
        StopPolling();
        pollTimer = new System.Timers.Timer(1500);
        pollTimer.Elapsed += async (_, _) =>
        {
            await InvokeAsync(async () =>
            {
                await RefreshSummary();
                StateHasChanged();
            });
        };
        pollTimer.AutoReset = true;
        pollTimer.Start();
    }

    void StopPolling()
    {
        pollTimer?.Stop();
        pollTimer?.Dispose();
        pollTimer = null;
    }

    async Task RefreshSummary()
    {
        if (currentBattleId == Guid.Empty) return;
        summary = await Api.GetBattleSummaryAsync(currentBattleId);
    }

    async Task LoadSegments()
    {
        if (currentBattleId == Guid.Empty) return;
        try
        {
            segmentsLoading = true;
            segments = await Api.GetBattleSegmentsAsync(currentBattleId);
        }
        finally
        {
            segmentsLoading = false;
        }
    }

    async Task ForceRefresh()
    {
        if (battleInProgress) return;
        try
        {
            isBusy = true;
            await RefreshSummary();
        }
        finally
        {
            isBusy = false;
        }
    }

    public void Dispose()
    {
        StopPolling();
        StopStepPolling();
    }

    // ===== 异步 Step 战斗（嵌入调试） =====

    Guid? stepBattleId;
    double stepSeconds = 20;
    int stepEnemyCount = 1;
    string? stepSeedInput = null;
    int stepPollMs = 500;

    StepBattleStatusDto? stepStatus;
    List<StepBattleSegmentDto> stepSegments = new();
    Dictionary<string, int> stepAggBySource = new();
    Dictionary<string, int> stepAggByType = new();

    CancellationTokenSource? _stepPollCts;
    bool stepIsPolling;
    int _stepSinceIndex = 0;
    string? stepError;

    async Task StartStepBattle()
    {
        stepError = null;
        if (lastCreated is null) { stepError = "请先创建角色"; return; }
        if (stepSeconds <= 0) stepSeconds = 1;
        if (stepEnemyCount < 1) stepEnemyCount = 1;

        try
        {
            isBusy = true;

            ulong? seed = null;
            if (ulong.TryParse(stepSeedInput, out var seedVal))
                seed = seedVal;

            var resp = await Api.StartStepBattleAsync(
                lastCreated!.Id,
                seconds: stepSeconds,
                enemyId: selectedEnemyId,
                enemyCount: stepEnemyCount,
                seed: seed);

            stepBattleId = resp.BattleId;
            _stepSinceIndex = 0;
            stepSegments.Clear();
            stepAggBySource.Clear();
            stepAggByType.Clear();
            stepStatus = null;

            _ = StartStepPollingAsync();
            await InvokeAsync(StateHasChanged);
        }
        catch (Exception ex)
        {
            stepError = $"StartStep 异常: {ex.Message}";
        }
        finally
        {
            isBusy = false;
        }
    }

    async Task StartStepPollingAsync()
    {
        if (stepBattleId is null) return;
        _stepPollCts?.Cancel();
        _stepPollCts = new CancellationTokenSource();
        stepIsPolling = true;

        try
        {
            while (!_stepPollCts.IsCancellationRequested)
            {
                await PollStepOnceAsync(_stepPollCts.Token);
                await InvokeAsync(StateHasChanged);
                if (stepStatus?.Completed == true) break;
                await Task.Delay(stepPollMs, _stepPollCts.Token);
            }
        }
        catch (TaskCanceledException) { }
        catch (Exception ex)
        {
            stepError = $"轮询异常: {ex.Message}";
        }
        finally
        {
            stepIsPolling = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    async Task PollStepOnceAsync(CancellationToken ct)
    {
        if (stepBattleId is null) return;

        var s = await Api.GetStepBattleStatusAsync(stepBattleId.Value, ct);
        if (s is not null)
            stepStatus = s;

        var segList = await Api.GetStepBattleSegmentsAsync(stepBattleId.Value, _stepSinceIndex, ct);
        if (segList is { Count: > 0 })
        {
            foreach (var seg in segList)
            {
                stepSegments.Add(seg);
                foreach (var kv in seg.DamageBySource)
                {
                    if (!stepAggBySource.ContainsKey(kv.Key)) stepAggBySource[kv.Key] = 0;
                    stepAggBySource[kv.Key] += kv.Value;
                }
                foreach (var kv in seg.DamageByType)
                {
                    if (!stepAggByType.ContainsKey(kv.Key)) stepAggByType[kv.Key] = 0;
                    stepAggByType[kv.Key] += kv.Value;
                }
            }
            _stepSinceIndex = stepSegments.Count;
        }
    }

    void StopStepPolling()
    {
        _stepPollCts?.Cancel();
        stepIsPolling = false;
        StateHasChanged();
    }

    void ResetStep()
    {
        StopStepPolling();
        stepBattleId = null;
        stepStatus = null;
        stepSegments.Clear();
        stepAggBySource.Clear();
        stepAggByType.Clear();
        stepError = null;
        _stepSinceIndex = 0;
    }

    async Task StopAndSaveAsync()
    {
        if (stepBattleId is null) return;
        try
        {
            var resp = await Api.StopStepBattleAsync(stepBattleId.Value);
            StopStepPolling(); // 停止轮询
            // 更新状态中的 PersistedBattleId
            if (stepStatus is not null)
                stepStatus.PersistedBattleId = resp.PersistedBattleId;

            await InvokeAsync(StateHasChanged);
        }
        catch (Exception ex)
        {
            stepError = $"Stop & Save 异常: {ex.Message}";
        }
    }

    void OpenSummary(Guid id)
    {
        // 简化处理：直接打开 API summary（如果你有专门前端页面可改为导航）
        //var url = $"/api/battles/{id}/summary";_ = Microsoft.JSInterop.JSHost.ImportAsync("open", "data:text/javascript,"); // 如果未引入 IJSRuntime 可忽略
    }
}