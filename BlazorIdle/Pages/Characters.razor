@page "/"
@using BlazorIdle.Services
@using BlazorIdle.Shared.Models
@using BlazorIdle.Client.Services
@using BlazorIdle.Components
@using BlazorIdle.Models
@inject ApiClient Api
@inject AuthService AuthService
@inject NavigationManager Navigation
@inject IJSRuntime JS
@inject BattleSignalRService SignalRService
@inject ProgressBarConfigService ConfigService
@inject IConfiguration Configuration
@implements IDisposable

<!-- 离线结算弹窗 -->
<OfflineSettlementDialog Result="@offlineCheckResult" OnClaim="@CloseOfflineSettlement" />

<!-- Toast 通知组件 -->
<ToastNotification @ref="toastNotification" />

<!-- 确认对话框组件 -->
<ConfirmDialog 
    Show="@showConfirmDialog"
    Title="@confirmDialogTitle"
    Message="@confirmDialogMessage"
    WarningText="@confirmDialogWarning"
    Type="@confirmDialogType"
    ConfirmButtonText="@confirmButtonText"
    OnConfirm="@OnConfirmDialogConfirm"
    OnCancel="@OnConfirmDialogCancel" />

@if (!isAuthenticated)
{
    <p>正在检查登录状态...</p>
}
else
{
<h3>角色 & 战斗测试</h3>

<!-- 用户信息显示 -->
@if (currentUser is not null)
{
    <div class="user-info-panel">
        <h5>👤 当前用户: @currentUser.Username</h5>
        <p>角色数量: @userCharacters.Count / 5</p>
    </div>
}

<!-- 0) 角色列表 -->
@if (userCharacters.Count > 0)
{
    <div class="panel">
        <h4>我的角色列表</h4>
        <div class="character-list">
            @foreach (var character in userCharacters)
            {
                var isSelected = selectedCharacter?.Id == character.Id;
                var cardClass = isSelected ? "character-card selected" : "character-card";
                <div class="@cardClass" @key="character.Id" @onclick="() => SelectCharacter(character)">
                    <h5>@character.Name @(isSelected ? "✓" : "")</h5>
                    <div><b>职业:</b> @character.Profession</div>
                    <div><b>等级:</b> @character.Level</div>
                    <div><b>顺序:</b> #@(character.RosterOrder + 1)</div>
                    <small>ID: @character.Id.ToString().Substring(0, 8)...</small>
                </div>
            }
        </div>
    </div>
}

<!-- 1) 创建角色 -->
<div class="panel">
    <h4>1. 创建角色</h4>
    <input @bind="newName" placeholder="角色名" />
    <select @bind="selectedProfession">
        @foreach (var p in Enum.GetValues<Profession>())
        {
            <option value="@p">@p</option>
        }
    </select>
    <button @onclick="CreateCharacter" disabled="@(isBusy || userCharacters.Count >= 5)">
        @(userCharacters.Count >= 5 ? "已达上限" : "创建")
    </button>
    @if (userCharacters.Count >= 5)
    {
        <p style="color: #dc3545;">已达到角色数量上限（最多5个角色）</p>
    }
    @if (lastCreated is not null)
    {
        <p>已创建: @lastCreated.Name (@lastCreated.Id)</p>
        <button class="btn btn-sm" @onclick="ResetBattleStateWithConfirm" disabled="@isBusy">重置战斗状态</button>
    }
</div>

<!-- 1.5) 背包界面 -->
@if (lastCreated is not null)
{
    <InventoryPanel CharacterId="@lastCreated.Id" CharacterName="@lastCreated.Name" />
}

<!-- 1.6) 装备系统界面（Step 5: 装备系统UI预留） -->
@if (lastCreated is not null)
{
    <EquipmentPanel 
        CharacterId="@lastCreated.Id" 
        IsLoading="@isLoadingEquipment"
        ErrorMessage="@equipmentError"
        Slots="@equipmentSlots"
        TotalStats="@equipmentStats" />
}

<!-- 1.7) 装备增强界面（Phase 7: 装备增强系统） -->
@if (lastCreated is not null)
{
    <EquipmentEnhancementPanel 
        CharacterId="@lastCreated.Id"
        IsLoading="@isLoadingEquipment"
        ErrorMessage="@equipmentError"
        InventoryItems="@GetInventoryItemsForEnhancement()"
        EquippedItems="@GetEquippedItemsForEnhancement()"
        ToastNotification="@toastNotification"
        OnItemsChanged="@RefreshEquipmentData" />
}

<!-- 1.8) 商店系统界面（Phase 5: 商店前端集成） -->
@if (lastCreated is not null)
{
    <ShopPanel 
        CharacterId="@lastCreated.Id.ToString()"
        OnPurchaseSuccess="@OnShopPurchaseSuccess" />
}

<!-- 2) 同步战斗 -->
@if (lastCreated is not null)
{
    <div class="panel">
        <h4>2. 发起战斗（同步一次性）</h4>
        时长(s): <input type="number" min="1" max="120" @bind="battleSeconds" style="width:80px" />
        敌人:
        <select @bind="selectedEnemyId" style="width:240px">
            @if (enemies?.Count > 0)
            {
                @foreach (var e in enemies)
                {
                    <option value="@e.Id">@e.Name (@e.Id)</option>
                }
            }
            else
            {
                <option value="dummy">Training Dummy (dummy)</option>
                <option value="tank">Armored Golem (tank)</option>
                <option value="magebane">Magebane Warden (magebane)</option>
                <option value="paper">Paper Slime (paper)</option>
            }
        </select>

        <button @onclick="StartBattle" disabled="@(!CanStartBattle)">开始战斗</button>
        @if (currentBattleId != Guid.Empty)
        {
            <p>当前 BattleId: @currentBattleId</p>
        }
    </div>
}

@if (currentBattleId != Guid.Empty || summary is not null)
{
    <div class="panel">
        <h4>3. 战斗结果@(battleInProgress ? "（进行中/轮询）" : "")</h4>
        <p>
            总伤害: @summary?.TotalDamage |
            时长: @summary?.DurationSeconds s |
            DPS: @summary?.Dps |
            段数: @summary?.SegmentCount
        </p>
        @if (summary is not null)
        {
            <p>Attack间隔: @summary.AttackIntervalSeconds | Special间隔: @summary.SpecialIntervalSeconds</p>
        }

        <div style="display:flex;gap:8px;flex-wrap:wrap;">
            <button class="btn btn-outline-secondary" @onclick="ForceRefresh" disabled="@(isBusy || battleInProgress)">手动刷新</button>
            <button class="btn btn-outline-primary" @onclick="LoadSegments" disabled="@(isBusy || segmentsLoading)">加载段详情</button>
            @if (summary is not null)
            {
                <button class="btn btn-success" @onclick="ReplayThisBattle">回放此战斗（Step）</button>
            }
        </div>

        @if (segmentsLoading)
        {
            <p>加载段数据中...</p>
        }
        @if (segments is null)
        {
            <p>（尚未加载段数据）</p>
        }
        @if (segments?.Count > 0)
        {
            <table class="table">
                <thead>
                    <tr>
                        <th>#</th>
                        <th>Start-End</th>
                        <th>Events</th>
                        <th>Damage</th>
                        <th>Sources</th>
                        <th>Resources</th>
                    </tr>
                </thead>
                <tbody>
                    @for (int i = 0; i < segments.Count; i++)
                    {
                        var s = segments[i];
                        <tr>
                            <td>@i</td>
                            <td>@s.StartTime - @s.EndTime</td>
                            <td>@s.EventCount</td>
                            <td>@s.TotalDamage</td>
                            <td>
                                @foreach (var kv in s.DamageBySource)
                                {
                                    <span>@kv.Key:@kv.Value </span>
                                }
                            </td>
                            <td>
                                @foreach (var kv in s.ResourceFlow)
                                {
                                    <span>@kv.Key:@(kv.Value >= 0 ? "+" : "")@kv.Value </span>
                                }
                            </td>
                        </tr>
                    }
                </tbody>
            </table>
        }
    </div>
}

<!-- 4) 活动计划管理 -->
@if (lastCreated is not null)
{
    <div class="panel" style="margin-top: 18px;">
        <h4>4. 活动计划管理</h4>

        <div class="form-row">
            <div>
                <label>活动类型</label>
                <select @bind="planActivityType">
                    <option value="combat">战斗 (Combat)</option>
                    <option value="dungeon">地下城 (Dungeon)</option>
                </select>
            </div>
            <div>
                <label>限制类型</label>
                <select @bind="planLimitType">
                    <option value="duration">时长限制</option>
                    <option value="infinite">无限制</option>
                </select>
            </div>
            <div>
                <label>时长(秒)</label>
                <input type="number" min="1" step="1" @bind="planLimitValue" disabled="@(planLimitType != "duration")" />
            </div>
            <div>
                <label>槽位</label>
                <input type="number" min="0" max="4" step="1" @bind="planSlotIndex" />
            </div>

            @if (planActivityType == "combat")
            {
                <div>
                    <label>敌人</label>
                    <select @bind="selectedEnemyId">
                        @if (enemies?.Count > 0)
                        {
                            @foreach (var e in enemies)
                            {
                                <option value="@e.Id">@e.Name (@e.Id)</option>
                            }
                        }
                        else
                        {
                            <option value="dummy">Training Dummy (dummy)</option>
                            <option value="tank">Armored Golem (tank)</option>
                            <option value="magebane">Magebane Warden (magebane)</option>
                            <option value="paper">Paper Slime (paper)</option>
                        }
                    </select>
                </div>
                <div>
                    <label>敌人数</label>
                    <input type="number" min="1" step="1" @bind="planEnemyCount" />
                </div>
            }
            else
            {
                <div>
                    <label>地下城ID</label>
                    <input @bind="planDungeonId" placeholder="intro_cave" />
                </div>
                <div style="display:flex;align-items:center;gap:6px; margin-top: 20px;">
                    <input type="checkbox" id="chkDungeonLoop" @bind="planDungeonLoop" />
                    <label for="chkDungeonLoop">循环模式</label>
                </div>
            }

            <div>
                <label>Seed(可选)</label>
                <input @bind="planSeedInput" />
            </div>
            <div class="button-group">
                <button class="btn btn-primary" @onclick="CreateActivityPlanAsync" disabled="@isBusy">创建计划</button>
                <button class="btn btn-outline-secondary" @onclick="RefreshPlansAsync" disabled="@isBusy">刷新列表</button>
            </div>
        </div>

        @if (characterPlans?.Count > 0)
        {
            <div class="card" style="padding: 12px;">
                <h5>活动计划列表 (@characterPlans.Count)</h5>
                <table class="table table-sm table-striped">
                    <thead>
                        <tr>
                            <th>ID</th>
                            <th>类型</th>
                            <th>状态</th>
                            <th>槽位</th>
                            <th>限制</th>
                            <th>执行时长</th>
                            <th>BattleId</th>
                            <th>操作</th>
                        </tr>
                    </thead>
                    <tbody>
                        @foreach (var plan in characterPlans.OrderBy(p => p.SlotIndex).ThenBy(p => p.CreatedAt))
                        {
                            var planKey = plan.Id;
                            var typeName = plan.Type == 1 ? "战斗" : plan.Type == 2 ? "地下城" : "未知";
                            var stateName = plan.State == 0 ? "待执行" : plan.State == 1 ? "执行中" : plan.State == 2 ? "已完成" : plan.State == 3 ? "已取消" : plan.State == 4 ? "已暂停" : "未知";
                            var stateClass = plan.State == 0 ? "text-warning" : plan.State == 1 ? "text-success" : plan.State == 2 ? "text-secondary" : plan.State == 3 ? "text-muted" : plan.State == 4 ? "text-info" : "text-muted";
                            var limitText = plan.LimitType == 2 ? "无限制" : $"{plan.LimitValue:F0}秒";
                            <tr @key="planKey">
                                <td><small>@plan.Id.ToString().Substring(0, 8)...</small></td>
                                <td>@typeName</td>
                                <td class="@stateClass"><b>@stateName</b></td>
                                <td>@plan.SlotIndex</td>
                                <td>@limitText</td>
                                <td>@plan.ExecutedSeconds.ToString("F0")秒</td>
                                <td>
                                    @if (plan.BattleId.HasValue)
                                    {
                                        <small>@plan.BattleId.Value.ToString().Substring(0, 8)...</small>
                                    }
                                    else
                                    {
                                        <span>-</span>
                                    }
                                </td>
                                <td>
                                    @if (plan.State == 1) // Running
                                    {
                                        <button class="btn btn-sm btn-warning" @onclick="() => StopPlanWithConfirm(plan.Id)" disabled="@isBusy">停止</button>
                                        @if (plan.BattleId.HasValue)
                                        {
                                            <button class="btn btn-sm btn-info" @onclick="() => ViewPlanBattleAsync(plan.BattleId.Value)" disabled="@isBusy">查看战斗</button>
                                        }
                                    }
                                    else if (plan.State == 0) // Pending
                                    {
                                        <button class="btn btn-sm btn-danger" @onclick="() => CancelPlanWithConfirm(plan.Id)" disabled="@isBusy">取消</button>
                                    }
                                    else if (plan.State == 4) // Paused
                                    {
                                        <button class="btn btn-sm btn-success" @onclick="() => ResumePlanAsync(plan.Id)" disabled="@isBusy">恢复</button>
                                        <button class="btn btn-sm btn-danger" @onclick="() => CancelPlanWithConfirm(plan.Id)" disabled="@isBusy">取消</button>
                                    }
                                    else if (plan.State == 2 || plan.State == 3) // Completed or Cancelled
                                    {
                                        <button class="btn btn-sm btn-outline-secondary" @onclick="() => DeletePlanWithConfirm(plan.Id)" disabled="@isBusy">删除</button>
                                    }
                                </td>
                            </tr>
                        }
                    </tbody>
                </table>
            </div>
        }
        else if (characterPlans is not null)
        {
            <p style="color: #999; font-style: italic; padding: 12px;">该角色暂无活动计划</p>
        }

        @if (currentPlanBattle is not null)
        {
            <div class="card" style="padding: 12px; margin-top: 12px;">
                <h5>当前计划战斗状态</h5>
                <div class="row">
                    <div class="col-md-3"><b>BattleId:</b> @currentPlanBattle.Id</div>
                    <div class="col-md-3"><b>SimSec:</b> @currentPlanBattle.SimulatedSeconds.ToString("0.00")</div>
                    <div class="col-md-2"><b>DPS:</b> @currentPlanBattle.Dps.ToString("0.00")</div>
                    <div class="col-md-2"><b>Segments:</b> @currentPlanBattle.SegmentCount</div>
                    <div class="col-md-2"><b>Completed:</b> @(currentPlanBattle.Completed ? "Yes" : "No")</div>
                </div>
                <div class="row" style="margin-top:6px">
                    <div class="col-md-4"><b>Mode:</b> @(currentPlanBattle.Mode ?? "duration")</div>
                    <div class="col-md-4"><b>Gold:</b> @currentPlanBattle.Gold, <b>Exp:</b> @currentPlanBattle.Exp</div>
                </div>
                    <!-- 战斗实况：使用新组件 -->
                    <div style="margin-top: 16px; padding-top: 12px; border-top: 1px solid #ddd;">
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px; margin-bottom: 16px;">
                            <!-- 玩家状态面板 -->
                            <PlayerStatusPanel 
                                CharacterName="@(selectedCharacter?.Name ?? "角色")"
                                Profession="@currentPlanBattle.Profession"
                                CurrentHp="@((int)(currentPlanBattle.PlayerMaxHp * currentPlanBattle.PlayerHpPercent))"
                                MaxHp="@currentPlanBattle.PlayerMaxHp"
                                HpPercent="@currentPlanBattle.PlayerHpPercent"
                                BattleDurationSeconds="@currentPlanBattle.SimulatedSeconds"
                                ShowAttackProgress="true"
                                NextAttackAt="@currentPlanBattle.NextAttackAt"
                                NextSpecialAt="@currentPlanBattle.NextSpecialAt"
                                CurrentTime="@currentPlanBattle.CurrentTime"
                                AttackProgress="@(CalculateSmoothProgress(currentPlanBattle.CurrentTime, currentPlanBattle.NextAttackAt ?? 0, _planAttackInterval, _planLastUpdateTime))"
                                SpecialProgress="@(CalculateSmoothProgress(currentPlanBattle.CurrentTime, currentPlanBattle.NextSpecialAt ?? 0, _planSpecialInterval, _planLastUpdateTime))" />
                            
                            <!-- 怪物状态面板 -->
                            <MonsterStatusPanel 
                                Enemies="@currentPlanBattle.Enemies"
                                ModeInfo="@GetPlanModeInfo(currentPlanBattle)"
                                MaxOtherEnemies="2" />
                        </div>
                        
                        <!-- Buff状态显示 -->
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px; margin-bottom: 16px;">
                            @if (currentPlanBattle.PlayerBuffs != null && currentPlanBattle.PlayerBuffs.Count > 0)
                            {
                                <BuffBarPanel 
                                    Buffs="@currentPlanBattle.PlayerBuffs"
                                    Title="🎭 增益效果"
                                    BackgroundColor="#e8f5e9"
                                    BorderColor="#66bb6a" />
                            }
                            @if (currentPlanBattle.EnemyBuffs != null && currentPlanBattle.EnemyBuffs.Count > 0)
                            {
                                <BuffBarPanel 
                                    Buffs="@currentPlanBattle.EnemyBuffs"
                                    Title="😈 敌方效果"
                                    BackgroundColor="#ffebee"
                                    BorderColor="#ef5350" />
                            }
                        </div>
                        
                        <!-- 技能状态显示（Step 4: 技能系统UI） -->
                        @if (currentPlanBattle.Skills != null && currentPlanBattle.Skills.Count > 0)
                        {
                            <SkillStatusPanel 
                                Skills="@currentPlanBattle.Skills"
                                Title="⚔️ 技能状态"
                                BackgroundColor="#fff3e0"
                                BorderColor="#ffb74d" />
                        }
                        
                        <!-- 地下城进度面板（仅地下城模式） -->
                        @if (currentPlanBattle.Mode == "dungeonsingle" || currentPlanBattle.Mode == "dungeonloop")
                        {
                            <DungeonProgressPanel 
                                DungeonName="@(currentPlanBattle.DungeonId ?? "未知地下城")"
                                WaveIndex="@currentPlanBattle.WaveIndex"
                                TotalWaves="@GetTotalWaves(currentPlanBattle.DungeonId)"
                                RunCount="@currentPlanBattle.RunCount"
                                IsBossWave="@IsBossWave(currentPlanBattle.WaveIndex)"
                                EnemyCount="@(currentPlanBattle.Enemies?.Count ?? 0)"
                                Gold="@currentPlanBattle.Gold"
                                Exp="@currentPlanBattle.Exp" />
                        }
                    </div>
            </div>
        }
    
    </div>
}

<!-- 5) 异步 Step 战斗（调试 - 保留原功能） -->
@if (lastCreated is not null)
{
    <div class="panel" style="margin-top: 18px;">
        <h4 @onclick="() => showStepBattle = !showStepBattle" style="cursor: pointer; user-select: none; display: flex; align-items: center; gap: 8px;">
            <span style="transition: transform 0.2s; display: inline-block; transform: rotate(@(showStepBattle ? "0deg" : "-90deg"));">▼</span>
            5. 异步 Step 战斗（调试）
        </h4>

        @if (showStepBattle)
        {
        <div class="form-row">
            <div>
                <label>模式</label>
                <select @bind="stepMode">
                    <option value="duration">Duration（按时长）</option>
                    <option value="continuous">Continuous（持续同怪）</option>
                    <option value="dungeonsingle">Dungeon（单次）</option>
                    <option value="dungeonloop">Dungeon Loop（循环）</option>
                </select>
            </div>
            <div>
                <label>时长(s)</label>
                <input type="number" min="1" step="1" @bind="stepSeconds" disabled="@(stepMode != "duration")" />
            </div>
            <div>
                <label>敌人数</label>
                <input type="number" min="1" step="1" @bind="stepEnemyCount" disabled="@(IsDungeonMode)" />
            </div>
            <div>
                <label>Seed(可选)</label>
                <input @bind="stepSeedInput" />
            </div>
            <div>
                <label>敌人</label>
                <select @bind="selectedEnemyId" disabled="@(IsDungeonMode)">
                    @if (enemies?.Count > 0)
                    {
                        @foreach (var e in enemies)
                        {
                            <option value="@e.Id">@e.Name (@e.Id)</option>
                        }
                    }
                    else
                    {
                        <option value="dummy">Training Dummy (dummy)</option>
                        <option value="tank">Armored Golem (tank)</option>
                        <option value="magebane">Magebane Warden (magebane)</option>
                        <option value="paper">Paper Slime (paper)</option>
                    }
                </select>
            </div>
            <div>
                <label>DungeonId</label>
                <input @bind="stepDungeonId" placeholder="intro_cave" disabled="@(stepMode == "duration" || stepMode == "continuous")" />
            </div>
            <div>
                <label>掉落模式</label>
                <select @bind="stepDropMode">
                    <option value="expected">expected</option>
                    <option value="sampled">sampled</option>
                </select>
            </div>
            <div>
                <label>状态轮询(ms)</label>
                <input type="number" min="100" step="100" @bind="stepPollMs" />
            </div>
            <div>
                <label>调试轮询(ms)</label>
                <input type="number" min="200" step="100" @bind="stepDebugPollMs" />
            </div>
            <div class="button-group">
                <button class="btn btn-primary" @onclick="StartStepBattle" disabled="@isBusy">Start Step</button>
                <button class="btn btn-secondary" @onclick="StopStepPolling" disabled="@(!stepIsPolling)">Stop Poll</button>
                <button class="btn btn-outline-danger" @onclick="ResetStep" disabled="@isBusy">Reset</button>
                <button class="btn btn-success" @onclick="StopAndSaveAsync" disabled="@(!stepBattleId.HasValue)">Stop &amp; Save</button>
                <button class="btn btn-outline-info" @onclick="RefreshRuntimeDebug" disabled="@(!stepBattleId.HasValue)">刷新运行态</button>
                <div style="display:flex;align-items:center;gap:6px;">
                    <input type="checkbox" id="chkAutoDbg" @bind="stepAutoDebug" @bind:after="OnAutoDebugChanged" />
                    <label for="chkAutoDbg">自动刷新运行态</label>
                </div>
            </div>
        </div>

        @if (stepStatus is not null)
        {
            <div class="card" style="padding: 12px; margin-top: 12px;">
                <h5>Status</h5>
                <div class="row">
                    <div class="col-md-3"><b>BattleId:</b> @stepBattleId</div>
                    <div class="col-md-3"><b>SimSec:</b> @stepStatus.SimulatedSeconds.ToString("0.00")</div>
                    <div class="col-md-2"><b>DPS:</b> @stepStatus.Dps.ToString("0.00")</div>
                    <div class="col-md-2"><b>Segments:</b> @stepStatus.SegmentCount</div>
                    <div class="col-md-2"><b>Completed:</b> @(stepStatus.Completed ? "Yes" : "No")</div>
                </div>
                <div class="row">
                    <div class="col-md-4"><b>Seed:</b> @stepStatus.Seed</div>
                    <div class="col-md-4"><b>SeedIdx:</b> @stepStatus.SeedIndexStart - @stepStatus.SeedIndexEnd</div>
                    <div class="col-md-2"><b>Killed:</b> @(stepStatus.Killed ? "Yes" : "No")</div>
                    <div class="col-md-2"><b>KillTime:</b> @(stepStatus.KillTimeSeconds?.ToString("0.00") ?? "-")</div>
                </div>
                <div class="row" style="margin-top:6px">
                    <div class="col-md-4"><b>Mode:</b> @(stepStatus.Mode ?? "duration")</div>
                    <div class="col-md-4"><b>Wave:</b> @(stepStatus.WaveIndex?.ToString() ?? "-")</div>
                    <div class="col-md-4"><b>RunCount:</b> @(stepStatus.RunCount?.ToString() ?? "0")</div>
                </div>
                @if (stepStatus.PersistedBattleId is not null)
                {
                    <div class="row" style="margin-top:6px">
                        <div class="col-md-12">
                            <b>Persisted BattleId:</b> @stepStatus.PersistedBattleId
                            <button class="btn btn-sm btn-outline-primary" @onclick="() => OpenSummary(stepStatus.PersistedBattleId!.Value)">打开摘要</button>
                        </div>
                    </div>
                }
                
                <!-- 战斗实况：使用新组件 -->
                <div style="margin-top: 16px; padding-top: 12px; border-top: 1px solid #ddd;">
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px; margin-bottom: 16px;">
                        <!-- 玩家状态面板 -->
                        <PlayerStatusPanel 
                            CharacterName="@(selectedCharacter?.Name ?? "角色")"
                            Profession="@stepStatus.Profession"
                            CurrentHp="@((int)(stepStatus.PlayerMaxHp * stepStatus.PlayerHpPercent))"
                            MaxHp="@stepStatus.PlayerMaxHp"
                            HpPercent="@stepStatus.PlayerHpPercent"
                            BattleDurationSeconds="@stepStatus.SimulatedSeconds"
                            ShowAttackProgress="true"
                            NextAttackAt="@stepStatus.NextAttackAt"
                            NextSpecialAt="@stepStatus.NextSpecialAt"
                            CurrentTime="@stepStatus.CurrentTime"
                            AttackProgress="@(CalculateSmoothProgress(stepStatus.CurrentTime, stepStatus.NextAttackAt ?? 0, _stepAttackInterval, _stepLastUpdateTime))"
                            SpecialProgress="@(CalculateSmoothProgress(stepStatus.CurrentTime, stepStatus.NextSpecialAt ?? 0, _stepSpecialInterval, _stepLastUpdateTime))" />
                        
                        <!-- 怪物状态面板 -->
                        <MonsterStatusPanel 
                            Enemies="@stepStatus.Enemies"
                            ModeInfo="@GetStepModeInfo(stepStatus)"
                            MaxOtherEnemies="4" />
                    </div>
                    
                    <!-- Buff状态显示 -->
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px; margin-bottom: 16px;">
                        @if (stepStatus.PlayerBuffs != null && stepStatus.PlayerBuffs.Count > 0)
                        {
                            <BuffBarPanel 
                                Buffs="@stepStatus.PlayerBuffs"
                                Title="🎭 增益效果"
                                BackgroundColor="#e8f5e9"
                                BorderColor="#66bb6a" />
                        }
                        @if (stepStatus.EnemyBuffs != null && stepStatus.EnemyBuffs.Count > 0)
                        {
                            <BuffBarPanel 
                                Buffs="@stepStatus.EnemyBuffs"
                                Title="😈 敌方效果"
                                BackgroundColor="#ffebee"
                                BorderColor="#ef5350" />
                        }
                    </div>
                    
                    <!-- 技能状态显示（Step 4: 技能系统UI） -->
                    @if (stepStatus.Skills != null && stepStatus.Skills.Count > 0)
                    {
                        <SkillStatusPanel 
                            Skills="@stepStatus.Skills"
                            Title="⚔️ 技能状态"
                            BackgroundColor="#fff3e0"
                            BorderColor="#ffb74d" />
                    }
                    
                    <!-- 地下城进度面板（仅地下城模式） -->
                    @if (stepStatus.Mode == "dungeonsingle" || stepStatus.Mode == "dungeonloop")
                    {
                        <DungeonProgressPanel 
                            DungeonName="@(stepStatus.DungeonId ?? "未知地下城")"
                            WaveIndex="@stepStatus.WaveIndex"
                            TotalWaves="@GetTotalWaves(stepStatus.DungeonId)"
                            RunCount="@stepStatus.RunCount"
                            IsBossWave="@IsBossWave(stepStatus.WaveIndex)"
                            EnemyCount="@(stepStatus.Enemies?.Count ?? 0)"
                            Gold="@stepStatus.Gold"
                            Exp="@stepStatus.Exp" />
                    }
                </div>
            </div>

            <div class="card" style="padding: 12px; margin-top: 12px;">
                <h5>收益</h5>
                <div><b>DropMode:</b> @stepDropMode</div>
                <div><b>Gold:</b> @stepStatus.Gold, <b>Exp:</b> @stepStatus.Exp</div>
                @if ((stepStatus.DropMode ?? stepDropMode) == "expected")
                {
                    <div>
                        <b>Loot (expected):</b>
                        <ul>
                            @foreach (var kv in stepStatus.LootExpected.OrderByDescending(kv => kv.Value))
                            {
                                <li>@kv.Key: @kv.Value.ToString("0.##")</li>
                            }
                        </ul>
                    </div>
                }
                else
                {
                    <div>
                        <b>Loot (sampled):</b>
                        <ul>
                            @foreach (var kv in stepStatus.LootSampled.OrderByDescending(kv => kv.Value))
                            {
                                <li>@kv.Key: @kv.Value</li>
                            }
                        </ul>
                    </div>
                }
            </div>

            <div class="card" style="padding: 12px; margin-top: 12px;">
                <h5>Segments (@stepSegments.Count)</h5>
                <table class="table table-sm table-striped">
                    <thead>
                        <tr>
                            <th>#</th>
                            <th>Time</th>
                            <th>Events</th>
                            <th>Total</th>
                            <th>Top Source</th>
                            <th>Phys/Magic/True</th>
                        </tr>
                    </thead>
                    <tbody>
                        @foreach (var s in stepSegments)
                        {
                            var topSrc = s.DamageBySource.OrderByDescending(kv => kv.Value).FirstOrDefault();
                            var phys = s.DamageByType.TryGetValue("physical", out var pv) ? pv : 0;
                            var magic = s.DamageByType.TryGetValue("magic", out var mv) ? mv : 0;
                            var tru = s.DamageByType.TryGetValue("true", out var tv) ? tv : 0;
                            <tr>
                                <td>@s.Index</td>
                                <td>@s.StartTime.ToString("0.00") - @s.EndTime.ToString("0.00")</td>
                                <td>@s.EventCount</td>
                                <td>@s.TotalDamage</td>
                                <td>@(string.IsNullOrEmpty(topSrc.Key) ? "-" : $"{topSrc.Key}:{topSrc.Value}")</td>
                                <td>@phys / @magic / @tru</td>
                            </tr>
                        }
                    </tbody>
                </table>
            </div>

            <div class="card" style="padding: 12px; margin-top: 12px;">
                <h5>Runtime Debug</h5>
                @if (stepDebug is null)
                {
                    <div><i>点击“刷新运行态”或勾选“自动刷新运行态”查看。</i></div>
                }
                else
                {
                    <div class="row">
                        <div class="col-md-3"><b>Now:</b> @stepDebug.Now.ToString("0.00")</div>
                        <div class="col-md-3"><b>RNG Index:</b> @stepDebug.RngIndex</div>
                        <div class="col-md-3"><b>Scheduler:</b> @stepDebug.SchedulerCount</div>
                        <div class="col-md-3"><b>Enemy:</b> @stepDebug.Encounter.EnemyId (@stepDebug.Encounter.CurrentHp/@stepDebug.Encounter.EnemyMaxHp)</div>
                    </div>

                    <div class="row" style="margin-top:6px">
                        <div class="col-md-4"><b>SegmentStart:</b> @stepDebug.Collector.SegmentStart.ToString("0.00")</div>
                        <div class="col-md-4"><b>LastEventTime:</b> @stepDebug.Collector.LastEventTime.ToString("0.00")</div>
                        <div class="col-md-4"><b>EventCount:</b> @stepDebug.Collector.EventCount</div>
                    </div>

                    <h6 style="margin-top:10px">Tracks</h6>
                    <table class="table table-sm table-striped">
                        <thead><tr><th>Type</th><th>Base</th><th>Haste</th><th>Current</th><th>Next</th></tr></thead>
                        <tbody>
                            @foreach (var t in stepDebug.Tracks)
                            {
                                <tr>
                                    <td>@t.Type</td>
                                    <td>@t.BaseInterval.ToString("0.00")</td>
                                    <td>@t.HasteFactor.ToString("0.00")</td>
                                    <td>@t.CurrentInterval.ToString("0.00")</td>
                                    <td>@t.NextTriggerAt.ToString("0.00")</td>
                                </tr>
                            }
                        </tbody>
                    </table>

                    <h6>Resources</h6>
                    @if (stepDebug.Resources?.Count > 0)
                    {
                        <table class="table table-sm table-bordered" style="max-width:400px">
                            <thead><tr><th>Id</th><th>Current</th><th>Max</th></tr></thead>
                            <tbody>
                                @foreach (var kv in stepDebug.Resources)
                                {
                                    <tr><td>@kv.Key</td><td>@kv.Value.Current</td><td>@kv.Value.Max</td></tr>
                                }
                            </tbody>
                        </table>
                    }
                    else
                    {
                        <div><i>(无资源快照或未命中 rage/focus)</i></div>
                    }

                    <h6>Buffs (@stepDebug.Buffs.Count)</h6>
                    <table class="table table-sm table-striped">
                        <thead><tr><th>Id</th><th>Stacks</th><th>Expire</th><th>NextTick</th><th>TickIntv</th><th>HasteSnap</th><th>BasePerStack</th><th>Type</th><th>DmgType</th></tr></thead>
                        <tbody>
                            @foreach (var b in stepDebug.Buffs.OrderBy(x => x.Id))
                            {
                                <tr>
                                    <td>@b.Id</td>
                                    <td>@b.Stacks</td>
                                    <td>@b.ExpiresAt.ToString("0.00")</td>
                                    <td>@(b.NextTickAt?.ToString("0.00") ?? "-")</td>
                                    <td>@b.TickIntervalSeconds.ToString("0.00")</td>
                                    <td>@b.HasteSnapshot.ToString("0.00")</td>
                                    <td>@b.TickBasePerStack.ToString("0")</td>
                                    <td>@b.PeriodicType</td>
                                    <td>@b.PeriodicDamageType</td>
                                </tr>
                            }
                        </tbody>
                    </table>

                    <h6>Skills (@(stepDebug.AutoCast?.Skills?.Count ?? 0))</h6>
                    <div><b>GCDUntil:</b> @(stepDebug.AutoCast?.GlobalCooldownUntil.ToString("0.00") ?? "N/A") | <b>IsCasting:</b> @(stepDebug.AutoCast?.IsCasting == true ? "Yes" : "No") | <b>CastingUntil:</b> @(stepDebug.AutoCast?.CastingUntil.ToString("0.00") ?? "N/A")</div>
                    <table class="table table-sm table-striped">
                        <thead><tr><th>Id</th><th>Prio</th><th>Charges</th><th>NextCharge</th><th>NextAvail</th><th>CD</th><th>Cast</th><th>GCD</th><th>OffGCD</th><th>Cost</th><th>DMGType</th></tr></thead>
                        <tbody>
                            @if (stepDebug.AutoCast?.Skills != null)
                            {
                                @foreach (var s in stepDebug.AutoCast.Skills.OrderBy(x => x.Priority))
                            {
                                <tr>
                                    <td>@s.Id</td>
                                    <td>@s.Priority</td>
                                    <td>@s.Charges/@s.MaxCharges</td>
                                    <td>@(s.NextChargeReadyAt?.ToString("0.00") ?? "-")</td>
                                    <td>@s.NextAvailableTime.ToString("0.00")</td>
                                    <td>@s.CooldownSeconds.ToString("0.00")</td>
                                    <td>@s.CastTimeSeconds.ToString("0.00")</td>
                                    <td>@s.GcdSeconds.ToString("0.00")</td>
                                    <td>@(s.OffGcd ? "Y" : "N")</td>
                                    <td>@(s.CostResourceId is null ? "-" : $"{s.CostResourceId}:{s.CostAmount}")</td>
                                    <td>@s.DamageType</td>
                                </tr>
                                }
                            }
                        </tbody>
                    </table>
                }
            </div>
        }
        }
    </div>
}

<!-- 战斗日志面板 -->
    @if (lastCreated is not null && _isSignalRConnected)
    {
        <div class="panel" style="margin-top: 18px;">
            <BattleLogPanel Messages="@_battleLogMessages"
                            DisplayLimit="@_maxBattleLogMessages"
                            OnClear="@ClearBattleLog" />
        </div>
    }

@if (lastCreated is not null)
{
    <div class="panel" style="margin-top: 18px;">
        <h4 @onclick="() => showSimulator = !showSimulator" style="cursor: pointer; user-select: none; display: flex; align-items: center; gap: 8px;">
            <span style="transition: transform 0.2s; display: inline-block; transform: rotate(@(showSimulator ? "0deg" : "-90deg"));">▼</span>
            6. 批量模拟器
        </h4>

        @if (showSimulator)
        {
        <div class="row" style="gap:12px; align-items:end;">
            <div>
                <label>模式</label>
                <select class="form-control" style="width:140px" @bind="simMode">
                    <option value="Kills">按击杀数</option>
                    <option value="Hours">按小时数</option>
                </select>
            </div>
            <div>
                <label>@(simMode == SimulateMode.Kills ? "击杀数" : "小时数")</label>
                <input type="number" min="1" step="1" class="form-control" style="width:140px" @bind="simValue" />
            </div>
            <div>
                <label>样本时长(s)</label>
                <input type="number" min="1" step="1" class="form-control" style="width:140px" @bind="simSampleSeconds" />
            </div>
            <div>
                <label>敌人数</label>
                <input type="number" min="1" step="1" class="form-control" style="width:120px" @bind="simEnemyCount" />
            </div>
            <div>
                <label>敌人</label>
                <select class="form-control" style="width:240px" @bind="selectedEnemyId">
                    @if (enemies?.Count > 0)
                    {
                        @foreach (var e in enemies)
                        {
                            <option value="@e.Id">@e.Name (@e.Id)</option>
                        }
                    }
                    else
                    {
                        <option value="dummy">Training Dummy (dummy)</option>
                        <option value="tank">Armored Golem (tank)</option>
                        <option value="magebane">Magebane Warden (magebane)</option>
                        <option value="paper">Paper Slime (paper)</option>
                    }
                </select>
            </div>
            <div>
                <label>Seed(可选)</label>
                <input class="form-control" style="width:200px" @bind="simSeedInput" />
            </div>
            <div style="display:flex;gap:8px;">
                <button class="btn btn-primary" @onclick="RunSimAsync" disabled="@isBusy">开始模拟</button>
            </div>
        </div>

        @if (simResult is not null)
        {
            <div class="card" style="padding: 12px; margin-top: 12px;">
                <h5>结果摘要</h5>
                <div class="row">
                    <div class="col-md-3"><b>总时长(s):</b> @simResult.TotalSimulatedSeconds.ToString("0.00")</div>
                    <div class="col-md-3"><b>总伤害:</b> @simResult.TotalDamage</div>
                    <div class="col-md-3"><b>平均 DPS:</b> @simResult.AvgDps.ToString("0.00")</div>
                    <div class="col-md-3"><b>样本数:</b> @simResult.Runs</div>
                </div>
                <div class="row">
                    <div class="col-md-3"><b>总击杀:</b> @simResult.TotalKills</div>
                    <div class="col-md-3"><b>每小时击杀:</b> @simResult.KillsPerHour.ToString("0.00")</div>
                    <div class="col-md-3"><b>TTK 平均:</b> @(simResult.AvgTtk?.ToString("0.00") ?? "-")</div>
                    <div class="col-md-3">
                        <b>TTK P50/P90/P95/P99:</b>
                        @(simResult.TtkP50?.ToString("0.00") ?? "-") /
                        @(simResult.TtkP90?.ToString("0.00") ?? "-") /
                        @(simResult.TtkP95?.ToString("0.00") ?? "-") /
                        @(simResult.TtkP99?.ToString("0.00") ?? "-")
                    </div>
                </div>
            </div>
        }
        }
    </div>
}
}

@code {
    // ====== 认证状态 ======
    private bool isAuthenticated = false;
    private UserInfoDto? currentUser;
    private List<UserCharacterDto> userCharacters = new();
    private UserCharacterDto? selectedCharacter;
    private ToastNotification? toastNotification;
    
    // ====== SignalR 状态 ======
    private bool _isSignalRConnected = false;
    private bool _isSignalREnabled = true;
    
    // ====== 战斗日志 ======
    private List<BattleLogMessage> _battleLogMessages = new();
    private int _maxBattleLogMessages = 100;  // 默认值，从配置文件加载
    
    // ====== 确认对话框 ======
    private bool showConfirmDialog = false;
    private string confirmDialogTitle = "";
    private string confirmDialogMessage = "";
    private string confirmDialogWarning = "";
    private ConfirmDialog.DialogType confirmDialogType = ConfirmDialog.DialogType.Danger;
    private string confirmButtonText = "确认";
    private Func<Task>? pendingConfirmAction;
    
    // ====== 折叠面板状态 ======
    private bool showStepBattle = false;     // Step战斗默认折叠
    private bool showSimulator = false;       // 模拟器默认折叠

    // ====== 离线战斗 ======
    private OfflineCheckResult? offlineCheckResult;
    private DateTime lastHeartbeatUpdate = DateTime.MinValue;
    
    // ====== 进度条配置 ======
    private ProgressBarConfig? _progressBarConfig;

    // ====== 创建/同步战斗 ======
    protected override async Task OnInitializedAsync()
    {
        try
        {
            // 检查登录状态
            await AuthService.InitializeAsync();
            if (!AuthService.IsAuthenticated)
            {
                Navigation.NavigateTo("/login", replace: true);
                return;
            }

            isAuthenticated = true;

            // 注册认证事件处理器（用于后续登录/登出时的 SignalR 连接管理）
            AuthService.OnAuthenticated += HandleAuthenticatedAsync;
            AuthService.OnUnauthenticated += HandleUnauthenticatedAsync;

            // 加载进度条配置
            _progressBarConfig = await ConfigService.GetConfigAsync();
            
            // 加载战斗消息配置
            _maxBattleLogMessages = Configuration.GetValue<int>("BattleMessages:MaxMessageHistory", 100);

            // 加载当前用户信息和角色列表
            await LoadUserDataAsync();

            try { enemies = await Api.GetEnemiesAsync() ?? new(); }
            catch (ApiAuthException)
            {
                // 认证错误已在API客户端中处理，只需导航到登录页
                Navigation.NavigateTo("/login", replace: true);
                return;
            }
            catch { enemies = new(); }
            
            // 登录后立即初始化 SignalR 连接（保持连接）
            await InitializeSignalRAsync();
        }
        catch (Exception ex)
        {
            toastNotification?.ShowError($"初始化失败: {ex.Message}");
        }
    }
    
    /// <summary>
    /// 初始化 SignalR 连接和事件处理器（登录后自动调用）
    /// </summary>
    private async Task InitializeSignalRAsync()
    {
        try
        {
            // 确保已认证
            if (!AuthService.IsAuthenticated)
            {
                Console.WriteLine("[SignalR] 未认证，跳过连接");
                return;
            }

            // 尝试连接到 SignalR Hub
            _isSignalRConnected = await SignalRService.ConnectAsync();
            
            if (_isSignalRConnected)
            {
                // 注册 SignalR 事件处理器
                SignalRService.OnStateChanged(HandleSignalRStateChanged);
                SignalRService.OnBattleEvent(HandleBattleEvent);
                Console.WriteLine("[SignalR] 连接成功，实时通知已启用");
                toastNotification?.ShowSuccess("✅ 实时通知已启用", "", 2000);
            }
            else
            {
                // SignalR 连接失败，降级到纯轮询模式
                _isSignalREnabled = false;
                Console.WriteLine("[SignalR] 连接失败，使用轮询模式");
                toastNotification?.ShowInfo("ℹ️ 使用轮询模式", "", 2000);
            }
        }
        catch (Exception ex)
        {
            // SignalR 连接异常，不影响主功能
            _isSignalREnabled = false;
            Console.WriteLine($"[SignalR] 初始化失败: {ex.Message}");
            toastNotification?.ShowWarning($"⚠️ 实时通知不可用: {ex.Message}", "", 3000);
        }
    }
    
    /// <summary>
    /// 处理认证成功事件（用于后续登录时重新连接 SignalR）
    /// </summary>
    private async Task HandleAuthenticatedAsync()
    {
        Console.WriteLine("[SignalR] 认证成功，正在连接...");
        await InitializeSignalRAsync();
    }
    
    /// <summary>
    /// 处理登出事件（断开 SignalR 连接）
    /// </summary>
    private async Task HandleUnauthenticatedAsync()
    {
        Console.WriteLine("[SignalR] 登出，断开连接");
        _isSignalRConnected = false;
        _isSignalREnabled = false;
        await SignalRService.DisposeAsync();
    }
    
    /// <summary>
    /// 处理 SignalR 状态变更事件
    /// </summary>
    private async void HandleSignalRStateChanged(StateChangedEvent evt)
    {
        try
        {
            // 记录事件（开发环境）
            Console.WriteLine($"[SignalR] 收到事件: {evt.EventType}, BattleId: {evt.BattleId}");
            
            // 根据事件类型显示通知
            ShowSignalRNotification(evt.EventType);
            
            // 触发立即轮询以获取最新状态
            await TriggerImmediatePollAsync(evt.BattleId);
            
            // 刷新 UI
            await InvokeAsync(StateHasChanged);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"[SignalR] 处理事件失败: {ex.Message}");
        }
    }
    
    /// <summary>
    /// 显示 SignalR 事件通知
    /// </summary>
    private void ShowSignalRNotification(string eventType)
    {
        switch (eventType)
        {
            case "PlayerDeath":
                toastNotification?.ShowWarning("💀 角色死亡", "5秒后复活", 3000);
                break;
            case "PlayerRevive":
                toastNotification?.ShowSuccess("✨ 角色已复活", "", 2000);
                break;
            case "EnemyKilled":
                toastNotification?.ShowSuccess("⚔️ 击杀敌人", "", 2000);
                break;
            case "TargetSwitched":
                toastNotification?.ShowInfo("🎯 目标切换", "", 2000);
                break;
        }
    }
    
    /// <summary>
    /// 触发立即轮询以获取最新状态
    /// </summary>
    private async Task TriggerImmediatePollAsync(Guid battleId)
    {
        try
        {
            // 如果是 Step 战斗，立即轮询
            if (stepBattleId.HasValue && stepBattleId.Value == battleId)
            {
                await PollStepOnceAsync(CancellationToken.None);
            }
            
            // 如果是活动计划战斗，立即轮询
            if (currentPlanBattle is not null && currentPlanBattle.Id == battleId)
            {
                await PollPlanBattleOnceAsync(CancellationToken.None);
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"[SignalR] 立即轮询失败: {ex.Message}");
        }
    }
    
    /// <summary>
    /// 处理 SignalR 战斗事件（轻量级增量事件）
    /// </summary>
    private async void HandleBattleEvent(object eventData)
    {
        try
        {
            // 处理战斗消息事件（AttackStarted, DamageApplied, DamageReceived等）
            HandleBattleMessageEvent(eventData);
            
            var config = _progressBarConfig?.SignalRIncrementalUpdate;
            if (config?.EnableIncrementalUpdate != true)
            {
                return;
            }

            // 根据事件类型处理增量更新
            switch (eventData)
            {
                case BlazorIdle.Shared.Models.AttackTickEventDto attackEvent:
                    if (config.EnableAttackTickUpdate)
                    {
                        await HandleAttackTickEvent(attackEvent);
                    }
                    break;
                    
                case BlazorIdle.Shared.Models.SkillCastCompleteEventDto skillEvent:
                    if (config.EnableSkillCastUpdate)
                    {
                        await HandleSkillCastCompleteEvent(skillEvent);
                    }
                    break;
                    
                case BlazorIdle.Shared.Models.DamageAppliedEventDto damageEvent:
                    if (config.EnableDamageAppliedUpdate)
                    {
                        await HandleDamageAppliedEvent(damageEvent);
                    }
                    break;
                    
                // 战斗循环优化 Task 3.3: 处理轨道进度重置事件
                case BlazorIdle.Shared.Models.TrackProgressResetEventDto resetEvent:
                    await HandleTrackProgressResetEvent(resetEvent);
                    break;
            }
        }
        catch (Exception ex)
        {
            if (_progressBarConfig?.Debug.LogSignalREvents == true)
            {
                Console.WriteLine($"[SignalR] 处理轻量事件失败: {ex.Message}");
            }
        }
    }
    
    /// <summary>
    /// 处理攻击触发事件（增量更新进度条）
    /// </summary>
    private async Task HandleAttackTickEvent(BlazorIdle.Shared.Models.AttackTickEventDto evt)
    {
        if (_progressBarConfig?.Debug.LogIncrementalUpdates == true)
        {
            Console.WriteLine($"[SignalR] AttackTick: NextAt={evt.NextTriggerAt:F2}, Interval={evt.Interval:F2}");
        }
        
        // 检查是否是当前战斗
        var isStepBattle = stepBattleId.HasValue && stepBattleId.Value == evt.BattleId;
        var isPlanBattle = currentPlanBattle is not null && currentPlanBattle.Id == evt.BattleId;
        
        if (!isStepBattle && !isPlanBattle)
        {
            return;
        }
        
        // 增量更新进度条状态
        if (isStepBattle && stepStatus is not null)
        {
            // 更新攻击进度跟踪
            UpdateProgressTracking(
                ref _stepAttackInterval,
                ref _stepPrevNextAttackAt,
                evt.NextTriggerAt,
                ref _stepLastUpdateTime
            );
            
            // 刷新 UI（不需要完整轮询）
            await InvokeAsync(StateHasChanged);
        }
        else if (isPlanBattle && currentPlanBattle is not null)
        {
            // 更新活动计划战斗进度
            UpdateProgressTracking(
                ref _planAttackInterval,
                ref _planPrevNextAttackAt,
                evt.NextTriggerAt,
                ref _planLastUpdateTime
            );
            
            // 刷新 UI
            await InvokeAsync(StateHasChanged);
        }
    }
    
    /// <summary>
    /// 处理技能施放完成事件
    /// </summary>
    private async Task HandleSkillCastCompleteEvent(BlazorIdle.Shared.Models.SkillCastCompleteEventDto evt)
    {
        if (_progressBarConfig?.Debug.LogIncrementalUpdates == true)
        {
            Console.WriteLine($"[SignalR] SkillCast: SkillId={evt.SkillId}, CompleteAt={evt.CastCompleteAt:F2}");
        }
        
        // 技能施放完成后，可能需要触发一次轻量轮询来更新技能冷却等状态
        // 但这里我们主要关注进度条，所以只记录日志
        await Task.CompletedTask;
    }
    
    /// <summary>
    /// 处理伤害应用事件
    /// </summary>
    private async Task HandleDamageAppliedEvent(BlazorIdle.Shared.Models.DamageAppliedEventDto evt)
    {
        if (_progressBarConfig?.Debug.LogIncrementalUpdates == true)
        {
            Console.WriteLine($"[SignalR] DamageApplied: Source={evt.Source}, Damage={evt.Damage}, Crit={evt.IsCrit}");
        }
        
        // 伤害事件可用于实时更新血量显示（如果需要）
        await Task.CompletedTask;
    }
    
    /// <summary>
    /// 战斗循环优化 Task 3.3: 处理轨道进度重置事件
    /// 用于前端实时响应轨道暂停/恢复状态
    /// </summary>
    private async Task HandleTrackProgressResetEvent(BlazorIdle.Shared.Models.TrackProgressResetEventDto evt)
    {
        try
        {
            Console.WriteLine($"[SignalR] TrackProgressReset: Reason={evt.ResetReason}, Tracks={string.Join(",", evt.TrackTypes)}");
            
            // 根据重置原因更新UI状态
            if (evt.ResetReason == "spawn_wait")
            {
                // 怪物全部死亡，进入等待刷新状态
                // 前端可以显示"等待刷新"提示，进度条显示为0或暂停状态
                Console.WriteLine("[CombatLoop] 轨道已暂停，等待怪物刷新");
            }
            else if (evt.ResetReason == "spawn_complete")
            {
                // 怪物刷新完成，轨道恢复
                // 前端重新开始显示进度
                Console.WriteLine("[CombatLoop] 轨道已恢复，怪物已刷新");
                
                // 如果提供了新的触发时间，更新追踪变量
                if (evt.NewTriggerTimes != null)
                {
                    foreach (var kvp in evt.NewTriggerTimes)
                    {
                        Console.WriteLine($"[CombatLoop] {kvp.Key} 新触发时间: {kvp.Value:F2}s");
                    }
                }
            }
            
            // 刷新UI显示
            await InvokeAsync(StateHasChanged);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"[SignalR] 处理轨道重置事件失败: {ex.Message}");
        }
    }
    
    /// <summary>
    /// 处理战斗消息事件（显示在战斗日志中）
    /// </summary>
    private void HandleBattleMessageEvent(object eventData)
    {
        try
        {
            switch (eventData)
            {
                case BlazorIdle.Shared.Models.AttackStartedEventDto attackStarted:
                    AddBattleLogMessage(new BattleLogMessage
                    {
                        Timestamp = DateTime.Now,
                        Text = attackStarted.Message,
                        Type = BattleLogMessageType.AttackStarted,
                        BattleId = attackStarted.BattleId
                    });
                    break;
                    
                case BlazorIdle.Shared.Models.DamageAppliedEventDto damageApplied:
                    AddBattleLogMessage(new BattleLogMessage
                    {
                        Timestamp = DateTime.Now,
                        Text = damageApplied.Message,
                        Type = BattleLogMessageType.DamageDealt,
                        IsCrit = damageApplied.IsCrit,
                        BattleId = damageApplied.BattleId
                    });
                    break;
                    
                case BlazorIdle.Shared.Models.DamageReceivedEventDto damageReceived:
                    AddBattleLogMessage(new BattleLogMessage
                    {
                        Timestamp = DateTime.Now,
                        Text = damageReceived.Message,
                        Type = BattleLogMessageType.DamageReceived,
                        BattleId = damageReceived.BattleId
                    });
                    break;
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"[BattleLog] 处理消息失败: {ex.Message}");
        }
    }
    
    /// <summary>
    /// 添加战斗日志消息
    /// </summary>
    private void AddBattleLogMessage(BattleLogMessage message)
    {
        _battleLogMessages.Add(message);
        
        // 限制消息历史数量（从配置文件读取）
        if (_battleLogMessages.Count > _maxBattleLogMessages)
        {
            _battleLogMessages.RemoveAt(0);
        }
        
        // 触发UI更新
        InvokeAsync(StateHasChanged);
    }
    
    /// <summary>
    /// 清空战斗日志
    /// </summary>
    private void ClearBattleLog()
    {
        _battleLogMessages.Clear();
        StateHasChanged();
    }

    async Task LoadUserDataAsync()
    {
        try
        {
            currentUser = await Api.GetCurrentUserAsync();
            if (currentUser is not null)
            {
                userCharacters = currentUser.Characters.OrderBy(c => c.RosterOrder).ToList();
                
                // 如果有角色，默认选中第一个
                if (userCharacters.Count > 0 && selectedCharacter is null)
                {
                    selectedCharacter = userCharacters[0];
                    // 用选中的角色作为 lastCreated 以便其他功能使用
                    lastCreated = new CharacterCreated(selectedCharacter.Id, selectedCharacter.Name);
                    
                    // 检查离线收益（会触发 RefreshPlansAsync）
                    await CheckOfflineRewardsAsync();
                }
                // 如果已经有选中的角色，刷新其计划列表
                else if (selectedCharacter is not null && lastCreated is not null)
                {
                    await RefreshPlansAsync();
                }
                
                toastNotification?.ShowInfo($"欢迎回来！你有 {userCharacters.Count} 个角色。", "", 2000);
            }
            else
            {
                // 用户数据不存在，可能是数据库被重置
                await AuthService.LogoutAsync();
                Navigation.NavigateTo("/login", replace: true);
                return;
            }
        }
        catch (Exception ex)
        {
            // 根据错误类型处理
            if (ex.Message.Contains("404") || ex.Message.Contains("401") || ex.Message.Contains("Unauthorized"))
            {
                // 用户不存在或未授权，执行自动登出
                await AuthService.LogoutAsync();
                Navigation.NavigateTo("/login", replace: true);
                return;
            }

            toastNotification?.ShowError($"加载用户数据失败: {ex.Message}");
        }
    }

    /// <summary>
    /// 检查离线收益（在角色加载时自动调用）
    /// 注意：现在心跳更新会自动触发离线检测和结算
    /// </summary>
    private async Task CheckOfflineRewardsAsync()
    {
        if (selectedCharacter is null) return;

        try
        {
            // 更新心跳时间（会自动触发离线检测和结算）
            var heartbeatResponse = await Api.UpdateHeartbeatAsync(selectedCharacter.Id);
            
            // 刷新计划列表（无论是否有离线时间都需要刷新以获取运行中的计划）
            await RefreshPlansAsync();
            
            // 如果心跳响应中包含离线结算结果，显示弹窗
            if (heartbeatResponse?.OfflineSettlement != null && heartbeatResponse.OfflineSettlement.HasOfflineTime)
            {
                offlineCheckResult = heartbeatResponse.OfflineSettlement;
                
                // 重新加载用户数据以更新金币和经验显示（因为收益已自动应用）
                await LoadUserDataAsync();
                
                // 再次刷新计划列表以获取最新状态
                await RefreshPlansAsync();
                
                // 如果计划未完成且下一个计划已启动，重新开始轮询
                if (heartbeatResponse.OfflineSettlement.NextPlanStarted && heartbeatResponse.OfflineSettlement.NextPlanId.HasValue)
                {
                    var nextPlan = characterPlans?.FirstOrDefault(p => p.Id == heartbeatResponse.OfflineSettlement.NextPlanId.Value);
                    if (nextPlan?.BattleId.HasValue == true)
                    {
                        _ = StartPlanPollingAsync(nextPlan.BattleId.Value);
                    }
                }
                // 如果计划未完成但没有启动下一个计划，检查当前运行中的计划
                else if (!heartbeatResponse.OfflineSettlement.PlanCompleted && heartbeatResponse.OfflineSettlement.HasRunningPlan)
                {
                    var runningPlan = characterPlans?.FirstOrDefault(p => p.State == 1); // State=1 is Running
                    if (runningPlan?.BattleId.HasValue == true)
                    {
                        _ = StartPlanPollingAsync(runningPlan.BattleId.Value);
                    }
                }
                
                await InvokeAsync(StateHasChanged);
            }
        }
        catch (Exception ex)
        {
            toastNotification?.ShowError($"检查离线收益失败: {ex.Message}");
        }
    }

    /// <summary>
    /// 关闭离线结算弹窗（收益已自动应用，不需要手动领取）
    /// </summary>
    private async Task CloseOfflineSettlement()
    {
        // 清除离线结算结果，关闭弹窗
        offlineCheckResult = null;
        await InvokeAsync(StateHasChanged);
    }

    /// <summary>
    /// 更新心跳时间（如果需要）
    /// 在计划任务刷新时也会调用，实现每2秒更新一次
    /// 注意：心跳更新会自动触发离线检测和结算
    /// </summary>
    private async Task UpdateHeartbeatIfNeededAsync()
    {
        if (selectedCharacter is null) return;

        // 每2秒更新一次心跳
        var now = DateTime.UtcNow;
        if ((now - lastHeartbeatUpdate).TotalSeconds < 2)
            return;

        try
        {
            var heartbeatResponse = await Api.UpdateHeartbeatAsync(selectedCharacter.Id);
            lastHeartbeatUpdate = now;
            
            // 如果心跳响应中包含离线结算结果（首次检测到离线），显示弹窗
            if (heartbeatResponse?.OfflineSettlement != null && 
                heartbeatResponse.OfflineSettlement.HasOfflineTime &&
                offlineCheckResult == null) // 避免重复弹窗
            {
                offlineCheckResult = heartbeatResponse.OfflineSettlement;
                
                // 重新加载用户数据以更新金币和经验显示
                await LoadUserDataAsync();
                
                // 刷新计划列表
                await RefreshPlansAsync();
                
                // 如果计划未完成且下一个计划已启动，重新开始轮询
                if (heartbeatResponse.OfflineSettlement.NextPlanStarted && heartbeatResponse.OfflineSettlement.NextPlanId.HasValue)
                {
                    var nextPlan = characterPlans?.FirstOrDefault(p => p.Id == heartbeatResponse.OfflineSettlement.NextPlanId.Value);
                    if (nextPlan?.BattleId.HasValue == true)
                    {
                        _ = StartPlanPollingAsync(nextPlan.BattleId.Value);
                    }
                }
                // 如果计划未完成但没有启动下一个计划，检查当前运行中的计划
                else if (!heartbeatResponse.OfflineSettlement.PlanCompleted && heartbeatResponse.OfflineSettlement.HasRunningPlan)
                {
                    var runningPlan = characterPlans?.FirstOrDefault(p => p.State == 1); // State=1 is Running
                    if (runningPlan?.BattleId.HasValue == true)
                    {
                        _ = StartPlanPollingAsync(runningPlan.BattleId.Value);
                    }
                }
                
                await InvokeAsync(StateHasChanged);
            }
        }
        catch
        {
            // 心跳更新失败不影响主流程
        }
    }

    void SelectCharacter(UserCharacterDto character)
    {
        selectedCharacter = character;
        lastCreated = new CharacterCreated(character.Id, character.Name);
        
        // 停止当前角色的所有轮询
        StopPlanPolling();
        currentPlanBattle = null;
        characterPlans = null;
        
        ResetBattleState();
        StateHasChanged();
        
        // 加载新角色的计划
        _ = RefreshPlansAsync();
    }

    string newName = "TestWarrior";
    Profession selectedProfession = Profession.Warrior;

    List<ApiClient.EnemyDto> enemies = new();
    string selectedEnemyId = "dummy";

    bool isBusy;
    bool battleInProgress;
    bool segmentsLoading;
    CharacterCreated? lastCreated;
    Guid currentBattleId;
    double battleSeconds = 10;
    BattleSummaryResponse? summary;
    List<BattleSegmentDto>? segments;
    System.Timers.Timer? pollTimer;

    // ====== 装备系统（Step 5: 装备系统UI预留） ======
    bool isLoadingEquipment = false;
    string equipmentError = "";
    List<EquipmentSlotDto> equipmentSlots = new();
    Dictionary<string, double> equipmentStats = new();
    List<EquipmentEnhancementPanel.InventoryItemDto> inventoryGearItems = new();

    bool CanStartBattle => !isBusy && lastCreated is not null && !battleInProgress;

    async Task CreateCharacter()
    {
        try 
        { 
            isBusy = true;
            
            // 检查是否已达上限
            if (userCharacters.Count >= 5)
            {
                toastNotification?.ShowWarning("已达到角色数量上限（最多5个角色）");
                return;
            }
            
            lastCreated = await Api.CreateCharacterAsync(newName, selectedProfession);
            
            // 重新加载用户角色列表
            await LoadUserDataAsync();
            
            // 选中新创建的角色
            var newChar = userCharacters.FirstOrDefault(c => c.Id == lastCreated.Id);
            if (newChar is not null)
            {
                selectedCharacter = newChar;
                toastNotification?.ShowSuccess($"角色 {newChar.Name} 创建成功！");
            }
            
            ResetBattleState();
            await RefreshPlansAsync();  // 加载角色的活动计划
            await LoadEquipmentAsync();  // 加载装备信息
        }
        catch (Exception ex)
        {
            toastNotification?.ShowError($"创建角色失败: {ex.Message}");
        }
        finally { isBusy = false; }
    }

    /// <summary>
    /// 加载装备信息（Step 5: 装备系统UI预留）
    /// </summary>
    async Task LoadEquipmentAsync()
    {
        if (lastCreated == null) return;

        isLoadingEquipment = true;
        equipmentError = "";
        try
        {
            // 加载已装备的装备
            var response = await Api.GetEquipmentAsync(lastCreated.Id);
            if (response != null)
            {
                equipmentSlots = response.Slots;
                equipmentStats = response.TotalStats;
            }

            // 加载背包中的装备（未装备）
            try
            {
                var inventoryResponse = await Api.GetInventoryGearAsync(lastCreated.Id);
                if (inventoryResponse?.Items != null)
                {
                    inventoryGearItems = inventoryResponse.Items
                        .Select(item => new EquipmentEnhancementPanel.InventoryItemDto
                        {
                            Id = item.Id,
                            Name = item.Name,
                            Icon = item.Icon,
                            Rarity = item.Rarity,
                            ItemLevel = item.ItemLevel
                        })
                        .ToList();
                }
            }
            catch
            {
                // 如果加载背包装备失败，只清空列表，不影响主装备加载
                inventoryGearItems = new();
            }
        }
        catch (Exception ex)
        {
            equipmentError = $"加载装备失败: {ex.Message}";
        }
        finally
        {
            isLoadingEquipment = false;
        }
    }

    /// <summary>
    /// 刷新装备数据（用于装备增强后的刷新）
    /// </summary>
    async Task RefreshEquipmentData()
    {
        await LoadEquipmentAsync();
        StateHasChanged();
    }

    /// <summary>
    /// 商店购买成功后的回调（刷新角色金币和背包）
    /// </summary>
    async Task OnShopPurchaseSuccess()
    {
        if (lastCreated is not null)
        {
            // 刷新装备数据（会同时刷新背包和角色信息）
            await RefreshEquipmentData();
            
            // 显示成功提示
            if (toastNotification is not null)
            {
                toastNotification.ShowSuccess("购买成功！");
            }
        }
    }

    /// <summary>
    /// 获取背包中的装备物品（用于装备增强面板）
    /// </summary>
    List<EquipmentEnhancementPanel.InventoryItemDto> GetInventoryItemsForEnhancement()
    {
        // 返回已加载的背包装备列表
        return inventoryGearItems;
    }

    /// <summary>
    /// 获取已装备的物品（用于装备增强面板）
    /// </summary>
    List<EquipmentEnhancementPanel.EquippedItemDto> GetEquippedItemsForEnhancement()
    {
        var equippedItems = new List<EquipmentEnhancementPanel.EquippedItemDto>();
        
        foreach (var slot in equipmentSlots)
        {
            if (slot.Item != null)
            {
                equippedItems.Add(new EquipmentEnhancementPanel.EquippedItemDto
                {
                    Id = slot.Item.Id,
                    Name = slot.Item.Name,
                    Icon = slot.Item.Icon,
                    Rarity = slot.Item.Rarity,
                    ItemLevel = slot.Item.ItemLevel,
                    TierLevel = slot.Item.Tier,
                    SlotName = slot.SlotName
                });
            }
        }
        
        return equippedItems;
    }

    /// <summary>
    /// 显示确认对话框
    /// </summary>
    private void ShowConfirmDialog(string title, string message, Func<Task> action, string warning = "", ConfirmDialog.DialogType type = ConfirmDialog.DialogType.Danger, string confirmText = "确认")
    {
        confirmDialogTitle = title;
        confirmDialogMessage = message;
        confirmDialogWarning = warning;
        confirmDialogType = type;
        confirmButtonText = confirmText;
        pendingConfirmAction = action;
        showConfirmDialog = true;
        StateHasChanged();
    }

    /// <summary>
    /// 确认对话框 - 确认回调
    /// </summary>
    private async Task OnConfirmDialogConfirm()
    {
        showConfirmDialog = false;
        if (pendingConfirmAction != null)
        {
            await pendingConfirmAction();
            pendingConfirmAction = null;
        }
    }

    /// <summary>
    /// 确认对话框 - 取消回调
    /// </summary>
    private Task OnConfirmDialogCancel()
    {
        showConfirmDialog = false;
        pendingConfirmAction = null;
        StateHasChanged();
        return Task.CompletedTask;
    }

    void ResetBattleState()
    {
        battleInProgress = false;
        currentBattleId = Guid.Empty;
        summary = null;
        segments = null;
        StopPolling();
        StateHasChanged();
    }
    
    /// <summary>
    /// 重置战斗状态（带确认）
    /// </summary>
    void ResetBattleStateWithConfirm()
    {
        ShowConfirmDialog(
            "重置战斗状态",
            "确定要重置当前战斗状态吗？这将清除当前战斗数据。",
            () => { ResetBattleState(); return Task.CompletedTask; },
            type: ConfirmDialog.DialogType.Warning,
            confirmText: "重置"
        );
    }

    async Task StartBattle()
    {
        if (!CanStartBattle || lastCreated is null) return;
        try
        {
            isBusy = true; battleInProgress = true; summary = null; segments = null;
            var resp = await Api.StartBattleAsync(lastCreated.Id, battleSeconds, enemyId: selectedEnemyId);
            currentBattleId = resp.BattleId;
            await RefreshSummary();
            await LoadSegments();
            battleInProgress = false;
        }
        finally { isBusy = false; StateHasChanged(); }
    }

    void StartPolling()
    {
        StopPolling();
        pollTimer = new System.Timers.Timer(1500);
        pollTimer.Elapsed += async (_, _) => await InvokeAsync(async () => { await RefreshSummary(); StateHasChanged(); });
        pollTimer.AutoReset = true; pollTimer.Start();
    }

    void StopPolling() { pollTimer?.Stop(); pollTimer?.Dispose(); pollTimer = null; }

    async Task RefreshSummary() { if (currentBattleId == Guid.Empty) return; summary = await Api.GetBattleSummaryAsync(currentBattleId); }

    async Task LoadSegments()
    {
        if (currentBattleId == Guid.Empty) return;
        try { segmentsLoading = true; segments = await Api.GetBattleSegmentsAsync(currentBattleId); }
        finally { segmentsLoading = false; }
    }

    async Task ForceRefresh() { if (battleInProgress) return; try { isBusy = true; await RefreshSummary(); } finally { isBusy = false; } }

    async Task ReplayThisBattle()
    {
        if (summary is null || lastCreated is null) return;
        try
        {
            isBusy = true;
            var start = await Api.StartReplayStepBattleAsync(summary.Id, seconds: summary.DurationSeconds, enemyCount: 1);
            stepBattleId = start.BattleId;
            _stepSinceIndex = 0;
            stepSegments.Clear(); stepAggBySource.Clear(); stepAggByType.Clear();
            stepStatus = null; stepDebug = null;
            _ = StartStepPollingAsync();
        }
        catch (Exception ex)
        {
            stepError = $"回放启动失败: {ex.Message}";
            toastNotification?.ShowError($"回放启动失败: {ex.Message}");
        }
        finally { isBusy = false; }
    }

    // ====== Step 战斗（含运行态调试）======
    Guid? stepBattleId;
    string stepMode = "duration";     // duration | continuous | dungeonsingle | dungeonloop
    bool IsDungeonMode => stepMode == "dungeonsingle" || stepMode == "dungeonloop";
    string stepDungeonId = "intro_cave";

    double stepSeconds = 20;
    int stepEnemyCount = 1;
    string? stepSeedInput = null;
    int stepPollMs = 500;

    // 新：掉落模式（透传到 /status）
    string stepDropMode = "expected"; // expected | sampled

    StepStatusResponse? stepStatus;
    List<StepBattleSegmentDto> stepSegments = new();
    Dictionary<string, int> stepAggBySource = new();
    Dictionary<string, int> stepAggByType = new();

    bool stepIsPolling;
    int _stepSinceIndex = 0;
    string? stepError;
    
    // 攻击进度平滑化追踪变量（步进战斗）
    double _stepAttackInterval = 0;
    double _stepSpecialInterval = 0;
    double? _stepPrevNextAttackAt = null;
    double? _stepPrevNextSpecialAt = null;
    DateTime _stepLastUpdateTime = DateTime.UtcNow;

    StepBattleDebugDto? stepDebug;
    bool stepAutoDebug = false;
    int stepDebugPollMs = 1000;

    async Task StartStepBattle()
    {
        stepError = null;
        if (lastCreated is null)
        {
            stepError = "请先创建角色";
            toastNotification?.ShowWarning("请先创建角色");
            return;
        }
        if (stepSeconds <= 0) stepSeconds = 1;
        if (stepEnemyCount < 1) stepEnemyCount = 1;

        try
        {
            isBusy = true;
            ulong? seed = null;
            if (ulong.TryParse(stepSeedInput, out var seedVal)) seed = seedVal;

            var secondsToSend = stepMode == "duration" ? stepSeconds : Math.Max(1, stepSeconds); // 非 duration 仅占位
            string? enemyToSend = IsDungeonMode ? null : selectedEnemyId;
            int enemyCountToSend = IsDungeonMode ? 0 : stepEnemyCount;

            var resp = await Api.StartStepBattleAsync(
                characterId: lastCreated!.Id,
                seconds: secondsToSend,
                enemyId: enemyToSend,
                enemyCount: enemyCountToSend <= 0 ? 1 : enemyCountToSend,
                seed: seed,
                mode: stepMode,
                dungeonId: IsDungeonMode ? stepDungeonId : null
            );

            stepBattleId = resp.BattleId;
            _stepSinceIndex = 0; stepSegments.Clear(); stepAggBySource.Clear(); stepAggByType.Clear(); stepStatus = null; stepDebug = null;
            
            // 订阅 SignalR 战斗事件
            if (_isSignalRConnected)
            {
                await SignalRService.SubscribeBattleAsync(resp.BattleId);
            }
            
            _ = StartStepPollingAsync();
            if (stepAutoDebug) _ = StartDebugAutoPollingAsync();
            await InvokeAsync(StateHasChanged);
        }
        catch (Exception ex)
        {
            stepError = $"StartStep 异常: {ex.Message}";
            toastNotification?.ShowError($"StartStep 异常: {ex.Message}");
        }
        finally { isBusy = false; }
    }

    async Task StartStepPollingAsync()
    {
        if (stepBattleId is null) return;
        
        // 使用统一的轮询协调器
        stepIsPolling = true;
        GetPollingCoordinator().StartStepBattlePolling(stepBattleId.Value, stepPollMs);
        
        await InvokeAsync(StateHasChanged);
    }

    async Task PollStepOnceAsync(CancellationToken ct)
    {
        if (stepBattleId is null) return;
        var s = await Api.GetStepBattleStatusAsync(stepBattleId.Value, stepDropMode, ct);
        if (s is not null)
        {
            // 更新攻击间隔追踪
            UpdateProgressTracking(
                ref _stepAttackInterval, 
                ref _stepPrevNextAttackAt, 
                s.NextAttackAt,
                ref _stepLastUpdateTime);
            
            UpdateProgressTracking(
                ref _stepSpecialInterval, 
                ref _stepPrevNextSpecialAt, 
                s.NextSpecialAt,
                ref _stepLastUpdateTime);
            
            stepStatus = s;
        }

        var segList = await Api.GetStepBattleSegmentsAsync(stepBattleId.Value, _stepSinceIndex, ct);
        if (segList is { Count: > 0 })
        {
            foreach (var seg in segList)
            {
                stepSegments.Add(seg);
                foreach (var kv in seg.DamageBySource)
                {
                    if (!stepAggBySource.ContainsKey(kv.Key)) stepAggBySource[kv.Key] = 0;
                    stepAggBySource[kv.Key] += kv.Value;
                }
                foreach (var kv in seg.DamageByType)
                {
                    if (!stepAggByType.ContainsKey(kv.Key)) stepAggByType[kv.Key] = 0;
                    stepAggByType[kv.Key] += kv.Value;
                }
            }
            _stepSinceIndex = stepSegments.Count;
        }
    }

    void StopStepPolling() 
    { 
        // 使用统一的轮询协调器
        GetPollingCoordinator().StopStepBattlePolling();
        stepIsPolling = false;
        
        // 取消订阅 SignalR 战斗事件
        if (_isSignalRConnected && stepBattleId.HasValue)
        {
            _ = SignalRService.UnsubscribeBattleAsync(stepBattleId.Value);
        }
        
        StateHasChanged(); 
    }

    void ResetStep()
    {
        StopStepPolling(); StopDebugAutoPolling();
        stepBattleId = null; stepStatus = null; stepSegments.Clear(); stepAggBySource.Clear(); stepAggByType.Clear(); stepDebug = null; stepError = null; _stepSinceIndex = 0;
        StateHasChanged();
    }

    void OnAutoDebugChanged()
    {
        if (stepAutoDebug) _ = StartDebugAutoPollingAsync();
        else StopDebugAutoPolling();
    }

    async Task StopAndSaveAsync()
    {
        if (stepBattleId is null) return;
        try
        {
            var resp = await Api.StopStepBattleAsync(stepBattleId.Value);
            StopStepPolling(); StopDebugAutoPolling();
            if (stepStatus is not null) stepStatus.PersistedBattleId = resp.PersistedBattleId;
            await InvokeAsync(StateHasChanged);
        }
        catch (Exception ex)
        {
            stepError = $"Stop & Save 异常: {ex.Message}";
            toastNotification?.ShowError($"Stop & Save 异常: {ex.Message}");
        }
    }

    async Task RefreshRuntimeDebug()
    {
        if (stepBattleId is null) return;
        try { stepDebug = await Api.GetStepBattleDebugAsync(stepBattleId.Value); await InvokeAsync(StateHasChanged); }
        catch (Exception ex)
        {
            stepError = $"Debug 异常: {ex.Message}";
            toastNotification?.ShowError($"Debug 异常: {ex.Message}");
        }
    }

    async Task StartDebugAutoPollingAsync()
    {
        if (stepBattleId is null) return;
        
        // 使用统一的轮询协调器
        GetPollingCoordinator().StartDebugPolling(stepDebugPollMs);
        
        await Task.CompletedTask;
    }
    
    void StopDebugAutoPolling() 
    { 
        // 使用统一的轮询协调器
        GetPollingCoordinator().StopDebugPolling();
    }

    async Task OpenSummary(Guid id) { var url = $"/api/battles/{id}/summary"; await JS.InvokeVoidAsync("open", url, "_blank"); }

    public void Dispose() 
    { 
        StopPolling(); 
        StopStepPolling(); 
        StopDebugAutoPolling(); 
        StopPlanPolling();
        _pollingCoordinator?.Dispose();
        
        // 清理认证事件处理器
        if (AuthService != null)
        {
            AuthService.OnAuthenticated -= HandleAuthenticatedAsync;
            AuthService.OnUnauthenticated -= HandleUnauthenticatedAsync;
        }
        
        // 清理 SignalR 连接
        Task.Run(async () => await SignalRService.DisposeAsync()).Wait(TimeSpan.FromSeconds(5));
    }

    // ====== 活动计划管理 ======
    string planActivityType = "combat";  // combat | dungeon
    string planLimitType = "duration";   // duration | infinite
    double planLimitValue = 300;
    int planSlotIndex = 0;
    int planEnemyCount = 1;
    string planDungeonId = "intro_cave";
    bool planDungeonLoop = false;
    string? planSeedInput = null;
    string? planError = null;

    List<ActivityPlanDto>? characterPlans;
    StepStatusResponse? currentPlanBattle;
    bool planIsPolling;
    
    // 攻击进度平滑化追踪变量（计划战斗）
    double _planAttackInterval = 0;
    double _planSpecialInterval = 0;
    double? _planPrevNextAttackAt = null;
    double? _planPrevNextSpecialAt = null;
    DateTime _planLastUpdateTime = DateTime.UtcNow;

    async Task CreateActivityPlanAsync()
    {
        planError = null;
        if (lastCreated is null)
        {
            planError = "请先创建角色";
            toastNotification?.ShowWarning("请先创建角色");
            return;
        }

        try
        {
            isBusy = true;
            ulong? seed = null;
            if (ulong.TryParse(planSeedInput, out var seedVal)) seed = seedVal;

            ActivityPlanDto plan;
            if (planActivityType == "combat")
            {
                plan = await Api.CreateCombatPlanAsync(
                    characterId: lastCreated.Id,
                    slotIndex: planSlotIndex,
                    limitType: planLimitType,
                    limitValue: planLimitType == "duration" ? planLimitValue : null,
                    enemyId: selectedEnemyId,
                    enemyCount: planEnemyCount,
                    seed: seed
                );
            }
            else
            {
                plan = await Api.CreateDungeonPlanAsync(
                    characterId: lastCreated.Id,
                    slotIndex: planSlotIndex,
                    limitType: planLimitType,
                    limitValue: planLimitType == "duration" ? planLimitValue : null,
                    dungeonId: planDungeonId,
                    loop: planDungeonLoop,
                    seed: seed
                );
            }

            await RefreshPlansAsync();

            // 如果创建的计划自动启动了（State=1），开始轮询战斗状态
            if (plan.State == 1 && plan.BattleId.HasValue)
            {
                _ = StartPlanPollingAsync(plan.BattleId.Value);
            }
        }
        catch (Exception ex)
        {
            planError = $"创建计划失败: {ex.Message}";
            toastNotification?.ShowError($"创建计划失败: {ex.Message}");
        }
        finally
        {
            isBusy = false;
        }
    }

    async Task RefreshPlansAsync()
    {
        if (lastCreated is null) return;
        try
        {
            characterPlans = await Api.GetCharacterPlansAsync(lastCreated.Id);
            
            // 查找正在运行的计划并获取其战斗状态
            // State: 0=Pending, 1=Running, 2=Completed, 3=Cancelled, 4=Paused
            var runningPlan = characterPlans?.FirstOrDefault(p => p.State == 1);
            if (runningPlan?.BattleId.HasValue == true)
            {
                if (!planIsPolling)
                {
                    _ = StartPlanPollingAsync(runningPlan.BattleId.Value);
                }
            }
            else
            {
                StopPlanPolling();
                currentPlanBattle = null;
            }
        }
        catch (Exception ex)
        {
            planError = $"刷新计划列表失败: {ex.Message}";
            toastNotification?.ShowError($"刷新计划列表失败: {ex.Message}");
        }
    }

    /// <summary>
    /// 停止计划（带确认）
    /// </summary>
    void StopPlanWithConfirm(Guid planId)
    {
        ShowConfirmDialog(
            "停止计划",
            "确定要停止此计划吗？计划将被暂停，可以稍后恢复。",
            () => StopPlanAsync(planId),
            type: ConfirmDialog.DialogType.Warning,
            confirmText: "停止"
        );
    }

    async Task StopPlanAsync(Guid planId)
    {
        try
        {
            isBusy = true;
            var success = await Api.StopPlanAsync(planId);
            if (success)
            {
                await RefreshPlansAsync();
                toastNotification?.ShowSuccess("计划已停止");
            }
            else
            {
                planError = "停止计划失败";
                toastNotification?.ShowError("停止计划失败");
            }
        }
        catch (Exception ex)
        {
            planError = $"停止计划异常: {ex.Message}";
            toastNotification?.ShowError($"停止计划异常: {ex.Message}");
        }
        finally
        {
            isBusy = false;
        }
    }

    /// <summary>
    /// 取消计划（带确认）
    /// </summary>
    void CancelPlanWithConfirm(Guid planId)
    {
        ShowConfirmDialog(
            "取消计划",
            "确定要取消此计划吗？此操作不可撤销。",
            () => CancelPlanAsync(planId),
            warning: "取消后的计划无法恢复，但可以重新创建。",
            confirmText: "取消计划"
        );
    }

    async Task CancelPlanAsync(Guid planId)
    {
        try
        {
            isBusy = true;
            var success = await Api.CancelPlanAsync(planId);
            if (success)
            {
                await RefreshPlansAsync();
                toastNotification?.ShowSuccess("计划已取消");
            }
            else
            {
                planError = "取消计划失败";
                toastNotification?.ShowError("取消计划失败");
            }
        }
        catch (Exception ex)
        {
            planError = $"取消计划异常: {ex.Message}";
            toastNotification?.ShowError($"取消计划异常: {ex.Message}");
        }
        finally
        {
            isBusy = false;
        }
    }

    /// <summary>
    /// 删除计划（带确认）
    /// </summary>
    void DeletePlanWithConfirm(Guid planId)
    {
        ShowConfirmDialog(
            "删除计划",
            "确定要删除此计划吗？此操作不可撤销。",
            () => DeletePlanAsync(planId),
            warning: "删除后的计划记录将永久丢失。",
            confirmText: "删除"
        );
    }

    async Task DeletePlanAsync(Guid planId)
    {
        try
        {
            isBusy = true;
            var success = await Api.DeletePlanAsync(planId);
            if (success)
            {
                await RefreshPlansAsync();
                toastNotification?.ShowSuccess("计划已删除");
            }
            else
            {
                planError = "删除计划失败";
                toastNotification?.ShowError("删除计划失败");
            }
        }
        catch (Exception ex)
        {
            planError = $"删除计划异常: {ex.Message}";
            toastNotification?.ShowError($"删除计划异常: {ex.Message}");
        }
        finally
        {
            isBusy = false;
        }
    }

    async Task ResumePlanAsync(Guid planId)
    {
        try
        {
            isBusy = true;
            var response = await Api.ResumePlanAsync(planId);
            if (response != null)
            {
                await RefreshPlansAsync();
                
                // 如果计划恢复成功并且有战斗ID，开始轮询
                if (response.Resumed && response.BattleId.HasValue)
                {
                    _ = StartPlanPollingAsync(response.BattleId.Value);
                }
            }
            else
            {
                planError = "恢复计划失败";
                toastNotification?.ShowError("恢复计划失败");
            }
        }
        catch (Exception ex)
        {
            planError = $"恢复计划异常: {ex.Message}";
            toastNotification?.ShowError($"恢复计划异常: {ex.Message}");
        }
        finally
        {
            isBusy = false;
        }
    }

    async Task ViewPlanBattleAsync(Guid battleId)
    {
        try
        {
            currentPlanBattle = await Api.GetStepBattleStatusAsync(battleId, "sampled");
            if (!planIsPolling)
            {
                _ = StartPlanPollingAsync(battleId);
            }
        }
        catch (Exception ex)
        {
            planError = $"查看战斗失败: {ex.Message}";
            toastNotification?.ShowError($"查看战斗失败: {ex.Message}");
        }
    }

    async Task StartPlanPollingAsync(Guid battleId)
    {
        // 使用统一的轮询协调器
        planIsPolling = true;
        GetPollingCoordinator().StartPlanBattlePolling(battleId, 2000);
        
        // 订阅 SignalR 战斗事件
        if (_isSignalRConnected)
        {
            await SignalRService.SubscribeBattleAsync(battleId);
        }
        
        await InvokeAsync(StateHasChanged);
    }

    void StopPlanPolling()
    {
        // 使用统一的轮询协调器
        GetPollingCoordinator().StopPlanBattlePolling();
        planIsPolling = false;
        
        // 取消订阅 SignalR 战斗事件
        if (_isSignalRConnected && currentPlanBattle is not null)
        {
            _ = SignalRService.UnsubscribeBattleAsync(currentPlanBattle.Id);
        }
    }

    // 批量模拟器
    SimulateMode simMode = SimulateMode.Kills;
    double simValue = 10;
    double simSampleSeconds = 20;
    int simEnemyCount = 1;
    string? simSeedInput;
    SimulateResponse? simResult;
    string? simError;

    async Task RunSimAsync()
    {
        simError = null;
        simResult = null;
        if (lastCreated is null)
        {
            simError = "请先创建角色";
            toastNotification?.ShowWarning("请先创建角色");
            return;
        }
        if (simValue <= 0)
        {
            simError = "值必须大于 0";
            toastNotification?.ShowWarning("值必须大于 0");
            return;
        }
        try
        {
            isBusy = true;
            ulong? seed = null;
            if (ulong.TryParse(simSeedInput, out var sv)) seed = sv;
            var req = new SimulateRequest
            {
                CharacterId = lastCreated.Id,
                EnemyId = selectedEnemyId,
                EnemyCount = simEnemyCount,
                Mode = simMode,
                Value = simValue,
                SampleSeconds = simSampleSeconds,
                Seed = seed
            };
            simResult = await Api.SimulateAsync(req);
        }
        catch (Exception ex)
        {
            simError = $"模拟失败: {ex.Message}";
            toastNotification?.ShowError($"模拟失败: {ex.Message}");
        }
        finally
        {
            isBusy = false;
            StateHasChanged();
        }
    }

    // ====== 攻击进度平滑化计算 ======
    /// <summary>
    /// 更新攻击间隔追踪信息
    /// </summary>
    /// <param name="interval">攻击间隔引用</param>
    /// <param name="prevNextTriggerAt">上次的下次触发时间引用</param>
    /// <param name="currentNextTriggerAt">当前的下次触发时间</param>
    /// <param name="lastUpdateTime">最后更新时间引用</param>
    private void UpdateProgressTracking(ref double interval, ref double? prevNextTriggerAt, double? currentNextTriggerAt, ref DateTime lastUpdateTime)
    {
        // 更新最后更新时间
        lastUpdateTime = DateTime.UtcNow;

        // 如果当前没有下次触发时间，重置状态
        if (!currentNextTriggerAt.HasValue)
        {
            interval = 0;
            prevNextTriggerAt = null;
            return;
        }

        // 如果有上次的触发时间，且当前触发时间大于上次（说明攻击已触发，进入下一个周期）
        // 则计算攻击间隔
        if (prevNextTriggerAt.HasValue && currentNextTriggerAt.Value > prevNextTriggerAt.Value)
        {
            double calculatedInterval = currentNextTriggerAt.Value - prevNextTriggerAt.Value;
            // 只有当间隔合理时才更新（避免异常值）
            if (calculatedInterval > 0.1 && calculatedInterval < 100)
            {
                interval = calculatedInterval;
            }
        }

        // 更新上次的触发时间
        prevNextTriggerAt = currentNextTriggerAt.Value;
    }

    /// <summary>
    /// 计算平滑的攻击进度百分比（支持循环滚动）
    /// </summary>
    /// <param name="currentTime">服务器当前战斗时间</param>
    /// <param name="nextTriggerAt">下次触发时间</param>
    /// <param name="interval">攻击间隔（从追踪变量获取）</param>
    /// <param name="lastUpdateTime">上次服务器更新的客户端时间</param>
    /// <returns>0.0 到 1.0 之间的进度值</returns>
    private double CalculateSmoothProgress(double currentTime, double nextTriggerAt, double interval, DateTime lastUpdateTime)
    {
        // 如果没有有效的攻击间隔，使用简单的二元判断
        if (interval <= 0)
        {
            return currentTime >= nextTriggerAt ? 1.0 : 0.0;
        }

        // 获取配置参数
        var config = _progressBarConfig?.ProgressBar ?? new ProgressBarSettings();
        
        // 验证interval是否在有效范围内
        if (interval < config.MinIntervalForLooping || interval > config.MaxIntervalForLooping)
        {
            // interval超出有效范围，不进行循环
            return currentTime >= nextTriggerAt ? 1.0 : 0.0;
        }

        // 计算上次攻击时间
        double lastTriggerAt = nextTriggerAt - interval;

        // 计算基于服务器时间的进度
        double serverProgress = (currentTime - lastTriggerAt) / interval;

        // 添加客户端时间插值以实现平滑动画
        double clientElapsedSeconds = (DateTime.UtcNow - lastUpdateTime).TotalSeconds;
        double interpolatedProgress = serverProgress + (clientElapsedSeconds / interval);

        // 如果启用循环进度且进度超过1.0，使用取模继续循环
        if (config.EnableLoopingProgress && interpolatedProgress >= 1.0)
        {
            // 取模实现循环：progress % 1.0
            // 例如：progress=1.3 -> 0.3, progress=2.7 -> 0.7
            interpolatedProgress = interpolatedProgress % 1.0;
            
            // 可选：记录调试信息
            if (_progressBarConfig?.Debug.LogProgressCalculations == true)
            {
                Console.WriteLine($"[Progress] Looping enabled - raw: {serverProgress + (clientElapsedSeconds / interval):F3}, looped: {interpolatedProgress:F3}");
            }
        }
        else
        {
            // 不循环时限制在 0 到 1 之间
            interpolatedProgress = Math.Clamp(interpolatedProgress, 0.0, 1.0);
        }

        return interpolatedProgress;
    }

    // ====== 统一轮询协调器 (BattlePollingCoordinator) ======
    /// <summary>
    /// 统一管理所有战斗相关的轮询任务，包括：
    /// - Step战斗状态轮询
    /// - 活动计划战斗轮询
    /// - Debug信息轮询
    /// - 进度条动画定时器
    /// </summary>
    private class BattlePollingCoordinator : IDisposable
    {
        private readonly Characters _parent;
        private CancellationTokenSource? _mainCts;
        private System.Threading.Timer? _animationTimer;
        private bool _isPolling;
        
        // 轮询状态跟踪
        private bool _stepBattleActive;
        private bool _planBattleActive;
        private bool _debugPollingActive;
        
        // 轮询间隔配置（毫秒）
        private int _stepPollInterval = 500;
        private int _planPollInterval = 2000;
        private int _debugPollInterval = 1000;
        private const int AnimationInterval = 100;
        
        // JIT轮询跟踪（每个攻击周期最多触发一次）
        private double? _lastJITTriggerAtForAttack;
        private double? _lastJITTriggerAtForSpecial;

        public BattlePollingCoordinator(Characters parent)
        {
            _parent = parent;
        }

        /// <summary>
        /// 启动Step战斗轮询
        /// </summary>
        public void StartStepBattlePolling(Guid battleId, int pollIntervalMs = 500)
        {
            _stepBattleActive = true;
            _stepPollInterval = pollIntervalMs;
            EnsurePollingStarted();
        }
        
        /// <summary>
        /// 计算自适应轮询间隔（基于战斗状态动态调整）
        /// </summary>
        private int CalculateAdaptivePollingInterval()
        {
            var config = _parent._progressBarConfig?.JITPolling;
            if (config == null || !config.AdaptivePollingEnabled)
            {
                return _stepPollInterval;
            }

            // 根据血量百分比调整轮询频率
            var hpPercent = _parent.stepStatus?.PlayerHpPercent ?? 1.0;
            
            if (hpPercent <= config.HealthCriticalThreshold)
            {
                // 血量危急，提高轮询频率
                return config.CriticalHealthPollingMs;
            }
            else if (hpPercent <= config.HealthLowThreshold)
            {
                // 血量偏低，中等轮询频率
                return config.LowHealthPollingMs;
            }
            else
            {
                // 正常状态，标准轮询频率
                return config.NormalPollingMs;
            }
        }
        
        /// <summary>
        /// 检查是否应该触发JIT轮询
        /// </summary>
        private bool ShouldTriggerJITPolling(out int delayMs)
        {
            delayMs = 0;
            
            var config = _parent._progressBarConfig?.JITPolling;
            if (config == null || !config.EnableJITPolling)
            {
                return false;
            }

            var status = _parent.stepStatus;
            if (status == null)
            {
                return false;
            }

            // 检查普通攻击是否即将触发
            if (status.NextAttackAt.HasValue && _parent._stepAttackInterval > 0)
            {
                double timeUntilAttack = (status.NextAttackAt.Value - status.CurrentTime) * 1000; // 转换为毫秒
                double clientElapsed = (DateTime.UtcNow - _parent._stepLastUpdateTime).TotalMilliseconds;
                double predictedTimeUntilTrigger = timeUntilAttack - clientElapsed;

                // 如果预测时间在触发窗口内，且本周期还未触发过JIT轮询
                if (predictedTimeUntilTrigger > config.MinPredictionTimeMs && 
                    predictedTimeUntilTrigger <= config.TriggerWindowMs &&
                    _lastJITTriggerAtForAttack != status.NextAttackAt)
                {
                    delayMs = Math.Max(0, (int)(predictedTimeUntilTrigger - config.MinPredictionTimeMs));
                    _lastJITTriggerAtForAttack = status.NextAttackAt;
                    
                    if (config?.EnableJITPolling == true && _parent._progressBarConfig?.Debug.LogJITPollingEvents == true)
                    {
                        Console.WriteLine($"[JIT Polling] Attack trigger scheduled in {delayMs}ms (predicted: {predictedTimeUntilTrigger:F0}ms)");
                    }
                    
                    return true;
                }
            }

            // 检查特殊攻击是否即将触发
            if (status.NextSpecialAt.HasValue && _parent._stepSpecialInterval > 0)
            {
                double timeUntilSpecial = (status.NextSpecialAt.Value - status.CurrentTime) * 1000;
                double clientElapsed = (DateTime.UtcNow - _parent._stepLastUpdateTime).TotalMilliseconds;
                double predictedTimeUntilTrigger = timeUntilSpecial - clientElapsed;

                if (predictedTimeUntilTrigger > config.MinPredictionTimeMs && 
                    predictedTimeUntilTrigger <= config.TriggerWindowMs &&
                    _lastJITTriggerAtForSpecial != status.NextSpecialAt)
                {
                    delayMs = Math.Max(0, (int)(predictedTimeUntilTrigger - config.MinPredictionTimeMs));
                    _lastJITTriggerAtForSpecial = status.NextSpecialAt;
                    
                    if (config?.EnableJITPolling == true && _parent._progressBarConfig?.Debug.LogJITPollingEvents == true)
                    {
                        Console.WriteLine($"[JIT Polling] Special trigger scheduled in {delayMs}ms (predicted: {predictedTimeUntilTrigger:F0}ms)");
                    }
                    
                    return true;
                }
            }

            return false;
        }

        /// <summary>
        /// 停止Step战斗轮询
        /// </summary>
        public void StopStepBattlePolling()
        {
            _stepBattleActive = false;
            CheckStopPolling();
        }

        /// <summary>
        /// 启动活动计划战斗轮询
        /// </summary>
        public void StartPlanBattlePolling(Guid battleId, int pollIntervalMs = 2000)
        {
            _planBattleActive = true;
            _planPollInterval = pollIntervalMs;
            EnsurePollingStarted();
        }

        /// <summary>
        /// 停止活动计划战斗轮询
        /// </summary>
        public void StopPlanBattlePolling()
        {
            _planBattleActive = false;
            CheckStopPolling();
        }

        /// <summary>
        /// 启动Debug信息轮询
        /// </summary>
        public void StartDebugPolling(int pollIntervalMs = 1000)
        {
            _debugPollingActive = true;
            _debugPollInterval = pollIntervalMs;
            EnsurePollingStarted();
        }

        /// <summary>
        /// 停止Debug信息轮询
        /// </summary>
        public void StopDebugPolling()
        {
            _debugPollingActive = false;
            CheckStopPolling();
        }

        /// <summary>
        /// 确保轮询任务已启动
        /// </summary>
        private void EnsurePollingStarted()
        {
            if (_isPolling) return;

            _mainCts?.Cancel();
            _mainCts = new CancellationTokenSource();
            _isPolling = true;

            // 启动统一的轮询任务
            _ = RunPollingLoopAsync(_mainCts.Token);

            // 启动进度条动画定时器
            StartAnimationTimer();
        }

        /// <summary>
        /// 检查是否需要停止轮询
        /// </summary>
        private void CheckStopPolling()
        {
            if (!_stepBattleActive && !_planBattleActive && !_debugPollingActive)
            {
                StopAll();
            }
        }

        /// <summary>
        /// 统一的轮询循环
        /// </summary>
        private async Task RunPollingLoopAsync(CancellationToken ct)
        {
            // 跟踪每个任务的下次执行时间
            DateTime nextStepPoll = DateTime.UtcNow;
            DateTime nextPlanPoll = DateTime.UtcNow;
            DateTime nextDebugPoll = DateTime.UtcNow;

            try
            {
                while (!ct.IsCancellationRequested)
                {
                    var now = DateTime.UtcNow;
                    var tasks = new List<Task>();

                    // Step战斗状态轮询
                    if (_stepBattleActive && now >= nextStepPoll)
                    {
                        // 使用自适应轮询间隔
                        int adaptiveInterval = CalculateAdaptivePollingInterval();
                        nextStepPoll = now.AddMilliseconds(adaptiveInterval);
                        
                        tasks.Add(Task.Run(async () =>
                        {
                            try
                            {
                                await _parent.PollStepOnceAsync(ct);
                                await _parent.InvokeAsync(_parent.StateHasChanged);
                                
                                // 检查战斗是否完成
                                if (_parent.stepStatus?.Completed == true && 
                                    _parent.stepMode != "continuous" && 
                                    _parent.stepMode != "dungeonloop")
                                {
                                    StopStepBattlePolling();
                                }
                            }
                            catch (Exception ex) when (ex is not TaskCanceledException)
                            {
                                _parent.stepError = $"轮询异常: {ex.Message}";
                                _parent.toastNotification?.ShowError($"轮询异常: {ex.Message}");
                            }
                        }, ct));
                    }
                    
                    // 检查是否需要JIT轮询（在预测触发点前）
                    if (_stepBattleActive && ShouldTriggerJITPolling(out int jitDelayMs))
                    {
                        // 安排JIT轮询任务
                        tasks.Add(Task.Run(async () =>
                        {
                            try
                            {
                                // 等待到预测的触发时间
                                if (jitDelayMs > 0)
                                {
                                    await Task.Delay(jitDelayMs, ct);
                                }
                                
                                // 执行JIT轮询
                                await _parent.PollStepOnceAsync(ct);
                                await _parent.InvokeAsync(_parent.StateHasChanged);
                            }
                            catch (Exception ex) when (ex is not TaskCanceledException)
                            {
                                // JIT轮询失败不影响主流程
                                if (_parent._progressBarConfig?.Debug.LogJITPollingEvents == true)
                                {
                                    Console.WriteLine($"[JIT Polling] Failed: {ex.Message}");
                                }
                            }
                        }, ct));
                    }

                    // 活动计划战斗轮询
                    if (_planBattleActive && now >= nextPlanPoll)
                    {
                        nextPlanPoll = now.AddMilliseconds(_planPollInterval);
                        tasks.Add(Task.Run(async () =>
                        {
                            try
                            {
                                await _parent.PollPlanBattleOnceAsync(ct);
                                await _parent.InvokeAsync(_parent.StateHasChanged);
                            }
                            catch (Exception) { }
                        }, ct));
                    }

                    // Debug信息轮询
                    if (_debugPollingActive && now >= nextDebugPoll)
                    {
                        nextDebugPoll = now.AddMilliseconds(_debugPollInterval);
                        tasks.Add(Task.Run(async () =>
                        {
                            try
                            {
                                await _parent.RefreshRuntimeDebug();
                                
                                // 检查战斗是否完成
                                if (_parent.stepStatus?.Completed == true && 
                                    _parent.stepMode != "continuous" && 
                                    _parent.stepMode != "dungeonloop")
                                {
                                    StopDebugPolling();
                                }
                            }
                            catch (Exception ex) when (ex is not TaskCanceledException)
                            {
                                _parent.stepError = $"Debug 轮询异常: {ex.Message}";
                                _parent.toastNotification?.ShowError($"Debug 轮询异常: {ex.Message}");
                            }
                        }, ct));
                    }

                    // 等待所有任务完成
                    if (tasks.Count > 0)
                    {
                        await Task.WhenAll(tasks);
                    }

                    // 计算下一次轮询的等待时间
                    var nextPoll = new[] { nextStepPoll, nextPlanPoll, nextDebugPoll }
                        .Where(t => (t == nextStepPoll && _stepBattleActive) ||
                                   (t == nextPlanPoll && _planBattleActive) ||
                                   (t == nextDebugPoll && _debugPollingActive))
                        .DefaultIfEmpty(DateTime.UtcNow.AddSeconds(1))
                        .Min();

                    var delay = (int)Math.Max(50, (nextPoll - DateTime.UtcNow).TotalMilliseconds);
                    await Task.Delay(delay, ct);
                }
            }
            catch (TaskCanceledException) { }
            finally
            {
                _isPolling = false;
            }
        }

        /// <summary>
        /// 启动进度条动画定时器
        /// </summary>
        private void StartAnimationTimer()
        {
            if (_animationTimer != null) return;

            _animationTimer = new System.Threading.Timer(_ =>
            {
                _parent.InvokeAsync(_parent.StateHasChanged);
            }, null, TimeSpan.FromMilliseconds(AnimationInterval), TimeSpan.FromMilliseconds(AnimationInterval));
        }

        /// <summary>
        /// 停止进度条动画定时器
        /// </summary>
        private void StopAnimationTimer()
        {
            _animationTimer?.Dispose();
            _animationTimer = null;
        }

        /// <summary>
        /// 停止所有轮询任务
        /// </summary>
        public void StopAll()
        {
            _stepBattleActive = false;
            _planBattleActive = false;
            _debugPollingActive = false;
            
            _mainCts?.Cancel();
            _isPolling = false;
            
            StopAnimationTimer();
        }

        public void Dispose()
        {
            StopAll();
            _mainCts?.Dispose();
        }
    }

    // 轮询协调器实例
    private BattlePollingCoordinator? _pollingCoordinator;

    /// <summary>
    /// 获取或创建轮询协调器
    /// </summary>
    private BattlePollingCoordinator GetPollingCoordinator()
    {
        return _pollingCoordinator ??= new BattlePollingCoordinator(this);
    }

    /// <summary>
    /// 活动计划战斗轮询的单次执行
    /// </summary>
    private async Task PollPlanBattleOnceAsync(CancellationToken ct)
    {
        var runningPlan = characterPlans?.FirstOrDefault(p => p.State == 1);
        if (runningPlan?.BattleId == null) return;

        var newBattleStatus = await Api.GetStepBattleStatusAsync(runningPlan.BattleId.Value, "sampled", ct);
        
        // 更新攻击间隔追踪
        if (newBattleStatus != null)
        {
            UpdateProgressTracking(
                ref _planAttackInterval, 
                ref _planPrevNextAttackAt, 
                newBattleStatus.NextAttackAt,
                ref _planLastUpdateTime);
            
            UpdateProgressTracking(
                ref _planSpecialInterval, 
                ref _planPrevNextSpecialAt, 
                newBattleStatus.NextSpecialAt,
                ref _planLastUpdateTime);
            
            currentPlanBattle = newBattleStatus;
        }
        
        // 同时刷新计划列表以获取最新的ExecutedSeconds
        if (lastCreated is not null)
        {
            characterPlans = await Api.GetCharacterPlansAsync(lastCreated.Id);
        }
        
        // 更新心跳时间（每次刷新计划状态时）
        await UpdateHeartbeatIfNeededAsync();
    }
    
    // ========== 新增：UI 组件辅助方法 ==========
    
    /// <summary>
    /// 获取 Step 战斗的模式信息文本
    /// </summary>
    private string? GetStepModeInfo(StepStatusResponse status)
    {
        if (status.Mode == "dungeonsingle" || status.Mode == "dungeonloop")
        {
            return $"[波次: {status.WaveIndex ?? 1} | 轮次: {status.RunCount ?? 0} | 怪物数: {status.Enemies?.Count ?? 0}]";
        }
        else if (status.Enemies?.Count > 0)
        {
            return $"[怪物数: {status.Enemies.Count}]";
        }
        return null;
    }
    
    /// <summary>
    /// 获取活动计划战斗的模式信息文本
    /// </summary>
    private string? GetPlanModeInfo(StepStatusResponse status)
    {
        if (status.Mode == "dungeonsingle" || status.Mode == "dungeonloop")
        {
            return $"[波次: {status.WaveIndex ?? 1} | 轮次: {status.RunCount ?? 0} | 怪物数: {status.Enemies?.Count ?? 0}]";
        }
        else if (status.Enemies?.Count > 0)
        {
            return $"[怪物数: {status.Enemies.Count}]";
        }
        return null;
    }
    
    /// <summary>
    /// 获取地下城的总波次数（硬编码，后续可从API获取）
    /// </summary>
    private int? GetTotalWaves(string? dungeonId)
    {
        // 暂时返回固定值，后续可以从地下城配置中获取
        if (string.IsNullOrEmpty(dungeonId)) return null;
        return dungeonId switch
        {
            "goblin_hideout" => 5,
            "forest_temple" => 7,
            _ => 5 // 默认5波
        };
    }
    
    /// <summary>
    /// 判断是否为Boss波次（简单判断：最后一波）
    /// </summary>
    private bool IsBossWave(int? waveIndex)
    {
        // 简单判断：如果已知总波次，判断是否为最后一波
        // 这里暂时硬编码，后续可以从地下城配置获取
        if (!waveIndex.HasValue) return false;
        return waveIndex.Value >= 5; // 假设第5波及以后可能是Boss
    }
}