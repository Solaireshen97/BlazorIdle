# BlazorIdle 数据库优化实施方案 - 中篇：高频操作迁移

**文档版本**: 1.0  
**阶段**: Phase 2 - 功能迁移  
**预计工时**: 64-96 小时（8-12 个工作日）  
**优先级**: P1（核心功能）  
**依赖**: 上篇（基础设施）完成  

---

## 📋 目录

1. [阶段目标](#阶段目标)
2. [迁移策略](#迁移策略)
3. [详细迁移步骤](#详细迁移步骤)
4. [测试和验证](#测试和验证)
5. [回退方案](#回退方案)
6. [验收标准](#验收标准)

---

## 阶段目标

### 主要目标

✅ **迁移高频数据库操作到内存管理**
- 角色心跳（最高优先级）
- 战斗快照（核心功能）
- 活动计划进度（中等频率）

✅ **保持功能完整性**
- 不改变业务逻辑
- 不影响用户体验
- API 接口保持兼容

✅ **验证性能提升**
- 数据库写入减少 > 80%
- 响应时间改善 > 30%
- 并发能力提升 > 2x

### 迁移原则

1. **渐进式迁移**: 每次迁移一个模块，逐步推进
2. **充分测试**: 每个模块迁移后独立测试验证
3. **保留回退**: 配置开关支持快速回退
4. **监控对比**: 迁移前后性能指标对比
5. **用户无感**: 不影响线上用户体验

---

## 迁移策略

### 优先级排序（按影响 × 风险）

| 模块 | 影响（收益） | 风险 | 优先级 | 工时 |
|-----|------------|------|--------|-----|
| 角色心跳 | 高（18K/h → 1.2K/h） | 低 | P0 | 12-16h |
| 战斗快照 | 极高（72K/h → 60/h） | 中 | P0 | 24-32h |
| 活动计划进度 | 中（3K/h → 120/h） | 低 | P1 | 16-24h |
| 其他操作 | 低 | 极低 | P2 | 12-24h |

### 迁移顺序

```
Phase 2.1: 角色心跳迁移（12-16h）
    ↓ 测试验证
Phase 2.2: 战斗快照迁移（24-32h）
    ↓ 测试验证
Phase 2.3: 活动计划迁移（16-24h）
    ↓ 测试验证
Phase 2.4: 其他操作优化（12-24h）
    ↓ 全面测试
验收和上线
```

---

## 详细迁移步骤

### Phase 2.1: 角色心跳迁移 ⏱️ 12-16h

#### 目标
将角色心跳从"每次立即保存"改为"内存更新 + 定期保存"

#### 现状分析

**当前代码** (`CharactersController.cs:Heartbeat`):
```csharp
[HttpPost("{id}/heartbeat")]
public async Task<IActionResult> Heartbeat(Guid id)
{
    var character = await _db.Characters.FindAsync(id);
    if (character == null)
        return NotFound();
        
    character.LastSeenAtUtc = DateTime.UtcNow;
    character.IsOnline = true;
    
    // 每次心跳都保存到数据库
    await DatabaseRetryPolicy.SaveChangesWithRetryAsync(_db);
    
    return Ok();
}
```

**问题**:
- 每 10-20 秒心跳一次
- 100 个在线玩家 = 18,000-36,000 次/小时数据库写入
- LastSeenAtUtc 只用于离线检测（60秒阈值），不需要实时精确

#### 迁移方案

**步骤 1: 修改 CharactersController.Heartbeat** ⏱️ 2-3h

**新实现**:
```csharp
[HttpPost("{id}/heartbeat")]
public async Task<IActionResult> Heartbeat(Guid id)
{
    var character = await _characterManager.GetAsync(id);
    if (character == null)
        return NotFound();
    
    // 仅更新内存
    character.LastSeenAtUtc = DateTime.UtcNow;
    character.IsOnline = true;
    
    // 标记为 Dirty（不立即保存）
    _characterManager.Update(character);
    
    _logger.LogDebug("角色 {CharacterId} 心跳已更新（内存）", id);
    
    return Ok();
}
```

**注意事项**:
- ✅ 保持 API 接口不变（客户端无需修改）
- ✅ 响应速度更快（无需等待数据库写入）
- ⚠️ LastSeenAtUtc 可能有延迟（最多 5 分钟）

**步骤 2: 更新离线检测逻辑** ⏱️ 3-4h

**现状** (`OfflineDetectionService.cs`):
```csharp
protected override async Task ExecuteAsync(CancellationToken stoppingToken)
{
    while (!stoppingToken.IsCancellationRequested)
    {
        await Task.Delay(TimeSpan.FromSeconds(30), stoppingToken);
        
        var threshold = DateTime.UtcNow.AddSeconds(-_thresholdSeconds);
        
        // 从数据库查询
        var offlineCharacters = await _db.Characters
            .Where(c => c.IsOnline && c.LastSeenAtUtc < threshold)
            .ToListAsync(stoppingToken);
            
        foreach (var character in offlineCharacters)
        {
            character.IsOnline = false;
            // 立即保存
            await _db.SaveChangesAsync(stoppingToken);
        }
    }
}
```

**新实现**:
```csharp
protected override async Task ExecuteAsync(CancellationToken stoppingToken)
{
    while (!stoppingToken.IsCancellationRequested)
    {
        await Task.Delay(TimeSpan.FromSeconds(30), stoppingToken);
        
        // 增加阈值以适应心跳保存延迟（60s + 最大延迟 5min = 360s）
        var threshold = DateTime.UtcNow.AddSeconds(-360); // 6 分钟
        
        // 从内存中检查（更快）
        var allCharacters = _characterManager.GetSnapshot();
        var offlineCharacters = allCharacters
            .Where(kv => kv.Value.IsOnline && kv.Value.LastSeenAtUtc < threshold)
            .Select(kv => kv.Value)
            .ToList();
        
        if (!offlineCharacters.Any())
            continue;
            
        _logger.LogInformation("检测到 {Count} 个离线角色", offlineCharacters.Count);
        
        foreach (var character in offlineCharacters)
        {
            character.IsOnline = false;
            // 更新内存（不立即保存）
            _characterManager.Update(character);
        }
        
        // 可选：立即触发一次保存（确保离线状态及时持久化）
        await _persistenceCoordinator.TriggerSaveAsync("Character");
    }
}
```

**配置更新** (`appsettings.json`):
```json
{
  "Offline": {
    "OfflineDetectionSeconds": 30,
    "OfflineThresholdSeconds": 360,  // 从 60s 增加到 360s
    "MaxOfflineSeconds": 43200,
    "AutoApplyRewards": true
  }
}
```

**步骤 3: 单元测试** ⏱️ 3-4h

```csharp
public class CharacterHeartbeatTests
{
    [Fact]
    public async Task Heartbeat_ShouldUpdateMemoryOnly()
    {
        // Arrange
        var characterManager = new MemoryStateManager<Character>();
        var character = new Character { Id = Guid.NewGuid() };
        characterManager.Add(character);
        
        // Act
        character.LastSeenAtUtc = DateTime.UtcNow;
        characterManager.Update(character);
        
        // Assert
        var dirtyEntities = characterManager.GetDirtyEntities().ToList();
        dirtyEntities.Should().ContainSingle();
    }
    
    [Fact]
    public async Task OfflineDetection_ShouldUseMemory()
    {
        // 测试离线检测从内存读取
        // ...
    }
}
```

**步骤 4: 集成测试和验证** ⏱️ 4-5h

**测试场景**:
1. 模拟 100 个玩家心跳（每 10 秒一次，持续 5 分钟）
2. 验证数据库写入次数大幅减少
3. 验证离线检测仍然正常工作
4. 验证关闭时所有心跳正确保存

**性能验证**:
```csharp
[Fact]
public async Task Heartbeat_PerformanceTest()
{
    // 模拟 100 个玩家，5 分钟心跳
    var playerCount = 100;
    var durationMinutes = 5;
    
    var sw = Stopwatch.StartNew();
    
    // 执行心跳
    for (int i = 0; i < durationMinutes * 60 / 10; i++)
    {
        foreach (var player in players)
        {
            await controller.Heartbeat(player.Id);
        }
        await Task.Delay(10000); // 10秒
    }
    
    sw.Stop();
    
    // 验证数据库保存次数
    var saveCount = GetDatabaseSaveCount();
    saveCount.Should().BeLessThan(100); // 远少于之前的 3000 次
}
```

#### 验收标准

- [ ] 心跳 API 正常工作
- [ ] 离线检测正常工作
- [ ] 数据库写入减少 > 90%
- [ ] 响应时间减少 > 50%
- [ ] 所有测试通过

---

### Phase 2.2: 战斗快照迁移 ⏱️ 24-32h

#### 目标
将战斗快照从"每 500ms 保存"改为"内存管理 + 每分钟保存"

#### 现状分析

**当前代码** (`StepBattleHostedService.cs`):
```csharp
protected override async Task ExecuteAsync(CancellationToken stoppingToken)
{
    while (!stoppingToken.IsCancellationRequested)
    {
        await Task.Delay(500, stoppingToken);
        
        // 每 500ms 保存所有战斗快照
        await _snapshotService.SaveAllRunningBattleSnapshotsAsync(stoppingToken);
    }
}
```

**StepBattleSnapshotService.SaveAllRunningBattleSnapshotsAsync**:
```csharp
public async Task SaveAllRunningBattleSnapshotsAsync(CancellationToken ct)
{
    var battleIds = _coordinator.InternalIdsSnapshot();
    
    using var scope = _scopeFactory.CreateScope();
    var db = scope.ServiceProvider.GetRequiredService<GameDbContext>();
    
    foreach (var id in battleIds)
    {
        var (found, status) = _coordinator.GetStatus(id);
        if (!found) continue;
        
        var snapshot = CreateSnapshot(id, status);
        
        // 立即保存到数据库
        db.RunningBattleSnapshots.Update(snapshot);
        await db.SaveChangesAsync(ct);
    }
}
```

**问题**:
- 每 500ms 保存一次，每个战斗 7,200 次/小时
- 10 个并发战斗 = 72,000 次/小时
- 快照主要用于恢复，不需要实时更新

#### 迁移方案

**步骤 1: 修改 StepBattleHostedService** ⏱️ 4-6h

**新实现**:
```csharp
protected override async Task ExecuteAsync(CancellationToken stoppingToken)
{
    _logger.LogInformation("战斗快照服务已启动（使用内存管理）");
    
    while (!stoppingToken.IsCancellationRequested)
    {
        await Task.Delay(500, stoppingToken);
        
        // 仅更新内存快照（不保存到数据库）
        await UpdateAllBattleSnapshotsInMemoryAsync(stoppingToken);
    }
}

private async Task UpdateAllBattleSnapshotsInMemoryAsync(CancellationToken ct)
{
    var battleIds = _coordinator.InternalIdsSnapshot();
    
    foreach (var id in battleIds)
    {
        var (found, status) = _coordinator.GetStatus(id);
        if (!found) continue;
        
        var snapshot = CreateSnapshot(id, status);
        
        // 更新内存（不立即保存）
        _battleSnapshotManager.Update(snapshot);
    }
    
    _logger.LogDebug("已更新 {Count} 个战斗快照（内存）", battleIds.Count());
}
```

**步骤 2: 创建 BattleSnapshotRecoveryService** ⏱️ 6-8h

战斗恢复逻辑需要调整，因为快照不再实时保存：

```csharp
public class BattleSnapshotRecoveryService
{
    private readonly MemoryStateManager<RunningBattleSnapshotRecord> _snapshotManager;
    private readonly GameDbContext _db;
    private readonly ILogger<BattleSnapshotRecoveryService> _logger;
    
    /// <summary>
    /// 恢复角色的运行中战斗
    /// 策略：
    /// 1. 先从内存查找最新快照
    /// 2. 内存未命中则从数据库加载
    /// 3. 快照过期则放弃恢复
    /// </summary>
    public async Task<RunningBattleSnapshotRecord?> GetLatestSnapshotAsync(
        Guid characterId, 
        CancellationToken ct = default)
    {
        // 1. 从内存中查找（最新）
        var memorySnapshot = _snapshotManager.GetSnapshot()
            .Values
            .Where(s => s.CharacterId == characterId)
            .OrderByDescending(s => s.SavedAtUtc)
            .FirstOrDefault();
        
        if (memorySnapshot != null)
        {
            _logger.LogInformation(
                "从内存恢复战斗快照（角色 {CharacterId}）",
                characterId
            );
            return memorySnapshot;
        }
        
        // 2. 内存未命中，从数据库加载
        var dbSnapshot = await _db.RunningBattleSnapshots
            .Where(s => s.CharacterId == characterId)
            .OrderByDescending(s => s.SavedAtUtc)
            .FirstOrDefaultAsync(ct);
        
        if (dbSnapshot != null)
        {
            // 检查快照是否过期（> 2 分钟视为过期）
            var age = DateTime.UtcNow - dbSnapshot.SavedAtUtc;
            if (age.TotalMinutes > 2)
            {
                _logger.LogWarning(
                    "战斗快照已过期（{Age} 分钟），放弃恢复",
                    age.TotalMinutes
                );
                return null;
            }
            
            _logger.LogInformation(
                "从数据库恢复战斗快照（角色 {CharacterId}，快照年龄 {Age}s）",
                characterId,
                age.TotalSeconds
            );
            
            // 加载到内存
            _snapshotManager.Add(dbSnapshot);
            
            return dbSnapshot;
        }
        
        _logger.LogInformation(
            "未找到战斗快照（角色 {CharacterId}）",
            characterId
        );
        
        return null;
    }
}
```

**步骤 3: 更新战斗结束清理逻辑** ⏱️ 3-4h

```csharp
public async Task CleanupBattleSnapshotAsync(Guid battleId)
{
    // 从内存中移除
    _battleSnapshotManager.Remove(battleId);
    
    // 数据库中删除（延迟到下次保存周期，或者立即删除）
    using var scope = _scopeFactory.CreateScope();
    var db = scope.ServiceProvider.GetRequiredService<GameDbContext>();
    
    var snapshot = await db.RunningBattleSnapshots.FindAsync(battleId);
    if (snapshot != null)
    {
        db.RunningBattleSnapshots.Remove(snapshot);
        await db.SaveChangesAsync();
    }
}
```

**步骤 4: 配置更新** ⏱️ 1-2h

```json
{
  "Persistence": {
    "EntitySaveStrategies": {
      "BattleSnapshot": {
        "SaveIntervalMs": 60000,  // 每分钟保存（而非 500ms）
        "MaxBatchSize": 500,
        "SnapshotExpirationMinutes": 2  // 快照过期时间
      }
    }
  }
}
```

**步骤 5: 单元测试** ⏱️ 4-6h

```csharp
public class BattleSnapshotMigrationTests
{
    [Fact]
    public async Task UpdateSnapshot_ShouldOnlyUpdateMemory()
    {
        // 测试快照仅更新内存
    }
    
    [Fact]
    public async Task RecoverSnapshot_ShouldTryMemoryFirst()
    {
        // 测试恢复优先从内存读取
    }
    
    [Fact]
    public async Task RecoverSnapshot_ShouldRejectExpiredSnapshot()
    {
        // 测试拒绝过期快照
    }
}
```

**步骤 6: 集成测试和性能验证** ⏱️ 6-8h

**测试场景**:
1. 模拟 10 个并发战斗，持续 10 分钟
2. 验证快照内存更新正常
3. 验证定期保存正常工作
4. 验证战斗恢复功能正常
5. 模拟服务器重启，验证恢复逻辑

**性能验证**:
```csharp
[Fact]
public async Task BattleSnapshot_PerformanceTest()
{
    // 10 个并发战斗，10 分钟
    var battleCount = 10;
    var durationMinutes = 10;
    
    var sw = Stopwatch.StartNew();
    
    // 启动战斗
    var battles = StartBattles(battleCount);
    
    // 等待 10 分钟
    await Task.Delay(TimeSpan.FromMinutes(durationMinutes));
    
    sw.Stop();
    
    // 验证数据库保存次数
    var saveCount = GetDatabaseSaveCount();
    
    // 之前: 10 * 7200 * (10/60) = 12,000 次
    // 现在: 10 * 10 = 100 次
    saveCount.Should().BeLessThan(200); // 减少 99%
}
```

#### 验收标准

- [ ] 战斗快照功能正常
- [ ] 战斗恢复功能正常
- [ ] 数据库写入减少 > 98%
- [ ] 快照过期机制正常工作
- [ ] 所有测试通过

---

### Phase 2.3: 活动计划迁移 ⏱️ 16-24h

#### 目标
将活动计划状态更新从"立即保存"改为"内存管理 + 定期保存"

#### 现状分析

**当前代码** (`ActivityPlanRepository.cs`):
```csharp
public async Task UpdateAsync(ActivityPlan plan, CancellationToken ct = default)
{
    _db.ActivityPlans.Update(plan);
    await DatabaseRetryPolicy.SaveChangesWithRetryAsync(_db, ct);
}
```

活动计划状态变更频繁：
- 状态切换（Pending → Running → Completed）
- 进度更新（RemainingCount, RemainingDurationSeconds）
- 完成时间记录

#### 迁移方案

**步骤 1: 创建 ActivityPlanService 适配层** ⏱️ 6-8h

```csharp
public class ActivityPlanService
{
    private readonly MemoryStateManager<ActivityPlan> _planManager;
    private readonly GameDbContext _db;
    private readonly ILogger<ActivityPlanService> _logger;
    
    /// <summary>
    /// 创建活动计划（立即持久化，关键操作）
    /// </summary>
    public async Task<ActivityPlan> CreateAsync(
        Guid characterId,
        ActivityType type,
        ActivityLimit limit,
        CancellationToken ct = default)
    {
        var plan = new ActivityPlan
        {
            Id = Guid.NewGuid(),
            CharacterId = characterId,
            Type = type,
            State = ActivityState.Pending,
            Limit = limit,
            CreatedAt = DateTime.UtcNow
        };
        
        // 添加到内存
        _planManager.Add(plan);
        
        // 立即持久化（创建操作是关键操作）
        _db.ActivityPlans.Add(plan);
        await _db.SaveChangesAsync(ct);
        
        _logger.LogInformation(
            "活动计划已创建：{PlanId}, 类型 {Type}",
            plan.Id, plan.Type
        );
        
        return plan;
    }
    
    /// <summary>
    /// 更新活动计划状态（仅内存）
    /// </summary>
    public void UpdateState(Guid planId, ActivityState newState)
    {
        var plan = _planManager.GetAsync(planId).GetAwaiter().GetResult();
        if (plan == null)
        {
            _logger.LogWarning("活动计划未找到：{PlanId}", planId);
            return;
        }
        
        plan.State = newState;
        plan.UpdatedAt = DateTime.UtcNow;
        
        if (newState == ActivityState.Completed)
        {
            plan.CompletedAt = DateTime.UtcNow;
        }
        
        // 更新内存（不立即保存）
        _planManager.Update(plan);
        
        _logger.LogDebug(
            "活动计划状态已更新（内存）：{PlanId} -> {State}",
            planId, newState
        );
    }
    
    /// <summary>
    /// 更新活动进度（仅内存）
    /// </summary>
    public void UpdateProgress(Guid planId, int? remainingCount, double? remainingSeconds)
    {
        var plan = _planManager.GetAsync(planId).GetAwaiter().GetResult();
        if (plan == null) return;
        
        if (remainingCount.HasValue)
            plan.RemainingCount = remainingCount.Value;
            
        if (remainingSeconds.HasValue)
            plan.RemainingDurationSeconds = remainingSeconds.Value;
        
        plan.UpdatedAt = DateTime.UtcNow;
        
        // 更新内存
        _planManager.Update(plan);
        
        _logger.LogTrace(
            "活动进度已更新（内存）：{PlanId}, 剩余 {Count}/{Seconds}",
            planId, remainingCount, remainingSeconds
        );
    }
    
    /// <summary>
    /// 删除活动计划（立即持久化）
    /// </summary>
    public async Task DeleteAsync(Guid planId, CancellationToken ct = default)
    {
        // 从内存移除
        _planManager.Remove(planId);
        
        // 立即从数据库删除
        var plan = await _db.ActivityPlans.FindAsync(new object[] { planId }, ct);
        if (plan != null)
        {
            _db.ActivityPlans.Remove(plan);
            await _db.SaveChangesAsync(ct);
        }
        
        _logger.LogInformation("活动计划已删除：{PlanId}", planId);
    }
}
```

**步骤 2: 更新使用 ActivityPlanRepository 的代码** ⏱️ 6-8h

需要修改的文件：
- `ActivityPlansController.cs`
- `StepBattleCoordinator.cs`
- `OfflineSettlementService.cs`

**示例修改** (`ActivityPlansController.cs`):
```csharp
// 之前
await _repository.UpdateAsync(plan);

// 之后
_activityPlanService.UpdateState(plan.Id, ActivityState.Running);
```

**步骤 3: 单元测试** ⏱️ 4-6h

```csharp
public class ActivityPlanMigrationTests
{
    [Fact]
    public async Task CreatePlan_ShouldPersistImmediately()
    {
        // 创建应立即持久化
    }
    
    [Fact]
    public void UpdateState_ShouldOnlyUpdateMemory()
    {
        // 状态更新仅内存
    }
    
    [Fact]
    public void UpdateProgress_ShouldOnlyUpdateMemory()
    {
        // 进度更新仅内存
    }
}
```

**步骤 4: 集成测试** ⏱️ 4-6h

**测试场景**:
1. 创建多个活动计划
2. 模拟活动状态变更和进度更新
3. 验证内存更新正常
4. 验证定期保存正常
5. 验证关闭时所有计划正确保存

#### 验收标准

- [ ] 活动计划创建正常
- [ ] 状态更新正常
- [ ] 进度跟踪正常
- [ ] 数据库写入减少 > 90%
- [ ] 所有测试通过

---

### Phase 2.4: 其他操作优化 ⏱️ 12-24h

#### 目标
优化其他低频但可优化的操作

#### 优化项目

**1. 经济事件记录** ⏱️ 4-6h

当前：每次经济事件（金币、经验获得）立即记录
优化：批量记录（每分钟汇总一次）

**2. 装备变更** ⏱️ 4-6h

当前：每次装备操作立即保存
保持：装备变更保持立即保存（涉及玩家资产，应确保安全）

**3. 商店购买记录** ⏱️ 4-6h

当前：每次购买立即记录
保持：购买记录保持立即保存（涉及玩家消费）

**4. 统计数据** ⏱️ 4-6h

当前：部分统计数据立即更新
优化：统计数据批量更新（每 5 分钟）

---

## 测试和验证

### 全面集成测试

**测试环境搭建** ⏱️ 4-6h

1. 准备测试数据
2. 配置测试环境
3. 部署迁移后版本

**测试场景** ⏱️ 8-12h

#### 场景 1: 正常游戏流程
```
1. 创建角色
2. 开始战斗（10 分钟）
3. 心跳保持（每 10 秒）
4. 活动计划切换
5. 正常退出
```

**验证点**:
- [ ] 所有功能正常
- [ ] 数据完整性
- [ ] 性能提升明显

#### 场景 2: 高负载测试
```
1. 模拟 100 个在线玩家
2. 50 个并发战斗
3. 持续 30 分钟
4. 正常关闭
```

**验证点**:
- [ ] 系统稳定性
- [ ] 内存使用合理
- [ ] 数据库压力降低
- [ ] 所有数据正确保存

#### 场景 3: 异常恢复测试
```
1. 启动多个战斗
2. 模拟服务器重启
3. 恢复战斗
4. 验证数据完整性
```

**验证点**:
- [ ] 战斗恢复正常
- [ ] 无数据丢失
- [ ] 状态一致性

### 性能对比测试

**测试工具**: Apache JMeter / k6

**测试指标**:

| 指标 | 迁移前 | 迁移后 | 目标改善 |
|-----|-------|-------|---------|
| 数据库写入次数/小时 | ~100,000 | <5,000 | > 95% ↓ |
| API 响应时间 P95 | 300ms | <100ms | > 66% ↓ |
| 内存使用 | 200MB | <400MB | +100MB (acceptable) |
| CPU 使用率 | 40% | <35% | > 12% ↓ |
| 并发战斗数 | 15 | >50 | > 3x ↑ |

---

## 回退方案

### 配置开关

```json
{
  "Persistence": {
    "EnableMemoryBuffering": false  // 设为 false 即可回退
  }
}
```

### 回退流程

1. **检测问题**：监控指标异常或用户反馈
2. **评估影响**：确认是否需要回退
3. **执行回退**：
   ```bash
   # 更新配置
   "EnableMemoryBuffering": false
   
   # 重启服务
   systemctl restart blazoridle
   ```
4. **验证回退**：确认系统恢复正常
5. **分析问题**：定位根本原因
6. **修复问题**：修复后重新上线

### 回退准备

- [ ] 准备回退配置文件
- [ ] 测试回退流程
- [ ] 文档化回退步骤
- [ ] 准备回退决策标准

---

## 验收标准

### 功能验收

- [ ] 所有现有功能正常工作
- [ ] API 接口兼容性保持
- [ ] 用户体验无感知变化

### 性能验收

- [ ] 数据库写入减少 > 80%
- [ ] API 响应时间改善 > 30%
- [ ] 并发能力提升 > 2x
- [ ] 内存增加 < 200MB

### 稳定性验收

- [ ] 24 小时稳定性测试通过
- [ ] 无内存泄漏
- [ ] 无数据丢失
- [ ] 错误率 < 0.1%

### 文档验收

- [ ] 迁移文档完整
- [ ] API 文档更新
- [ ] 运维文档更新
- [ ] 回退方案文档

---

## 上线计划

### 灰度发布

**Stage 1**: 内部测试（1-2 天）
- 开发环境全面测试
- 修复发现的问题

**Stage 2**: 小范围灰度（2-3 天）
- 10% 用户流量
- 密切监控指标
- 快速响应问题

**Stage 3**: 扩大灰度（3-5 天）
- 50% 用户流量
- 继续监控
- 收集反馈

**Stage 4**: 全量上线（1 天）
- 100% 用户流量
- 持续监控
- 准备快速回退

### 监控指标

上线后持续监控：
- 数据库写入次数
- API 响应时间
- 内存使用
- CPU 使用率
- 错误率
- 用户反馈

---

## 下一步

完成中篇后，进入下篇：**优化和完善**

预览下篇核心任务：
1. 性能调优
2. 监控指标完善
3. 文档完善
4. 运维工具开发

---

**文档状态**: ✅ 待实施  
**依赖**: 上篇完成  
**预计开始**: 上篇完成后 1-2 天  
**预计完成**: 8-12 个工作日
