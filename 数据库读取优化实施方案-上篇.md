# BlazorIdle 数据库读取优化实施方案 - 上篇

**阶段**: Phase 1 - 缓存层基础设施建设  
**文档版本**: 1.0  
**创建日期**: 2025-10-18  
**工作量估算**: 3-4 天  
**前置条件**: 写入优化 Phase 1-3 已完成

---

## 📋 目录

1. [阶段目标](#阶段目标)
2. [核心任务清单](#核心任务清单)
3. [详细实施步骤](#详细实施步骤)
4. [测试验证](#测试验证)
5. [验收标准](#验收标准)

---

## 阶段目标

### 主要目标

**建立数据库读取缓存的基础设施，为后续迁移做准备。**

具体目标：
1. ✅ 增强现有 MemoryStateManager，支持高效的缓存读取
2. ✅ 创建 CacheCoordinator，管理缓存预加载和清理
3. ✅ 建立完整的配置系统（CacheConfiguration）
4. ✅ 添加缓存监控指标（命中率、内存使用）
5. ✅ 确保所有参数配置化，无硬编码

### 关键原则

1. **不改变现有接口**：Repository 接口保持不变
2. **与写入协同**：利用已有的 MemoryStateManager
3. **配置化优先**：所有参数在 appsettings.json
4. **渐进式演进**：先建基础设施，再迁移使用
5. **保持代码风格**：遵循项目规范

### 不包含在本阶段

- ❌ 迁移现有 Repository 到缓存读取（放在中篇）
- ❌ 性能调优和压力测试（放在下篇）
- ❌ 管理接口开发（放在下篇）

---

## 核心任务清单

### Task 1: 增强 MemoryStateManager

**目的**：添加缓存读取能力

#### 1.1 添加 TryGetAsync 方法
- [ ] 实现"先查内存，未命中再查数据库"逻辑
- [ ] 添加缓存命中/未命中计数器
- [ ] 线程安全保证

#### 1.2 添加批量预加载方法
- [ ] PreloadBatch：批量加载实体到内存
- [ ] PreloadFromDatabase：从数据库批量预加载

#### 1.3 添加缓存统计方法
- [ ] GetCacheHitRate：获取缓存命中率
- [ ] GetCachedCount：获取当前缓存数量
- [ ] GetCacheStatistics：获取详细统计信息

#### 1.4 添加缓存管理方法
- [ ] InvalidateCache：使特定实体缓存失效
- [ ] ClearExpired：清理过期缓存（基于 TTL）
- [ ] ClearAll：清空所有缓存

**文件位置**：
```
BlazorIdle.Server/Infrastructure/DatabaseOptimization/MemoryStateManager.cs
```

**工作量**：4-6 小时

---

### Task 2: 创建 CacheCoordinator

**目的**：统一管理缓存生命周期

#### 2.1 创建 CacheCoordinator 类
- [ ] 继承 BackgroundService
- [ ] 依赖注入所有 MemoryStateManager<T>
- [ ] 加载 CacheConfiguration

#### 2.2 实现启动时预加载
- [ ] PreloadStaticDataAsync：预加载静态配置数据
- [ ] PreloadEntityAsync<T>：预加载特定实体类型
- [ ] 分批加载，避免内存峰值

#### 2.3 实现定期缓存清理
- [ ] ExecuteAsync：后台定期任务
- [ ] CleanupExpiredCachesAsync：清理过期缓存
- [ ] 基于 TTL 和 LRU 策略

#### 2.4 实现缓存失效通知
- [ ] InvalidateEntity：使特定实体失效
- [ ] InvalidateEntityType：使整个类型失效
- [ ] 支持外部触发（API 调用）

**文件位置**：
```
BlazorIdle.Server/Infrastructure/DatabaseOptimization/CacheCoordinator.cs
```

**工作量**：6-8 小时

---

### Task 3: 创建配置系统

**目的**：所有参数配置化

#### 3.1 创建配置类
- [ ] CacheConfiguration：顶层配置
- [ ] EntityCacheStrategy：实体缓存策略
- [ ] GlobalCacheSettings：全局设置
- [ ] CacheStrategyType：枚举（None/Permanent/Temporary）

#### 3.2 添加数据验证
- [ ] DataAnnotations 验证范围
- [ ] 自定义验证逻辑
- [ ] 启动时配置验证

#### 3.3 创建配置文件
- [ ] appsettings.json 添加 CacheConfiguration 节
- [ ] appsettings.Development.json 示例配置
- [ ] appsettings.Production.example.json 示例配置

#### 3.4 注册配置服务
- [ ] Program.cs 或 DependencyInjection.cs 注册
- [ ] 配置验证
- [ ] 配置绑定

**文件位置**：
```
BlazorIdle.Server/Config/DatabaseOptimization/
├── CacheConfiguration.cs
├── EntityCacheStrategy.cs
├── GlobalCacheSettings.cs
└── CacheStrategyType.cs
```

**工作量**：3-4 小时

---

### Task 4: 扩展缓存监控

**目的**：监控缓存性能

#### 4.1 扩展 DatabaseMetricsCollector
- [ ] RecordCacheHit：记录缓存命中
- [ ] RecordCacheMiss：记录缓存未命中
- [ ] RecordCacheSize：记录缓存大小
- [ ] GetCacheMetrics：获取缓存指标

#### 4.2 添加缓存监控配置
- [ ] 扩展 MonitoringOptions
- [ ] 添加 CacheMonitoringSettings
- [ ] 配置化监控参数

#### 4.3 集成到 DatabaseHealthController
- [ ] 添加 /api/database/cache-stats 端点
- [ ] 返回各实体类型的缓存统计
- [ ] 返回总体命中率

**文件位置**：
```
BlazorIdle.Server/Infrastructure/DatabaseOptimization/DatabaseMetricsCollector.cs
BlazorIdle.Server/Api/DatabaseHealthController.cs
BlazorIdle.Server/Config/DatabaseOptimization/MonitoringOptions.cs (扩展)
```

**工作量**：3-4 小时

---

### Task 5: 依赖注入配置

**目的**：注册所有新服务

#### 5.1 注册 CacheCoordinator
- [ ] 注册为 HostedService
- [ ] 确保在其他服务之后启动

#### 5.2 注册配置选项
- [ ] 注册 CacheConfiguration
- [ ] 配置验证

#### 5.3 更新 MemoryStateManager 注册
- [ ] 确保所有实体类型都有对应的 MemoryStateManager
- [ ] 单例生命周期

**文件位置**：
```
BlazorIdle.Server/Infrastructure/DependencyInjection.cs
BlazorIdle.Server/Program.cs
```

**工作量**：1-2 小时

---

### Task 6: 单元测试

**目的**：确保基础功能正确

#### 6.1 MemoryStateManager 测试
- [ ] TryGetAsync 功能测试
- [ ] 缓存命中/未命中测试
- [ ] PreloadBatch 测试
- [ ] 线程安全测试

#### 6.2 CacheCoordinator 测试
- [ ] PreloadStaticDataAsync 测试
- [ ] CleanupExpiredCachesAsync 测试
- [ ] TTL 过期测试

#### 6.3 配置验证测试
- [ ] 配置加载测试
- [ ] 验证规则测试
- [ ] 默认值测试

**文件位置**：
```
tests/BlazorIdle.Tests/DatabaseOptimization/
├── MemoryStateManagerCacheTests.cs
├── CacheCoordinatorTests.cs
└── CacheConfigurationTests.cs
```

**工作量**：4-6 小时

---

## 详细实施步骤

### Step 1: 增强 MemoryStateManager（4-6小时）

#### 1.1 添加缓存统计字段

```csharp
// 在 MemoryStateManager<T> 类中添加：

/// <summary>
/// 缓存命中次数
/// Cache hit count
/// </summary>
private long _cacheHits = 0;

/// <summary>
/// 缓存未命中次数
/// Cache miss count
/// </summary>
private long _cacheMisses = 0;

/// <summary>
/// 最后访问时间（用于 LRU）
/// Last access time (for LRU)
/// </summary>
private readonly ConcurrentDictionary<Guid, DateTime> _lastAccessTime = new();
```

#### 1.2 实现 TryGetAsync 方法

```csharp
/// <summary>
/// 尝试获取实体（缓存优先）
/// Try to get entity (cache first)
/// 
/// 逻辑说明：
/// 1. 先查内存缓存（_store）
/// 2. 命中则更新访问时间，增加命中计数，返回
/// 3. 未命中则调用 databaseLoader 查询数据库
/// 4. 查到后加载到内存，返回
/// 5. 未查到则返回 null
/// </summary>
/// <param name="id">实体 ID</param>
/// <param name="databaseLoader">数据库查询委托</param>
/// <param name="ct">取消令牌</param>
/// <returns>实体对象，未找到返回 null</returns>
public async Task<T?> TryGetAsync(
    Guid id, 
    Func<Guid, CancellationToken, Task<T?>> databaseLoader, 
    CancellationToken ct = default)
{
    // 1. 先查内存缓存
    if (_store.TryGetValue(id, out var cached))
    {
        // 命中：更新统计
        Interlocked.Increment(ref _cacheHits);
        _lastAccessTime.TryAdd(id, DateTime.UtcNow);
        
        _logger?.LogDebug(
            "[MemoryStateManager<{EntityType}>] 缓存命中: {Id}",
            typeof(T).Name, id
        );
        
        return cached;
    }
    
    // 2. 未命中：查询数据库
    Interlocked.Increment(ref _cacheMisses);
    
    _logger?.LogDebug(
        "[MemoryStateManager<{EntityType}>] 缓存未命中，查询数据库: {Id}",
        typeof(T).Name, id
    );
    
    var entity = await databaseLoader(id, ct);
    
    // 3. 加载到内存（如果查到了）
    if (entity != null)
    {
        _store.TryAdd(id, entity);
        _lastAccessTime.TryAdd(id, DateTime.UtcNow);
        
        // 检查是否超过容量限制
        await CheckAndEvictIfNeededAsync();
    }
    
    return entity;
}
```

#### 1.3 实现批量预加载方法

```csharp
/// <summary>
/// 批量预加载实体（不标记为 Dirty）
/// Batch preload entities (without marking as Dirty)
/// </summary>
/// <param name="entities">实体集合</param>
public void PreloadBatch(IEnumerable<T> entities)
{
    var now = DateTime.UtcNow;
    var count = 0;
    
    foreach (var entity in entities)
    {
        if (_store.TryAdd(entity.Id, entity))
        {
            _lastAccessTime.TryAdd(entity.Id, now);
            count++;
        }
    }
    
    _logger?.LogInformation(
        "[MemoryStateManager<{EntityType}>] 预加载完成: {Count} 个实体",
        typeof(T).Name, count
    );
}

/// <summary>
/// 从数据库批量预加载
/// Batch preload from database
/// </summary>
/// <param name="dbContext">数据库上下文</param>
/// <param name="batchSize">批量大小</param>
/// <param name="ct">取消令牌</param>
public async Task PreloadFromDatabaseAsync(
    GameDbContext dbContext, 
    int batchSize = 1000, 
    CancellationToken ct = default)
{
    var skip = 0;
    int loaded;
    var totalLoaded = 0;
    
    do
    {
        var batch = await dbContext.Set<T>()
            .Skip(skip)
            .Take(batchSize)
            .ToListAsync(ct);
        
        loaded = batch.Count;
        PreloadBatch(batch);
        
        skip += batchSize;
        totalLoaded += loaded;
    }
    while (loaded == batchSize && !ct.IsCancellationRequested);
    
    _logger?.LogInformation(
        "[MemoryStateManager<{EntityType}>] 从数据库预加载完成: {Total} 个实体",
        typeof(T).Name, totalLoaded
    );
}
```

#### 1.4 实现缓存统计方法

```csharp
/// <summary>
/// 获取缓存命中率
/// Get cache hit rate
/// </summary>
/// <returns>命中率（0.0-1.0）</returns>
public double GetCacheHitRate()
{
    var total = _cacheHits + _cacheMisses;
    return total > 0 ? (double)_cacheHits / total : 0.0;
}

/// <summary>
/// 获取缓存统计信息
/// Get cache statistics
/// </summary>
public CacheStatistics GetCacheStatistics()
{
    return new CacheStatistics
    {
        EntityType = typeof(T).Name,
        CachedCount = _store.Count,
        DirtyCount = _dirtyEntities.Count,
        CacheHits = _cacheHits,
        CacheMisses = _cacheMisses,
        HitRate = GetCacheHitRate()
    };
}
```

#### 1.5 实现缓存清理方法

```csharp
/// <summary>
/// 清理过期缓存（基于 TTL）
/// Clear expired cache entries (based on TTL)
/// </summary>
/// <param name="ttlSeconds">过期时间（秒）</param>
public int ClearExpired(int ttlSeconds)
{
    var cutoff = DateTime.UtcNow.AddSeconds(-ttlSeconds);
    var expiredIds = _lastAccessTime
        .Where(kvp => kvp.Value < cutoff)
        .Select(kvp => kvp.Key)
        .ToList();
    
    var removedCount = 0;
    foreach (var id in expiredIds)
    {
        // 不移除 Dirty 的实体（还未保存）
        if (!_dirtyEntities.ContainsKey(id))
        {
            if (_store.TryRemove(id, out _))
            {
                _lastAccessTime.TryRemove(id, out _);
                removedCount++;
            }
        }
    }
    
    if (removedCount > 0)
    {
        _logger?.LogInformation(
            "[MemoryStateManager<{EntityType}>] 清理过期缓存: {Count} 个实体",
            typeof(T).Name, removedCount
        );
    }
    
    return removedCount;
}

/// <summary>
/// LRU 清理：移除最久未访问的实体
/// LRU eviction: Remove least recently used entities
/// </summary>
/// <param name="targetCount">目标保留数量</param>
private async Task CheckAndEvictIfNeededAsync()
{
    var maxCount = _options?.MaxCachedEntities ?? 10000;
    
    if (_store.Count <= maxCount)
        return;
    
    // LRU 清理：移除最久未访问的
    var toRemoveCount = _store.Count - (int)(maxCount * 0.9); // 清理到 90%
    
    var lruEntities = _lastAccessTime
        .Where(kvp => !_dirtyEntities.ContainsKey(kvp.Key)) // 不移除 Dirty
        .OrderBy(kvp => kvp.Value)
        .Take(toRemoveCount)
        .Select(kvp => kvp.Key)
        .ToList();
    
    foreach (var id in lruEntities)
    {
        _store.TryRemove(id, out _);
        _lastAccessTime.TryRemove(id, out _);
    }
    
    _logger?.LogWarning(
        "[MemoryStateManager<{EntityType}>] LRU 清理: {Count} 个实体",
        typeof(T).Name, lruEntities.Count
    );
}
```

---

### Step 2: 创建 CacheCoordinator（6-8小时）

#### 2.1 创建类骨架

```csharp
/// <summary>
/// 缓存协调器 - 管理缓存的预加载、清理和失效
/// Cache Coordinator - Manages cache preloading, cleanup, and invalidation
/// 
/// 职责：
/// 1. 启动时预加载静态配置数据（GearDefinition, Affix 等）
/// 2. 定期清理过期缓存（基于 TTL）
/// 3. 提供手动刷新缓存的接口
/// 4. 记录缓存监控指标
/// </summary>
public class CacheCoordinator : BackgroundService
{
    private readonly IServiceScopeFactory _scopeFactory;
    private readonly IOptions<CacheConfiguration> _cacheConfig;
    private readonly ILogger<CacheCoordinator> _logger;
    private readonly DatabaseMetricsCollector? _metricsCollector;
    
    // 各类型实体的内存管理器
    private readonly IMemoryStateManager<Character>? _characterManager;
    private readonly IMemoryStateManager<GearDefinition>? _gearDefManager;
    private readonly IMemoryStateManager<Affix>? _affixManager;
    private readonly IMemoryStateManager<GearSet>? _gearSetManager;
    private readonly IMemoryStateManager<GearInstance>? _gearInstanceManager;
    private readonly IMemoryStateManager<ActivityPlan>? _activityPlanManager;
    private readonly IMemoryStateManager<RunningBattleSnapshotRecord>? _snapshotManager;
    
    public CacheCoordinator(
        IServiceScopeFactory scopeFactory,
        IOptions<CacheConfiguration> cacheConfig,
        ILogger<CacheCoordinator> logger,
        DatabaseMetricsCollector? metricsCollector = null,
        IMemoryStateManager<Character>? characterManager = null,
        IMemoryStateManager<GearDefinition>? gearDefManager = null,
        IMemoryStateManager<Affix>? affixManager = null,
        IMemoryStateManager<GearSet>? gearSetManager = null,
        IMemoryStateManager<GearInstance>? gearInstanceManager = null,
        IMemoryStateManager<ActivityPlan>? activityPlanManager = null,
        IMemoryStateManager<RunningBattleSnapshotRecord>? snapshotManager = null)
    {
        _scopeFactory = scopeFactory;
        _cacheConfig = cacheConfig;
        _logger = logger;
        _metricsCollector = metricsCollector;
        _characterManager = characterManager;
        _gearDefManager = gearDefManager;
        _affixManager = affixManager;
        _gearSetManager = gearSetManager;
        _gearInstanceManager = gearInstanceManager;
        _activityPlanManager = activityPlanManager;
        _snapshotManager = snapshotManager;
    }
    
    // ... 实现方法
}
```

#### 2.2 实现启动时预加载

```csharp
/// <summary>
/// 启动时预加载静态数据
/// Preload static data on startup
/// </summary>
public override async Task StartAsync(CancellationToken cancellationToken)
{
    _logger.LogInformation("=== 缓存协调器启动 ===");
    
    // 检查是否启用读取缓存
    if (!_cacheConfig.Value.GlobalSettings.EnableReadCaching)
    {
        _logger.LogWarning("读取缓存已禁用（EnableReadCaching = false）");
        return;
    }
    
    try
    {
        // 预加载静态配置数据
        await PreloadStaticDataAsync(cancellationToken);
        
        _logger.LogInformation("=== 缓存预加载完成 ===");
    }
    catch (Exception ex)
    {
        _logger.LogError(ex, "缓存预加载失败");
        // 不抛出异常，允许服务继续启动
    }
    
    await base.StartAsync(cancellationToken);
}

/// <summary>
/// 预加载静态配置数据
/// Preload static configuration data
/// </summary>
private async Task PreloadStaticDataAsync(CancellationToken ct)
{
    using var scope = _scopeFactory.CreateScope();
    var db = scope.ServiceProvider.GetRequiredService<GameDbContext>();
    
    // 1. 预加载装备定义
    await PreloadEntityIfConfiguredAsync<GearDefinition>(
        "GearDefinition", 
        _gearDefManager, 
        db, 
        ct
    );
    
    // 2. 预加载词缀定义
    await PreloadEntityIfConfiguredAsync<Affix>(
        "Affix", 
        _affixManager, 
        db, 
        ct
    );
    
    // 3. 预加载装备套装
    await PreloadEntityIfConfiguredAsync<GearSet>(
        "GearSet", 
        _gearSetManager, 
        db, 
        ct
    );
}

/// <summary>
/// 根据配置预加载特定实体类型
/// Preload specific entity type based on configuration
/// </summary>
private async Task PreloadEntityIfConfiguredAsync<T>(
    string entityTypeName,
    IMemoryStateManager<T>? manager,
    GameDbContext db,
    CancellationToken ct) where T : class, IEntity
{
    if (manager == null)
    {
        _logger.LogWarning(
            "跳过 {EntityType} 预加载：MemoryStateManager 未注册",
            entityTypeName
        );
        return;
    }
    
    // 检查配置
    if (!_cacheConfig.Value.EntityStrategies.TryGetValue(entityTypeName, out var strategy))
    {
        _logger.LogDebug(
            "跳过 {EntityType} 预加载：未配置缓存策略",
            entityTypeName
        );
        return;
    }
    
    if (!strategy.PreloadOnStartup)
    {
        _logger.LogDebug(
            "跳过 {EntityType} 预加载：PreloadOnStartup = false",
            entityTypeName
        );
        return;
    }
    
    // 执行预加载
    var sw = System.Diagnostics.Stopwatch.StartNew();
    
    await manager.PreloadFromDatabaseAsync(db, strategy.PreloadBatchSize, ct);
    
    sw.Stop();
    
    var stats = manager.GetCacheStatistics();
    _logger.LogInformation(
        "✓ {EntityType} 预加载完成: {Count} 条记录，耗时 {ElapsedMs}ms",
        entityTypeName, stats.CachedCount, sw.ElapsedMilliseconds
    );
}
```

#### 2.3 实现定期清理

```csharp
/// <summary>
/// 后台定期任务：清理过期缓存
/// Background periodic task: Clean expired cache entries
/// </summary>
protected override async Task ExecuteAsync(CancellationToken stoppingToken)
{
    if (!_cacheConfig.Value.GlobalSettings.EnableReadCaching)
        return;
    
    var interval = TimeSpan.FromMinutes(
        _cacheConfig.Value.GlobalSettings.CleanupIntervalMinutes
    );
    
    _logger.LogInformation(
        "缓存清理任务启动，间隔: {IntervalMinutes} 分钟",
        interval.TotalMinutes
    );
    
    while (!stoppingToken.IsCancellationRequested)
    {
        try
        {
            await Task.Delay(interval, stoppingToken);
            await CleanupExpiredCachesAsync(stoppingToken);
        }
        catch (OperationCanceledException)
        {
            // 正常关闭
            break;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "缓存清理任务出错");
        }
    }
    
    _logger.LogInformation("缓存清理任务已停止");
}

/// <summary>
/// 清理过期缓存
/// Clean expired cache entries
/// </summary>
private async Task CleanupExpiredCachesAsync(CancellationToken ct)
{
    _logger.LogDebug("开始清理过期缓存...");
    
    var totalRemoved = 0;
    
    // 清理各类型实体的过期缓存
    totalRemoved += CleanupEntityIfConfigured<Character>(
        "Character", _characterManager);
    totalRemoved += CleanupEntityIfConfigured<GearInstance>(
        "GearInstance", _gearInstanceManager);
    totalRemoved += CleanupEntityIfConfigured<ActivityPlan>(
        "ActivityPlan", _activityPlanManager);
    totalRemoved += CleanupEntityIfConfigured<RunningBattleSnapshotRecord>(
        "RunningBattleSnapshot", _snapshotManager);
    
    if (totalRemoved > 0)
    {
        _logger.LogInformation(
            "过期缓存清理完成: 总计移除 {Count} 个实体",
            totalRemoved
        );
    }
    else
    {
        _logger.LogDebug("过期缓存清理完成: 无过期项");
    }
    
    await Task.CompletedTask;
}

/// <summary>
/// 清理单个实体类型的过期缓存
/// Clean expired cache for a single entity type
/// </summary>
private int CleanupEntityIfConfigured<T>(
    string entityTypeName,
    IMemoryStateManager<T>? manager) where T : class, IEntity
{
    if (manager == null)
        return 0;
    
    if (!_cacheConfig.Value.EntityStrategies.TryGetValue(entityTypeName, out var strategy))
        return 0;
    
    // 只清理 Temporary 策略的缓存
    if (strategy.Strategy != CacheStrategyType.Temporary)
        return 0;
    
    var removed = manager.ClearExpired(strategy.TtlSeconds);
    
    if (removed > 0)
    {
        _logger.LogDebug(
            "清理 {EntityType} 过期缓存: {Count} 个实体",
            entityTypeName, removed
        );
    }
    
    return removed;
}
```

---

### Step 3: 创建配置系统（3-4小时）

#### 3.1 创建配置类

**文件**: `Config/DatabaseOptimization/CacheConfiguration.cs`

```csharp
using System.ComponentModel.DataAnnotations;
using System.Text.Json.Serialization;

namespace BlazorIdle.Server.Config.DatabaseOptimization;

/// <summary>
/// 缓存配置 - 定义不同实体类型的缓存策略
/// Cache Configuration - Define caching strategies for different entity types
/// </summary>
public class CacheConfiguration
{
    /// <summary>
    /// 实体特定的缓存策略
    /// Entity-specific cache strategies
    /// 
    /// Key: 实体类型名称（如 "GearDefinition", "Character"）
    /// Value: 该实体的缓存策略
    /// </summary>
    public Dictionary<string, EntityCacheStrategy> EntityStrategies { get; set; } 
        = new Dictionary<string, EntityCacheStrategy>();
    
    /// <summary>
    /// 全局缓存设置
    /// Global cache settings
    /// </summary>
    public GlobalCacheSettings GlobalSettings { get; set; } = new GlobalCacheSettings();
}
```

**文件**: `Config/DatabaseOptimization/EntityCacheStrategy.cs`

```csharp
/// <summary>
/// 单个实体类型的缓存策略
/// Cache strategy for a single entity type
/// </summary>
public class EntityCacheStrategy
{
    /// <summary>
    /// 缓存策略类型（None/Permanent/Temporary）
    /// Cache strategy type
    /// 
    /// 说明：
    /// - None: 不缓存，直接查询数据库
    /// - Permanent: 永久缓存，适用于静态配置数据（如装备定义）
    /// - Temporary: 临时缓存，带 TTL，适用于用户数据（如角色、装备实例）
    /// </summary>
    [JsonConverter(typeof(JsonStringEnumConverter))]
    public CacheStrategyType Strategy { get; set; } = CacheStrategyType.Temporary;
    
    /// <summary>
    /// TTL（秒）- 仅对 Temporary 策略有效
    /// Time-to-live in seconds (for Temporary strategy only)
    /// 
    /// 范围：60 秒（1分钟）到 86400 秒（24小时）
    /// 默认：3600 秒（1小时）
    /// </summary>
    [Range(60, 86400)]
    public int TtlSeconds { get; set; } = 3600;
    
    /// <summary>
    /// 最大缓存数量
    /// Maximum cached entities
    /// 
    /// 范围：100 到 1000000
    /// 超过此数量后触发 LRU 清理
    /// </summary>
    [Range(100, 1000000)]
    public int MaxCachedCount { get; set; } = 10000;
    
    /// <summary>
    /// 是否在启动时预加载
    /// Preload on startup
    /// 
    /// 说明：
    /// - 仅对 Permanent 策略推荐启用
    /// - 启用后会在服务启动时从数据库批量加载所有数据到内存
    /// - 适用于数据量不大的静态配置数据
    /// </summary>
    public bool PreloadOnStartup { get; set; } = false;
    
    /// <summary>
    /// 预加载批量大小
    /// Preload batch size
    /// 
    /// 范围：100 到 10000
    /// 默认：1000
    /// 
    /// 说明：控制每次从数据库读取的记录数，避免一次性加载过多导致内存峰值
    /// </summary>
    [Range(100, 10000)]
    public int PreloadBatchSize { get; set; } = 1000;
}
```

**文件**: `Config/DatabaseOptimization/CacheStrategyType.cs`

```csharp
/// <summary>
/// 缓存策略类型枚举
/// Cache Strategy Type Enum
/// </summary>
public enum CacheStrategyType
{
    /// <summary>
    /// 无缓存 - 直接查询数据库
    /// No caching - Query database directly
    /// </summary>
    None = 0,
    
    /// <summary>
    /// 永久缓存 - 适用于静态配置数据
    /// Permanent caching - For static configuration data
    /// 
    /// 特点：
    /// - 启动时预加载
    /// - 不过期（除非手动刷新）
    /// - 适用于：装备定义、词缀定义、装备套装等
    /// </summary>
    Permanent = 1,
    
    /// <summary>
    /// 临时缓存 - 适用于用户数据，带 TTL
    /// Temporary caching - For user data, with TTL
    /// 
    /// 特点：
    /// - 懒加载（按需加载）
    /// - 带过期时间（TTL）
    /// - LRU 清理策略
    /// - 适用于：角色、装备实例、活动计划等
    /// </summary>
    Temporary = 2
}
```

**文件**: `Config/DatabaseOptimization/GlobalCacheSettings.cs`

```csharp
/// <summary>
/// 全局缓存设置
/// Global Cache Settings
/// </summary>
public class GlobalCacheSettings
{
    /// <summary>
    /// 是否启用读取缓存（总开关）
    /// Enable read caching (master switch)
    /// 
    /// 说明：
    /// - true: 启用所有缓存功能
    /// - false: 禁用缓存，所有读取直接查询数据库（用于回退）
    /// 
    /// 默认：true
    /// </summary>
    public bool EnableReadCaching { get; set; } = true;
    
    /// <summary>
    /// 缓存清理间隔（分钟）
    /// Cleanup interval in minutes
    /// 
    /// 范围：1 到 60 分钟
    /// 默认：5 分钟
    /// 
    /// 说明：CacheCoordinator 定期清理过期缓存的间隔
    /// </summary>
    [Range(1, 60)]
    public int CleanupIntervalMinutes { get; set; } = 5;
    
    /// <summary>
    /// 是否记录缓存命中率
    /// Track cache hit rate
    /// 
    /// 说明：
    /// - true: 记录每个实体类型的缓存命中率
    /// - false: 不记录（节省少量性能开销）
    /// 
    /// 默认：true
    /// 推荐：生产环境启用，便于监控
    /// </summary>
    public bool TrackCacheHitRate { get; set; } = true;
    
    /// <summary>
    /// 命中率记录间隔（分钟）
    /// Hit rate logging interval in minutes
    /// 
    /// 范围：1 到 60 分钟
    /// 默认：10 分钟
    /// 
    /// 说明：定期输出缓存命中率到日志的间隔
    /// </summary>
    [Range(1, 60)]
    public int HitRateLogIntervalMinutes { get; set; } = 10;
}
```

#### 3.2 配置文件示例

**文件**: `appsettings.json`

```json
{
  "CacheConfiguration": {
    "EntityStrategies": {
      // === 静态配置数据：永久缓存，启动时预加载 ===
      
      "GearDefinition": {
        "Strategy": "Permanent",
        "PreloadOnStartup": true,
        "PreloadBatchSize": 500,
        "MaxCachedCount": 10000
      },
      
      "Affix": {
        "Strategy": "Permanent",
        "PreloadOnStartup": true,
        "PreloadBatchSize": 1000,
        "MaxCachedCount": 10000
      },
      
      "GearSet": {
        "Strategy": "Permanent",
        "PreloadOnStartup": true,
        "PreloadBatchSize": 100,
        "MaxCachedCount": 1000
      },
      
      // === 用户数据：临时缓存，TTL 机制 ===
      
      "Character": {
        "Strategy": "Temporary",
        "TtlSeconds": 3600,
        "MaxCachedCount": 10000,
        "PreloadOnStartup": false
      },
      
      "GearInstance": {
        "Strategy": "Temporary",
        "TtlSeconds": 1800,
        "MaxCachedCount": 50000,
        "PreloadOnStartup": false
      },
      
      "ActivityPlan": {
        "Strategy": "Temporary",
        "TtlSeconds": 600,
        "MaxCachedCount": 20000,
        "PreloadOnStartup": false
      },
      
      "RunningBattleSnapshot": {
        "Strategy": "Temporary",
        "TtlSeconds": 300,
        "MaxCachedCount": 5000,
        "PreloadOnStartup": false
      }
    },
    
    "GlobalSettings": {
      "EnableReadCaching": true,
      "CleanupIntervalMinutes": 5,
      "TrackCacheHitRate": true,
      "HitRateLogIntervalMinutes": 10
    }
  }
}
```

#### 3.3 注册配置

**文件**: `Infrastructure/DependencyInjection.cs` 或 `Program.cs`

```csharp
// 注册缓存配置
services.Configure<CacheConfiguration>(
    configuration.GetSection("CacheConfiguration"));

// 配置验证
services.AddOptions<CacheConfiguration>()
    .Bind(configuration.GetSection("CacheConfiguration"))
    .ValidateDataAnnotations()
    .ValidateOnStart();
```

---

### Step 4: 扩展监控（3-4小时）

#### 4.1 扩展 MonitoringOptions

**文件**: `Config/DatabaseOptimization/MonitoringOptions.cs`（扩展现有文件）

```csharp
/// <summary>
/// 监控配置选项（扩展版）
/// Monitoring Configuration Options (Extended)
/// </summary>
public class MonitoringOptions
{
    // ... 现有字段 ...
    
    /// <summary>
    /// 缓存监控配置
    /// Cache monitoring configuration
    /// </summary>
    public CacheMonitoringSettings CacheMonitoring { get; set; } 
        = new CacheMonitoringSettings();
}

/// <summary>
/// 缓存监控配置
/// Cache Monitoring Configuration
/// </summary>
public class CacheMonitoringSettings
{
    /// <summary>
    /// 是否启用缓存指标收集
    /// Enable cache metrics collection
    /// </summary>
    public bool EnableCacheMetrics { get; set; } = true;
    
    /// <summary>
    /// 是否跟踪每个实体类型的指标
    /// Track per-entity metrics
    /// </summary>
    public bool TrackPerEntityMetrics { get; set; } = true;
    
    /// <summary>
    /// 缓存指标记录间隔（秒）
    /// Cache metrics interval in seconds
    /// </summary>
    [Range(10, 600)]
    public int CacheMetricsIntervalSeconds { get; set; } = 60;
}
```

#### 4.2 扩展 DatabaseMetricsCollector

**文件**: `Infrastructure/DatabaseOptimization/DatabaseMetricsCollector.cs`

```csharp
// 在类中添加：

/// <summary>
/// 缓存命中记录
/// Cache hit records
/// </summary>
private readonly ConcurrentDictionary<string, CacheMetricsData> _cacheMetrics 
    = new ConcurrentDictionary<string, CacheMetricsData>();

/// <summary>
/// 记录缓存命中
/// Record cache hit
/// </summary>
public void RecordCacheHit(string entityType)
{
    if (!_options.CacheMonitoring.EnableCacheMetrics)
        return;
    
    var data = _cacheMetrics.GetOrAdd(entityType, _ => new CacheMetricsData());
    Interlocked.Increment(ref data.Hits);
}

/// <summary>
/// 记录缓存未命中
/// Record cache miss
/// </summary>
public void RecordCacheMiss(string entityType)
{
    if (!_options.CacheMonitoring.EnableCacheMetrics)
        return;
    
    var data = _cacheMetrics.GetOrAdd(entityType, _ => new CacheMetricsData());
    Interlocked.Increment(ref data.Misses);
}

/// <summary>
/// 记录缓存大小
/// Record cache size
/// </summary>
public void RecordCacheSize(string entityType, int cachedCount, int dirtyCount)
{
    if (!_options.CacheMonitoring.EnableCacheMetrics)
        return;
    
    var data = _cacheMetrics.GetOrAdd(entityType, _ => new CacheMetricsData());
    data.CachedCount = cachedCount;
    data.DirtyCount = dirtyCount;
    data.LastUpdated = DateTime.UtcNow;
}

/// <summary>
/// 获取缓存指标
/// Get cache metrics
/// </summary>
public Dictionary<string, CacheMetricsSummary> GetCacheMetrics()
{
    return _cacheMetrics.ToDictionary(
        kvp => kvp.Key,
        kvp => new CacheMetricsSummary
        {
            EntityType = kvp.Key,
            Hits = kvp.Value.Hits,
            Misses = kvp.Value.Misses,
            HitRate = kvp.Value.GetHitRate(),
            CachedCount = kvp.Value.CachedCount,
            DirtyCount = kvp.Value.DirtyCount,
            LastUpdated = kvp.Value.LastUpdated
        }
    );
}

// 内部数据类
private class CacheMetricsData
{
    public long Hits = 0;
    public long Misses = 0;
    public int CachedCount = 0;
    public int DirtyCount = 0;
    public DateTime LastUpdated = DateTime.UtcNow;
    
    public double GetHitRate()
    {
        var total = Hits + Misses;
        return total > 0 ? (double)Hits / total : 0.0;
    }
}

/// <summary>
/// 缓存指标摘要
/// Cache Metrics Summary
/// </summary>
public class CacheMetricsSummary
{
    public string EntityType { get; set; } = string.Empty;
    public long Hits { get; set; }
    public long Misses { get; set; }
    public double HitRate { get; set; }
    public int CachedCount { get; set; }
    public int DirtyCount { get; set; }
    public DateTime LastUpdated { get; set; }
}
```

#### 4.3 添加缓存健康检查端点

**文件**: `Api/DatabaseHealthController.cs`

```csharp
/// <summary>
/// 获取缓存统计信息
/// Get cache statistics
/// </summary>
/// <returns>缓存命中率、缓存大小等统计信息</returns>
/// <response code="200">返回缓存统计信息</response>
[HttpGet("cache-stats")]
[ProducesResponseType(typeof(CacheStatsResponse), StatusCodes.Status200OK)]
public ActionResult<CacheStatsResponse> GetCacheStats()
{
    try
    {
        var cacheMetrics = _metricsCollector?.GetCacheMetrics() 
            ?? new Dictionary<string, DatabaseMetricsCollector.CacheMetricsSummary>();
        
        return Ok(new CacheStatsResponse
        {
            Timestamp = DateTime.UtcNow,
            CacheEnabled = _configuration.GetValue<bool>(
                "CacheConfiguration:GlobalSettings:EnableReadCaching", true),
            EntityMetrics = cacheMetrics,
            OverallHitRate = CalculateOverallHitRate(cacheMetrics)
        });
    }
    catch (Exception ex)
    {
        _logger.LogError(ex, "获取缓存统计信息失败");
        return StatusCode(500, new { error = "获取缓存统计信息失败" });
    }
}

private double CalculateOverallHitRate(
    Dictionary<string, DatabaseMetricsCollector.CacheMetricsSummary> metrics)
{
    var totalHits = metrics.Values.Sum(m => m.Hits);
    var totalMisses = metrics.Values.Sum(m => m.Misses);
    var total = totalHits + totalMisses;
    
    return total > 0 ? (double)totalHits / total : 0.0;
}

/// <summary>
/// 缓存统计响应
/// Cache Statistics Response
/// </summary>
public class CacheStatsResponse
{
    public DateTime Timestamp { get; set; }
    public bool CacheEnabled { get; set; }
    public Dictionary<string, DatabaseMetricsCollector.CacheMetricsSummary> EntityMetrics { get; set; } 
        = new Dictionary<string, DatabaseMetricsCollector.CacheMetricsSummary>();
    public double OverallHitRate { get; set; }
}
```

---

### Step 5: 依赖注入配置（1-2小时）

**文件**: `Infrastructure/DependencyInjection.cs` 或 `Program.cs`

```csharp
/// <summary>
/// 注册数据库读取缓存服务
/// Register database read caching services
/// </summary>
public static IServiceCollection AddDatabaseReadCaching(
    this IServiceCollection services,
    IConfiguration configuration)
{
    // 1. 注册缓存配置
    services.Configure<CacheConfiguration>(
        configuration.GetSection("CacheConfiguration"));
    
    services.AddOptions<CacheConfiguration>()
        .Bind(configuration.GetSection("CacheConfiguration"))
        .ValidateDataAnnotations()
        .ValidateOnStart();
    
    // 2. 注册 CacheCoordinator（作为 HostedService）
    services.AddSingleton<CacheCoordinator>();
    services.AddHostedService(sp => sp.GetRequiredService<CacheCoordinator>());
    
    // 3. 确保所有 MemoryStateManager 已注册
    // （这些在写入优化时已注册，此处仅确认）
    
    return services;
}

// 在 Program.cs 中调用：
builder.Services.AddDatabaseReadCaching(builder.Configuration);
```

---

## 测试验证

### 编译测试

```bash
# 编译项目
dotnet build BlazorIdle.Server/BlazorIdle.Server.csproj

# 确保零错误
```

### 单元测试

**创建测试文件**: `tests/BlazorIdle.Tests/DatabaseOptimization/`

#### 测试 1: MemoryStateManager 缓存读取

```csharp
[Fact]
public async Task TryGetAsync_CacheHit_ReturnsFromMemory()
{
    // Arrange
    var manager = new MemoryStateManager<Character>(...);
    var character = new Character { Id = Guid.NewGuid(), Name = "TestChar" };
    manager.Add(character);
    
    // Act
    var result = await manager.TryGetAsync(
        character.Id,
        async (id, ct) => {
            // 不应该被调用
            Assert.Fail("Database loader should not be called on cache hit");
            return null;
        }
    );
    
    // Assert
    Assert.NotNull(result);
    Assert.Equal(character.Id, result.Id);
    Assert.Equal(1.0, manager.GetCacheHitRate()); // 100% 命中
}

[Fact]
public async Task TryGetAsync_CacheMiss_LoadsFromDatabase()
{
    // Arrange
    var manager = new MemoryStateManager<Character>(...);
    var character = new Character { Id = Guid.NewGuid(), Name = "TestChar" };
    var dbLoaderCalled = false;
    
    // Act
    var result = await manager.TryGetAsync(
        character.Id,
        async (id, ct) => {
            dbLoaderCalled = true;
            return character;
        }
    );
    
    // Assert
    Assert.True(dbLoaderCalled);
    Assert.NotNull(result);
    Assert.Equal(character.Id, result.Id);
    
    // 第二次查询应该命中缓存
    var result2 = await manager.TryGetAsync(
        character.Id,
        async (id, ct) => {
            Assert.Fail("Should hit cache on second call");
            return null;
        }
    );
    
    Assert.NotNull(result2);
    Assert.Equal(0.5, manager.GetCacheHitRate()); // 50% 命中（1/2）
}
```

#### 测试 2: CacheCoordinator 预加载

```csharp
[Fact]
public async Task PreloadStaticDataAsync_LoadsGearDefinitions()
{
    // Arrange
    var coordinator = CreateCacheCoordinator();
    
    // Act
    await coordinator.PreloadStaticDataAsync(CancellationToken.None);
    
    // Assert
    var stats = _gearDefManager.GetCacheStatistics();
    Assert.True(stats.CachedCount > 0);
}
```

#### 测试 3: 配置验证

```csharp
[Fact]
public void CacheConfiguration_ValidConfig_Loads()
{
    // Arrange & Act
    var config = LoadConfigFromJson();
    
    // Assert
    Assert.True(config.GlobalSettings.EnableReadCaching);
    Assert.Contains("GearDefinition", config.EntityStrategies.Keys);
    Assert.Equal(CacheStrategyType.Permanent, 
        config.EntityStrategies["GearDefinition"].Strategy);
}
```

### 集成测试

```csharp
[Fact]
public async Task IntegrationTest_CacheCoordinator_PreloadsOnStartup()
{
    // 创建测试 Host
    var host = CreateTestHost();
    
    // 启动服务
    await host.StartAsync();
    
    // 等待预加载完成
    await Task.Delay(2000);
    
    // 验证
    var gearDefManager = host.Services.GetRequiredService<
        IMemoryStateManager<GearDefinition>>();
    
    var stats = gearDefManager.GetCacheStatistics();
    Assert.True(stats.CachedCount > 0);
    
    await host.StopAsync();
}
```

---

## 验收标准

### 功能完整性

- [ ] MemoryStateManager 添加 TryGetAsync 方法
- [ ] MemoryStateManager 添加 PreloadBatch 方法
- [ ] MemoryStateManager 添加缓存统计方法
- [ ] CacheCoordinator 创建完成
- [ ] CacheCoordinator 实现启动时预加载
- [ ] CacheCoordinator 实现定期清理
- [ ] 配置系统创建完成（CacheConfiguration, EntityCacheStrategy, GlobalCacheSettings）
- [ ] appsettings.json 添加 CacheConfiguration 节
- [ ] DatabaseMetricsCollector 扩展缓存监控
- [ ] DatabaseHealthController 添加 /api/database/cache-stats 端点
- [ ] 所有服务正确注册

### 代码质量

- [ ] 编译成功，零错误
- [ ] 所有代码有详细的中英文注释
- [ ] 遵循项目命名规范
- [ ] 遵循 DDD 架构
- [ ] 所有公开方法有 XML 文档注释

### 配置化

- [ ] 所有参数在 appsettings.json
- [ ] 使用 DataAnnotations 验证
- [ ] 提供合理默认值
- [ ] 支持不同环境的配置

### 测试覆盖

- [ ] MemoryStateManager 缓存功能测试（至少 3 个测试）
- [ ] CacheCoordinator 预加载测试（至少 2 个测试）
- [ ] 配置加载测试（至少 2 个测试）
- [ ] 所有测试通过

### 文档完整性

- [ ] 本实施方案文档
- [ ] 代码注释完整
- [ ] README 更新（如需要）

---

## 后续步骤

完成 Phase 1 后，进入 **中篇 - 分阶段迁移读取操作**。

---

**阶段状态**：⏳ 待实施  
**预计完成时间**：3-4 天  
**责任人**：开发团队  
**最后更新**：2025-10-18
