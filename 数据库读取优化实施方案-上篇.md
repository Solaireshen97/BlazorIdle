# BlazorIdle 数据库读取优化实施方案 - 上篇

**项目名称**: BlazorIdle 数据库读取操作优化  
**文档类型**: 需求分析与架构设计  
**文档版本**: 1.0  
**创建日期**: 2025-10-18  
**状态**: 方案设计 - 待审核

---

## 📋 目录

1. [执行摘要](#执行摘要)
2. [项目背景](#项目背景)
3. [现状分析](#现状分析)
4. [问题识别](#问题识别)
5. [优化目标](#优化目标)
6. [架构设计](#架构设计)
7. [技术选型](#技术选型)
8. [配置设计](#配置设计)

---

## 执行摘要

### 背景

BlazorIdle 项目已完成数据库写入操作的优化（Phase 1-2），通过内存缓冲和批量保存机制，成功将数据库写入次数减少了 **97.9%**。然而，当前系统仍存在大量的数据库读取操作：

- **角色信息查询**：每次 API 请求都从数据库读取
- **战斗数据查询**：实时查询战斗状态和快照
- **活动计划查询**：频繁读取活动状态
- **装备和背包查询**：每次操作都读取完整数据
- **配置数据查询**：技能、物品等静态数据重复查询

### 核心问题

1. **读取频率过高**：每秒数百次数据库查询
2. **数据重复读取**：相同数据在短时间内多次从数据库读取
3. **缺少缓存策略**：没有内存缓存层，所有读取直达数据库
4. **性能瓶颈**：数据库读取成为系统响应时间的主要瓶颈
5. **资源浪费**：CPU 和磁盘 I/O 资源用于重复读取

### 优化目标

**核心目标**：建立统一的内存缓存层，优先从内存读取数据，减少数据库查询次数

**量化指标**：
- 数据库读取次数减少 **70-90%**
- API 响应时间改善 **30-50%**
- 缓存命中率达到 **80%+**
- 内存增长控制在 **150-300MB** 以内

**设计原则**：
1. ✅ **完全配置化**：所有参数通过配置文件管理
2. ✅ **向后兼容**：可通过开关禁用缓存
3. ✅ **数据一致性**：确保缓存与数据库同步
4. ✅ **渐进式迁移**：分阶段实施，降低风险
5. ✅ **维持代码风格**：遵循项目既有规范

---

## 项目背景

### 已完成的工作

#### Phase 1-2: 写入优化 ✅

**成果**：
- 实现了 `MemoryStateManager<T>` 管理实体内存副本
- 实现了 `PersistenceCoordinator` 定期批量保存
- 实现了 `EnhancedShutdownManager` 优雅关闭
- 数据库写入次数从 93,000次/小时 降至 1,920次/小时
- 减少比例：**97.9%**

**架构**：
```
API Controller
    ↓
Service Layer
    ↓
MemoryStateManager (写入时更新内存)
    ↓ (定期批量)
PersistenceCoordinator → Database
```

**覆盖范围**：
- ✅ Character 心跳更新
- ✅ RunningBattleSnapshot 快照保存
- ✅ ActivityPlan 活动计划更新

### 当前的不足

#### 读取操作未优化 ⚠️

**问题现状**：
```csharp
// 现有代码模式（每次都查数据库）
public async Task<Character?> GetCharacterAsync(Guid id)
{
    return await _db.Characters
        .Include(c => c.Equipment)
        .Include(c => c.Inventory)
        .FirstOrDefaultAsync(c => c.Id == id);
}
```

**影响**：
- 每次 API 调用都执行数据库查询
- 相同角色信息在短时间内多次读取
- EF Core Include 导致额外的 JOIN 查询
- 数据库连接池压力增大

#### 缺少统一的缓存策略

**当前状况**：
1. 没有读取缓存层
2. 没有缓存失效策略
3. 没有缓存预热机制
4. 没有缓存命中率监控

#### 数据一致性挑战

**现有写入优化的副作用**：
- 数据已在 `MemoryStateManager` 中更新
- 但读取操作仍从数据库查询
- 可能读到"旧数据"（尚未批量保存）

**示例场景**：
```
T0: 玩家心跳更新 LastSeenAtUtc (写入内存，标记dirty)
T1: API 查询玩家状态 (从数据库读取，仍是旧时间)
T30: PersistenceCoordinator 批量保存 (更新数据库)
```

---

## 现状分析

### 读取操作统计

通过代码审查和日志分析，识别出以下高频读取操作：

#### 1. 角色信息查询 ⚠️⚠️⚠️

**位置**：`Infrastructure/Persistence/Repositories/CharacterRepository.cs`

**频率分析**：
| 操作 | 触发场景 | 频率估算 |
|------|---------|---------|
| `GetByIdAsync` | 每次 API 请求 | ~500-1000 次/分钟 |
| `GetByAccountIdAsync` | 登录、切换角色 | ~50-100 次/分钟 |
| `GetAllOnlineAsync` | 离线检测、统计 | ~2 次/分钟 |

**代码模式**：
```csharp
public async Task<Character?> GetByIdAsync(Guid id, CancellationToken ct = default)
{
    return await _db.Characters
        .Include(c => c.Equipment)      // JOIN Equipment 表
        .Include(c => c.Inventory)      // JOIN Inventory 表
        .Include(c => c.ActiveBattles)  // JOIN Battles 表
        .FirstOrDefaultAsync(c => c.Id == id, ct);
}
```

**性能影响**：
- 每次查询执行 3-4 个 JOIN
- 加载大量不必要的关联数据
- 数据库 CPU 和 I/O 压力高

#### 2. 战斗数据查询 ⚠️⚠️⚠️

**位置**：`Infrastructure/Persistence/Repositories/BattleRepository.cs`

**频率分析**：
| 操作 | 触发场景 | 频率估算 |
|------|---------|---------|
| `GetRunningBattlesAsync` | 战斗循环 | ~100-200 次/分钟 |
| `GetBattleSnapshotAsync` | 前端轮询 | ~200-400 次/分钟 |
| `GetBattleHistoryAsync` | 查看历史 | ~10-20 次/分钟 |

**代码模式**：
```csharp
public async Task<IEnumerable<RunningBattleSnapshotRecord>> GetSnapshotsAsync(
    Guid characterId, CancellationToken ct = default)
{
    return await _db.RunningBattleSnapshots
        .Where(s => s.CharacterId == characterId && s.IsActive)
        .OrderByDescending(s => s.CreatedAtUtc)
        .ToListAsync(ct);
}
```

**性能影响**：
- 每个活跃战斗每秒查询 1-2 次
- 10 个并发战斗 = 600-1200 次/分钟
- 快照数据较大（JSON 序列化）

#### 3. 活动计划查询 ⚠️⚠️

**位置**：`Infrastructure/Persistence/Repositories/ActivityPlanRepository.cs`

**频率分析**：
| 操作 | 触发场景 | 频率估算 |
|------|---------|---------|
| `GetActiveByCharacterAsync` | 活动状态检查 | ~100-200 次/分钟 |
| `GetPendingAsync` | 活动调度 | ~50-100 次/分钟 |

**代码模式**：
```csharp
public async Task<IEnumerable<ActivityPlan>> GetActiveByCharacterAsync(
    Guid characterId, CancellationToken ct = default)
{
    return await _db.ActivityPlans
        .Where(p => p.CharacterId == characterId && p.State == ActivityState.Running)
        .ToListAsync(ct);
}
```

#### 4. 装备和背包查询 ⚠️

**位置**：`Infrastructure/Persistence/Repositories/InventoryRepository.cs`

**频率分析**：
| 操作 | 触发场景 | 频率估算 |
|------|---------|---------|
| `GetCharacterInventoryAsync` | 背包操作 | ~50-100 次/分钟 |
| `GetEquippedItemsAsync` | 装备查询 | ~30-50 次/分钟 |

#### 5. 配置数据查询 ⚠️⚠️

**位置**：多个服务层

**频率分析**：
| 数据类型 | 触发场景 | 频率估算 |
|---------|---------|---------|
| 技能定义 | 战斗计算 | ~200-300 次/分钟 |
| 物品定义 | 物品操作 | ~50-100 次/分钟 |
| 怪物模板 | 战斗初始化 | ~10-20 次/分钟 |

**代码模式**：
```csharp
// 每次战斗都查询技能定义
var skill = await _db.Skills.FindAsync(skillId);
```

**性能影响**：
- 静态数据重复查询
- 数据基本不变，完全可以缓存
- 查询次数与业务频率成正比

### 总体读取频率

| 数据类型 | 查询频率（次/分钟） | 每小时查询次数 | 备注 |
|---------|---------------|--------------|------|
| 角色信息 | 500-1000 | 30,000-60,000 | 高频，需优先优化 |
| 战斗数据 | 300-600 | 18,000-36,000 | 高频，实时性要求 |
| 活动计划 | 150-300 | 9,000-18,000 | 中频，状态查询 |
| 装备背包 | 80-150 | 4,800-9,000 | 中频，用户操作触发 |
| 配置数据 | 250-400 | 15,000-24,000 | 高频，纯静态数据 |
| **总计** | **1,280-2,450** | **~76,800-147,000** | **极高频率** |

**对比写入优化前的 93,000 次/小时**：
- 读取次数是写入次数的 **0.8-1.6 倍**
- 如果加上写入操作的剩余 1,920 次/小时
- 总数据库操作：**78,720-148,920 次/小时**
- **读取占比：97.4-98.7%**

**结论**：
> 📊 虽然写入优化取得显著成效，但读取操作已成为新的性能瓶颈，占总数据库操作的 **97%+**

---

## 问题识别

### 核心问题点

#### 问题 1: 数据重复读取 ⚠️⚠️⚠️

**现象**：
```
T0: API 请求 A 读取 Character(ID=123)
T0.5: API 请求 B 读取 Character(ID=123)  // 重复
T1: API 请求 C 读取 Character(ID=123)    // 重复
T2: API 请求 D 读取 Character(ID=123)    // 重复
```

**统计**：
- 同一角色在 10 秒内平均被读取 **5-10 次**
- 80% 的读取是重复的（读取最近访问过的数据）

**影响**：
- 浪费数据库资源
- 增加响应延迟
- 放大并发压力

#### 问题 2: 缺少读写一致性 ⚠️⚠️

**现象**：
```
T0: 写入 Character.LastSeenAtUtc (更新内存，标记dirty)
T1: 读取 Character (从数据库，获得旧值)
T30: 批量保存 (更新数据库)
```

**影响**：
- 读取到"过时"的数据
- 可能影响业务逻辑判断（如离线检测）
- 用户体验：看到旧信息

#### 问题 3: 静态数据重复查询 ⚠️⚠️⚠️

**现象**：
- 技能定义、物品定义等配置数据每次都查数据库
- 这些数据基本不变（或极少变更）
- 查询频率高达 15,000-24,000 次/小时

**影响**：
- 纯粹的资源浪费
- 容易优化，效果显著

#### 问题 4: 关联查询过度 ⚠️⚠️

**现象**：
```csharp
// 每次都加载所有关联数据
.Include(c => c.Equipment)
.Include(c => c.Inventory)
.Include(c => c.ActiveBattles)
```

**问题**：
- 大部分场景只需要基础信息
- 关联数据增加查询复杂度和时间
- 加载的数据大部分用不上

**影响**：
- JOIN 查询性能开销
- 内存占用增加
- 序列化/反序列化开销

#### 问题 5: 缺少缓存策略 ⚠️⚠️⚠️

**现状**：
- 没有缓存失效机制
- 没有缓存预热
- 没有分级缓存（热数据/冷数据）
- 没有缓存监控指标

**影响**：
- 无法系统化优化读取性能
- 没有数据支持调优决策

### 根本原因分析

```
根本原因 1: 架构设计缺少读取缓存层
    ↓
直接模式：API → Repository → Database
    ↓
结果：每次读取都查数据库

根本原因 2: 写入优化未考虑读取一致性
    ↓
写入在内存，读取在数据库，数据源不一致
    ↓
结果：可能读到旧数据

根本原因 3: 未区分"动态数据"和"静态数据"
    ↓
所有数据一视同仁，都实时查询
    ↓
结果：静态数据重复查询

根本原因 4: 缺少分层缓存策略
    ↓
没有 L1(进程内缓存) / L2(分布式缓存) 分层
    ↓
结果：缓存策略不够灵活
```

---

## 优化目标

### 业务目标

1. **降低数据库压力**
   - 读取次数减少 70-90%
   - 从 ~120,000 次/小时 降至 ~12,000-36,000 次/小时

2. **提升响应速度**
   - API 响应时间改善 30-50%
   - P95 响应时间 < 100ms

3. **确保数据一致性**
   - 读取最新的内存数据（如果已更新）
   - 避免读到"过时"数据

4. **优化资源使用**
   - 内存增长控制在 150-300MB
   - CPU 利用率降低 10-20%

### 技术目标

1. **建立统一的读取缓存层**
   - 实现 `CacheManager<T>` 统一管理缓存
   - 支持多种缓存策略（LRU、TTL、LFU）
   - 与现有 `MemoryStateManager<T>` 集成

2. **实现分层缓存架构**
   - L1 缓存：进程内高速缓存（热数据）
   - L2 缓存：可选的分布式缓存（未来扩展）

3. **数据分类管理**
   - 动态数据：Character、Battle、ActivityPlan
   - 静态数据：技能、物品、怪物模板
   - 半静态数据：装备实例、背包

4. **缓存失效策略**
   - 手动失效：写入更新时主动失效
   - 定时失效：TTL 到期自动失效
   - 事件驱动：监听数据变更事件

### 量化指标

| 指标类型 | 当前值 | 目标值 | 改善幅度 |
|---------|--------|--------|---------|
| 数据库读取（次/小时） | 120,000 | 12,000-36,000 | **70-90%** ↓ |
| 缓存命中率 | 0% | 80-95% | - |
| API 响应时间 P95 | 150-200ms | <100ms | **30-50%** ↓ |
| 数据库连接池利用率 | 60-80% | 30-50% | **30-50%** ↓ |
| 内存使用 | ~350MB | ~500-650MB | +150-300MB |
| 缓存失效延迟 | N/A | <100ms | - |

### 非功能性目标

1. **可配置性**
   - 所有缓存参数在配置文件中
   - 支持实体类型差异化策略
   - 可通过配置开关禁用缓存

2. **可观测性**
   - 缓存命中率监控
   - 缓存失效统计
   - 内存使用监控
   - 性能对比指标

3. **可维护性**
   - 清晰的代码结构
   - 完整的文档注释
   - 详细的实施指南

4. **向后兼容**
   - 不修改现有 API 接口
   - 通过开关可立即禁用
   - Fallback 机制保证稳定性

---

## 架构设计

### 整体架构

#### 当前架构（Phase 1-2 写入优化后）

```
┌─────────────────────────────────────────────────────┐
│                  API Controllers                     │
└───────────────────┬─────────────────────────────────┘
                    │
┌───────────────────▼─────────────────────────────────┐
│               Service Layer                          │
│  (Domain Services, Application Services)            │
└───────────┬───────────────────────────┬─────────────┘
            │                           │
            │ 写入                       │ 读取
            ▼                           ▼
┌───────────────────────┐   ┌──────────────────────────┐
│ MemoryStateManager<T> │   │    Repositories          │
│  (写入时更新内存)      │   │  (每次都查数据库) ⚠️     │
└───────┬───────────────┘   └────────┬─────────────────┘
        │ 定期批量                    │ 每次读取
        ▼                             ▼
┌───────────────────┐         ┌──────────────┐
│PersistenceCoordinator│       │   Database   │
└───────┬───────────┘         └──────────────┘
        │ 批量保存
        ▼
┌───────────────┐
│   Database    │
└───────────────┘
```

**问题**：
- ✅ 写入路径已优化（内存缓冲 + 批量保存）
- ⚠️ 读取路径未优化（每次都查数据库）
- ⚠️ 读写数据源不一致（写入在内存，读取在数据库）

#### 目标架构（Phase 3 读取优化后）

```
┌─────────────────────────────────────────────────────────┐
│                  API Controllers                         │
└───────────────────┬─────────────────────────────────────┘
                    │
┌───────────────────▼──────────────────────────────────────┐
│               Service Layer                               │
│  (Domain Services, Application Services)                 │
└───────────┬────────────────────────────┬──────────────────┘
            │                            │
            │ 写入                        │ 读取
            ▼                            ▼
┌──────────────────────┐    ┌────────────────────────────┐
│MemoryStateManager<T> │    │   CacheManager<T> ✨新增   │
│ (写入时更新)          │───▶│  - 统一读取入口            │
└──────────┬───────────┘    │  - 优先读内存              │
           │                │  - 未命中查数据库           │
           │                │  - 自动失效管理             │
           │                └────────┬───────────────────┘
           │                         │
           │ 定期批量                 │ 缓存未命中
           ▼                         ▼
┌────────────────────┐       ┌──────────────┐
│PersistenceCoordinator│      │ Repositories │
└────────┬────────────┘       └──────┬───────┘
         │                           │
         │ 批量保存                   │ 查询
         ▼                           ▼
┌────────────────────────────────────────────┐
│              Database                       │
└────────────────────────────────────────────┘
```

**改进**：
- ✅ 读取路径优化（优先内存，未命中才查数据库）
- ✅ 读写一致性（优先读取 MemoryStateManager 中的最新数据）
- ✅ 缓存自动失效（写入更新时主动失效缓存）

### 核心组件设计

#### 1. CacheManager<T>

**职责**：
- 统一的读取缓存管理
- 集成 MemoryStateManager 的数据
- 管理缓存失效策略
- 提供缓存统计信息

**接口定义**：
```csharp
public interface ICacheManager<T> where T : class, IEntity
{
    /// <summary>
    /// 获取实体（优先从缓存，未命中则从数据库加载）
    /// Get entity (from cache first, load from database if miss)
    /// </summary>
    Task<T?> GetAsync(Guid id, CancellationToken ct = default);
    
    /// <summary>
    /// 批量获取实体
    /// Get multiple entities
    /// </summary>
    Task<IReadOnlyList<T>> GetManyAsync(
        IEnumerable<Guid> ids, 
        CancellationToken ct = default);
    
    /// <summary>
    /// 获取满足条件的实体（先查缓存，必要时查数据库）
    /// Get entities by predicate
    /// </summary>
    Task<IReadOnlyList<T>> GetWhereAsync(
        Expression<Func<T, bool>> predicate, 
        CancellationToken ct = default);
    
    /// <summary>
    /// 使指定实体的缓存失效
    /// Invalidate cache for specific entity
    /// </summary>
    void Invalidate(Guid id);
    
    /// <summary>
    /// 使所有缓存失效
    /// Invalidate all cache
    /// </summary>
    void InvalidateAll();
    
    /// <summary>
    /// 预热缓存（加载常用数据）
    /// Warm up cache
    /// </summary>
    Task WarmUpAsync(CancellationToken ct = default);
    
    /// <summary>
    /// 获取缓存统计信息
    /// Get cache statistics
    /// </summary>
    CacheStatistics GetStatistics();
}
```

**关键特性**：
- 与 `IMemoryStateManager<T>` 集成（优先读取已更新的数据）
- 支持单个和批量查询
- 支持条件查询（缓存索引）
- 自动失效机制
- 统计信息收集

#### 2. CacheStatistics

**统计信息结构**：
```csharp
public class CacheStatistics
{
    /// <summary>
    /// 缓存总命中次数
    /// </summary>
    public long TotalHits { get; set; }
    
    /// <summary>
    /// 缓存总未命中次数
    /// </summary>
    public long TotalMisses { get; set; }
    
    /// <summary>
    /// 缓存命中率（百分比）
    /// </summary>
    public double HitRate => TotalHits + TotalMisses > 0
        ? (double)TotalHits / (TotalHits + TotalMisses) * 100
        : 0;
    
    /// <summary>
    /// 当前缓存实体数量
    /// </summary>
    public int CachedCount { get; set; }
    
    /// <summary>
    /// 缓存失效次数
    /// </summary>
    public long InvalidationCount { get; set; }
    
    /// <summary>
    /// 平均查询时间（毫秒）
    /// </summary>
    public double AverageQueryMs { get; set; }
}
```

#### 3. CacheInvalidationCoordinator

**职责**：
- 监听数据变更事件
- 协调缓存失效
- 确保读写一致性

**工作流程**：
```
MemoryStateManager.Update(entity)
    ↓
触发 EntityUpdatedEvent
    ↓
CacheInvalidationCoordinator 监听
    ↓
调用 CacheManager.Invalidate(entity.Id)
    ↓
下次读取时重新加载最新数据
```

#### 4. StaticDataCacheManager

**职责**：
- 专门管理静态配置数据
- 技能定义、物品定义等
- 长期缓存，极少失效

**特点**：
- 启动时预热（加载全部静态数据）
- TTL 设置为极长（24小时或更长）
- 支持手动刷新（配置热更新时）

### 数据分类策略

#### 动态数据（实时性要求高）

**数据类型**：
- Character（角色信息）
- RunningBattleSnapshot（战斗快照）
- ActivityPlan（活动计划）

**缓存策略**：
- TTL：5-10 分钟
- 失效：写入更新时主动失效
- 优先级：优先读取 MemoryStateManager 中的最新数据

#### 半静态数据（偶尔变更）

**数据类型**：
- EquipmentInstance（装备实例）
- InventoryItem（背包物品）

**缓存策略**：
- TTL：30-60 分钟
- 失效：装备/背包操作时失效
- 预热：登录时加载角色的装备和背包

#### 静态数据（基本不变）

**数据类型**：
- SkillDefinition（技能定义）
- ItemDefinition（物品定义）
- MonsterTemplate（怪物模板）

**缓存策略**：
- TTL：24 小时或更长
- 失效：配置热更新时手动失效
- 预热：启动时加载全部静态数据

### 缓存失效策略

#### 策略 1: 主动失效（Write-Through）

**流程**：
```
更新数据
    ↓
写入 MemoryStateManager
    ↓
触发 EntityUpdatedEvent
    ↓
CacheInvalidationCoordinator 失效缓存
    ↓
下次读取时重新加载
```

**优点**：
- 确保读取最新数据
- 数据一致性强

**适用**：动态数据（Character、Battle、ActivityPlan）

#### 策略 2: TTL 失效（Time-To-Live）

**流程**：
```
数据加载到缓存
    ↓
记录加载时间和 TTL
    ↓
每次读取检查是否过期
    ↓
过期则重新加载
```

**优点**：
- 自动清理旧数据
- 减少内存占用

**适用**：半静态数据、静态数据

#### 策略 3: LRU 清理（Least Recently Used）

**流程**：
```
缓存达到容量上限
    ↓
找出最久未访问的实体（非 Dirty）
    ↓
移除缓存
    ↓
下次访问时重新加载
```

**优点**：
- 控制内存使用
- 保留热数据

**适用**：所有数据类型

---

## 技术选型

### 缓存实现方案

#### 方案 1: 扩展 MemoryStateManager ⭐⭐⭐⭐⭐ (推荐)

**方案描述**：
- 在现有 `MemoryStateManager<T>` 基础上增强读取功能
- 添加缓存统计、失效策略等功能
- 保持架构一致性

**优点**：
- ✅ 复用现有基础设施
- ✅ 读写数据源统一（天然一致性）
- ✅ 最小化架构变更
- ✅ 代码维护简单

**缺点**：
- ⚠️ `MemoryStateManager` 职责增加
- ⚠️ 需要重构现有接口

**实施难度**：⭐⭐⭐（中等）

#### 方案 2: 新建独立的 CacheManager

**方案描述**：
- 创建独立的 `CacheManager<T>` 组件
- 与 `MemoryStateManager<T>` 协同工作
- 读取时先查 `MemoryStateManager`，再查 `CacheManager`

**优点**：
- ✅ 职责分离清晰
- ✅ 不影响现有 `MemoryStateManager`
- ✅ 灵活的缓存策略

**缺点**：
- ⚠️ 架构复杂度增加
- ⚠️ 两个组件需要同步
- ⚠️ 可能的数据不一致

**实施难度**：⭐⭐⭐⭐（较高）

#### 方案 3: 使用第三方缓存库（如 LazyCache）

**方案描述**：
- 集成 `LazyCache` 或类似库
- 封装为统一的缓存接口

**优点**：
- ✅ 成熟稳定
- ✅ 功能丰富

**缺点**：
- ⚠️ 引入外部依赖
- ⚠️ 与 `MemoryStateManager` 集成复杂
- ⚠️ 可能的许可证问题

**实施难度**：⭐⭐⭐（中等）

### 推荐方案

**选择**：方案 1 - 扩展 MemoryStateManager ⭐⭐⭐⭐⭐

**理由**：
1. 与现有架构最契合
2. 读写数据源统一，天然保证一致性
3. 最小化变更，降低风险
4. 代码维护简单

**实施要点**：
- 将 `MemoryStateManager<T>` 扩展为同时支持读写
- 添加缓存统计功能
- 实现多种失效策略
- 保持向后兼容

---

## 配置设计

### 配置文件结构

```json
{
  "Cache": {
    // 主开关：是否启用读取缓存
    "EnableReadCache": true,
    
    // 默认缓存配置
    "DefaultCacheOptions": {
      // 缓存 TTL（秒，0表示永不过期）
      "TimeToLiveSeconds": 600,
      
      // 缓存容量限制
      "MaxCachedEntities": 50000,
      
      // 清理策略：LRU、TTL、LFU
      "EvictionPolicy": "LRU",
      
      // 缓存预热：启动时是否预加载
      "EnableWarmUp": true,
      
      // 失效延迟（毫秒，用于批量失效）
      "InvalidationDelayMs": 100
    },
    
    // 实体类型差异化缓存策略
    "EntityCacheStrategies": {
      // 角色信息（动态数据）
      "Character": {
        "TimeToLiveSeconds": 300,        // 5分钟
        "MaxCachedEntities": 10000,
        "EvictionPolicy": "LRU",
        "EnableWarmUp": false,
        "InvalidateOnWrite": true         // 写入时失效
      },
      
      // 战斗快照（实时数据）
      "RunningBattleSnapshot": {
        "TimeToLiveSeconds": 60,          // 1分钟（实时性要求高）
        "MaxCachedEntities": 5000,
        "EvictionPolicy": "LRU",
        "EnableWarmUp": false,
        "InvalidateOnWrite": true
      },
      
      // 活动计划（动态数据）
      "ActivityPlan": {
        "TimeToLiveSeconds": 300,         // 5分钟
        "MaxCachedEntities": 5000,
        "EvictionPolicy": "LRU",
        "EnableWarmUp": false,
        "InvalidateOnWrite": true
      },
      
      // 装备实例（半静态）
      "EquipmentInstance": {
        "TimeToLiveSeconds": 1800,        // 30分钟
        "MaxCachedEntities": 20000,
        "EvictionPolicy": "LRU",
        "EnableWarmUp": true,             // 登录时预热
        "InvalidateOnWrite": true
      },
      
      // 技能定义（静态配置）
      "SkillDefinition": {
        "TimeToLiveSeconds": 86400,       // 24小时
        "MaxCachedEntities": 1000,
        "EvictionPolicy": "None",         // 不清理，除非手动
        "EnableWarmUp": true,             // 启动时加载全部
        "InvalidateOnWrite": false        // 配置更新时手动失效
      },
      
      // 物品定义（静态配置）
      "ItemDefinition": {
        "TimeToLiveSeconds": 86400,
        "MaxCachedEntities": 2000,
        "EvictionPolicy": "None",
        "EnableWarmUp": true,
        "InvalidateOnWrite": false
      },
      
      // 怪物模板（静态配置）
      "MonsterTemplate": {
        "TimeToLiveSeconds": 86400,
        "MaxCachedEntities": 500,
        "EvictionPolicy": "None",
        "EnableWarmUp": true,
        "InvalidateOnWrite": false
      }
    },
    
    // 监控配置
    "Monitoring": {
      // 是否启用缓存统计
      "EnableStatistics": true,
      
      // 统计信息记录间隔（秒）
      "StatisticsIntervalSeconds": 60,
      
      // 是否启用详细日志
      "EnableDetailedLogging": false,
      
      // 缓存命中率告警阈值（百分比）
      "HitRateAlertThreshold": 70
    },
    
    // 预热配置
    "WarmUp": {
      // 是否在启动时预热
      "EnableOnStartup": true,
      
      // 预热超时（秒）
      "TimeoutSeconds": 30,
      
      // 预热失败是否阻塞启动
      "BlockStartupOnFailure": false,
      
      // 需要预热的实体类型
      "EntityTypes": [
        "SkillDefinition",
        "ItemDefinition",
        "MonsterTemplate"
      ]
    }
  }
}
```

### 配置类定义

```csharp
/// <summary>
/// 缓存配置选项
/// Cache configuration options
/// </summary>
public class CacheOptions
{
    /// <summary>
    /// 是否启用读取缓存
    /// Enable read cache
    /// </summary>
    public bool EnableReadCache { get; set; } = true;
    
    /// <summary>
    /// 默认缓存配置
    /// Default cache options
    /// </summary>
    public EntityCacheOptions DefaultCacheOptions { get; set; } = new();
    
    /// <summary>
    /// 实体类型差异化缓存策略
    /// Entity-specific cache strategies
    /// </summary>
    public Dictionary<string, EntityCacheOptions> EntityCacheStrategies { get; set; } = new();
    
    /// <summary>
    /// 监控配置
    /// Monitoring configuration
    /// </summary>
    public CacheMonitoringOptions Monitoring { get; set; } = new();
    
    /// <summary>
    /// 预热配置
    /// Warm-up configuration
    /// </summary>
    public CacheWarmUpOptions WarmUp { get; set; } = new();
}

/// <summary>
/// 实体缓存配置选项
/// Entity cache options
/// </summary>
public class EntityCacheOptions
{
    /// <summary>
    /// 缓存 TTL（秒，0表示永不过期）
    /// Time to live in seconds (0 = never expire)
    /// </summary>
    [Range(0, 86400 * 7)]  // 最长7天
    public int TimeToLiveSeconds { get; set; } = 600;
    
    /// <summary>
    /// 缓存容量限制
    /// Maximum cached entities
    /// </summary>
    [Range(100, 1000000)]
    public int MaxCachedEntities { get; set; } = 50000;
    
    /// <summary>
    /// 清理策略
    /// Eviction policy
    /// </summary>
    public string EvictionPolicy { get; set; } = "LRU";
    
    /// <summary>
    /// 是否启用预热
    /// Enable warm-up
    /// </summary>
    public bool EnableWarmUp { get; set; } = false;
    
    /// <summary>
    /// 写入时是否失效缓存
    /// Invalidate cache on write
    /// </summary>
    public bool InvalidateOnWrite { get; set; } = true;
    
    /// <summary>
    /// 失效延迟（毫秒）
    /// Invalidation delay in milliseconds
    /// </summary>
    [Range(0, 10000)]
    public int InvalidationDelayMs { get; set; } = 100;
}

/// <summary>
/// 缓存监控配置
/// Cache monitoring options
/// </summary>
public class CacheMonitoringOptions
{
    /// <summary>
    /// 是否启用缓存统计
    /// Enable statistics
    /// </summary>
    public bool EnableStatistics { get; set; } = true;
    
    /// <summary>
    /// 统计信息记录间隔（秒）
    /// Statistics interval in seconds
    /// </summary>
    [Range(10, 3600)]
    public int StatisticsIntervalSeconds { get; set; } = 60;
    
    /// <summary>
    /// 是否启用详细日志
    /// Enable detailed logging
    /// </summary>
    public bool EnableDetailedLogging { get; set; } = false;
    
    /// <summary>
    /// 缓存命中率告警阈值（百分比）
    /// Hit rate alert threshold (percentage)
    /// </summary>
    [Range(0, 100)]
    public double HitRateAlertThreshold { get; set; } = 70;
}

/// <summary>
/// 缓存预热配置
/// Cache warm-up options
/// </summary>
public class CacheWarmUpOptions
{
    /// <summary>
    /// 是否在启动时预热
    /// Enable warm-up on startup
    /// </summary>
    public bool EnableOnStartup { get; set; } = true;
    
    /// <summary>
    /// 预热超时（秒）
    /// Warm-up timeout in seconds
    /// </summary>
    [Range(5, 300)]
    public int TimeoutSeconds { get; set; } = 30;
    
    /// <summary>
    /// 预热失败是否阻塞启动
    /// Block startup on warm-up failure
    /// </summary>
    public bool BlockStartupOnFailure { get; set; } = false;
    
    /// <summary>
    /// 需要预热的实体类型
    /// Entity types to warm up
    /// </summary>
    public List<string> EntityTypes { get; set; } = new();
}
```

### 配置验证

```csharp
// Program.cs or DependencyInjection.cs
services.AddOptions<CacheOptions>()
    .Bind(configuration.GetSection("Cache"))
    .ValidateDataAnnotations()
    .ValidateOnStart();
```

---

## 总结

### 上篇要点回顾

1. **现状分析**
   - ✅ 写入优化已完成（减少 97.9%）
   - ⚠️ 读取未优化（每小时 120,000 次查询）
   - ⚠️ 读取占总数据库操作的 97%+

2. **核心问题**
   - 数据重复读取（80% 重复）
   - 缺少读写一致性（读旧数据）
   - 静态数据重复查询（纯浪费）
   - 关联查询过度（JOIN 开销）

3. **优化目标**
   - 数据库读取减少 70-90%
   - 缓存命中率 80%+
   - API 响应时间改善 30-50%
   - 内存增长控制在 150-300MB

4. **架构设计**
   - 扩展 `MemoryStateManager` 支持读取
   - 实现统一的 `CacheManager` 接口
   - 分层缓存（L1 进程内）
   - 数据分类（动态、半静态、静态）

5. **配置设计**
   - 完全配置化（appsettings.json）
   - 实体差异化策略
   - 可通过开关禁用
   - 监控和预热配置

### 下一步

请阅读 **中篇：详细实施方案**，包含：
- 详细的实施步骤
- 代码实现示例
- 测试方案
- 风险管理
- 迁移策略

---

**文档状态**: ✅ 需求分析完成  
**预期审核时间**: 1-2 个工作日  
**下一文档**: 数据库读取优化实施方案-中篇.md
