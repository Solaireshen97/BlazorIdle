# BlazorIdle æ•°æ®åº“è¯»å–ä¼˜åŒ–å®æ–½æ–¹æ¡ˆ - ä¸Šç¯‡

**é˜¶æ®µ**: Phase 1 - ç¼“å­˜å±‚åŸºç¡€è®¾æ–½å»ºè®¾  
**æ–‡æ¡£ç‰ˆæœ¬**: 1.0  
**åˆ›å»ºæ—¥æœŸ**: 2025-10-18  
**å·¥ä½œé‡ä¼°ç®—**: 3-4 å¤©  
**å‰ç½®æ¡ä»¶**: å†™å…¥ä¼˜åŒ– Phase 1-3 å·²å®Œæˆ

---

## ğŸ“‹ ç›®å½•

1. [é˜¶æ®µç›®æ ‡](#é˜¶æ®µç›®æ ‡)
2. [æ ¸å¿ƒä»»åŠ¡æ¸…å•](#æ ¸å¿ƒä»»åŠ¡æ¸…å•)
3. [è¯¦ç»†å®æ–½æ­¥éª¤](#è¯¦ç»†å®æ–½æ­¥éª¤)
4. [æµ‹è¯•éªŒè¯](#æµ‹è¯•éªŒè¯)
5. [éªŒæ”¶æ ‡å‡†](#éªŒæ”¶æ ‡å‡†)

---

## é˜¶æ®µç›®æ ‡

### ä¸»è¦ç›®æ ‡

**å»ºç«‹æ•°æ®åº“è¯»å–ç¼“å­˜çš„åŸºç¡€è®¾æ–½ï¼Œä¸ºåç»­è¿ç§»åšå‡†å¤‡ã€‚**

å…·ä½“ç›®æ ‡ï¼š
1. âœ… å¢å¼ºç°æœ‰ MemoryStateManagerï¼Œæ”¯æŒé«˜æ•ˆçš„ç¼“å­˜è¯»å–
2. âœ… åˆ›å»º CacheCoordinatorï¼Œç®¡ç†ç¼“å­˜é¢„åŠ è½½å’Œæ¸…ç†
3. âœ… å»ºç«‹å®Œæ•´çš„é…ç½®ç³»ç»Ÿï¼ˆCacheConfigurationï¼‰
4. âœ… æ·»åŠ ç¼“å­˜ç›‘æ§æŒ‡æ ‡ï¼ˆå‘½ä¸­ç‡ã€å†…å­˜ä½¿ç”¨ï¼‰
5. âœ… ç¡®ä¿æ‰€æœ‰å‚æ•°é…ç½®åŒ–ï¼Œæ— ç¡¬ç¼–ç 

### å…³é”®åŸåˆ™

1. **ä¸æ”¹å˜ç°æœ‰æ¥å£**ï¼šRepository æ¥å£ä¿æŒä¸å˜
2. **ä¸å†™å…¥ååŒ**ï¼šåˆ©ç”¨å·²æœ‰çš„ MemoryStateManager
3. **é…ç½®åŒ–ä¼˜å…ˆ**ï¼šæ‰€æœ‰å‚æ•°åœ¨ appsettings.json
4. **æ¸è¿›å¼æ¼”è¿›**ï¼šå…ˆå»ºåŸºç¡€è®¾æ–½ï¼Œå†è¿ç§»ä½¿ç”¨
5. **ä¿æŒä»£ç é£æ ¼**ï¼šéµå¾ªé¡¹ç›®è§„èŒƒ

### ä¸åŒ…å«åœ¨æœ¬é˜¶æ®µ

- âŒ è¿ç§»ç°æœ‰ Repository åˆ°ç¼“å­˜è¯»å–ï¼ˆæ”¾åœ¨ä¸­ç¯‡ï¼‰
- âŒ æ€§èƒ½è°ƒä¼˜å’Œå‹åŠ›æµ‹è¯•ï¼ˆæ”¾åœ¨ä¸‹ç¯‡ï¼‰
- âŒ ç®¡ç†æ¥å£å¼€å‘ï¼ˆæ”¾åœ¨ä¸‹ç¯‡ï¼‰

---

## æ ¸å¿ƒä»»åŠ¡æ¸…å•

### Task 1: å¢å¼º MemoryStateManager

**ç›®çš„**ï¼šæ·»åŠ ç¼“å­˜è¯»å–èƒ½åŠ›

#### 1.1 æ·»åŠ  TryGetAsync æ–¹æ³•
- [ ] å®ç°"å…ˆæŸ¥å†…å­˜ï¼Œæœªå‘½ä¸­å†æŸ¥æ•°æ®åº“"é€»è¾‘
- [ ] æ·»åŠ ç¼“å­˜å‘½ä¸­/æœªå‘½ä¸­è®¡æ•°å™¨
- [ ] çº¿ç¨‹å®‰å…¨ä¿è¯

#### 1.2 æ·»åŠ æ‰¹é‡é¢„åŠ è½½æ–¹æ³•
- [ ] PreloadBatchï¼šæ‰¹é‡åŠ è½½å®ä½“åˆ°å†…å­˜
- [ ] PreloadFromDatabaseï¼šä»æ•°æ®åº“æ‰¹é‡é¢„åŠ è½½

#### 1.3 æ·»åŠ ç¼“å­˜ç»Ÿè®¡æ–¹æ³•
- [ ] GetCacheHitRateï¼šè·å–ç¼“å­˜å‘½ä¸­ç‡
- [ ] GetCachedCountï¼šè·å–å½“å‰ç¼“å­˜æ•°é‡
- [ ] GetCacheStatisticsï¼šè·å–è¯¦ç»†ç»Ÿè®¡ä¿¡æ¯

#### 1.4 æ·»åŠ ç¼“å­˜ç®¡ç†æ–¹æ³•
- [ ] InvalidateCacheï¼šä½¿ç‰¹å®šå®ä½“ç¼“å­˜å¤±æ•ˆ
- [ ] ClearExpiredï¼šæ¸…ç†è¿‡æœŸç¼“å­˜ï¼ˆåŸºäº TTLï¼‰
- [ ] ClearAllï¼šæ¸…ç©ºæ‰€æœ‰ç¼“å­˜

**æ–‡ä»¶ä½ç½®**ï¼š
```
BlazorIdle.Server/Infrastructure/DatabaseOptimization/MemoryStateManager.cs
```

**å·¥ä½œé‡**ï¼š4-6 å°æ—¶

---

### Task 2: åˆ›å»º CacheCoordinator

**ç›®çš„**ï¼šç»Ÿä¸€ç®¡ç†ç¼“å­˜ç”Ÿå‘½å‘¨æœŸ

#### 2.1 åˆ›å»º CacheCoordinator ç±»
- [ ] ç»§æ‰¿ BackgroundService
- [ ] ä¾èµ–æ³¨å…¥æ‰€æœ‰ MemoryStateManager<T>
- [ ] åŠ è½½ CacheConfiguration

#### 2.2 å®ç°å¯åŠ¨æ—¶é¢„åŠ è½½
- [ ] PreloadStaticDataAsyncï¼šé¢„åŠ è½½é™æ€é…ç½®æ•°æ®
- [ ] PreloadEntityAsync<T>ï¼šé¢„åŠ è½½ç‰¹å®šå®ä½“ç±»å‹
- [ ] åˆ†æ‰¹åŠ è½½ï¼Œé¿å…å†…å­˜å³°å€¼

#### 2.3 å®ç°å®šæœŸç¼“å­˜æ¸…ç†
- [ ] ExecuteAsyncï¼šåå°å®šæœŸä»»åŠ¡
- [ ] CleanupExpiredCachesAsyncï¼šæ¸…ç†è¿‡æœŸç¼“å­˜
- [ ] åŸºäº TTL å’Œ LRU ç­–ç•¥

#### 2.4 å®ç°ç¼“å­˜å¤±æ•ˆé€šçŸ¥
- [ ] InvalidateEntityï¼šä½¿ç‰¹å®šå®ä½“å¤±æ•ˆ
- [ ] InvalidateEntityTypeï¼šä½¿æ•´ä¸ªç±»å‹å¤±æ•ˆ
- [ ] æ”¯æŒå¤–éƒ¨è§¦å‘ï¼ˆAPI è°ƒç”¨ï¼‰

**æ–‡ä»¶ä½ç½®**ï¼š
```
BlazorIdle.Server/Infrastructure/DatabaseOptimization/CacheCoordinator.cs
```

**å·¥ä½œé‡**ï¼š6-8 å°æ—¶

---

### Task 3: åˆ›å»ºé…ç½®ç³»ç»Ÿ

**ç›®çš„**ï¼šæ‰€æœ‰å‚æ•°é…ç½®åŒ–

#### 3.1 åˆ›å»ºé…ç½®ç±»
- [ ] CacheConfigurationï¼šé¡¶å±‚é…ç½®
- [ ] EntityCacheStrategyï¼šå®ä½“ç¼“å­˜ç­–ç•¥
- [ ] GlobalCacheSettingsï¼šå…¨å±€è®¾ç½®
- [ ] CacheStrategyTypeï¼šæšä¸¾ï¼ˆNone/Permanent/Temporaryï¼‰

#### 3.2 æ·»åŠ æ•°æ®éªŒè¯
- [ ] DataAnnotations éªŒè¯èŒƒå›´
- [ ] è‡ªå®šä¹‰éªŒè¯é€»è¾‘
- [ ] å¯åŠ¨æ—¶é…ç½®éªŒè¯

#### 3.3 åˆ›å»ºé…ç½®æ–‡ä»¶
- [ ] appsettings.json æ·»åŠ  CacheConfiguration èŠ‚
- [ ] appsettings.Development.json ç¤ºä¾‹é…ç½®
- [ ] appsettings.Production.example.json ç¤ºä¾‹é…ç½®

#### 3.4 æ³¨å†Œé…ç½®æœåŠ¡
- [ ] Program.cs æˆ– DependencyInjection.cs æ³¨å†Œ
- [ ] é…ç½®éªŒè¯
- [ ] é…ç½®ç»‘å®š

**æ–‡ä»¶ä½ç½®**ï¼š
```
BlazorIdle.Server/Config/DatabaseOptimization/
â”œâ”€â”€ CacheConfiguration.cs
â”œâ”€â”€ EntityCacheStrategy.cs
â”œâ”€â”€ GlobalCacheSettings.cs
â””â”€â”€ CacheStrategyType.cs
```

**å·¥ä½œé‡**ï¼š3-4 å°æ—¶

---

### Task 4: æ‰©å±•ç¼“å­˜ç›‘æ§

**ç›®çš„**ï¼šç›‘æ§ç¼“å­˜æ€§èƒ½

#### 4.1 æ‰©å±• DatabaseMetricsCollector
- [ ] RecordCacheHitï¼šè®°å½•ç¼“å­˜å‘½ä¸­
- [ ] RecordCacheMissï¼šè®°å½•ç¼“å­˜æœªå‘½ä¸­
- [ ] RecordCacheSizeï¼šè®°å½•ç¼“å­˜å¤§å°
- [ ] GetCacheMetricsï¼šè·å–ç¼“å­˜æŒ‡æ ‡

#### 4.2 æ·»åŠ ç¼“å­˜ç›‘æ§é…ç½®
- [ ] æ‰©å±• MonitoringOptions
- [ ] æ·»åŠ  CacheMonitoringSettings
- [ ] é…ç½®åŒ–ç›‘æ§å‚æ•°

#### 4.3 é›†æˆåˆ° DatabaseHealthController
- [ ] æ·»åŠ  /api/database/cache-stats ç«¯ç‚¹
- [ ] è¿”å›å„å®ä½“ç±»å‹çš„ç¼“å­˜ç»Ÿè®¡
- [ ] è¿”å›æ€»ä½“å‘½ä¸­ç‡

**æ–‡ä»¶ä½ç½®**ï¼š
```
BlazorIdle.Server/Infrastructure/DatabaseOptimization/DatabaseMetricsCollector.cs
BlazorIdle.Server/Api/DatabaseHealthController.cs
BlazorIdle.Server/Config/DatabaseOptimization/MonitoringOptions.cs (æ‰©å±•)
```

**å·¥ä½œé‡**ï¼š3-4 å°æ—¶

---

### Task 5: ä¾èµ–æ³¨å…¥é…ç½®

**ç›®çš„**ï¼šæ³¨å†Œæ‰€æœ‰æ–°æœåŠ¡

#### 5.1 æ³¨å†Œ CacheCoordinator
- [ ] æ³¨å†Œä¸º HostedService
- [ ] ç¡®ä¿åœ¨å…¶ä»–æœåŠ¡ä¹‹åå¯åŠ¨

#### 5.2 æ³¨å†Œé…ç½®é€‰é¡¹
- [ ] æ³¨å†Œ CacheConfiguration
- [ ] é…ç½®éªŒè¯

#### 5.3 æ›´æ–° MemoryStateManager æ³¨å†Œ
- [ ] ç¡®ä¿æ‰€æœ‰å®ä½“ç±»å‹éƒ½æœ‰å¯¹åº”çš„ MemoryStateManager
- [ ] å•ä¾‹ç”Ÿå‘½å‘¨æœŸ

**æ–‡ä»¶ä½ç½®**ï¼š
```
BlazorIdle.Server/Infrastructure/DependencyInjection.cs
BlazorIdle.Server/Program.cs
```

**å·¥ä½œé‡**ï¼š1-2 å°æ—¶

---

### Task 6: å•å…ƒæµ‹è¯•

**ç›®çš„**ï¼šç¡®ä¿åŸºç¡€åŠŸèƒ½æ­£ç¡®

#### 6.1 MemoryStateManager æµ‹è¯•
- [ ] TryGetAsync åŠŸèƒ½æµ‹è¯•
- [ ] ç¼“å­˜å‘½ä¸­/æœªå‘½ä¸­æµ‹è¯•
- [ ] PreloadBatch æµ‹è¯•
- [ ] çº¿ç¨‹å®‰å…¨æµ‹è¯•

#### 6.2 CacheCoordinator æµ‹è¯•
- [ ] PreloadStaticDataAsync æµ‹è¯•
- [ ] CleanupExpiredCachesAsync æµ‹è¯•
- [ ] TTL è¿‡æœŸæµ‹è¯•

#### 6.3 é…ç½®éªŒè¯æµ‹è¯•
- [ ] é…ç½®åŠ è½½æµ‹è¯•
- [ ] éªŒè¯è§„åˆ™æµ‹è¯•
- [ ] é»˜è®¤å€¼æµ‹è¯•

**æ–‡ä»¶ä½ç½®**ï¼š
```
tests/BlazorIdle.Tests/DatabaseOptimization/
â”œâ”€â”€ MemoryStateManagerCacheTests.cs
â”œâ”€â”€ CacheCoordinatorTests.cs
â””â”€â”€ CacheConfigurationTests.cs
```

**å·¥ä½œé‡**ï¼š4-6 å°æ—¶

---

## è¯¦ç»†å®æ–½æ­¥éª¤

### Step 1: å¢å¼º MemoryStateManagerï¼ˆ4-6å°æ—¶ï¼‰

#### 1.1 æ·»åŠ ç¼“å­˜ç»Ÿè®¡å­—æ®µ

```csharp
// åœ¨ MemoryStateManager<T> ç±»ä¸­æ·»åŠ ï¼š

/// <summary>
/// ç¼“å­˜å‘½ä¸­æ¬¡æ•°
/// Cache hit count
/// </summary>
private long _cacheHits = 0;

/// <summary>
/// ç¼“å­˜æœªå‘½ä¸­æ¬¡æ•°
/// Cache miss count
/// </summary>
private long _cacheMisses = 0;

/// <summary>
/// æœ€åè®¿é—®æ—¶é—´ï¼ˆç”¨äº LRUï¼‰
/// Last access time (for LRU)
/// </summary>
private readonly ConcurrentDictionary<Guid, DateTime> _lastAccessTime = new();
```

#### 1.2 å®ç° TryGetAsync æ–¹æ³•

```csharp
/// <summary>
/// å°è¯•è·å–å®ä½“ï¼ˆç¼“å­˜ä¼˜å…ˆï¼‰
/// Try to get entity (cache first)
/// 
/// é€»è¾‘è¯´æ˜ï¼š
/// 1. å…ˆæŸ¥å†…å­˜ç¼“å­˜ï¼ˆ_storeï¼‰
/// 2. å‘½ä¸­åˆ™æ›´æ–°è®¿é—®æ—¶é—´ï¼Œå¢åŠ å‘½ä¸­è®¡æ•°ï¼Œè¿”å›
/// 3. æœªå‘½ä¸­åˆ™è°ƒç”¨ databaseLoader æŸ¥è¯¢æ•°æ®åº“
/// 4. æŸ¥åˆ°ååŠ è½½åˆ°å†…å­˜ï¼Œè¿”å›
/// 5. æœªæŸ¥åˆ°åˆ™è¿”å› null
/// </summary>
/// <param name="id">å®ä½“ ID</param>
/// <param name="databaseLoader">æ•°æ®åº“æŸ¥è¯¢å§”æ‰˜</param>
/// <param name="ct">å–æ¶ˆä»¤ç‰Œ</param>
/// <returns>å®ä½“å¯¹è±¡ï¼Œæœªæ‰¾åˆ°è¿”å› null</returns>
public async Task<T?> TryGetAsync(
    Guid id, 
    Func<Guid, CancellationToken, Task<T?>> databaseLoader, 
    CancellationToken ct = default)
{
    // 1. å…ˆæŸ¥å†…å­˜ç¼“å­˜
    if (_store.TryGetValue(id, out var cached))
    {
        // å‘½ä¸­ï¼šæ›´æ–°ç»Ÿè®¡
        Interlocked.Increment(ref _cacheHits);
        _lastAccessTime.TryAdd(id, DateTime.UtcNow);
        
        _logger?.LogDebug(
            "[MemoryStateManager<{EntityType}>] ç¼“å­˜å‘½ä¸­: {Id}",
            typeof(T).Name, id
        );
        
        return cached;
    }
    
    // 2. æœªå‘½ä¸­ï¼šæŸ¥è¯¢æ•°æ®åº“
    Interlocked.Increment(ref _cacheMisses);
    
    _logger?.LogDebug(
        "[MemoryStateManager<{EntityType}>] ç¼“å­˜æœªå‘½ä¸­ï¼ŒæŸ¥è¯¢æ•°æ®åº“: {Id}",
        typeof(T).Name, id
    );
    
    var entity = await databaseLoader(id, ct);
    
    // 3. åŠ è½½åˆ°å†…å­˜ï¼ˆå¦‚æœæŸ¥åˆ°äº†ï¼‰
    if (entity != null)
    {
        _store.TryAdd(id, entity);
        _lastAccessTime.TryAdd(id, DateTime.UtcNow);
        
        // æ£€æŸ¥æ˜¯å¦è¶…è¿‡å®¹é‡é™åˆ¶
        await CheckAndEvictIfNeededAsync();
    }
    
    return entity;
}
```

#### 1.3 å®ç°æ‰¹é‡é¢„åŠ è½½æ–¹æ³•

```csharp
/// <summary>
/// æ‰¹é‡é¢„åŠ è½½å®ä½“ï¼ˆä¸æ ‡è®°ä¸º Dirtyï¼‰
/// Batch preload entities (without marking as Dirty)
/// </summary>
/// <param name="entities">å®ä½“é›†åˆ</param>
public void PreloadBatch(IEnumerable<T> entities)
{
    var now = DateTime.UtcNow;
    var count = 0;
    
    foreach (var entity in entities)
    {
        if (_store.TryAdd(entity.Id, entity))
        {
            _lastAccessTime.TryAdd(entity.Id, now);
            count++;
        }
    }
    
    _logger?.LogInformation(
        "[MemoryStateManager<{EntityType}>] é¢„åŠ è½½å®Œæˆ: {Count} ä¸ªå®ä½“",
        typeof(T).Name, count
    );
}

/// <summary>
/// ä»æ•°æ®åº“æ‰¹é‡é¢„åŠ è½½
/// Batch preload from database
/// </summary>
/// <param name="dbContext">æ•°æ®åº“ä¸Šä¸‹æ–‡</param>
/// <param name="batchSize">æ‰¹é‡å¤§å°</param>
/// <param name="ct">å–æ¶ˆä»¤ç‰Œ</param>
public async Task PreloadFromDatabaseAsync(
    GameDbContext dbContext, 
    int batchSize = 1000, 
    CancellationToken ct = default)
{
    var skip = 0;
    int loaded;
    var totalLoaded = 0;
    
    do
    {
        var batch = await dbContext.Set<T>()
            .Skip(skip)
            .Take(batchSize)
            .ToListAsync(ct);
        
        loaded = batch.Count;
        PreloadBatch(batch);
        
        skip += batchSize;
        totalLoaded += loaded;
    }
    while (loaded == batchSize && !ct.IsCancellationRequested);
    
    _logger?.LogInformation(
        "[MemoryStateManager<{EntityType}>] ä»æ•°æ®åº“é¢„åŠ è½½å®Œæˆ: {Total} ä¸ªå®ä½“",
        typeof(T).Name, totalLoaded
    );
}
```

#### 1.4 å®ç°ç¼“å­˜ç»Ÿè®¡æ–¹æ³•

```csharp
/// <summary>
/// è·å–ç¼“å­˜å‘½ä¸­ç‡
/// Get cache hit rate
/// </summary>
/// <returns>å‘½ä¸­ç‡ï¼ˆ0.0-1.0ï¼‰</returns>
public double GetCacheHitRate()
{
    var total = _cacheHits + _cacheMisses;
    return total > 0 ? (double)_cacheHits / total : 0.0;
}

/// <summary>
/// è·å–ç¼“å­˜ç»Ÿè®¡ä¿¡æ¯
/// Get cache statistics
/// </summary>
public CacheStatistics GetCacheStatistics()
{
    return new CacheStatistics
    {
        EntityType = typeof(T).Name,
        CachedCount = _store.Count,
        DirtyCount = _dirtyEntities.Count,
        CacheHits = _cacheHits,
        CacheMisses = _cacheMisses,
        HitRate = GetCacheHitRate()
    };
}
```

#### 1.5 å®ç°ç¼“å­˜æ¸…ç†æ–¹æ³•

```csharp
/// <summary>
/// æ¸…ç†è¿‡æœŸç¼“å­˜ï¼ˆåŸºäº TTLï¼‰
/// Clear expired cache entries (based on TTL)
/// </summary>
/// <param name="ttlSeconds">è¿‡æœŸæ—¶é—´ï¼ˆç§’ï¼‰</param>
public int ClearExpired(int ttlSeconds)
{
    var cutoff = DateTime.UtcNow.AddSeconds(-ttlSeconds);
    var expiredIds = _lastAccessTime
        .Where(kvp => kvp.Value < cutoff)
        .Select(kvp => kvp.Key)
        .ToList();
    
    var removedCount = 0;
    foreach (var id in expiredIds)
    {
        // ä¸ç§»é™¤ Dirty çš„å®ä½“ï¼ˆè¿˜æœªä¿å­˜ï¼‰
        if (!_dirtyEntities.ContainsKey(id))
        {
            if (_store.TryRemove(id, out _))
            {
                _lastAccessTime.TryRemove(id, out _);
                removedCount++;
            }
        }
    }
    
    if (removedCount > 0)
    {
        _logger?.LogInformation(
            "[MemoryStateManager<{EntityType}>] æ¸…ç†è¿‡æœŸç¼“å­˜: {Count} ä¸ªå®ä½“",
            typeof(T).Name, removedCount
        );
    }
    
    return removedCount;
}

/// <summary>
/// LRU æ¸…ç†ï¼šç§»é™¤æœ€ä¹…æœªè®¿é—®çš„å®ä½“
/// LRU eviction: Remove least recently used entities
/// </summary>
/// <param name="targetCount">ç›®æ ‡ä¿ç•™æ•°é‡</param>
private async Task CheckAndEvictIfNeededAsync()
{
    var maxCount = _options?.MaxCachedEntities ?? 10000;
    
    if (_store.Count <= maxCount)
        return;
    
    // LRU æ¸…ç†ï¼šç§»é™¤æœ€ä¹…æœªè®¿é—®çš„
    var toRemoveCount = _store.Count - (int)(maxCount * 0.9); // æ¸…ç†åˆ° 90%
    
    var lruEntities = _lastAccessTime
        .Where(kvp => !_dirtyEntities.ContainsKey(kvp.Key)) // ä¸ç§»é™¤ Dirty
        .OrderBy(kvp => kvp.Value)
        .Take(toRemoveCount)
        .Select(kvp => kvp.Key)
        .ToList();
    
    foreach (var id in lruEntities)
    {
        _store.TryRemove(id, out _);
        _lastAccessTime.TryRemove(id, out _);
    }
    
    _logger?.LogWarning(
        "[MemoryStateManager<{EntityType}>] LRU æ¸…ç†: {Count} ä¸ªå®ä½“",
        typeof(T).Name, lruEntities.Count
    );
}
```

---

### Step 2: åˆ›å»º CacheCoordinatorï¼ˆ6-8å°æ—¶ï¼‰

#### 2.1 åˆ›å»ºç±»éª¨æ¶

```csharp
/// <summary>
/// ç¼“å­˜åè°ƒå™¨ - ç®¡ç†ç¼“å­˜çš„é¢„åŠ è½½ã€æ¸…ç†å’Œå¤±æ•ˆ
/// Cache Coordinator - Manages cache preloading, cleanup, and invalidation
/// 
/// èŒè´£ï¼š
/// 1. å¯åŠ¨æ—¶é¢„åŠ è½½é™æ€é…ç½®æ•°æ®ï¼ˆGearDefinition, Affix ç­‰ï¼‰
/// 2. å®šæœŸæ¸…ç†è¿‡æœŸç¼“å­˜ï¼ˆåŸºäº TTLï¼‰
/// 3. æä¾›æ‰‹åŠ¨åˆ·æ–°ç¼“å­˜çš„æ¥å£
/// 4. è®°å½•ç¼“å­˜ç›‘æ§æŒ‡æ ‡
/// </summary>
public class CacheCoordinator : BackgroundService
{
    private readonly IServiceScopeFactory _scopeFactory;
    private readonly IOptions<CacheConfiguration> _cacheConfig;
    private readonly ILogger<CacheCoordinator> _logger;
    private readonly DatabaseMetricsCollector? _metricsCollector;
    
    // å„ç±»å‹å®ä½“çš„å†…å­˜ç®¡ç†å™¨
    private readonly IMemoryStateManager<Character>? _characterManager;
    private readonly IMemoryStateManager<GearDefinition>? _gearDefManager;
    private readonly IMemoryStateManager<Affix>? _affixManager;
    private readonly IMemoryStateManager<GearSet>? _gearSetManager;
    private readonly IMemoryStateManager<GearInstance>? _gearInstanceManager;
    private readonly IMemoryStateManager<ActivityPlan>? _activityPlanManager;
    private readonly IMemoryStateManager<RunningBattleSnapshotRecord>? _snapshotManager;
    
    public CacheCoordinator(
        IServiceScopeFactory scopeFactory,
        IOptions<CacheConfiguration> cacheConfig,
        ILogger<CacheCoordinator> logger,
        DatabaseMetricsCollector? metricsCollector = null,
        IMemoryStateManager<Character>? characterManager = null,
        IMemoryStateManager<GearDefinition>? gearDefManager = null,
        IMemoryStateManager<Affix>? affixManager = null,
        IMemoryStateManager<GearSet>? gearSetManager = null,
        IMemoryStateManager<GearInstance>? gearInstanceManager = null,
        IMemoryStateManager<ActivityPlan>? activityPlanManager = null,
        IMemoryStateManager<RunningBattleSnapshotRecord>? snapshotManager = null)
    {
        _scopeFactory = scopeFactory;
        _cacheConfig = cacheConfig;
        _logger = logger;
        _metricsCollector = metricsCollector;
        _characterManager = characterManager;
        _gearDefManager = gearDefManager;
        _affixManager = affixManager;
        _gearSetManager = gearSetManager;
        _gearInstanceManager = gearInstanceManager;
        _activityPlanManager = activityPlanManager;
        _snapshotManager = snapshotManager;
    }
    
    // ... å®ç°æ–¹æ³•
}
```

#### 2.2 å®ç°å¯åŠ¨æ—¶é¢„åŠ è½½

```csharp
/// <summary>
/// å¯åŠ¨æ—¶é¢„åŠ è½½é™æ€æ•°æ®
/// Preload static data on startup
/// </summary>
public override async Task StartAsync(CancellationToken cancellationToken)
{
    _logger.LogInformation("=== ç¼“å­˜åè°ƒå™¨å¯åŠ¨ ===");
    
    // æ£€æŸ¥æ˜¯å¦å¯ç”¨è¯»å–ç¼“å­˜
    if (!_cacheConfig.Value.GlobalSettings.EnableReadCaching)
    {
        _logger.LogWarning("è¯»å–ç¼“å­˜å·²ç¦ç”¨ï¼ˆEnableReadCaching = falseï¼‰");
        return;
    }
    
    try
    {
        // é¢„åŠ è½½é™æ€é…ç½®æ•°æ®
        await PreloadStaticDataAsync(cancellationToken);
        
        _logger.LogInformation("=== ç¼“å­˜é¢„åŠ è½½å®Œæˆ ===");
    }
    catch (Exception ex)
    {
        _logger.LogError(ex, "ç¼“å­˜é¢„åŠ è½½å¤±è´¥");
        // ä¸æŠ›å‡ºå¼‚å¸¸ï¼Œå…è®¸æœåŠ¡ç»§ç»­å¯åŠ¨
    }
    
    await base.StartAsync(cancellationToken);
}

/// <summary>
/// é¢„åŠ è½½é™æ€é…ç½®æ•°æ®
/// Preload static configuration data
/// </summary>
private async Task PreloadStaticDataAsync(CancellationToken ct)
{
    using var scope = _scopeFactory.CreateScope();
    var db = scope.ServiceProvider.GetRequiredService<GameDbContext>();
    
    // 1. é¢„åŠ è½½è£…å¤‡å®šä¹‰
    await PreloadEntityIfConfiguredAsync<GearDefinition>(
        "GearDefinition", 
        _gearDefManager, 
        db, 
        ct
    );
    
    // 2. é¢„åŠ è½½è¯ç¼€å®šä¹‰
    await PreloadEntityIfConfiguredAsync<Affix>(
        "Affix", 
        _affixManager, 
        db, 
        ct
    );
    
    // 3. é¢„åŠ è½½è£…å¤‡å¥—è£…
    await PreloadEntityIfConfiguredAsync<GearSet>(
        "GearSet", 
        _gearSetManager, 
        db, 
        ct
    );
}

/// <summary>
/// æ ¹æ®é…ç½®é¢„åŠ è½½ç‰¹å®šå®ä½“ç±»å‹
/// Preload specific entity type based on configuration
/// </summary>
private async Task PreloadEntityIfConfiguredAsync<T>(
    string entityTypeName,
    IMemoryStateManager<T>? manager,
    GameDbContext db,
    CancellationToken ct) where T : class, IEntity
{
    if (manager == null)
    {
        _logger.LogWarning(
            "è·³è¿‡ {EntityType} é¢„åŠ è½½ï¼šMemoryStateManager æœªæ³¨å†Œ",
            entityTypeName
        );
        return;
    }
    
    // æ£€æŸ¥é…ç½®
    if (!_cacheConfig.Value.EntityStrategies.TryGetValue(entityTypeName, out var strategy))
    {
        _logger.LogDebug(
            "è·³è¿‡ {EntityType} é¢„åŠ è½½ï¼šæœªé…ç½®ç¼“å­˜ç­–ç•¥",
            entityTypeName
        );
        return;
    }
    
    if (!strategy.PreloadOnStartup)
    {
        _logger.LogDebug(
            "è·³è¿‡ {EntityType} é¢„åŠ è½½ï¼šPreloadOnStartup = false",
            entityTypeName
        );
        return;
    }
    
    // æ‰§è¡Œé¢„åŠ è½½
    var sw = System.Diagnostics.Stopwatch.StartNew();
    
    await manager.PreloadFromDatabaseAsync(db, strategy.PreloadBatchSize, ct);
    
    sw.Stop();
    
    var stats = manager.GetCacheStatistics();
    _logger.LogInformation(
        "âœ“ {EntityType} é¢„åŠ è½½å®Œæˆ: {Count} æ¡è®°å½•ï¼Œè€—æ—¶ {ElapsedMs}ms",
        entityTypeName, stats.CachedCount, sw.ElapsedMilliseconds
    );
}
```

#### 2.3 å®ç°å®šæœŸæ¸…ç†

```csharp
/// <summary>
/// åå°å®šæœŸä»»åŠ¡ï¼šæ¸…ç†è¿‡æœŸç¼“å­˜
/// Background periodic task: Clean expired cache entries
/// </summary>
protected override async Task ExecuteAsync(CancellationToken stoppingToken)
{
    if (!_cacheConfig.Value.GlobalSettings.EnableReadCaching)
        return;
    
    var interval = TimeSpan.FromMinutes(
        _cacheConfig.Value.GlobalSettings.CleanupIntervalMinutes
    );
    
    _logger.LogInformation(
        "ç¼“å­˜æ¸…ç†ä»»åŠ¡å¯åŠ¨ï¼Œé—´éš”: {IntervalMinutes} åˆ†é’Ÿ",
        interval.TotalMinutes
    );
    
    while (!stoppingToken.IsCancellationRequested)
    {
        try
        {
            await Task.Delay(interval, stoppingToken);
            await CleanupExpiredCachesAsync(stoppingToken);
        }
        catch (OperationCanceledException)
        {
            // æ­£å¸¸å…³é—­
            break;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "ç¼“å­˜æ¸…ç†ä»»åŠ¡å‡ºé”™");
        }
    }
    
    _logger.LogInformation("ç¼“å­˜æ¸…ç†ä»»åŠ¡å·²åœæ­¢");
}

/// <summary>
/// æ¸…ç†è¿‡æœŸç¼“å­˜
/// Clean expired cache entries
/// </summary>
private async Task CleanupExpiredCachesAsync(CancellationToken ct)
{
    _logger.LogDebug("å¼€å§‹æ¸…ç†è¿‡æœŸç¼“å­˜...");
    
    var totalRemoved = 0;
    
    // æ¸…ç†å„ç±»å‹å®ä½“çš„è¿‡æœŸç¼“å­˜
    totalRemoved += CleanupEntityIfConfigured<Character>(
        "Character", _characterManager);
    totalRemoved += CleanupEntityIfConfigured<GearInstance>(
        "GearInstance", _gearInstanceManager);
    totalRemoved += CleanupEntityIfConfigured<ActivityPlan>(
        "ActivityPlan", _activityPlanManager);
    totalRemoved += CleanupEntityIfConfigured<RunningBattleSnapshotRecord>(
        "RunningBattleSnapshot", _snapshotManager);
    
    if (totalRemoved > 0)
    {
        _logger.LogInformation(
            "è¿‡æœŸç¼“å­˜æ¸…ç†å®Œæˆ: æ€»è®¡ç§»é™¤ {Count} ä¸ªå®ä½“",
            totalRemoved
        );
    }
    else
    {
        _logger.LogDebug("è¿‡æœŸç¼“å­˜æ¸…ç†å®Œæˆ: æ— è¿‡æœŸé¡¹");
    }
    
    await Task.CompletedTask;
}

/// <summary>
/// æ¸…ç†å•ä¸ªå®ä½“ç±»å‹çš„è¿‡æœŸç¼“å­˜
/// Clean expired cache for a single entity type
/// </summary>
private int CleanupEntityIfConfigured<T>(
    string entityTypeName,
    IMemoryStateManager<T>? manager) where T : class, IEntity
{
    if (manager == null)
        return 0;
    
    if (!_cacheConfig.Value.EntityStrategies.TryGetValue(entityTypeName, out var strategy))
        return 0;
    
    // åªæ¸…ç† Temporary ç­–ç•¥çš„ç¼“å­˜
    if (strategy.Strategy != CacheStrategyType.Temporary)
        return 0;
    
    var removed = manager.ClearExpired(strategy.TtlSeconds);
    
    if (removed > 0)
    {
        _logger.LogDebug(
            "æ¸…ç† {EntityType} è¿‡æœŸç¼“å­˜: {Count} ä¸ªå®ä½“",
            entityTypeName, removed
        );
    }
    
    return removed;
}
```

---

### Step 3: åˆ›å»ºé…ç½®ç³»ç»Ÿï¼ˆ3-4å°æ—¶ï¼‰

#### 3.1 åˆ›å»ºé…ç½®ç±»

**æ–‡ä»¶**: `Config/DatabaseOptimization/CacheConfiguration.cs`

```csharp
using System.ComponentModel.DataAnnotations;
using System.Text.Json.Serialization;

namespace BlazorIdle.Server.Config.DatabaseOptimization;

/// <summary>
/// ç¼“å­˜é…ç½® - å®šä¹‰ä¸åŒå®ä½“ç±»å‹çš„ç¼“å­˜ç­–ç•¥
/// Cache Configuration - Define caching strategies for different entity types
/// </summary>
public class CacheConfiguration
{
    /// <summary>
    /// å®ä½“ç‰¹å®šçš„ç¼“å­˜ç­–ç•¥
    /// Entity-specific cache strategies
    /// 
    /// Key: å®ä½“ç±»å‹åç§°ï¼ˆå¦‚ "GearDefinition", "Character"ï¼‰
    /// Value: è¯¥å®ä½“çš„ç¼“å­˜ç­–ç•¥
    /// </summary>
    public Dictionary<string, EntityCacheStrategy> EntityStrategies { get; set; } 
        = new Dictionary<string, EntityCacheStrategy>();
    
    /// <summary>
    /// å…¨å±€ç¼“å­˜è®¾ç½®
    /// Global cache settings
    /// </summary>
    public GlobalCacheSettings GlobalSettings { get; set; } = new GlobalCacheSettings();
}
```

**æ–‡ä»¶**: `Config/DatabaseOptimization/EntityCacheStrategy.cs`

```csharp
/// <summary>
/// å•ä¸ªå®ä½“ç±»å‹çš„ç¼“å­˜ç­–ç•¥
/// Cache strategy for a single entity type
/// </summary>
public class EntityCacheStrategy
{
    /// <summary>
    /// ç¼“å­˜ç­–ç•¥ç±»å‹ï¼ˆNone/Permanent/Temporaryï¼‰
    /// Cache strategy type
    /// 
    /// è¯´æ˜ï¼š
    /// - None: ä¸ç¼“å­˜ï¼Œç›´æ¥æŸ¥è¯¢æ•°æ®åº“
    /// - Permanent: æ°¸ä¹…ç¼“å­˜ï¼Œé€‚ç”¨äºé™æ€é…ç½®æ•°æ®ï¼ˆå¦‚è£…å¤‡å®šä¹‰ï¼‰
    /// - Temporary: ä¸´æ—¶ç¼“å­˜ï¼Œå¸¦ TTLï¼Œé€‚ç”¨äºç”¨æˆ·æ•°æ®ï¼ˆå¦‚è§’è‰²ã€è£…å¤‡å®ä¾‹ï¼‰
    /// </summary>
    [JsonConverter(typeof(JsonStringEnumConverter))]
    public CacheStrategyType Strategy { get; set; } = CacheStrategyType.Temporary;
    
    /// <summary>
    /// TTLï¼ˆç§’ï¼‰- ä»…å¯¹ Temporary ç­–ç•¥æœ‰æ•ˆ
    /// Time-to-live in seconds (for Temporary strategy only)
    /// 
    /// èŒƒå›´ï¼š60 ç§’ï¼ˆ1åˆ†é’Ÿï¼‰åˆ° 86400 ç§’ï¼ˆ24å°æ—¶ï¼‰
    /// é»˜è®¤ï¼š3600 ç§’ï¼ˆ1å°æ—¶ï¼‰
    /// </summary>
    [Range(60, 86400)]
    public int TtlSeconds { get; set; } = 3600;
    
    /// <summary>
    /// æœ€å¤§ç¼“å­˜æ•°é‡
    /// Maximum cached entities
    /// 
    /// èŒƒå›´ï¼š100 åˆ° 1000000
    /// è¶…è¿‡æ­¤æ•°é‡åè§¦å‘ LRU æ¸…ç†
    /// </summary>
    [Range(100, 1000000)]
    public int MaxCachedCount { get; set; } = 10000;
    
    /// <summary>
    /// æ˜¯å¦åœ¨å¯åŠ¨æ—¶é¢„åŠ è½½
    /// Preload on startup
    /// 
    /// è¯´æ˜ï¼š
    /// - ä»…å¯¹ Permanent ç­–ç•¥æ¨èå¯ç”¨
    /// - å¯ç”¨åä¼šåœ¨æœåŠ¡å¯åŠ¨æ—¶ä»æ•°æ®åº“æ‰¹é‡åŠ è½½æ‰€æœ‰æ•°æ®åˆ°å†…å­˜
    /// - é€‚ç”¨äºæ•°æ®é‡ä¸å¤§çš„é™æ€é…ç½®æ•°æ®
    /// </summary>
    public bool PreloadOnStartup { get; set; } = false;
    
    /// <summary>
    /// é¢„åŠ è½½æ‰¹é‡å¤§å°
    /// Preload batch size
    /// 
    /// èŒƒå›´ï¼š100 åˆ° 10000
    /// é»˜è®¤ï¼š1000
    /// 
    /// è¯´æ˜ï¼šæ§åˆ¶æ¯æ¬¡ä»æ•°æ®åº“è¯»å–çš„è®°å½•æ•°ï¼Œé¿å…ä¸€æ¬¡æ€§åŠ è½½è¿‡å¤šå¯¼è‡´å†…å­˜å³°å€¼
    /// </summary>
    [Range(100, 10000)]
    public int PreloadBatchSize { get; set; } = 1000;
}
```

**æ–‡ä»¶**: `Config/DatabaseOptimization/CacheStrategyType.cs`

```csharp
/// <summary>
/// ç¼“å­˜ç­–ç•¥ç±»å‹æšä¸¾
/// Cache Strategy Type Enum
/// </summary>
public enum CacheStrategyType
{
    /// <summary>
    /// æ— ç¼“å­˜ - ç›´æ¥æŸ¥è¯¢æ•°æ®åº“
    /// No caching - Query database directly
    /// </summary>
    None = 0,
    
    /// <summary>
    /// æ°¸ä¹…ç¼“å­˜ - é€‚ç”¨äºé™æ€é…ç½®æ•°æ®
    /// Permanent caching - For static configuration data
    /// 
    /// ç‰¹ç‚¹ï¼š
    /// - å¯åŠ¨æ—¶é¢„åŠ è½½
    /// - ä¸è¿‡æœŸï¼ˆé™¤éæ‰‹åŠ¨åˆ·æ–°ï¼‰
    /// - é€‚ç”¨äºï¼šè£…å¤‡å®šä¹‰ã€è¯ç¼€å®šä¹‰ã€è£…å¤‡å¥—è£…ç­‰
    /// </summary>
    Permanent = 1,
    
    /// <summary>
    /// ä¸´æ—¶ç¼“å­˜ - é€‚ç”¨äºç”¨æˆ·æ•°æ®ï¼Œå¸¦ TTL
    /// Temporary caching - For user data, with TTL
    /// 
    /// ç‰¹ç‚¹ï¼š
    /// - æ‡’åŠ è½½ï¼ˆæŒ‰éœ€åŠ è½½ï¼‰
    /// - å¸¦è¿‡æœŸæ—¶é—´ï¼ˆTTLï¼‰
    /// - LRU æ¸…ç†ç­–ç•¥
    /// - é€‚ç”¨äºï¼šè§’è‰²ã€è£…å¤‡å®ä¾‹ã€æ´»åŠ¨è®¡åˆ’ç­‰
    /// </summary>
    Temporary = 2
}
```

**æ–‡ä»¶**: `Config/DatabaseOptimization/GlobalCacheSettings.cs`

```csharp
/// <summary>
/// å…¨å±€ç¼“å­˜è®¾ç½®
/// Global Cache Settings
/// </summary>
public class GlobalCacheSettings
{
    /// <summary>
    /// æ˜¯å¦å¯ç”¨è¯»å–ç¼“å­˜ï¼ˆæ€»å¼€å…³ï¼‰
    /// Enable read caching (master switch)
    /// 
    /// è¯´æ˜ï¼š
    /// - true: å¯ç”¨æ‰€æœ‰ç¼“å­˜åŠŸèƒ½
    /// - false: ç¦ç”¨ç¼“å­˜ï¼Œæ‰€æœ‰è¯»å–ç›´æ¥æŸ¥è¯¢æ•°æ®åº“ï¼ˆç”¨äºå›é€€ï¼‰
    /// 
    /// é»˜è®¤ï¼štrue
    /// </summary>
    public bool EnableReadCaching { get; set; } = true;
    
    /// <summary>
    /// ç¼“å­˜æ¸…ç†é—´éš”ï¼ˆåˆ†é’Ÿï¼‰
    /// Cleanup interval in minutes
    /// 
    /// èŒƒå›´ï¼š1 åˆ° 60 åˆ†é’Ÿ
    /// é»˜è®¤ï¼š5 åˆ†é’Ÿ
    /// 
    /// è¯´æ˜ï¼šCacheCoordinator å®šæœŸæ¸…ç†è¿‡æœŸç¼“å­˜çš„é—´éš”
    /// </summary>
    [Range(1, 60)]
    public int CleanupIntervalMinutes { get; set; } = 5;
    
    /// <summary>
    /// æ˜¯å¦è®°å½•ç¼“å­˜å‘½ä¸­ç‡
    /// Track cache hit rate
    /// 
    /// è¯´æ˜ï¼š
    /// - true: è®°å½•æ¯ä¸ªå®ä½“ç±»å‹çš„ç¼“å­˜å‘½ä¸­ç‡
    /// - false: ä¸è®°å½•ï¼ˆèŠ‚çœå°‘é‡æ€§èƒ½å¼€é”€ï¼‰
    /// 
    /// é»˜è®¤ï¼štrue
    /// æ¨èï¼šç”Ÿäº§ç¯å¢ƒå¯ç”¨ï¼Œä¾¿äºç›‘æ§
    /// </summary>
    public bool TrackCacheHitRate { get; set; } = true;
    
    /// <summary>
    /// å‘½ä¸­ç‡è®°å½•é—´éš”ï¼ˆåˆ†é’Ÿï¼‰
    /// Hit rate logging interval in minutes
    /// 
    /// èŒƒå›´ï¼š1 åˆ° 60 åˆ†é’Ÿ
    /// é»˜è®¤ï¼š10 åˆ†é’Ÿ
    /// 
    /// è¯´æ˜ï¼šå®šæœŸè¾“å‡ºç¼“å­˜å‘½ä¸­ç‡åˆ°æ—¥å¿—çš„é—´éš”
    /// </summary>
    [Range(1, 60)]
    public int HitRateLogIntervalMinutes { get; set; } = 10;
}
```

#### 3.2 é…ç½®æ–‡ä»¶ç¤ºä¾‹

**æ–‡ä»¶**: `appsettings.json`

```json
{
  "CacheConfiguration": {
    "EntityStrategies": {
      // === é™æ€é…ç½®æ•°æ®ï¼šæ°¸ä¹…ç¼“å­˜ï¼Œå¯åŠ¨æ—¶é¢„åŠ è½½ ===
      
      "GearDefinition": {
        "Strategy": "Permanent",
        "PreloadOnStartup": true,
        "PreloadBatchSize": 500,
        "MaxCachedCount": 10000
      },
      
      "Affix": {
        "Strategy": "Permanent",
        "PreloadOnStartup": true,
        "PreloadBatchSize": 1000,
        "MaxCachedCount": 10000
      },
      
      "GearSet": {
        "Strategy": "Permanent",
        "PreloadOnStartup": true,
        "PreloadBatchSize": 100,
        "MaxCachedCount": 1000
      },
      
      // === ç”¨æˆ·æ•°æ®ï¼šä¸´æ—¶ç¼“å­˜ï¼ŒTTL æœºåˆ¶ ===
      
      "Character": {
        "Strategy": "Temporary",
        "TtlSeconds": 3600,
        "MaxCachedCount": 10000,
        "PreloadOnStartup": false
      },
      
      "GearInstance": {
        "Strategy": "Temporary",
        "TtlSeconds": 1800,
        "MaxCachedCount": 50000,
        "PreloadOnStartup": false
      },
      
      "ActivityPlan": {
        "Strategy": "Temporary",
        "TtlSeconds": 600,
        "MaxCachedCount": 20000,
        "PreloadOnStartup": false
      },
      
      "RunningBattleSnapshot": {
        "Strategy": "Temporary",
        "TtlSeconds": 300,
        "MaxCachedCount": 5000,
        "PreloadOnStartup": false
      }
    },
    
    "GlobalSettings": {
      "EnableReadCaching": true,
      "CleanupIntervalMinutes": 5,
      "TrackCacheHitRate": true,
      "HitRateLogIntervalMinutes": 10
    }
  }
}
```

#### 3.3 æ³¨å†Œé…ç½®

**æ–‡ä»¶**: `Infrastructure/DependencyInjection.cs` æˆ– `Program.cs`

```csharp
// æ³¨å†Œç¼“å­˜é…ç½®
services.Configure<CacheConfiguration>(
    configuration.GetSection("CacheConfiguration"));

// é…ç½®éªŒè¯
services.AddOptions<CacheConfiguration>()
    .Bind(configuration.GetSection("CacheConfiguration"))
    .ValidateDataAnnotations()
    .ValidateOnStart();
```

---

### Step 4: æ‰©å±•ç›‘æ§ï¼ˆ3-4å°æ—¶ï¼‰

#### 4.1 æ‰©å±• MonitoringOptions

**æ–‡ä»¶**: `Config/DatabaseOptimization/MonitoringOptions.cs`ï¼ˆæ‰©å±•ç°æœ‰æ–‡ä»¶ï¼‰

```csharp
/// <summary>
/// ç›‘æ§é…ç½®é€‰é¡¹ï¼ˆæ‰©å±•ç‰ˆï¼‰
/// Monitoring Configuration Options (Extended)
/// </summary>
public class MonitoringOptions
{
    // ... ç°æœ‰å­—æ®µ ...
    
    /// <summary>
    /// ç¼“å­˜ç›‘æ§é…ç½®
    /// Cache monitoring configuration
    /// </summary>
    public CacheMonitoringSettings CacheMonitoring { get; set; } 
        = new CacheMonitoringSettings();
}

/// <summary>
/// ç¼“å­˜ç›‘æ§é…ç½®
/// Cache Monitoring Configuration
/// </summary>
public class CacheMonitoringSettings
{
    /// <summary>
    /// æ˜¯å¦å¯ç”¨ç¼“å­˜æŒ‡æ ‡æ”¶é›†
    /// Enable cache metrics collection
    /// </summary>
    public bool EnableCacheMetrics { get; set; } = true;
    
    /// <summary>
    /// æ˜¯å¦è·Ÿè¸ªæ¯ä¸ªå®ä½“ç±»å‹çš„æŒ‡æ ‡
    /// Track per-entity metrics
    /// </summary>
    public bool TrackPerEntityMetrics { get; set; } = true;
    
    /// <summary>
    /// ç¼“å­˜æŒ‡æ ‡è®°å½•é—´éš”ï¼ˆç§’ï¼‰
    /// Cache metrics interval in seconds
    /// </summary>
    [Range(10, 600)]
    public int CacheMetricsIntervalSeconds { get; set; } = 60;
}
```

#### 4.2 æ‰©å±• DatabaseMetricsCollector

**æ–‡ä»¶**: `Infrastructure/DatabaseOptimization/DatabaseMetricsCollector.cs`

```csharp
// åœ¨ç±»ä¸­æ·»åŠ ï¼š

/// <summary>
/// ç¼“å­˜å‘½ä¸­è®°å½•
/// Cache hit records
/// </summary>
private readonly ConcurrentDictionary<string, CacheMetricsData> _cacheMetrics 
    = new ConcurrentDictionary<string, CacheMetricsData>();

/// <summary>
/// è®°å½•ç¼“å­˜å‘½ä¸­
/// Record cache hit
/// </summary>
public void RecordCacheHit(string entityType)
{
    if (!_options.CacheMonitoring.EnableCacheMetrics)
        return;
    
    var data = _cacheMetrics.GetOrAdd(entityType, _ => new CacheMetricsData());
    Interlocked.Increment(ref data.Hits);
}

/// <summary>
/// è®°å½•ç¼“å­˜æœªå‘½ä¸­
/// Record cache miss
/// </summary>
public void RecordCacheMiss(string entityType)
{
    if (!_options.CacheMonitoring.EnableCacheMetrics)
        return;
    
    var data = _cacheMetrics.GetOrAdd(entityType, _ => new CacheMetricsData());
    Interlocked.Increment(ref data.Misses);
}

/// <summary>
/// è®°å½•ç¼“å­˜å¤§å°
/// Record cache size
/// </summary>
public void RecordCacheSize(string entityType, int cachedCount, int dirtyCount)
{
    if (!_options.CacheMonitoring.EnableCacheMetrics)
        return;
    
    var data = _cacheMetrics.GetOrAdd(entityType, _ => new CacheMetricsData());
    data.CachedCount = cachedCount;
    data.DirtyCount = dirtyCount;
    data.LastUpdated = DateTime.UtcNow;
}

/// <summary>
/// è·å–ç¼“å­˜æŒ‡æ ‡
/// Get cache metrics
/// </summary>
public Dictionary<string, CacheMetricsSummary> GetCacheMetrics()
{
    return _cacheMetrics.ToDictionary(
        kvp => kvp.Key,
        kvp => new CacheMetricsSummary
        {
            EntityType = kvp.Key,
            Hits = kvp.Value.Hits,
            Misses = kvp.Value.Misses,
            HitRate = kvp.Value.GetHitRate(),
            CachedCount = kvp.Value.CachedCount,
            DirtyCount = kvp.Value.DirtyCount,
            LastUpdated = kvp.Value.LastUpdated
        }
    );
}

// å†…éƒ¨æ•°æ®ç±»
private class CacheMetricsData
{
    public long Hits = 0;
    public long Misses = 0;
    public int CachedCount = 0;
    public int DirtyCount = 0;
    public DateTime LastUpdated = DateTime.UtcNow;
    
    public double GetHitRate()
    {
        var total = Hits + Misses;
        return total > 0 ? (double)Hits / total : 0.0;
    }
}

/// <summary>
/// ç¼“å­˜æŒ‡æ ‡æ‘˜è¦
/// Cache Metrics Summary
/// </summary>
public class CacheMetricsSummary
{
    public string EntityType { get; set; } = string.Empty;
    public long Hits { get; set; }
    public long Misses { get; set; }
    public double HitRate { get; set; }
    public int CachedCount { get; set; }
    public int DirtyCount { get; set; }
    public DateTime LastUpdated { get; set; }
}
```

#### 4.3 æ·»åŠ ç¼“å­˜å¥åº·æ£€æŸ¥ç«¯ç‚¹

**æ–‡ä»¶**: `Api/DatabaseHealthController.cs`

```csharp
/// <summary>
/// è·å–ç¼“å­˜ç»Ÿè®¡ä¿¡æ¯
/// Get cache statistics
/// </summary>
/// <returns>ç¼“å­˜å‘½ä¸­ç‡ã€ç¼“å­˜å¤§å°ç­‰ç»Ÿè®¡ä¿¡æ¯</returns>
/// <response code="200">è¿”å›ç¼“å­˜ç»Ÿè®¡ä¿¡æ¯</response>
[HttpGet("cache-stats")]
[ProducesResponseType(typeof(CacheStatsResponse), StatusCodes.Status200OK)]
public ActionResult<CacheStatsResponse> GetCacheStats()
{
    try
    {
        var cacheMetrics = _metricsCollector?.GetCacheMetrics() 
            ?? new Dictionary<string, DatabaseMetricsCollector.CacheMetricsSummary>();
        
        return Ok(new CacheStatsResponse
        {
            Timestamp = DateTime.UtcNow,
            CacheEnabled = _configuration.GetValue<bool>(
                "CacheConfiguration:GlobalSettings:EnableReadCaching", true),
            EntityMetrics = cacheMetrics,
            OverallHitRate = CalculateOverallHitRate(cacheMetrics)
        });
    }
    catch (Exception ex)
    {
        _logger.LogError(ex, "è·å–ç¼“å­˜ç»Ÿè®¡ä¿¡æ¯å¤±è´¥");
        return StatusCode(500, new { error = "è·å–ç¼“å­˜ç»Ÿè®¡ä¿¡æ¯å¤±è´¥" });
    }
}

private double CalculateOverallHitRate(
    Dictionary<string, DatabaseMetricsCollector.CacheMetricsSummary> metrics)
{
    var totalHits = metrics.Values.Sum(m => m.Hits);
    var totalMisses = metrics.Values.Sum(m => m.Misses);
    var total = totalHits + totalMisses;
    
    return total > 0 ? (double)totalHits / total : 0.0;
}

/// <summary>
/// ç¼“å­˜ç»Ÿè®¡å“åº”
/// Cache Statistics Response
/// </summary>
public class CacheStatsResponse
{
    public DateTime Timestamp { get; set; }
    public bool CacheEnabled { get; set; }
    public Dictionary<string, DatabaseMetricsCollector.CacheMetricsSummary> EntityMetrics { get; set; } 
        = new Dictionary<string, DatabaseMetricsCollector.CacheMetricsSummary>();
    public double OverallHitRate { get; set; }
}
```

---

### Step 5: ä¾èµ–æ³¨å…¥é…ç½®ï¼ˆ1-2å°æ—¶ï¼‰

**æ–‡ä»¶**: `Infrastructure/DependencyInjection.cs` æˆ– `Program.cs`

```csharp
/// <summary>
/// æ³¨å†Œæ•°æ®åº“è¯»å–ç¼“å­˜æœåŠ¡
/// Register database read caching services
/// </summary>
public static IServiceCollection AddDatabaseReadCaching(
    this IServiceCollection services,
    IConfiguration configuration)
{
    // 1. æ³¨å†Œç¼“å­˜é…ç½®
    services.Configure<CacheConfiguration>(
        configuration.GetSection("CacheConfiguration"));
    
    services.AddOptions<CacheConfiguration>()
        .Bind(configuration.GetSection("CacheConfiguration"))
        .ValidateDataAnnotations()
        .ValidateOnStart();
    
    // 2. æ³¨å†Œ CacheCoordinatorï¼ˆä½œä¸º HostedServiceï¼‰
    services.AddSingleton<CacheCoordinator>();
    services.AddHostedService(sp => sp.GetRequiredService<CacheCoordinator>());
    
    // 3. ç¡®ä¿æ‰€æœ‰ MemoryStateManager å·²æ³¨å†Œ
    // ï¼ˆè¿™äº›åœ¨å†™å…¥ä¼˜åŒ–æ—¶å·²æ³¨å†Œï¼Œæ­¤å¤„ä»…ç¡®è®¤ï¼‰
    
    return services;
}

// åœ¨ Program.cs ä¸­è°ƒç”¨ï¼š
builder.Services.AddDatabaseReadCaching(builder.Configuration);
```

---

## æµ‹è¯•éªŒè¯

### ç¼–è¯‘æµ‹è¯•

```bash
# ç¼–è¯‘é¡¹ç›®
dotnet build BlazorIdle.Server/BlazorIdle.Server.csproj

# ç¡®ä¿é›¶é”™è¯¯
```

### å•å…ƒæµ‹è¯•

**åˆ›å»ºæµ‹è¯•æ–‡ä»¶**: `tests/BlazorIdle.Tests/DatabaseOptimization/`

#### æµ‹è¯• 1: MemoryStateManager ç¼“å­˜è¯»å–

```csharp
[Fact]
public async Task TryGetAsync_CacheHit_ReturnsFromMemory()
{
    // Arrange
    var manager = new MemoryStateManager<Character>(...);
    var character = new Character { Id = Guid.NewGuid(), Name = "TestChar" };
    manager.Add(character);
    
    // Act
    var result = await manager.TryGetAsync(
        character.Id,
        async (id, ct) => {
            // ä¸åº”è¯¥è¢«è°ƒç”¨
            Assert.Fail("Database loader should not be called on cache hit");
            return null;
        }
    );
    
    // Assert
    Assert.NotNull(result);
    Assert.Equal(character.Id, result.Id);
    Assert.Equal(1.0, manager.GetCacheHitRate()); // 100% å‘½ä¸­
}

[Fact]
public async Task TryGetAsync_CacheMiss_LoadsFromDatabase()
{
    // Arrange
    var manager = new MemoryStateManager<Character>(...);
    var character = new Character { Id = Guid.NewGuid(), Name = "TestChar" };
    var dbLoaderCalled = false;
    
    // Act
    var result = await manager.TryGetAsync(
        character.Id,
        async (id, ct) => {
            dbLoaderCalled = true;
            return character;
        }
    );
    
    // Assert
    Assert.True(dbLoaderCalled);
    Assert.NotNull(result);
    Assert.Equal(character.Id, result.Id);
    
    // ç¬¬äºŒæ¬¡æŸ¥è¯¢åº”è¯¥å‘½ä¸­ç¼“å­˜
    var result2 = await manager.TryGetAsync(
        character.Id,
        async (id, ct) => {
            Assert.Fail("Should hit cache on second call");
            return null;
        }
    );
    
    Assert.NotNull(result2);
    Assert.Equal(0.5, manager.GetCacheHitRate()); // 50% å‘½ä¸­ï¼ˆ1/2ï¼‰
}
```

#### æµ‹è¯• 2: CacheCoordinator é¢„åŠ è½½

```csharp
[Fact]
public async Task PreloadStaticDataAsync_LoadsGearDefinitions()
{
    // Arrange
    var coordinator = CreateCacheCoordinator();
    
    // Act
    await coordinator.PreloadStaticDataAsync(CancellationToken.None);
    
    // Assert
    var stats = _gearDefManager.GetCacheStatistics();
    Assert.True(stats.CachedCount > 0);
}
```

#### æµ‹è¯• 3: é…ç½®éªŒè¯

```csharp
[Fact]
public void CacheConfiguration_ValidConfig_Loads()
{
    // Arrange & Act
    var config = LoadConfigFromJson();
    
    // Assert
    Assert.True(config.GlobalSettings.EnableReadCaching);
    Assert.Contains("GearDefinition", config.EntityStrategies.Keys);
    Assert.Equal(CacheStrategyType.Permanent, 
        config.EntityStrategies["GearDefinition"].Strategy);
}
```

### é›†æˆæµ‹è¯•

```csharp
[Fact]
public async Task IntegrationTest_CacheCoordinator_PreloadsOnStartup()
{
    // åˆ›å»ºæµ‹è¯• Host
    var host = CreateTestHost();
    
    // å¯åŠ¨æœåŠ¡
    await host.StartAsync();
    
    // ç­‰å¾…é¢„åŠ è½½å®Œæˆ
    await Task.Delay(2000);
    
    // éªŒè¯
    var gearDefManager = host.Services.GetRequiredService<
        IMemoryStateManager<GearDefinition>>();
    
    var stats = gearDefManager.GetCacheStatistics();
    Assert.True(stats.CachedCount > 0);
    
    await host.StopAsync();
}
```

---

## éªŒæ”¶æ ‡å‡†

### åŠŸèƒ½å®Œæ•´æ€§

- [ ] MemoryStateManager æ·»åŠ  TryGetAsync æ–¹æ³•
- [ ] MemoryStateManager æ·»åŠ  PreloadBatch æ–¹æ³•
- [ ] MemoryStateManager æ·»åŠ ç¼“å­˜ç»Ÿè®¡æ–¹æ³•
- [ ] CacheCoordinator åˆ›å»ºå®Œæˆ
- [ ] CacheCoordinator å®ç°å¯åŠ¨æ—¶é¢„åŠ è½½
- [ ] CacheCoordinator å®ç°å®šæœŸæ¸…ç†
- [ ] é…ç½®ç³»ç»Ÿåˆ›å»ºå®Œæˆï¼ˆCacheConfiguration, EntityCacheStrategy, GlobalCacheSettingsï¼‰
- [ ] appsettings.json æ·»åŠ  CacheConfiguration èŠ‚
- [ ] DatabaseMetricsCollector æ‰©å±•ç¼“å­˜ç›‘æ§
- [ ] DatabaseHealthController æ·»åŠ  /api/database/cache-stats ç«¯ç‚¹
- [ ] æ‰€æœ‰æœåŠ¡æ­£ç¡®æ³¨å†Œ

### ä»£ç è´¨é‡

- [ ] ç¼–è¯‘æˆåŠŸï¼Œé›¶é”™è¯¯
- [ ] æ‰€æœ‰ä»£ç æœ‰è¯¦ç»†çš„ä¸­è‹±æ–‡æ³¨é‡Š
- [ ] éµå¾ªé¡¹ç›®å‘½åè§„èŒƒ
- [ ] éµå¾ª DDD æ¶æ„
- [ ] æ‰€æœ‰å…¬å¼€æ–¹æ³•æœ‰ XML æ–‡æ¡£æ³¨é‡Š

### é…ç½®åŒ–

- [ ] æ‰€æœ‰å‚æ•°åœ¨ appsettings.json
- [ ] ä½¿ç”¨ DataAnnotations éªŒè¯
- [ ] æä¾›åˆç†é»˜è®¤å€¼
- [ ] æ”¯æŒä¸åŒç¯å¢ƒçš„é…ç½®

### æµ‹è¯•è¦†ç›–

- [ ] MemoryStateManager ç¼“å­˜åŠŸèƒ½æµ‹è¯•ï¼ˆè‡³å°‘ 3 ä¸ªæµ‹è¯•ï¼‰
- [ ] CacheCoordinator é¢„åŠ è½½æµ‹è¯•ï¼ˆè‡³å°‘ 2 ä¸ªæµ‹è¯•ï¼‰
- [ ] é…ç½®åŠ è½½æµ‹è¯•ï¼ˆè‡³å°‘ 2 ä¸ªæµ‹è¯•ï¼‰
- [ ] æ‰€æœ‰æµ‹è¯•é€šè¿‡

### æ–‡æ¡£å®Œæ•´æ€§

- [ ] æœ¬å®æ–½æ–¹æ¡ˆæ–‡æ¡£
- [ ] ä»£ç æ³¨é‡Šå®Œæ•´
- [ ] README æ›´æ–°ï¼ˆå¦‚éœ€è¦ï¼‰

---

## åç»­æ­¥éª¤

å®Œæˆ Phase 1 åï¼Œè¿›å…¥ **ä¸­ç¯‡ - åˆ†é˜¶æ®µè¿ç§»è¯»å–æ“ä½œ**ã€‚

---

**é˜¶æ®µçŠ¶æ€**ï¼šâ³ å¾…å®æ–½  
**é¢„è®¡å®Œæˆæ—¶é—´**ï¼š3-4 å¤©  
**è´£ä»»äºº**ï¼šå¼€å‘å›¢é˜Ÿ  
**æœ€åæ›´æ–°**ï¼š2025-10-18
