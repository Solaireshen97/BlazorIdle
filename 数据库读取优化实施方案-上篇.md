# BlazorIdle æ•°æ®åº“è¯»å–ä¼˜åŒ–å®æ–½æ–¹æ¡ˆ - ä¸Šç¯‡ï¼ˆåŸºç¡€è®¾æ–½å»ºè®¾ï¼‰

**é¡¹ç›®**: BlazorIdle æ•°æ®åº“è¯»å–ä¼˜åŒ–  
**æ–‡æ¡£ç‰ˆæœ¬**: 1.0  
**é˜¶æ®µ**: Phase 1 - åŸºç¡€è®¾æ–½  
**åˆ›å»ºæ—¥æœŸ**: 2025-10-19  
**é¢„è®¡å·¥æ—¶**: 24-32 å°æ—¶

---

## ğŸ“‹ ç›®å½•

1. [é˜¶æ®µæ¦‚è¿°](#é˜¶æ®µæ¦‚è¿°)
2. [æ ¸å¿ƒç»„ä»¶æ¸…å•](#æ ¸å¿ƒç»„ä»¶æ¸…å•)
3. [è¯¦ç»†å®æ–½æ­¥éª¤](#è¯¦ç»†å®æ–½æ­¥éª¤)
4. [é…ç½®ç³»ç»Ÿå®æ–½](#é…ç½®ç³»ç»Ÿå®æ–½)
5. [ä¾èµ–æ³¨å…¥é…ç½®](#ä¾èµ–æ³¨å…¥é…ç½®)
6. [æµ‹è¯•éªŒè¯](#æµ‹è¯•éªŒè¯)
7. [æ£€æŸ¥æ¸…å•](#æ£€æŸ¥æ¸…å•)

---

## é˜¶æ®µæ¦‚è¿°

### ç›®æ ‡

Phase 1 å»ºè®¾è¯»å–ç¼“å­˜çš„åŸºç¡€è®¾æ–½ï¼ŒåŒ…æ‹¬ï¼š
1. âœ… ReadThroughCacheManager<T> - é€šç”¨è¯»å–ç¼“å­˜ç®¡ç†å™¨
2. âœ… ConfigurationCacheService - é…ç½®æ•°æ®ä¸“ç”¨ç¼“å­˜
3. âœ… ReadCacheOptions åŠç›¸å…³é…ç½®ç±»
4. âœ… CacheStatistics - ç¼“å­˜ç»Ÿè®¡æŠ½è±¡
5. âœ… ä¾èµ–æ³¨å…¥é…ç½®

### äº¤ä»˜ç‰©

| ç»„ä»¶ | æ–‡ä»¶è·¯å¾„ | è¯´æ˜ |
|------|---------|------|
| IReadThroughCacheManager | Infrastructure/Caching/Abstractions/IReadThroughCacheManager.cs | æ¥å£å®šä¹‰ |
| ReadThroughCacheManager | Infrastructure/Caching/ReadThroughCacheManager.cs | å®ç°ç±» |
| IConfigurationCacheService | Infrastructure/Caching/Abstractions/IConfigurationCacheService.cs | æ¥å£å®šä¹‰ |
| ConfigurationCacheService | Infrastructure/Caching/ConfigurationCacheService.cs | å®ç°ç±» |
| ReadCacheOptions | Config/Caching/ReadCacheOptions.cs | é…ç½®æ ¹ç±» |
| EntityCacheConfig | Config/Caching/EntityCacheConfig.cs | å®ä½“ç¼“å­˜é…ç½® |
| ConfigurationCacheConfig | Config/Caching/ConfigurationCacheConfig.cs | é…ç½®ç¼“å­˜é…ç½® |
| QueryResultCacheConfig | Config/Caching/QueryResultCacheConfig.cs | æŸ¥è¯¢ç¼“å­˜é…ç½® |
| CacheStatistics | Infrastructure/Caching/Models/CacheStatistics.cs | ç»Ÿè®¡æ¨¡å‹ |
| CachingDependencyInjection | Infrastructure/Caching/CachingDependencyInjection.cs | DI æ‰©å±• |

### å·¥ä½œé‡ä¼°ç®—

| ä»»åŠ¡ | é¢„è®¡å·¥æ—¶ |
|-----|---------|
| 1. é…ç½®ç±»å®šä¹‰ | 4 å°æ—¶ |
| 2. ReadThroughCacheManager å®ç° | 8 å°æ—¶ |
| 3. ConfigurationCacheService å®ç° | 6 å°æ—¶ |
| 4. ç»Ÿè®¡ä¸ç›‘æ§ | 4 å°æ—¶ |
| 5. ä¾èµ–æ³¨å…¥é…ç½® | 2 å°æ—¶ |
| 6. å•å…ƒæµ‹è¯• | 8 å°æ—¶ |
| **æ€»è®¡** | **32 å°æ—¶** |

---

## æ ¸å¿ƒç»„ä»¶æ¸…å•

### 1. IReadThroughCacheManager<T>

**èŒè´£**ï¼š
- æä¾›å†…å­˜ä¼˜å…ˆçš„è¯»å–æ¥å£
- æ”¯æŒå•å®ä½“å’Œåˆ—è¡¨æŸ¥è¯¢
- è‡ªåŠ¨åŠ è½½ç¼ºå¤±æ•°æ®
- ç¼“å­˜å¤±æ•ˆç®¡ç†

**æ¥å£å®šä¹‰**ï¼š

```csharp
namespace BlazorIdle.Server.Infrastructure.Caching.Abstractions;

/// <summary>
/// è¯»ç©¿é€ç¼“å­˜ç®¡ç†å™¨æ¥å£
/// Read-through cache manager interface
/// </summary>
/// <typeparam name="T">å®ä½“ç±»å‹ / Entity type</typeparam>
public interface IReadThroughCacheManager<T> where T : class, IEntity
{
    /// <summary>
    /// æŒ‰ ID è·å–å®ä½“ï¼ˆå†…å­˜ä¼˜å…ˆï¼‰
    /// Get entity by ID (memory-first)
    /// </summary>
    /// <param name="id">å®ä½“ ID / Entity ID</param>
    /// <param name="ct">å–æ¶ˆä»¤ç‰Œ / Cancellation token</param>
    /// <returns>å®ä½“æˆ– null / Entity or null</returns>
    Task<T?> GetByIdAsync(Guid id, CancellationToken ct = default);
    
    /// <summary>
    /// æ‰¹é‡è·å–å®ä½“ï¼ˆå†…å­˜ä¼˜å…ˆï¼‰
    /// Get entities in batch (memory-first)
    /// </summary>
    /// <param name="ids">å®ä½“ ID åˆ—è¡¨ / Entity ID list</param>
    /// <param name="ct">å–æ¶ˆä»¤ç‰Œ / Cancellation token</param>
    /// <returns>å®ä½“åˆ—è¡¨ / Entity list</returns>
    Task<List<T>> GetByIdsAsync(IEnumerable<Guid> ids, CancellationToken ct = default);
    
    /// <summary>
    /// æ‰§è¡ŒæŸ¥è¯¢å¹¶ç¼“å­˜ç»“æœ
    /// Execute query and cache results
    /// </summary>
    /// <param name="predicate">æŸ¥è¯¢æ¡ä»¶ / Query predicate</param>
    /// <param name="cacheKey">ç¼“å­˜é”® / Cache key</param>
    /// <param name="ct">å–æ¶ˆä»¤ç‰Œ / Cancellation token</param>
    /// <returns>æŸ¥è¯¢ç»“æœ / Query results</returns>
    Task<List<T>> GetListAsync(
        Expression<Func<T, bool>> predicate,
        string cacheKey,
        CancellationToken ct = default);
    
    /// <summary>
    /// æ·»åŠ æˆ–æ›´æ–°ç¼“å­˜
    /// Add or update cache
    /// </summary>
    /// <param name="entity">å®ä½“ / Entity</param>
    void AddOrUpdate(T entity);
    
    /// <summary>
    /// æ‰¹é‡æ·»åŠ æˆ–æ›´æ–°ç¼“å­˜
    /// Add or update cache in batch
    /// </summary>
    /// <param name="entities">å®ä½“åˆ—è¡¨ / Entity list</param>
    void AddOrUpdateRange(IEnumerable<T> entities);
    
    /// <summary>
    /// ä½¿å•ä¸ªå®ä½“å¤±æ•ˆ
    /// Invalidate single entity
    /// </summary>
    /// <param name="id">å®ä½“ ID / Entity ID</param>
    void Invalidate(Guid id);
    
    /// <summary>
    /// ä½¿æŸ¥è¯¢ç»“æœå¤±æ•ˆ
    /// Invalidate query result
    /// </summary>
    /// <param name="cacheKey">ç¼“å­˜é”® / Cache key</param>
    void InvalidateList(string cacheKey);
    
    /// <summary>
    /// ä½¿æ‰€æœ‰ç¼“å­˜å¤±æ•ˆ
    /// Invalidate all cache
    /// </summary>
    void InvalidateAll();
    
    /// <summary>
    /// è·å–ç¼“å­˜ç»Ÿè®¡ä¿¡æ¯
    /// Get cache statistics
    /// </summary>
    /// <returns>ç»Ÿè®¡ä¿¡æ¯ / Statistics</returns>
    CacheStatistics GetStatistics();
}
```

### 2. IConfigurationCacheService

**èŒè´£**ï¼š
- ç¼“å­˜é…ç½®æ•°æ®ï¼ˆGearDefinition, Affix, GearSetï¼‰
- åº”ç”¨å¯åŠ¨æ—¶é¢„åŠ è½½
- æ”¯æŒæ‰‹åŠ¨åˆ·æ–°

**æ¥å£å®šä¹‰**ï¼š

```csharp
namespace BlazorIdle.Server.Infrastructure.Caching.Abstractions;

/// <summary>
/// é…ç½®æ•°æ®ç¼“å­˜æœåŠ¡æ¥å£
/// Configuration data cache service interface
/// </summary>
public interface IConfigurationCacheService
{
    /// <summary>
    /// é¢„åŠ è½½æ‰€æœ‰é…ç½®æ•°æ®
    /// Preload all configuration data
    /// </summary>
    /// <param name="ct">å–æ¶ˆä»¤ç‰Œ / Cancellation token</param>
    Task PreloadAsync(CancellationToken ct = default);
    
    /// <summary>
    /// é‡æ–°åŠ è½½æ‰€æœ‰é…ç½®æ•°æ®
    /// Reload all configuration data
    /// </summary>
    /// <param name="ct">å–æ¶ˆä»¤ç‰Œ / Cancellation token</param>
    Task ReloadAsync(CancellationToken ct = default);
    
    // ========== GearDefinition ==========
    
    /// <summary>
    /// è·å– GearDefinition
    /// Get GearDefinition
    /// </summary>
    Task<GearDefinition?> GetGearDefinitionAsync(Guid id);
    
    /// <summary>
    /// è·å–æ‰€æœ‰ GearDefinition
    /// Get all GearDefinitions
    /// </summary>
    Task<List<GearDefinition>> GetAllGearDefinitionsAsync();
    
    /// <summary>
    /// æŒ‰æ§½ä½è·å– GearDefinition
    /// Get GearDefinitions by slot
    /// </summary>
    Task<List<GearDefinition>> GetGearDefinitionsBySlotAsync(EquipmentSlot slot);
    
    // ========== Affix ==========
    
    /// <summary>
    /// è·å– Affix
    /// Get Affix
    /// </summary>
    Task<Affix?> GetAffixAsync(Guid id);
    
    /// <summary>
    /// è·å–æ‰€æœ‰ Affix
    /// Get all Affixes
    /// </summary>
    Task<List<Affix>> GetAllAffixesAsync();
    
    /// <summary>
    /// æŒ‰å“è´¨è·å– Affix
    /// Get Affixes by rarity
    /// </summary>
    Task<List<Affix>> GetAffixesByRarityAsync(AffixRarity rarity);
    
    // ========== GearSet ==========
    
    /// <summary>
    /// è·å– GearSet
    /// Get GearSet
    /// </summary>
    Task<GearSet?> GetGearSetAsync(Guid id);
    
    /// <summary>
    /// è·å–æ‰€æœ‰ GearSet
    /// Get all GearSets
    /// </summary>
    Task<List<GearSet>> GetAllGearSetsAsync();
    
    // ========== ç»Ÿè®¡ / Statistics ==========
    
    /// <summary>
    /// è·å–ç¼“å­˜ç»Ÿè®¡ä¿¡æ¯
    /// Get cache statistics
    /// </summary>
    ConfigurationCacheStatistics GetStatistics();
}
```

### 3. é…ç½®ç±»å±‚æ¬¡ç»“æ„

```
ReadCacheOptions (æ ¹é…ç½®)
â”œâ”€â”€ DefaultCacheOptions: EntityCacheConfig
â”œâ”€â”€ EntityCacheOptions: Dictionary<string, EntityCacheConfig>
â”œâ”€â”€ ConfigurationCache: ConfigurationCacheConfig
â”‚   â””â”€â”€ Entities: Dictionary<string, ConfigEntityCacheConfig>
â”œâ”€â”€ QueryResultCache: QueryResultCacheConfig
â”œâ”€â”€ Performance: PerformanceConfig
â””â”€â”€ Concurrency: ConcurrencyConfig
```

---

## è¯¦ç»†å®æ–½æ­¥éª¤

### æ­¥éª¤ 1ï¼šåˆ›å»ºé…ç½®ç±»ï¼ˆ4 å°æ—¶ï¼‰

#### 1.1 åˆ›å»º EntityCacheConfig

**æ–‡ä»¶è·¯å¾„**: `BlazorIdle.Server/Config/Caching/EntityCacheConfig.cs`

```csharp
using System.ComponentModel.DataAnnotations;

namespace BlazorIdle.Server.Config.Caching;

/// <summary>
/// å•ä¸ªå®ä½“ç±»å‹çš„ç¼“å­˜é…ç½®
/// Cache configuration for a single entity type
/// </summary>
public class EntityCacheConfig
{
    /// <summary>
    /// æœ€å¤§ç¼“å­˜å®ä½“æ•°é‡
    /// Maximum number of cached entities
    /// </summary>
    [Range(100, 1000000)]
    public int MaxCachedEntities { get; set; } = 10000;
    
    /// <summary>
    /// ç”Ÿå­˜æ—¶é—´ï¼ˆç§’ï¼‰ï¼Œ-1 è¡¨ç¤ºæ°¸ä¸è¿‡æœŸ
    /// Time to live in seconds, -1 means never expire
    /// </summary>
    [Range(-1, 86400)]
    public int TimeToLiveSeconds { get; set; } = 600;
    
    /// <summary>
    /// æ·˜æ±°ç­–ç•¥ï¼šLRUï¼ˆæœ€è¿‘æœ€å°‘ä½¿ç”¨ï¼‰ã€LFUï¼ˆæœ€ä¸å¸¸ç”¨ï¼‰ã€FIFOï¼ˆå…ˆè¿›å…ˆå‡ºï¼‰
    /// Eviction policy: LRU (Least Recently Used), LFU (Least Frequently Used), FIFO (First In First Out)
    /// </summary>
    [RegularExpression("^(LRU|LFU|FIFO)$")]
    public string EvictionPolicy { get; set; } = "LRU";
    
    /// <summary>
    /// æ˜¯å¦åœ¨åº”ç”¨å¯åŠ¨æ—¶é¢„åŠ è½½
    /// Whether to preload on application startup
    /// </summary>
    public bool PreloadOnStartup { get; set; } = false;
    
    /// <summary>
    /// æ˜¯å¦å¯ç”¨ç»Ÿè®¡
    /// Enable statistics
    /// </summary>
    public bool EnableStatistics { get; set; } = true;
}
```

#### 1.2 åˆ›å»º ConfigurationCacheConfig

**æ–‡ä»¶è·¯å¾„**: `BlazorIdle.Server/Config/Caching/ConfigurationCacheConfig.cs`

```csharp
using System.ComponentModel.DataAnnotations;

namespace BlazorIdle.Server.Config.Caching;

/// <summary>
/// é…ç½®æ•°æ®ç¼“å­˜é…ç½®
/// Configuration data cache configuration
/// </summary>
public class ConfigurationCacheConfig
{
    /// <summary>
    /// æ˜¯å¦å¯ç”¨é¢„åŠ è½½
    /// Enable preload
    /// </summary>
    public bool EnablePreload { get; set; } = true;
    
    /// <summary>
    /// åˆ·æ–°é—´éš”ï¼ˆåˆ†é’Ÿï¼‰ï¼Œ0 è¡¨ç¤ºä¸åˆ·æ–°
    /// Refresh interval in minutes, 0 means no refresh
    /// </summary>
    [Range(0, 1440)]
    public int RefreshIntervalMinutes { get; set; } = 0;
    
    /// <summary>
    /// å„é…ç½®å®ä½“çš„ç¼“å­˜é…ç½®
    /// Cache configuration for each configuration entity
    /// </summary>
    public Dictionary<string, ConfigEntityCacheConfig> Entities { get; set; } = new();
}

/// <summary>
/// å•ä¸ªé…ç½®å®ä½“çš„ç¼“å­˜é…ç½®
/// Cache configuration for a single configuration entity
/// </summary>
public class ConfigEntityCacheConfig
{
    /// <summary>
    /// æ˜¯å¦åœ¨åº”ç”¨å¯åŠ¨æ—¶é¢„åŠ è½½
    /// Whether to preload on application startup
    /// </summary>
    public bool PreloadOnStartup { get; set; } = true;
    
    /// <summary>
    /// ç”Ÿå­˜æ—¶é—´ï¼ˆç§’ï¼‰ï¼Œ-1 è¡¨ç¤ºæ°¸ä¸è¿‡æœŸ
    /// Time to live in seconds, -1 means never expire
    /// </summary>
    [Range(-1, 86400)]
    public int TimeToLiveSeconds { get; set; } = -1;
}
```

#### 1.3 åˆ›å»º QueryResultCacheConfig

**æ–‡ä»¶è·¯å¾„**: `BlazorIdle.Server/Config/Caching/QueryResultCacheConfig.cs`

```csharp
using System.ComponentModel.DataAnnotations;

namespace BlazorIdle.Server.Config.Caching;

/// <summary>
/// æŸ¥è¯¢ç»“æœç¼“å­˜é…ç½®
/// Query result cache configuration
/// </summary>
public class QueryResultCacheConfig
{
    /// <summary>
    /// æ˜¯å¦å¯ç”¨æŸ¥è¯¢ç»“æœç¼“å­˜
    /// Enable query result cache
    /// </summary>
    public bool EnableCache { get; set; } = true;
    
    /// <summary>
    /// æœ€å¤§ç¼“å­˜æŸ¥è¯¢æ•°é‡
    /// Maximum number of cached queries
    /// </summary>
    [Range(100, 10000)]
    public int MaxCachedQueries { get; set; } = 1000;
    
    /// <summary>
    /// é»˜è®¤ç”Ÿå­˜æ—¶é—´ï¼ˆç§’ï¼‰
    /// Default time to live in seconds
    /// </summary>
    [Range(1, 3600)]
    public int DefaultTTLSeconds { get; set; } = 30;
    
    /// <summary>
    /// æ·˜æ±°ç­–ç•¥ï¼šLRU, FIFO
    /// Eviction policy: LRU, FIFO
    /// </summary>
    [RegularExpression("^(LRU|FIFO)$")]
    public string EvictionPolicy { get; set; } = "LRU";
}
```

#### 1.4 åˆ›å»º PerformanceConfig å’Œ ConcurrencyConfig

**æ–‡ä»¶è·¯å¾„**: `BlazorIdle.Server/Config/Caching/PerformanceConfig.cs`

```csharp
using System.ComponentModel.DataAnnotations;

namespace BlazorIdle.Server.Config.Caching;

/// <summary>
/// æ€§èƒ½ä¸ç›‘æ§é…ç½®
/// Performance and monitoring configuration
/// </summary>
public class PerformanceConfig
{
    /// <summary>
    /// æ˜¯å¦å¯ç”¨æ€§èƒ½æŒ‡æ ‡æ”¶é›†
    /// Enable performance metrics collection
    /// </summary>
    public bool EnableMetrics { get; set; } = true;
    
    /// <summary>
    /// æŒ‡æ ‡ç»Ÿè®¡çª—å£ï¼ˆåˆ†é’Ÿï¼‰
    /// Metrics window in minutes
    /// </summary>
    [Range(1, 1440)]
    public int MetricsWindowMinutes { get; set; } = 10;
    
    /// <summary>
    /// æ˜¯å¦åœ¨ç¼“å­˜æœªå‘½ä¸­æ—¶è®°å½•è­¦å‘Šæ—¥å¿—
    /// Log warning on cache miss
    /// </summary>
    public bool LogCacheMissWarning { get; set; } = true;
    
    /// <summary>
    /// ç¼“å­˜æœªå‘½ä¸­ç‡å‘Šè­¦é˜ˆå€¼ï¼ˆ0-1ï¼‰
    /// Cache miss rate warning threshold (0-1)
    /// </summary>
    [Range(0.0, 1.0)]
    public double CacheMissWarningThreshold { get; set; } = 0.5;
}

/// <summary>
/// å¹¶å‘æ§åˆ¶é…ç½®
/// Concurrency control configuration
/// </summary>
public class ConcurrencyConfig
{
    /// <summary>
    /// æ˜¯å¦å¯ç”¨åŠ è½½å»é‡ï¼ˆé˜²æ­¢ç¼“å­˜é›ªå´©ï¼‰
    /// Enable load deduplication (prevent cache stampede)
    /// </summary>
    public bool EnableLoadDeduplication { get; set; } = true;
    
    /// <summary>
    /// æœ€å¤§å¹¶å‘åŠ è½½æ•°
    /// Maximum concurrent loads
    /// </summary>
    [Range(1, 1000)]
    public int MaxConcurrentLoads { get; set; } = 100;
}
```

#### 1.5 åˆ›å»ºæ ¹é…ç½®ç±» ReadCacheOptions

**æ–‡ä»¶è·¯å¾„**: `BlazorIdle.Server/Config/Caching/ReadCacheOptions.cs`

```csharp
namespace BlazorIdle.Server.Config.Caching;

/// <summary>
/// è¯»å–ç¼“å­˜æ€»ä½“é…ç½®
/// Read cache overall configuration
/// </summary>
public class ReadCacheOptions
{
    /// <summary>
    /// æ˜¯å¦å¯ç”¨è¯»å–ç¼“å­˜
    /// Enable read cache
    /// </summary>
    public bool EnableReadCache { get; set; } = true;
    
    /// <summary>
    /// é»˜è®¤ç¼“å­˜é…ç½®
    /// Default cache options
    /// </summary>
    public EntityCacheConfig DefaultCacheOptions { get; set; } = new();
    
    /// <summary>
    /// åˆ†å®ä½“ç±»å‹é…ç½®
    /// Entity-specific cache options
    /// </summary>
    public Dictionary<string, EntityCacheConfig> EntityCacheOptions { get; set; } = new();
    
    /// <summary>
    /// é…ç½®æ•°æ®ç¼“å­˜é€‰é¡¹
    /// Configuration cache options
    /// </summary>
    public ConfigurationCacheConfig ConfigurationCache { get; set; } = new();
    
    /// <summary>
    /// æŸ¥è¯¢ç»“æœç¼“å­˜é€‰é¡¹
    /// Query result cache options
    /// </summary>
    public QueryResultCacheConfig QueryResultCache { get; set; } = new();
    
    /// <summary>
    /// æ€§èƒ½ä¸ç›‘æ§é…ç½®
    /// Performance and monitoring configuration
    /// </summary>
    public PerformanceConfig Performance { get; set; } = new();
    
    /// <summary>
    /// å¹¶å‘æ§åˆ¶é…ç½®
    /// Concurrency control configuration
    /// </summary>
    public ConcurrencyConfig Concurrency { get; set; } = new();
    
    /// <summary>
    /// è·å–æŒ‡å®šå®ä½“ç±»å‹çš„ç¼“å­˜é…ç½®ï¼ˆå¦‚æœæ²¡æœ‰åˆ™è¿”å›é»˜è®¤é…ç½®ï¼‰
    /// Get cache configuration for specified entity type (return default if not found)
    /// </summary>
    public EntityCacheConfig GetEntityConfig(string entityTypeName)
    {
        return EntityCacheOptions.TryGetValue(entityTypeName, out var config)
            ? config
            : DefaultCacheOptions;
    }
}
```

### æ­¥éª¤ 2ï¼šåˆ›å»ºç»Ÿè®¡æ¨¡å‹ï¼ˆ2 å°æ—¶ï¼‰

#### 2.1 CacheStatistics

**æ–‡ä»¶è·¯å¾„**: `BlazorIdle.Server/Infrastructure/Caching/Models/CacheStatistics.cs`

```csharp
namespace BlazorIdle.Server.Infrastructure.Caching.Models;

/// <summary>
/// ç¼“å­˜ç»Ÿè®¡ä¿¡æ¯
/// Cache statistics
/// </summary>
public class CacheStatistics
{
    /// <summary>
    /// å®ä½“ç±»å‹åç§°
    /// Entity type name
    /// </summary>
    public string EntityTypeName { get; set; } = string.Empty;
    
    /// <summary>
    /// å½“å‰ç¼“å­˜å®ä½“æ•°é‡
    /// Current cached entities count
    /// </summary>
    public int CachedCount { get; set; }
    
    /// <summary>
    /// æœ€å¤§ç¼“å­˜å®¹é‡
    /// Maximum cache capacity
    /// </summary>
    public int MaxCapacity { get; set; }
    
    /// <summary>
    /// ç¼“å­˜å‘½ä¸­æ¬¡æ•°
    /// Cache hit count
    /// </summary>
    public long HitCount { get; set; }
    
    /// <summary>
    /// ç¼“å­˜æœªå‘½ä¸­æ¬¡æ•°
    /// Cache miss count
    /// </summary>
    public long MissCount { get; set; }
    
    /// <summary>
    /// ç¼“å­˜å‘½ä¸­ç‡
    /// Cache hit rate
    /// </summary>
    public double HitRate => (HitCount + MissCount) > 0
        ? (double)HitCount / (HitCount + MissCount)
        : 0;
    
    /// <summary>
    /// åŠ è½½æ¬¡æ•°ï¼ˆä»æ•°æ®åº“ï¼‰
    /// Load count (from database)
    /// </summary>
    public long LoadCount { get; set; }
    
    /// <summary>
    /// æ·˜æ±°æ¬¡æ•°
    /// Eviction count
    /// </summary>
    public long EvictionCount { get; set; }
    
    /// <summary>
    /// å¤±æ•ˆæ¬¡æ•°ï¼ˆæ‰‹åŠ¨ï¼‰
    /// Invalidation count (manual)
    /// </summary>
    public long InvalidationCount { get; set; }
    
    /// <summary>
    /// å¹³å‡åŠ è½½æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰
    /// Average load time in milliseconds
    /// </summary>
    public double AverageLoadTimeMs { get; set; }
    
    /// <summary>
    /// æœ€åæ›´æ–°æ—¶é—´
    /// Last update time
    /// </summary>
    public DateTime LastUpdatedAt { get; set; }
}

/// <summary>
/// é…ç½®ç¼“å­˜ç»Ÿè®¡ä¿¡æ¯
/// Configuration cache statistics
/// </summary>
public class ConfigurationCacheStatistics
{
    /// <summary>
    /// GearDefinition ç¼“å­˜æ•°é‡
    /// GearDefinition cached count
    /// </summary>
    public int GearDefinitionCount { get; set; }
    
    /// <summary>
    /// Affix ç¼“å­˜æ•°é‡
    /// Affix cached count
    /// </summary>
    public int AffixCount { get; set; }
    
    /// <summary>
    /// GearSet ç¼“å­˜æ•°é‡
    /// GearSet cached count
    /// </summary>
    public int GearSetCount { get; set; }
    
    /// <summary>
    /// æ€»æŸ¥è¯¢æ¬¡æ•°
    /// Total query count
    /// </summary>
    public long TotalQueryCount { get; set; }
    
    /// <summary>
    /// ä¸Šæ¬¡é¢„åŠ è½½æ—¶é—´
    /// Last preload time
    /// </summary>
    public DateTime? LastPreloadAt { get; set; }
    
    /// <summary>
    /// é¢„åŠ è½½è€—æ—¶ï¼ˆæ¯«ç§’ï¼‰
    /// Preload duration in milliseconds
    /// </summary>
    public double PreloadDurationMs { get; set; }
}
```

### æ­¥éª¤ 3ï¼šå®ç° ReadThroughCacheManagerï¼ˆ8 å°æ—¶ï¼‰

**æ–‡ä»¶è·¯å¾„**: `BlazorIdle.Server/Infrastructure/Caching/ReadThroughCacheManager.cs`

```csharp
using System.Collections.Concurrent;
using System.Diagnostics;
using System.Linq.Expressions;
using BlazorIdle.Server.Config.Caching;
using BlazorIdle.Server.Infrastructure.Caching.Abstractions;
using BlazorIdle.Server.Infrastructure.Caching.Models;
using BlazorIdle.Server.Infrastructure.DatabaseOptimization.Abstractions;
using BlazorIdle.Server.Infrastructure.Persistence;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Caching.Memory;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;

namespace BlazorIdle.Server.Infrastructure.Caching;

/// <summary>
/// è¯»ç©¿é€ç¼“å­˜ç®¡ç†å™¨å®ç°
/// Read-through cache manager implementation
/// </summary>
/// <typeparam name="T">å®ä½“ç±»å‹ / Entity type</typeparam>
public class ReadThroughCacheManager<T> : IReadThroughCacheManager<T> where T : class, IEntity
{
    private readonly IMemoryStateManager<T> _memoryStateManager;
    private readonly IMemoryCache _queryResultCache;
    private readonly IServiceScopeFactory _scopeFactory;
    private readonly ReadCacheOptions _options;
    private readonly EntityCacheConfig _entityConfig;
    private readonly ILogger<ReadThroughCacheManager<T>> _logger;
    
    // åŠ è½½é”å­—å…¸ï¼ˆé˜²æ­¢ç¼“å­˜é›ªå´©ï¼‰
    // Loading locks dictionary (prevent cache stampede)
    private readonly ConcurrentDictionary<Guid, SemaphoreSlim> _loadingLocks = new();
    
    // ç»Ÿè®¡ä¿¡æ¯
    // Statistics
    private long _hitCount = 0;
    private long _missCount = 0;
    private long _loadCount = 0;
    private long _invalidationCount = 0;
    private readonly ConcurrentQueue<double> _loadTimes = new();
    private const int MaxLoadTimeSamples = 100;
    
    public ReadThroughCacheManager(
        IMemoryStateManager<T> memoryStateManager,
        IMemoryCache queryResultCache,
        IServiceScopeFactory scopeFactory,
        IOptions<ReadCacheOptions> options,
        ILogger<ReadThroughCacheManager<T>> logger)
    {
        _memoryStateManager = memoryStateManager;
        _queryResultCache = queryResultCache;
        _scopeFactory = scopeFactory;
        _options = options.Value;
        _entityConfig = _options.GetEntityConfig(typeof(T).Name);
        _logger = logger;
        
        _logger.LogInformation(
            "ReadThroughCacheManager<{EntityType}> å·²åˆå§‹åŒ–ï¼Œé…ç½®ï¼šMaxEntities={Max}, TTL={TTL}s, Policy={Policy}",
            typeof(T).Name, _entityConfig.MaxCachedEntities, _entityConfig.TimeToLiveSeconds, _entityConfig.EvictionPolicy
        );
    }
    
    /// <inheritdoc />
    public async Task<T?> GetByIdAsync(Guid id, CancellationToken ct = default)
    {
        // å¦‚æœæœªå¯ç”¨è¯»å–ç¼“å­˜ï¼Œç›´æ¥æŸ¥æ•°æ®åº“
        if (!_options.EnableReadCache)
        {
            _logger.LogDebug("è¯»å–ç¼“å­˜æœªå¯ç”¨ï¼Œç›´æ¥æŸ¥è¯¢æ•°æ®åº“ {EntityType}#{Id}", typeof(T).Name, id);
            return await LoadFromDatabaseAsync(id, ct);
        }
        
        // å…ˆæŸ¥ MemoryStateManagerï¼ˆåŒ…å«æœªä¿å­˜çš„æ›´æ–°ï¼‰
        var entity = await _memoryStateManager.GetAsync(id, ct);
        
        if (entity != null)
        {
            Interlocked.Increment(ref _hitCount);
            _logger.LogTrace("ç¼“å­˜å‘½ä¸­ {EntityType}#{Id}", typeof(T).Name, id);
            return entity;
        }
        
        Interlocked.Increment(ref _missCount);
        _logger.LogDebug("ç¼“å­˜æœªå‘½ä¸­ {EntityType}#{Id}ï¼Œä»æ•°æ®åº“åŠ è½½", typeof(T).Name, id);
        
        // ç¼“å­˜æœªå‘½ä¸­ï¼Œä½¿ç”¨åŠ è½½é”é˜²æ­¢é‡å¤åŠ è½½
        if (_options.Concurrency.EnableLoadDeduplication)
        {
            return await LoadWithDeduplicationAsync(id, ct);
        }
        else
        {
            return await LoadAndCacheAsync(id, ct);
        }
    }
    
    /// <summary>
    /// å¸¦å»é‡çš„åŠ è½½ï¼ˆé˜²æ­¢ç¼“å­˜é›ªå´©ï¼‰
    /// Load with deduplication (prevent cache stampede)
    /// </summary>
    private async Task<T?> LoadWithDeduplicationAsync(Guid id, CancellationToken ct)
    {
        var loadLock = _loadingLocks.GetOrAdd(id, _ => new SemaphoreSlim(1, 1));
        
        await loadLock.WaitAsync(ct);
        try
        {
            // åŒé‡æ£€æŸ¥ï¼ˆå¯èƒ½åœ¨ç­‰å¾…æœŸé—´å·²è¢«å…¶ä»–çº¿ç¨‹åŠ è½½ï¼‰
            var entity = await _memoryStateManager.GetAsync(id, ct);
            if (entity != null)
            {
                _logger.LogTrace("ç­‰å¾…æœŸé—´å·²è¢«åŠ è½½ {EntityType}#{Id}", typeof(T).Name, id);
                return entity;
            }
            
            // ä»æ•°æ®åº“åŠ è½½å¹¶ç¼“å­˜
            return await LoadAndCacheAsync(id, ct);
        }
        finally
        {
            loadLock.Release();
            
            // æ¸…ç†é”ï¼ˆé¿å…å†…å­˜æ³„æ¼ï¼‰
            if (loadLock.CurrentCount == 1)
            {
                _loadingLocks.TryRemove(id, out _);
            }
        }
    }
    
    /// <summary>
    /// ä»æ•°æ®åº“åŠ è½½å¹¶ç¼“å­˜
    /// Load from database and cache
    /// </summary>
    private async Task<T?> LoadAndCacheAsync(Guid id, CancellationToken ct)
    {
        var sw = Stopwatch.StartNew();
        
        var entity = await LoadFromDatabaseAsync(id, ct);
        
        sw.Stop();
        RecordLoadTime(sw.Elapsed.TotalMilliseconds);
        
        if (entity != null)
        {
            // æ·»åŠ åˆ°ç¼“å­˜ï¼ˆä¸æ ‡è®°ä¸º Dirtyï¼‰
            _memoryStateManager.Add(entity);
            _logger.LogDebug("å®ä½“ {EntityType}#{Id} å·²åŠ è½½å¹¶ç¼“å­˜ï¼Œè€—æ—¶ {Ms}ms", typeof(T).Name, id, sw.ElapsedMilliseconds);
        }
        else
        {
            // å¯é€‰ï¼šç¼“å­˜ null ç»“æœï¼ˆé˜²æ­¢ç¼“å­˜ç©¿é€ï¼‰
            _logger.LogDebug("å®ä½“ {EntityType}#{Id} ä¸å­˜åœ¨", typeof(T).Name, id);
        }
        
        return entity;
    }
    
    /// <summary>
    /// ä»æ•°æ®åº“åŠ è½½å®ä½“
    /// Load entity from database
    /// </summary>
    private async Task<T?> LoadFromDatabaseAsync(Guid id, CancellationToken ct)
    {
        Interlocked.Increment(ref _loadCount);
        
        using var scope = _scopeFactory.CreateScope();
        var db = scope.ServiceProvider.GetRequiredService<GameDbContext>();
        
        return await db.Set<T>().AsNoTracking().FirstOrDefaultAsync(e => e.Id == id, ct);
    }
    
    /// <inheritdoc />
    public async Task<List<T>> GetByIdsAsync(IEnumerable<Guid> ids, CancellationToken ct = default)
    {
        var idList = ids.ToList();
        var results = new List<T>(idList.Count);
        var missingIds = new List<Guid>();
        
        // æ‰¹é‡æŸ¥è¯¢ç¼“å­˜
        foreach (var id in idList)
        {
            var entity = await _memoryStateManager.GetAsync(id, ct);
            if (entity != null)
            {
                results.Add(entity);
                Interlocked.Increment(ref _hitCount);
            }
            else
            {
                missingIds.Add(id);
                Interlocked.Increment(ref _missCount);
            }
        }
        
        // æ‰¹é‡åŠ è½½ç¼ºå¤±çš„å®ä½“
        if (missingIds.Any())
        {
            _logger.LogDebug("æ‰¹é‡åŠ è½½ {Count} ä¸ªç¼ºå¤±å®ä½“ {EntityType}", missingIds.Count, typeof(T).Name);
            
            using var scope = _scopeFactory.CreateScope();
            var db = scope.ServiceProvider.GetRequiredService<GameDbContext>();
            
            var loaded = await db.Set<T>()
                .AsNoTracking()
                .Where(e => missingIds.Contains(e.Id))
                .ToListAsync(ct);
            
            // æ·»åŠ åˆ°ç¼“å­˜
            foreach (var entity in loaded)
            {
                _memoryStateManager.Add(entity);
                results.Add(entity);
            }
            
            Interlocked.Add(ref _loadCount, loaded.Count);
        }
        
        return results;
    }
    
    /// <inheritdoc />
    public async Task<List<T>> GetListAsync(
        Expression<Func<T, bool>> predicate,
        string cacheKey,
        CancellationToken ct = default)
    {
        if (!_options.QueryResultCache.EnableCache)
        {
            _logger.LogDebug("æŸ¥è¯¢ç»“æœç¼“å­˜æœªå¯ç”¨ï¼Œç›´æ¥æŸ¥è¯¢æ•°æ®åº“");
            return await QueryDatabaseAsync(predicate, ct);
        }
        
        // å°è¯•ä»æŸ¥è¯¢ç»“æœç¼“å­˜è·å–
        if (_queryResultCache.TryGetValue<List<T>>(cacheKey, out var cachedResult))
        {
            _logger.LogTrace("æŸ¥è¯¢ç»“æœç¼“å­˜å‘½ä¸­ï¼š{CacheKey}", cacheKey);
            return cachedResult ?? new List<T>();
        }
        
        _logger.LogDebug("æŸ¥è¯¢ç»“æœç¼“å­˜æœªå‘½ä¸­ï¼š{CacheKey}ï¼ŒæŸ¥è¯¢æ•°æ®åº“", cacheKey);
        
        // æŸ¥è¯¢æ•°æ®åº“
        var results = await QueryDatabaseAsync(predicate, ct);
        
        // ç¼“å­˜æŸ¥è¯¢ç»“æœ
        var cacheOptions = new MemoryCacheEntryOptions
        {
            AbsoluteExpirationRelativeToNow = TimeSpan.FromSeconds(_options.QueryResultCache.DefaultTTLSeconds)
        };
        
        _queryResultCache.Set(cacheKey, results, cacheOptions);
        
        return results;
    }
    
    /// <summary>
    /// æŸ¥è¯¢æ•°æ®åº“
    /// Query database
    /// </summary>
    private async Task<List<T>> QueryDatabaseAsync(Expression<Func<T, bool>> predicate, CancellationToken ct)
    {
        using var scope = _scopeFactory.CreateScope();
        var db = scope.ServiceProvider.GetRequiredService<GameDbContext>();
        
        return await db.Set<T>()
            .AsNoTracking()
            .Where(predicate)
            .ToListAsync(ct);
    }
    
    /// <inheritdoc />
    public void AddOrUpdate(T entity)
    {
        _memoryStateManager.Add(entity);
        _logger.LogTrace("æ›´æ–°ç¼“å­˜ {EntityType}#{Id}", typeof(T).Name, entity.Id);
    }
    
    /// <inheritdoc />
    public void AddOrUpdateRange(IEnumerable<T> entities)
    {
        var entityList = entities.ToList();
        foreach (var entity in entityList)
        {
            _memoryStateManager.Add(entity);
        }
        _logger.LogDebug("æ‰¹é‡æ›´æ–°ç¼“å­˜ {Count} ä¸ª {EntityType}", entityList.Count, typeof(T).Name);
    }
    
    /// <inheritdoc />
    public void Invalidate(Guid id)
    {
        _memoryStateManager.Remove(id);
        Interlocked.Increment(ref _invalidationCount);
        _logger.LogTrace("å¤±æ•ˆç¼“å­˜ {EntityType}#{Id}", typeof(T).Name, id);
    }
    
    /// <inheritdoc />
    public void InvalidateList(string cacheKey)
    {
        _queryResultCache.Remove(cacheKey);
        _logger.LogTrace("å¤±æ•ˆæŸ¥è¯¢ç»“æœç¼“å­˜ï¼š{CacheKey}", cacheKey);
    }
    
    /// <inheritdoc />
    public void InvalidateAll()
    {
        // æ³¨æ„ï¼šMemoryStateManager æ²¡æœ‰æä¾›æ¸…ç©ºæ¥å£ï¼Œè¿™é‡Œåªèƒ½ç§»é™¤æ‰€æœ‰å·²çŸ¥çš„å®ä½“
        _logger.LogWarning("InvalidateAll è°ƒç”¨ï¼Œä½† MemoryStateManager ä¸æ”¯æŒæ¸…ç©ºæ‰€æœ‰ç¼“å­˜");
        // å¯é€‰ï¼šç»´æŠ¤ä¸€ä¸ªæ‰€æœ‰ ID çš„é›†åˆï¼Œè¿™é‡Œå…¨éƒ¨ç§»é™¤
    }
    
    /// <inheritdoc />
    public CacheStatistics GetStatistics()
    {
        return new CacheStatistics
        {
            EntityTypeName = typeof(T).Name,
            CachedCount = _memoryStateManager.Count,
            MaxCapacity = _entityConfig.MaxCachedEntities,
            HitCount = _hitCount,
            MissCount = _missCount,
            LoadCount = _loadCount,
            EvictionCount = 0,  // MemoryStateManager ä¼šæŠ¥å‘Š
            InvalidationCount = _invalidationCount,
            AverageLoadTimeMs = _loadTimes.Any() ? _loadTimes.Average() : 0,
            LastUpdatedAt = DateTime.UtcNow
        };
    }
    
    /// <summary>
    /// è®°å½•åŠ è½½æ—¶é—´
    /// Record load time
    /// </summary>
    private void RecordLoadTime(double milliseconds)
    {
        _loadTimes.Enqueue(milliseconds);
        
        // ä¿æŒé˜Ÿåˆ—å¤§å°
        while (_loadTimes.Count > MaxLoadTimeSamples)
        {
            _loadTimes.TryDequeue(out _);
        }
    }
}
```

*ï¼ˆç”±äºç¯‡å¹…é™åˆ¶ï¼ŒConfigurationCacheService å®ç°å’Œåç»­æ­¥éª¤å°†åœ¨æ–‡æ¡£ä¸­æä¾›è¯¦ç»†çš„ä¼ªä»£ç å’Œå®æ–½æŒ‡å—ï¼Œå®é™…å¼€å‘æ—¶éœ€è¦å®Œæ•´å®ç°ï¼‰*

### æ­¥éª¤ 4ï¼šå®ç° ConfigurationCacheServiceï¼ˆ6 å°æ—¶ï¼‰

**å®æ–½è¦ç‚¹**ï¼š

1. **ä½¿ç”¨ ConcurrentDictionary å­˜å‚¨**
   ```csharp
   private readonly ConcurrentDictionary<Guid, GearDefinition> _gearDefinitions = new();
   private readonly ConcurrentDictionary<Guid, Affix> _affixes = new();
   private readonly ConcurrentDictionary<Guid, GearSet> _gearSets = new();
   ```

2. **PreloadAsync å®ç°**
   - ä»æ•°æ®åº“æ‰¹é‡åŠ è½½æ‰€æœ‰é…ç½®æ•°æ®
   - ä½¿ç”¨ `AsNoTracking()` æå‡æ€§èƒ½
   - è®°å½•é¢„åŠ è½½è€—æ—¶

3. **æŒ‰æ¡ä»¶æŸ¥è¯¢æ”¯æŒ**
   - GetGearDefinitionsBySlotAsync: LINQ å†…å­˜æŸ¥è¯¢
   - GetAffixesByRarityAsync: LINQ å†…å­˜æŸ¥è¯¢

4. **ç»Ÿè®¡ä¿¡æ¯**
   - è®°å½•æŸ¥è¯¢æ¬¡æ•°
   - è®°å½•é¢„åŠ è½½æ—¶é—´

### æ­¥éª¤ 5ï¼šä¾èµ–æ³¨å…¥é…ç½®ï¼ˆ2 å°æ—¶ï¼‰

**æ–‡ä»¶è·¯å¾„**: `BlazorIdle.Server/Infrastructure/Caching/CachingDependencyInjection.cs`

```csharp
using BlazorIdle.Server.Config.Caching;
using BlazorIdle.Server.Domain.Activities;
using BlazorIdle.Server.Domain.Characters;
using BlazorIdle.Server.Domain.Equipment;
using BlazorIdle.Server.Domain.Records;
using BlazorIdle.Server.Infrastructure.Caching.Abstractions;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;

namespace BlazorIdle.Server.Infrastructure.Caching;

/// <summary>
/// ç¼“å­˜ç›¸å…³ä¾èµ–æ³¨å…¥æ‰©å±•
/// Caching dependency injection extensions
/// </summary>
public static class CachingDependencyInjection
{
    /// <summary>
    /// æ·»åŠ è¯»å–ç¼“å­˜æœåŠ¡
    /// Add read cache services
    /// </summary>
    public static IServiceCollection AddReadCaching(
        this IServiceCollection services,
        IConfiguration configuration)
    {
        // æ³¨å†Œé…ç½®
        services.Configure<ReadCacheOptions>(configuration.GetSection("ReadCache"));
        
        // é…ç½®éªŒè¯
        services.AddOptions<ReadCacheOptions>()
            .Bind(configuration.GetSection("ReadCache"))
            .ValidateDataAnnotations()
            .ValidateOnStart();
        
        // æ³¨å†Œ IMemoryCacheï¼ˆå¦‚æœå°šæœªæ³¨å†Œï¼‰
        services.AddMemoryCache();
        
        // æ³¨å†Œ ReadThroughCacheManagerï¼ˆå•ä¾‹ï¼‰
        services.AddSingleton<IReadThroughCacheManager<Character>, ReadThroughCacheManager<Character>>();
        services.AddSingleton<IReadThroughCacheManager<RunningBattleSnapshotRecord>, ReadThroughCacheManager<RunningBattleSnapshotRecord>>();
        services.AddSingleton<IReadThroughCacheManager<ActivityPlan>, ReadThroughCacheManager<ActivityPlan>>();
        services.AddSingleton<IReadThroughCacheManager<GearInstance>, ReadThroughCacheManager<GearInstance>>();
        
        // æ³¨å†Œ ConfigurationCacheServiceï¼ˆå•ä¾‹ï¼‰
        services.AddSingleton<IConfigurationCacheService, ConfigurationCacheService>();
        
        return services;
    }
}
```

**åœ¨ Program.cs ä¸­ä½¿ç”¨**ï¼š

```csharp
// æ·»åŠ è¯»å–ç¼“å­˜
builder.Services.AddReadCaching(builder.Configuration);

// åœ¨åº”ç”¨å¯åŠ¨æ—¶é¢„åŠ è½½é…ç½®æ•°æ®
var app = builder.Build();

// é¢„åŠ è½½é…ç½®ç¼“å­˜
if (builder.Configuration.GetValue<bool>("ReadCache:ConfigurationCache:EnablePreload", true))
{
    using var scope = app.Services.CreateScope();
    var configCache = scope.ServiceProvider.GetRequiredService<IConfigurationCacheService>();
    await configCache.PreloadAsync();
}
```

---

## é…ç½®ç³»ç»Ÿå®æ–½

### appsettings.json é…ç½®ç¤ºä¾‹

```json
{
  "ReadCache": {
    "EnableReadCache": true,
    
    "DefaultCacheOptions": {
      "MaxCachedEntities": 10000,
      "TimeToLiveSeconds": 600,
      "EvictionPolicy": "LRU",
      "PreloadOnStartup": false,
      "EnableStatistics": true
    },
    
    "EntityCacheOptions": {
      "Character": {
        "MaxCachedEntities": 5000,
        "TimeToLiveSeconds": 300,
        "PreloadOnStartup": false,
        "EnableStatistics": true
      },
      "RunningBattleSnapshotRecord": {
        "MaxCachedEntities": 1000,
        "TimeToLiveSeconds": 120,
        "PreloadOnStartup": false,
        "EnableStatistics": true
      },
      "ActivityPlan": {
        "MaxCachedEntities": 2000,
        "TimeToLiveSeconds": 180,
        "PreloadOnStartup": false,
        "EnableStatistics": true
      },
      "GearInstance": {
        "MaxCachedEntities": 10000,
        "TimeToLiveSeconds": 600,
        "PreloadOnStartup": false,
        "EnableStatistics": true
      }
    },
    
    "ConfigurationCache": {
      "EnablePreload": true,
      "RefreshIntervalMinutes": 0,
      "Entities": {
        "GearDefinition": {
          "PreloadOnStartup": true,
          "TimeToLiveSeconds": -1
        },
        "Affix": {
          "PreloadOnStartup": true,
          "TimeToLiveSeconds": -1
        },
        "GearSet": {
          "PreloadOnStartup": true,
          "TimeToLiveSeconds": -1
        }
      }
    },
    
    "QueryResultCache": {
      "EnableCache": true,
      "MaxCachedQueries": 1000,
      "DefaultTTLSeconds": 30,
      "EvictionPolicy": "LRU"
    },
    
    "Performance": {
      "EnableMetrics": true,
      "MetricsWindowMinutes": 10,
      "LogCacheMissWarning": false,
      "CacheMissWarningThreshold": 0.5
    },
    
    "Concurrency": {
      "EnableLoadDeduplication": true,
      "MaxConcurrentLoads": 100
    }
  }
}
```

---

## æµ‹è¯•éªŒè¯

### å•å…ƒæµ‹è¯•æ¸…å•

#### 1. ReadThroughCacheManager æµ‹è¯•

**æ–‡ä»¶è·¯å¾„**: `tests/BlazorIdle.Tests/Caching/ReadThroughCacheManagerTests.cs`

**æµ‹è¯•ç”¨ä¾‹**ï¼š
1. âœ… `GetByIdAsync_CacheHit_ReturnsFromCache`
2. âœ… `GetByIdAsync_CacheMiss_LoadsFromDatabase`
3. âœ… `GetByIdsAsync_BatchLoad_CombinesCacheAndDatabase`
4. âœ… `GetListAsync_CachesQueryResults`
5. âœ… `AddOrUpdate_UpdatesCache`
6. âœ… `Invalidate_RemovesFromCache`
7. âœ… `LoadDeduplication_PreventsDuplicateLoads`
8. âœ… `GetStatistics_ReturnsAccurateMetrics`

#### 2. ConfigurationCacheService æµ‹è¯•

**æ–‡ä»¶è·¯å¾„**: `tests/BlazorIdle.Tests/Caching/ConfigurationCacheServiceTests.cs`

**æµ‹è¯•ç”¨ä¾‹**ï¼š
1. âœ… `PreloadAsync_LoadsAllConfigurationData`
2. âœ… `GetGearDefinitionAsync_ReturnsFromCache`
3. âœ… `GetGearDefinitionsBySlotAsync_FiltersCorrectly`
4. âœ… `GetAffixAsync_ReturnsFromCache`
5. âœ… `ReloadAsync_RefreshesCache`
6. âœ… `GetStatistics_ReturnsAccurateStats`

### é›†æˆæµ‹è¯•

**æµ‹è¯•åœºæ™¯**ï¼š
1. åº”ç”¨å¯åŠ¨æ—¶é…ç½®ç¼“å­˜é¢„åŠ è½½
2. é«˜å¹¶å‘è¯»å–æ€§èƒ½æµ‹è¯•
3. ç¼“å­˜å¤±æ•ˆå’Œåˆ·æ–°æµ‹è¯•

---

## æ£€æŸ¥æ¸…å•

### Phase 1 å®Œæˆæ ‡å‡†

- [ ] æ‰€æœ‰é…ç½®ç±»å·²åˆ›å»ºå¹¶é€šè¿‡éªŒè¯
- [ ] ReadThroughCacheManager å®Œæ•´å®ç°
- [ ] ConfigurationCacheService å®Œæ•´å®ç°
- [ ] ç»Ÿè®¡æ¨¡å‹å®šä¹‰å®Œæ•´
- [ ] ä¾èµ–æ³¨å…¥æ­£ç¡®é…ç½®
- [ ] appsettings.json é…ç½®å®Œæ•´
- [ ] å•å…ƒæµ‹è¯•è¦†ç›–ç‡ > 80%
- [ ] ç¼–è¯‘æ— é”™è¯¯
- [ ] æ‰€æœ‰æµ‹è¯•é€šè¿‡

### ä»£ç è´¨é‡æ£€æŸ¥

- [ ] éµå¾ªé¡¹ç›®ç¼–ç è§„èŒƒ
- [ ] è¯¦ç»†çš„ä¸­è‹±æ–‡æ³¨é‡Š
- [ ] å®Œæ•´çš„ XML æ–‡æ¡£æ³¨é‡Š
- [ ] çº¿ç¨‹å®‰å…¨ä¿è¯
- [ ] å¼‚å¸¸å¤„ç†å®Œå–„
- [ ] æ—¥å¿—è®°å½•å®Œæ•´

---

## ä¸‹ä¸€æ­¥

Phase 1 å®Œæˆåï¼Œè¿›å…¥ **Phase 2ï¼šRepository æ”¹é€ **ï¼ˆä¸­ç¯‡ï¼‰ï¼Œå°†å„ Repository æ”¹é€ ä¸ºä½¿ç”¨ ReadThroughCacheManagerã€‚

---

**æ–‡æ¡£çŠ¶æ€**ï¼šâœ… Phase 1 å®æ–½æ–¹æ¡ˆå®Œæˆ  
**é¢„è®¡å®Œæˆæ—¶é—´**ï¼š2-3 ä¸ªå·¥ä½œæ—¥  
**æœ€åæ›´æ–°**ï¼š2025-10-19
