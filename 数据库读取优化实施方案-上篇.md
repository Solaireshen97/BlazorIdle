# BlazorIdle 数据库读取优化实施方案 - 上篇（基础设施建设）

**项目**: BlazorIdle 数据库读取优化  
**文档版本**: 1.0  
**阶段**: Phase 1 - 基础设施  
**创建日期**: 2025-10-19  
**预计工时**: 24-32 小时

---

## 📋 目录

1. [阶段概述](#阶段概述)
2. [核心组件清单](#核心组件清单)
3. [详细实施步骤](#详细实施步骤)
4. [配置系统实施](#配置系统实施)
5. [依赖注入配置](#依赖注入配置)
6. [测试验证](#测试验证)
7. [检查清单](#检查清单)

---

## 阶段概述

### 目标

Phase 1 建设读取缓存的基础设施，包括：
1. ✅ ReadThroughCacheManager<T> - 通用读取缓存管理器
2. ✅ ConfigurationCacheService - 配置数据专用缓存
3. ✅ ReadCacheOptions 及相关配置类
4. ✅ CacheStatistics - 缓存统计抽象
5. ✅ 依赖注入配置

### 交付物

| 组件 | 文件路径 | 说明 |
|------|---------|------|
| IReadThroughCacheManager | Infrastructure/Caching/Abstractions/IReadThroughCacheManager.cs | 接口定义 |
| ReadThroughCacheManager | Infrastructure/Caching/ReadThroughCacheManager.cs | 实现类 |
| IConfigurationCacheService | Infrastructure/Caching/Abstractions/IConfigurationCacheService.cs | 接口定义 |
| ConfigurationCacheService | Infrastructure/Caching/ConfigurationCacheService.cs | 实现类 |
| ReadCacheOptions | Config/Caching/ReadCacheOptions.cs | 配置根类 |
| EntityCacheConfig | Config/Caching/EntityCacheConfig.cs | 实体缓存配置 |
| ConfigurationCacheConfig | Config/Caching/ConfigurationCacheConfig.cs | 配置缓存配置 |
| QueryResultCacheConfig | Config/Caching/QueryResultCacheConfig.cs | 查询缓存配置 |
| CacheStatistics | Infrastructure/Caching/Models/CacheStatistics.cs | 统计模型 |
| CachingDependencyInjection | Infrastructure/Caching/CachingDependencyInjection.cs | DI 扩展 |

### 工作量估算

| 任务 | 预计工时 |
|-----|---------|
| 1. 配置类定义 | 4 小时 |
| 2. ReadThroughCacheManager 实现 | 8 小时 |
| 3. ConfigurationCacheService 实现 | 6 小时 |
| 4. 统计与监控 | 4 小时 |
| 5. 依赖注入配置 | 2 小时 |
| 6. 单元测试 | 8 小时 |
| **总计** | **32 小时** |

---

## 核心组件清单

### 1. IReadThroughCacheManager<T>

**职责**：
- 提供内存优先的读取接口
- 支持单实体和列表查询
- 自动加载缺失数据
- 缓存失效管理

**接口定义**：

```csharp
namespace BlazorIdle.Server.Infrastructure.Caching.Abstractions;

/// <summary>
/// 读穿透缓存管理器接口
/// Read-through cache manager interface
/// </summary>
/// <typeparam name="T">实体类型 / Entity type</typeparam>
public interface IReadThroughCacheManager<T> where T : class, IEntity
{
    /// <summary>
    /// 按 ID 获取实体（内存优先）
    /// Get entity by ID (memory-first)
    /// </summary>
    /// <param name="id">实体 ID / Entity ID</param>
    /// <param name="ct">取消令牌 / Cancellation token</param>
    /// <returns>实体或 null / Entity or null</returns>
    Task<T?> GetByIdAsync(Guid id, CancellationToken ct = default);
    
    /// <summary>
    /// 批量获取实体（内存优先）
    /// Get entities in batch (memory-first)
    /// </summary>
    /// <param name="ids">实体 ID 列表 / Entity ID list</param>
    /// <param name="ct">取消令牌 / Cancellation token</param>
    /// <returns>实体列表 / Entity list</returns>
    Task<List<T>> GetByIdsAsync(IEnumerable<Guid> ids, CancellationToken ct = default);
    
    /// <summary>
    /// 执行查询并缓存结果
    /// Execute query and cache results
    /// </summary>
    /// <param name="predicate">查询条件 / Query predicate</param>
    /// <param name="cacheKey">缓存键 / Cache key</param>
    /// <param name="ct">取消令牌 / Cancellation token</param>
    /// <returns>查询结果 / Query results</returns>
    Task<List<T>> GetListAsync(
        Expression<Func<T, bool>> predicate,
        string cacheKey,
        CancellationToken ct = default);
    
    /// <summary>
    /// 添加或更新缓存
    /// Add or update cache
    /// </summary>
    /// <param name="entity">实体 / Entity</param>
    void AddOrUpdate(T entity);
    
    /// <summary>
    /// 批量添加或更新缓存
    /// Add or update cache in batch
    /// </summary>
    /// <param name="entities">实体列表 / Entity list</param>
    void AddOrUpdateRange(IEnumerable<T> entities);
    
    /// <summary>
    /// 使单个实体失效
    /// Invalidate single entity
    /// </summary>
    /// <param name="id">实体 ID / Entity ID</param>
    void Invalidate(Guid id);
    
    /// <summary>
    /// 使查询结果失效
    /// Invalidate query result
    /// </summary>
    /// <param name="cacheKey">缓存键 / Cache key</param>
    void InvalidateList(string cacheKey);
    
    /// <summary>
    /// 使所有缓存失效
    /// Invalidate all cache
    /// </summary>
    void InvalidateAll();
    
    /// <summary>
    /// 获取缓存统计信息
    /// Get cache statistics
    /// </summary>
    /// <returns>统计信息 / Statistics</returns>
    CacheStatistics GetStatistics();
}
```

### 2. IConfigurationCacheService

**职责**：
- 缓存配置数据（GearDefinition, Affix, GearSet）
- 应用启动时预加载
- 支持手动刷新

**接口定义**：

```csharp
namespace BlazorIdle.Server.Infrastructure.Caching.Abstractions;

/// <summary>
/// 配置数据缓存服务接口
/// Configuration data cache service interface
/// </summary>
public interface IConfigurationCacheService
{
    /// <summary>
    /// 预加载所有配置数据
    /// Preload all configuration data
    /// </summary>
    /// <param name="ct">取消令牌 / Cancellation token</param>
    Task PreloadAsync(CancellationToken ct = default);
    
    /// <summary>
    /// 重新加载所有配置数据
    /// Reload all configuration data
    /// </summary>
    /// <param name="ct">取消令牌 / Cancellation token</param>
    Task ReloadAsync(CancellationToken ct = default);
    
    // ========== GearDefinition ==========
    
    /// <summary>
    /// 获取 GearDefinition
    /// Get GearDefinition
    /// </summary>
    Task<GearDefinition?> GetGearDefinitionAsync(Guid id);
    
    /// <summary>
    /// 获取所有 GearDefinition
    /// Get all GearDefinitions
    /// </summary>
    Task<List<GearDefinition>> GetAllGearDefinitionsAsync();
    
    /// <summary>
    /// 按槽位获取 GearDefinition
    /// Get GearDefinitions by slot
    /// </summary>
    Task<List<GearDefinition>> GetGearDefinitionsBySlotAsync(EquipmentSlot slot);
    
    // ========== Affix ==========
    
    /// <summary>
    /// 获取 Affix
    /// Get Affix
    /// </summary>
    Task<Affix?> GetAffixAsync(Guid id);
    
    /// <summary>
    /// 获取所有 Affix
    /// Get all Affixes
    /// </summary>
    Task<List<Affix>> GetAllAffixesAsync();
    
    /// <summary>
    /// 按品质获取 Affix
    /// Get Affixes by rarity
    /// </summary>
    Task<List<Affix>> GetAffixesByRarityAsync(AffixRarity rarity);
    
    // ========== GearSet ==========
    
    /// <summary>
    /// 获取 GearSet
    /// Get GearSet
    /// </summary>
    Task<GearSet?> GetGearSetAsync(Guid id);
    
    /// <summary>
    /// 获取所有 GearSet
    /// Get all GearSets
    /// </summary>
    Task<List<GearSet>> GetAllGearSetsAsync();
    
    // ========== 统计 / Statistics ==========
    
    /// <summary>
    /// 获取缓存统计信息
    /// Get cache statistics
    /// </summary>
    ConfigurationCacheStatistics GetStatistics();
}
```

### 3. 配置类层次结构

```
ReadCacheOptions (根配置)
├── DefaultCacheOptions: EntityCacheConfig
├── EntityCacheOptions: Dictionary<string, EntityCacheConfig>
├── ConfigurationCache: ConfigurationCacheConfig
│   └── Entities: Dictionary<string, ConfigEntityCacheConfig>
├── QueryResultCache: QueryResultCacheConfig
├── Performance: PerformanceConfig
└── Concurrency: ConcurrencyConfig
```

---

## 详细实施步骤

### 步骤 1：创建配置类（4 小时）

#### 1.1 创建 EntityCacheConfig

**文件路径**: `BlazorIdle.Server/Config/Caching/EntityCacheConfig.cs`

```csharp
using System.ComponentModel.DataAnnotations;

namespace BlazorIdle.Server.Config.Caching;

/// <summary>
/// 单个实体类型的缓存配置
/// Cache configuration for a single entity type
/// </summary>
public class EntityCacheConfig
{
    /// <summary>
    /// 最大缓存实体数量
    /// Maximum number of cached entities
    /// </summary>
    [Range(100, 1000000)]
    public int MaxCachedEntities { get; set; } = 10000;
    
    /// <summary>
    /// 生存时间（秒），-1 表示永不过期
    /// Time to live in seconds, -1 means never expire
    /// </summary>
    [Range(-1, 86400)]
    public int TimeToLiveSeconds { get; set; } = 600;
    
    /// <summary>
    /// 淘汰策略：LRU（最近最少使用）、LFU（最不常用）、FIFO（先进先出）
    /// Eviction policy: LRU (Least Recently Used), LFU (Least Frequently Used), FIFO (First In First Out)
    /// </summary>
    [RegularExpression("^(LRU|LFU|FIFO)$")]
    public string EvictionPolicy { get; set; } = "LRU";
    
    /// <summary>
    /// 是否在应用启动时预加载
    /// Whether to preload on application startup
    /// </summary>
    public bool PreloadOnStartup { get; set; } = false;
    
    /// <summary>
    /// 是否启用统计
    /// Enable statistics
    /// </summary>
    public bool EnableStatistics { get; set; } = true;
}
```

#### 1.2 创建 ConfigurationCacheConfig

**文件路径**: `BlazorIdle.Server/Config/Caching/ConfigurationCacheConfig.cs`

```csharp
using System.ComponentModel.DataAnnotations;

namespace BlazorIdle.Server.Config.Caching;

/// <summary>
/// 配置数据缓存配置
/// Configuration data cache configuration
/// </summary>
public class ConfigurationCacheConfig
{
    /// <summary>
    /// 是否启用预加载
    /// Enable preload
    /// </summary>
    public bool EnablePreload { get; set; } = true;
    
    /// <summary>
    /// 刷新间隔（分钟），0 表示不刷新
    /// Refresh interval in minutes, 0 means no refresh
    /// </summary>
    [Range(0, 1440)]
    public int RefreshIntervalMinutes { get; set; } = 0;
    
    /// <summary>
    /// 各配置实体的缓存配置
    /// Cache configuration for each configuration entity
    /// </summary>
    public Dictionary<string, ConfigEntityCacheConfig> Entities { get; set; } = new();
}

/// <summary>
/// 单个配置实体的缓存配置
/// Cache configuration for a single configuration entity
/// </summary>
public class ConfigEntityCacheConfig
{
    /// <summary>
    /// 是否在应用启动时预加载
    /// Whether to preload on application startup
    /// </summary>
    public bool PreloadOnStartup { get; set; } = true;
    
    /// <summary>
    /// 生存时间（秒），-1 表示永不过期
    /// Time to live in seconds, -1 means never expire
    /// </summary>
    [Range(-1, 86400)]
    public int TimeToLiveSeconds { get; set; } = -1;
}
```

#### 1.3 创建 QueryResultCacheConfig

**文件路径**: `BlazorIdle.Server/Config/Caching/QueryResultCacheConfig.cs`

```csharp
using System.ComponentModel.DataAnnotations;

namespace BlazorIdle.Server.Config.Caching;

/// <summary>
/// 查询结果缓存配置
/// Query result cache configuration
/// </summary>
public class QueryResultCacheConfig
{
    /// <summary>
    /// 是否启用查询结果缓存
    /// Enable query result cache
    /// </summary>
    public bool EnableCache { get; set; } = true;
    
    /// <summary>
    /// 最大缓存查询数量
    /// Maximum number of cached queries
    /// </summary>
    [Range(100, 10000)]
    public int MaxCachedQueries { get; set; } = 1000;
    
    /// <summary>
    /// 默认生存时间（秒）
    /// Default time to live in seconds
    /// </summary>
    [Range(1, 3600)]
    public int DefaultTTLSeconds { get; set; } = 30;
    
    /// <summary>
    /// 淘汰策略：LRU, FIFO
    /// Eviction policy: LRU, FIFO
    /// </summary>
    [RegularExpression("^(LRU|FIFO)$")]
    public string EvictionPolicy { get; set; } = "LRU";
}
```

#### 1.4 创建 PerformanceConfig 和 ConcurrencyConfig

**文件路径**: `BlazorIdle.Server/Config/Caching/PerformanceConfig.cs`

```csharp
using System.ComponentModel.DataAnnotations;

namespace BlazorIdle.Server.Config.Caching;

/// <summary>
/// 性能与监控配置
/// Performance and monitoring configuration
/// </summary>
public class PerformanceConfig
{
    /// <summary>
    /// 是否启用性能指标收集
    /// Enable performance metrics collection
    /// </summary>
    public bool EnableMetrics { get; set; } = true;
    
    /// <summary>
    /// 指标统计窗口（分钟）
    /// Metrics window in minutes
    /// </summary>
    [Range(1, 1440)]
    public int MetricsWindowMinutes { get; set; } = 10;
    
    /// <summary>
    /// 是否在缓存未命中时记录警告日志
    /// Log warning on cache miss
    /// </summary>
    public bool LogCacheMissWarning { get; set; } = true;
    
    /// <summary>
    /// 缓存未命中率告警阈值（0-1）
    /// Cache miss rate warning threshold (0-1)
    /// </summary>
    [Range(0.0, 1.0)]
    public double CacheMissWarningThreshold { get; set; } = 0.5;
}

/// <summary>
/// 并发控制配置
/// Concurrency control configuration
/// </summary>
public class ConcurrencyConfig
{
    /// <summary>
    /// 是否启用加载去重（防止缓存雪崩）
    /// Enable load deduplication (prevent cache stampede)
    /// </summary>
    public bool EnableLoadDeduplication { get; set; } = true;
    
    /// <summary>
    /// 最大并发加载数
    /// Maximum concurrent loads
    /// </summary>
    [Range(1, 1000)]
    public int MaxConcurrentLoads { get; set; } = 100;
}
```

#### 1.5 创建根配置类 ReadCacheOptions

**文件路径**: `BlazorIdle.Server/Config/Caching/ReadCacheOptions.cs`

```csharp
namespace BlazorIdle.Server.Config.Caching;

/// <summary>
/// 读取缓存总体配置
/// Read cache overall configuration
/// </summary>
public class ReadCacheOptions
{
    /// <summary>
    /// 是否启用读取缓存
    /// Enable read cache
    /// </summary>
    public bool EnableReadCache { get; set; } = true;
    
    /// <summary>
    /// 默认缓存配置
    /// Default cache options
    /// </summary>
    public EntityCacheConfig DefaultCacheOptions { get; set; } = new();
    
    /// <summary>
    /// 分实体类型配置
    /// Entity-specific cache options
    /// </summary>
    public Dictionary<string, EntityCacheConfig> EntityCacheOptions { get; set; } = new();
    
    /// <summary>
    /// 配置数据缓存选项
    /// Configuration cache options
    /// </summary>
    public ConfigurationCacheConfig ConfigurationCache { get; set; } = new();
    
    /// <summary>
    /// 查询结果缓存选项
    /// Query result cache options
    /// </summary>
    public QueryResultCacheConfig QueryResultCache { get; set; } = new();
    
    /// <summary>
    /// 性能与监控配置
    /// Performance and monitoring configuration
    /// </summary>
    public PerformanceConfig Performance { get; set; } = new();
    
    /// <summary>
    /// 并发控制配置
    /// Concurrency control configuration
    /// </summary>
    public ConcurrencyConfig Concurrency { get; set; } = new();
    
    /// <summary>
    /// 获取指定实体类型的缓存配置（如果没有则返回默认配置）
    /// Get cache configuration for specified entity type (return default if not found)
    /// </summary>
    public EntityCacheConfig GetEntityConfig(string entityTypeName)
    {
        return EntityCacheOptions.TryGetValue(entityTypeName, out var config)
            ? config
            : DefaultCacheOptions;
    }
}
```

### 步骤 2：创建统计模型（2 小时）

#### 2.1 CacheStatistics

**文件路径**: `BlazorIdle.Server/Infrastructure/Caching/Models/CacheStatistics.cs`

```csharp
namespace BlazorIdle.Server.Infrastructure.Caching.Models;

/// <summary>
/// 缓存统计信息
/// Cache statistics
/// </summary>
public class CacheStatistics
{
    /// <summary>
    /// 实体类型名称
    /// Entity type name
    /// </summary>
    public string EntityTypeName { get; set; } = string.Empty;
    
    /// <summary>
    /// 当前缓存实体数量
    /// Current cached entities count
    /// </summary>
    public int CachedCount { get; set; }
    
    /// <summary>
    /// 最大缓存容量
    /// Maximum cache capacity
    /// </summary>
    public int MaxCapacity { get; set; }
    
    /// <summary>
    /// 缓存命中次数
    /// Cache hit count
    /// </summary>
    public long HitCount { get; set; }
    
    /// <summary>
    /// 缓存未命中次数
    /// Cache miss count
    /// </summary>
    public long MissCount { get; set; }
    
    /// <summary>
    /// 缓存命中率
    /// Cache hit rate
    /// </summary>
    public double HitRate => (HitCount + MissCount) > 0
        ? (double)HitCount / (HitCount + MissCount)
        : 0;
    
    /// <summary>
    /// 加载次数（从数据库）
    /// Load count (from database)
    /// </summary>
    public long LoadCount { get; set; }
    
    /// <summary>
    /// 淘汰次数
    /// Eviction count
    /// </summary>
    public long EvictionCount { get; set; }
    
    /// <summary>
    /// 失效次数（手动）
    /// Invalidation count (manual)
    /// </summary>
    public long InvalidationCount { get; set; }
    
    /// <summary>
    /// 平均加载时间（毫秒）
    /// Average load time in milliseconds
    /// </summary>
    public double AverageLoadTimeMs { get; set; }
    
    /// <summary>
    /// 最后更新时间
    /// Last update time
    /// </summary>
    public DateTime LastUpdatedAt { get; set; }
}

/// <summary>
/// 配置缓存统计信息
/// Configuration cache statistics
/// </summary>
public class ConfigurationCacheStatistics
{
    /// <summary>
    /// GearDefinition 缓存数量
    /// GearDefinition cached count
    /// </summary>
    public int GearDefinitionCount { get; set; }
    
    /// <summary>
    /// Affix 缓存数量
    /// Affix cached count
    /// </summary>
    public int AffixCount { get; set; }
    
    /// <summary>
    /// GearSet 缓存数量
    /// GearSet cached count
    /// </summary>
    public int GearSetCount { get; set; }
    
    /// <summary>
    /// 总查询次数
    /// Total query count
    /// </summary>
    public long TotalQueryCount { get; set; }
    
    /// <summary>
    /// 上次预加载时间
    /// Last preload time
    /// </summary>
    public DateTime? LastPreloadAt { get; set; }
    
    /// <summary>
    /// 预加载耗时（毫秒）
    /// Preload duration in milliseconds
    /// </summary>
    public double PreloadDurationMs { get; set; }
}
```

### 步骤 3：实现 ReadThroughCacheManager（8 小时）

**文件路径**: `BlazorIdle.Server/Infrastructure/Caching/ReadThroughCacheManager.cs`

```csharp
using System.Collections.Concurrent;
using System.Diagnostics;
using System.Linq.Expressions;
using BlazorIdle.Server.Config.Caching;
using BlazorIdle.Server.Infrastructure.Caching.Abstractions;
using BlazorIdle.Server.Infrastructure.Caching.Models;
using BlazorIdle.Server.Infrastructure.DatabaseOptimization.Abstractions;
using BlazorIdle.Server.Infrastructure.Persistence;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Caching.Memory;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;

namespace BlazorIdle.Server.Infrastructure.Caching;

/// <summary>
/// 读穿透缓存管理器实现
/// Read-through cache manager implementation
/// </summary>
/// <typeparam name="T">实体类型 / Entity type</typeparam>
public class ReadThroughCacheManager<T> : IReadThroughCacheManager<T> where T : class, IEntity
{
    private readonly IMemoryStateManager<T> _memoryStateManager;
    private readonly IMemoryCache _queryResultCache;
    private readonly IServiceScopeFactory _scopeFactory;
    private readonly ReadCacheOptions _options;
    private readonly EntityCacheConfig _entityConfig;
    private readonly ILogger<ReadThroughCacheManager<T>> _logger;
    
    // 加载锁字典（防止缓存雪崩）
    // Loading locks dictionary (prevent cache stampede)
    private readonly ConcurrentDictionary<Guid, SemaphoreSlim> _loadingLocks = new();
    
    // 统计信息
    // Statistics
    private long _hitCount = 0;
    private long _missCount = 0;
    private long _loadCount = 0;
    private long _invalidationCount = 0;
    private readonly ConcurrentQueue<double> _loadTimes = new();
    private const int MaxLoadTimeSamples = 100;
    
    public ReadThroughCacheManager(
        IMemoryStateManager<T> memoryStateManager,
        IMemoryCache queryResultCache,
        IServiceScopeFactory scopeFactory,
        IOptions<ReadCacheOptions> options,
        ILogger<ReadThroughCacheManager<T>> logger)
    {
        _memoryStateManager = memoryStateManager;
        _queryResultCache = queryResultCache;
        _scopeFactory = scopeFactory;
        _options = options.Value;
        _entityConfig = _options.GetEntityConfig(typeof(T).Name);
        _logger = logger;
        
        _logger.LogInformation(
            "ReadThroughCacheManager<{EntityType}> 已初始化，配置：MaxEntities={Max}, TTL={TTL}s, Policy={Policy}",
            typeof(T).Name, _entityConfig.MaxCachedEntities, _entityConfig.TimeToLiveSeconds, _entityConfig.EvictionPolicy
        );
    }
    
    /// <inheritdoc />
    public async Task<T?> GetByIdAsync(Guid id, CancellationToken ct = default)
    {
        // 如果未启用读取缓存，直接查数据库
        if (!_options.EnableReadCache)
        {
            _logger.LogDebug("读取缓存未启用，直接查询数据库 {EntityType}#{Id}", typeof(T).Name, id);
            return await LoadFromDatabaseAsync(id, ct);
        }
        
        // 先查 MemoryStateManager（包含未保存的更新）
        var entity = await _memoryStateManager.GetAsync(id, ct);
        
        if (entity != null)
        {
            Interlocked.Increment(ref _hitCount);
            _logger.LogTrace("缓存命中 {EntityType}#{Id}", typeof(T).Name, id);
            return entity;
        }
        
        Interlocked.Increment(ref _missCount);
        _logger.LogDebug("缓存未命中 {EntityType}#{Id}，从数据库加载", typeof(T).Name, id);
        
        // 缓存未命中，使用加载锁防止重复加载
        if (_options.Concurrency.EnableLoadDeduplication)
        {
            return await LoadWithDeduplicationAsync(id, ct);
        }
        else
        {
            return await LoadAndCacheAsync(id, ct);
        }
    }
    
    /// <summary>
    /// 带去重的加载（防止缓存雪崩）
    /// Load with deduplication (prevent cache stampede)
    /// </summary>
    private async Task<T?> LoadWithDeduplicationAsync(Guid id, CancellationToken ct)
    {
        var loadLock = _loadingLocks.GetOrAdd(id, _ => new SemaphoreSlim(1, 1));
        
        await loadLock.WaitAsync(ct);
        try
        {
            // 双重检查（可能在等待期间已被其他线程加载）
            var entity = await _memoryStateManager.GetAsync(id, ct);
            if (entity != null)
            {
                _logger.LogTrace("等待期间已被加载 {EntityType}#{Id}", typeof(T).Name, id);
                return entity;
            }
            
            // 从数据库加载并缓存
            return await LoadAndCacheAsync(id, ct);
        }
        finally
        {
            loadLock.Release();
            
            // 清理锁（避免内存泄漏）
            if (loadLock.CurrentCount == 1)
            {
                _loadingLocks.TryRemove(id, out _);
            }
        }
    }
    
    /// <summary>
    /// 从数据库加载并缓存
    /// Load from database and cache
    /// </summary>
    private async Task<T?> LoadAndCacheAsync(Guid id, CancellationToken ct)
    {
        var sw = Stopwatch.StartNew();
        
        var entity = await LoadFromDatabaseAsync(id, ct);
        
        sw.Stop();
        RecordLoadTime(sw.Elapsed.TotalMilliseconds);
        
        if (entity != null)
        {
            // 添加到缓存（不标记为 Dirty）
            _memoryStateManager.Add(entity);
            _logger.LogDebug("实体 {EntityType}#{Id} 已加载并缓存，耗时 {Ms}ms", typeof(T).Name, id, sw.ElapsedMilliseconds);
        }
        else
        {
            // 可选：缓存 null 结果（防止缓存穿透）
            _logger.LogDebug("实体 {EntityType}#{Id} 不存在", typeof(T).Name, id);
        }
        
        return entity;
    }
    
    /// <summary>
    /// 从数据库加载实体
    /// Load entity from database
    /// </summary>
    private async Task<T?> LoadFromDatabaseAsync(Guid id, CancellationToken ct)
    {
        Interlocked.Increment(ref _loadCount);
        
        using var scope = _scopeFactory.CreateScope();
        var db = scope.ServiceProvider.GetRequiredService<GameDbContext>();
        
        return await db.Set<T>().AsNoTracking().FirstOrDefaultAsync(e => e.Id == id, ct);
    }
    
    /// <inheritdoc />
    public async Task<List<T>> GetByIdsAsync(IEnumerable<Guid> ids, CancellationToken ct = default)
    {
        var idList = ids.ToList();
        var results = new List<T>(idList.Count);
        var missingIds = new List<Guid>();
        
        // 批量查询缓存
        foreach (var id in idList)
        {
            var entity = await _memoryStateManager.GetAsync(id, ct);
            if (entity != null)
            {
                results.Add(entity);
                Interlocked.Increment(ref _hitCount);
            }
            else
            {
                missingIds.Add(id);
                Interlocked.Increment(ref _missCount);
            }
        }
        
        // 批量加载缺失的实体
        if (missingIds.Any())
        {
            _logger.LogDebug("批量加载 {Count} 个缺失实体 {EntityType}", missingIds.Count, typeof(T).Name);
            
            using var scope = _scopeFactory.CreateScope();
            var db = scope.ServiceProvider.GetRequiredService<GameDbContext>();
            
            var loaded = await db.Set<T>()
                .AsNoTracking()
                .Where(e => missingIds.Contains(e.Id))
                .ToListAsync(ct);
            
            // 添加到缓存
            foreach (var entity in loaded)
            {
                _memoryStateManager.Add(entity);
                results.Add(entity);
            }
            
            Interlocked.Add(ref _loadCount, loaded.Count);
        }
        
        return results;
    }
    
    /// <inheritdoc />
    public async Task<List<T>> GetListAsync(
        Expression<Func<T, bool>> predicate,
        string cacheKey,
        CancellationToken ct = default)
    {
        if (!_options.QueryResultCache.EnableCache)
        {
            _logger.LogDebug("查询结果缓存未启用，直接查询数据库");
            return await QueryDatabaseAsync(predicate, ct);
        }
        
        // 尝试从查询结果缓存获取
        if (_queryResultCache.TryGetValue<List<T>>(cacheKey, out var cachedResult))
        {
            _logger.LogTrace("查询结果缓存命中：{CacheKey}", cacheKey);
            return cachedResult ?? new List<T>();
        }
        
        _logger.LogDebug("查询结果缓存未命中：{CacheKey}，查询数据库", cacheKey);
        
        // 查询数据库
        var results = await QueryDatabaseAsync(predicate, ct);
        
        // 缓存查询结果
        var cacheOptions = new MemoryCacheEntryOptions
        {
            AbsoluteExpirationRelativeToNow = TimeSpan.FromSeconds(_options.QueryResultCache.DefaultTTLSeconds)
        };
        
        _queryResultCache.Set(cacheKey, results, cacheOptions);
        
        return results;
    }
    
    /// <summary>
    /// 查询数据库
    /// Query database
    /// </summary>
    private async Task<List<T>> QueryDatabaseAsync(Expression<Func<T, bool>> predicate, CancellationToken ct)
    {
        using var scope = _scopeFactory.CreateScope();
        var db = scope.ServiceProvider.GetRequiredService<GameDbContext>();
        
        return await db.Set<T>()
            .AsNoTracking()
            .Where(predicate)
            .ToListAsync(ct);
    }
    
    /// <inheritdoc />
    public void AddOrUpdate(T entity)
    {
        _memoryStateManager.Add(entity);
        _logger.LogTrace("更新缓存 {EntityType}#{Id}", typeof(T).Name, entity.Id);
    }
    
    /// <inheritdoc />
    public void AddOrUpdateRange(IEnumerable<T> entities)
    {
        var entityList = entities.ToList();
        foreach (var entity in entityList)
        {
            _memoryStateManager.Add(entity);
        }
        _logger.LogDebug("批量更新缓存 {Count} 个 {EntityType}", entityList.Count, typeof(T).Name);
    }
    
    /// <inheritdoc />
    public void Invalidate(Guid id)
    {
        _memoryStateManager.Remove(id);
        Interlocked.Increment(ref _invalidationCount);
        _logger.LogTrace("失效缓存 {EntityType}#{Id}", typeof(T).Name, id);
    }
    
    /// <inheritdoc />
    public void InvalidateList(string cacheKey)
    {
        _queryResultCache.Remove(cacheKey);
        _logger.LogTrace("失效查询结果缓存：{CacheKey}", cacheKey);
    }
    
    /// <inheritdoc />
    public void InvalidateAll()
    {
        // 注意：MemoryStateManager 没有提供清空接口，这里只能移除所有已知的实体
        _logger.LogWarning("InvalidateAll 调用，但 MemoryStateManager 不支持清空所有缓存");
        // 可选：维护一个所有 ID 的集合，这里全部移除
    }
    
    /// <inheritdoc />
    public CacheStatistics GetStatistics()
    {
        return new CacheStatistics
        {
            EntityTypeName = typeof(T).Name,
            CachedCount = _memoryStateManager.Count,
            MaxCapacity = _entityConfig.MaxCachedEntities,
            HitCount = _hitCount,
            MissCount = _missCount,
            LoadCount = _loadCount,
            EvictionCount = 0,  // MemoryStateManager 会报告
            InvalidationCount = _invalidationCount,
            AverageLoadTimeMs = _loadTimes.Any() ? _loadTimes.Average() : 0,
            LastUpdatedAt = DateTime.UtcNow
        };
    }
    
    /// <summary>
    /// 记录加载时间
    /// Record load time
    /// </summary>
    private void RecordLoadTime(double milliseconds)
    {
        _loadTimes.Enqueue(milliseconds);
        
        // 保持队列大小
        while (_loadTimes.Count > MaxLoadTimeSamples)
        {
            _loadTimes.TryDequeue(out _);
        }
    }
}
```

*（由于篇幅限制，ConfigurationCacheService 实现和后续步骤将在文档中提供详细的伪代码和实施指南，实际开发时需要完整实现）*

### 步骤 4：实现 ConfigurationCacheService（6 小时）

**实施要点**：

1. **使用 ConcurrentDictionary 存储**
   ```csharp
   private readonly ConcurrentDictionary<Guid, GearDefinition> _gearDefinitions = new();
   private readonly ConcurrentDictionary<Guid, Affix> _affixes = new();
   private readonly ConcurrentDictionary<Guid, GearSet> _gearSets = new();
   ```

2. **PreloadAsync 实现**
   - 从数据库批量加载所有配置数据
   - 使用 `AsNoTracking()` 提升性能
   - 记录预加载耗时

3. **按条件查询支持**
   - GetGearDefinitionsBySlotAsync: LINQ 内存查询
   - GetAffixesByRarityAsync: LINQ 内存查询

4. **统计信息**
   - 记录查询次数
   - 记录预加载时间

### 步骤 5：依赖注入配置（2 小时）

**文件路径**: `BlazorIdle.Server/Infrastructure/Caching/CachingDependencyInjection.cs`

```csharp
using BlazorIdle.Server.Config.Caching;
using BlazorIdle.Server.Domain.Activities;
using BlazorIdle.Server.Domain.Characters;
using BlazorIdle.Server.Domain.Equipment;
using BlazorIdle.Server.Domain.Records;
using BlazorIdle.Server.Infrastructure.Caching.Abstractions;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;

namespace BlazorIdle.Server.Infrastructure.Caching;

/// <summary>
/// 缓存相关依赖注入扩展
/// Caching dependency injection extensions
/// </summary>
public static class CachingDependencyInjection
{
    /// <summary>
    /// 添加读取缓存服务
    /// Add read cache services
    /// </summary>
    public static IServiceCollection AddReadCaching(
        this IServiceCollection services,
        IConfiguration configuration)
    {
        // 注册配置
        services.Configure<ReadCacheOptions>(configuration.GetSection("ReadCache"));
        
        // 配置验证
        services.AddOptions<ReadCacheOptions>()
            .Bind(configuration.GetSection("ReadCache"))
            .ValidateDataAnnotations()
            .ValidateOnStart();
        
        // 注册 IMemoryCache（如果尚未注册）
        services.AddMemoryCache();
        
        // 注册 ReadThroughCacheManager（单例）
        services.AddSingleton<IReadThroughCacheManager<Character>, ReadThroughCacheManager<Character>>();
        services.AddSingleton<IReadThroughCacheManager<RunningBattleSnapshotRecord>, ReadThroughCacheManager<RunningBattleSnapshotRecord>>();
        services.AddSingleton<IReadThroughCacheManager<ActivityPlan>, ReadThroughCacheManager<ActivityPlan>>();
        services.AddSingleton<IReadThroughCacheManager<GearInstance>, ReadThroughCacheManager<GearInstance>>();
        
        // 注册 ConfigurationCacheService（单例）
        services.AddSingleton<IConfigurationCacheService, ConfigurationCacheService>();
        
        return services;
    }
}
```

**在 Program.cs 中使用**：

```csharp
// 添加读取缓存
builder.Services.AddReadCaching(builder.Configuration);

// 在应用启动时预加载配置数据
var app = builder.Build();

// 预加载配置缓存
if (builder.Configuration.GetValue<bool>("ReadCache:ConfigurationCache:EnablePreload", true))
{
    using var scope = app.Services.CreateScope();
    var configCache = scope.ServiceProvider.GetRequiredService<IConfigurationCacheService>();
    await configCache.PreloadAsync();
}
```

---

## 配置系统实施

### appsettings.json 配置示例

```json
{
  "ReadCache": {
    "EnableReadCache": true,
    
    "DefaultCacheOptions": {
      "MaxCachedEntities": 10000,
      "TimeToLiveSeconds": 600,
      "EvictionPolicy": "LRU",
      "PreloadOnStartup": false,
      "EnableStatistics": true
    },
    
    "EntityCacheOptions": {
      "Character": {
        "MaxCachedEntities": 5000,
        "TimeToLiveSeconds": 300,
        "PreloadOnStartup": false,
        "EnableStatistics": true
      },
      "RunningBattleSnapshotRecord": {
        "MaxCachedEntities": 1000,
        "TimeToLiveSeconds": 120,
        "PreloadOnStartup": false,
        "EnableStatistics": true
      },
      "ActivityPlan": {
        "MaxCachedEntities": 2000,
        "TimeToLiveSeconds": 180,
        "PreloadOnStartup": false,
        "EnableStatistics": true
      },
      "GearInstance": {
        "MaxCachedEntities": 10000,
        "TimeToLiveSeconds": 600,
        "PreloadOnStartup": false,
        "EnableStatistics": true
      }
    },
    
    "ConfigurationCache": {
      "EnablePreload": true,
      "RefreshIntervalMinutes": 0,
      "Entities": {
        "GearDefinition": {
          "PreloadOnStartup": true,
          "TimeToLiveSeconds": -1
        },
        "Affix": {
          "PreloadOnStartup": true,
          "TimeToLiveSeconds": -1
        },
        "GearSet": {
          "PreloadOnStartup": true,
          "TimeToLiveSeconds": -1
        }
      }
    },
    
    "QueryResultCache": {
      "EnableCache": true,
      "MaxCachedQueries": 1000,
      "DefaultTTLSeconds": 30,
      "EvictionPolicy": "LRU"
    },
    
    "Performance": {
      "EnableMetrics": true,
      "MetricsWindowMinutes": 10,
      "LogCacheMissWarning": false,
      "CacheMissWarningThreshold": 0.5
    },
    
    "Concurrency": {
      "EnableLoadDeduplication": true,
      "MaxConcurrentLoads": 100
    }
  }
}
```

---

## 测试验证

### 单元测试清单

#### 1. ReadThroughCacheManager 测试

**文件路径**: `tests/BlazorIdle.Tests/Caching/ReadThroughCacheManagerTests.cs`

**测试用例**：
1. ✅ `GetByIdAsync_CacheHit_ReturnsFromCache`
2. ✅ `GetByIdAsync_CacheMiss_LoadsFromDatabase`
3. ✅ `GetByIdsAsync_BatchLoad_CombinesCacheAndDatabase`
4. ✅ `GetListAsync_CachesQueryResults`
5. ✅ `AddOrUpdate_UpdatesCache`
6. ✅ `Invalidate_RemovesFromCache`
7. ✅ `LoadDeduplication_PreventsDuplicateLoads`
8. ✅ `GetStatistics_ReturnsAccurateMetrics`

#### 2. ConfigurationCacheService 测试

**文件路径**: `tests/BlazorIdle.Tests/Caching/ConfigurationCacheServiceTests.cs`

**测试用例**：
1. ✅ `PreloadAsync_LoadsAllConfigurationData`
2. ✅ `GetGearDefinitionAsync_ReturnsFromCache`
3. ✅ `GetGearDefinitionsBySlotAsync_FiltersCorrectly`
4. ✅ `GetAffixAsync_ReturnsFromCache`
5. ✅ `ReloadAsync_RefreshesCache`
6. ✅ `GetStatistics_ReturnsAccurateStats`

### 集成测试

**测试场景**：
1. 应用启动时配置缓存预加载
2. 高并发读取性能测试
3. 缓存失效和刷新测试

---

## 检查清单

### Phase 1 完成标准

- [ ] 所有配置类已创建并通过验证
- [ ] ReadThroughCacheManager 完整实现
- [ ] ConfigurationCacheService 完整实现
- [ ] 统计模型定义完整
- [ ] 依赖注入正确配置
- [ ] appsettings.json 配置完整
- [ ] 单元测试覆盖率 > 80%
- [ ] 编译无错误
- [ ] 所有测试通过

### 代码质量检查

- [ ] 遵循项目编码规范
- [ ] 详细的中英文注释
- [ ] 完整的 XML 文档注释
- [ ] 线程安全保证
- [ ] 异常处理完善
- [ ] 日志记录完整

---

## 下一步

Phase 1 完成后，进入 **Phase 2：Repository 改造**（中篇），将各 Repository 改造为使用 ReadThroughCacheManager。

---

**文档状态**：✅ Phase 1 实施方案完成  
**预计完成时间**：2-3 个工作日  
**最后更新**：2025-10-19
