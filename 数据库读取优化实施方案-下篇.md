# BlazorIdle 数据库读取优化实施方案 - 下篇

**阶段**: Phase 3 - 优化、监控和验收  
**文档版本**: 1.0  
**创建日期**: 2025-10-18  
**工作量估算**: 2-3 天  
**前置条件**: Phase 1-2 (上篇、中篇) 已完成

---

## 📋 目录

1. [阶段目标](#阶段目标)
2. [核心任务清单](#核心任务清单)
3. [性能调优](#性能调优)
4. [监控完善](#监控完善)
5. [管理接口](#管理接口)
6. [文档和验收](#文档和验收)
7. [生产部署指南](#生产部署指南)

---

## 阶段目标

### 主要目标

**完善缓存系统，提供生产就绪的监控和管理能力。**

具体目标：
1. ✅ 性能测试和调优
2. ✅ 完善监控指标和告警
3. ✅ 提供管理接口（手动刷新缓存、查看状态）
4. ✅ 编写完整文档
5. ✅ 生成验收报告

### 关键成果

1. **性能目标达成**：
   - 数据库读取减少 85-90%
   - API 响应时间改善 30-50%
   - 缓存命中率达标

2. **监控完善**：
   - 实时性能指标
   - 缓存健康状态
   - 告警机制

3. **可运维**：
   - 手动刷新缓存 API
   - 诊断工具
   - 运维文档

---

## 核心任务清单

### Task 1: 性能测试和调优（1天）

#### 1.1 基准测试
- [ ] 测试各实体类型的缓存命中率
- [ ] 测试 API 响应时间（P50, P95, P99）
- [ ] 测试内存使用情况
- [ ] 测试并发能力

#### 1.2 压力测试
- [ ] 100 个在线用户持续 1 小时
- [ ] 10 个并发战斗持续 30 分钟
- [ ] 内存泄漏检测
- [ ] GC 性能监控

#### 1.3 性能调优
- [ ] 根据测试结果调整配置参数
- [ ] 优化缓存清理策略
- [ ] 优化 LRU 算法
- [ ] 减少不必要的缓存

**工作量**：6-8 小时

---

### Task 2: 监控完善（0.5天）

#### 2.1 添加性能日志
- [ ] 定期输出缓存命中率
- [ ] 定期输出内存使用
- [ ] 定期输出清理统计
- [ ] 异常日志增强

#### 2.2 集成 Prometheus 指标（可选）
- [ ] CacheHitRate 指标
- [ ] CacheSize 指标
- [ ] DatabaseReadCount 指标
- [ ] ApiResponseTime 指标

#### 2.3 告警配置
- [ ] 缓存命中率低于阈值告警
- [ ] 内存使用超过阈值告警
- [ ] 数据库读取异常增多告警

**工作量**：3-4 小时

---

### Task 3: 管理接口（0.5天）

#### 3.1 缓存刷新 API
- [ ] POST /api/admin/cache/refresh/{entityType}
- [ ] POST /api/admin/cache/refresh-all
- [ ] 权限保护（Admin only）

#### 3.2 缓存诊断 API
- [ ] GET /api/admin/cache/diagnostics
- [ ] GET /api/admin/cache/entity/{entityType}
- [ ] 详细的缓存状态信息

#### 3.3 配置热更新 API（可选）
- [ ] POST /api/admin/cache/config/reload
- [ ] 动态调整 TTL、清理间隔等

**工作量**：3-4 小时

---

### Task 4: 文档和验收（0.5天）

#### 4.1 技术文档
- [ ] 缓存架构说明
- [ ] 配置参数详解
- [ ] 故障排查指南
- [ ] 性能调优指南

#### 4.2 运维文档
- [ ] 部署流程
- [ ] 监控指标说明
- [ ] 常见问题解答
- [ ] 回退流程

#### 4.3 验收文档
- [ ] 功能验收清单
- [ ] 性能验收报告
- [ ] 测试覆盖报告
- [ ] 最终验收报告

**工作量**：3-4 小时

---

## 性能测试和调优

### 基准测试方案

#### 测试环境

```
硬件配置：
- CPU: 4 核
- 内存: 8 GB
- 磁盘: SSD

软件配置：
- .NET 8.0
- SQLite 3
- 测试数据：500 个装备定义、100 个角色、1000 个装备实例
```

#### 测试脚本

**测试 1: 缓存命中率测试**

```csharp
[Fact]
public async Task CacheHitRate_BenchmarkTest()
{
    // 准备测试数据
    var characterIds = GenerateTestCharacterIds(100);
    
    // 预热：加载所有角色到缓存
    foreach (var id in characterIds)
    {
        await _characterRepo.GetAsync(id);
    }
    
    // 测试：1000 次随机查询
    var random = new Random();
    var hitCount = 0;
    var missCount = 0;
    
    for (int i = 0; i < 1000; i++)
    {
        var randomId = characterIds[random.Next(characterIds.Count)];
        var character = await _characterRepo.GetAsync(randomId);
        
        // 统计命中率
        var stats = _memoryManager.GetCacheStatistics();
        // ...
    }
    
    var hitRate = (double)hitCount / (hitCount + missCount);
    
    _logger.LogInformation("缓存命中率: {HitRate:P}", hitRate);
    Assert.True(hitRate >= 0.80, $"缓存命中率 {hitRate:P} 低于 80%");
}
```

**测试 2: API 响应时间测试**

```csharp
[Fact]
public async Task ApiResponseTime_BenchmarkTest()
{
    var characterId = Guid.NewGuid();
    
    // 预热
    await _characterRepo.GetAsync(characterId);
    
    // 测试 1000 次
    var durations = new List<long>();
    
    for (int i = 0; i < 1000; i++)
    {
        var sw = Stopwatch.StartNew();
        await _characterRepo.GetAsync(characterId);
        sw.Stop();
        
        durations.Add(sw.ElapsedMilliseconds);
    }
    
    // 统计
    var p50 = durations.OrderBy(x => x).ElementAt((int)(durations.Count * 0.5));
    var p95 = durations.OrderBy(x => x).ElementAt((int)(durations.Count * 0.95));
    var p99 = durations.OrderBy(x => x).ElementAt((int)(durations.Count * 0.99));
    
    _logger.LogInformation("响应时间 P50: {P50}ms, P95: {P95}ms, P99: {P99}ms",
        p50, p95, p99);
    
    Assert.True(p95 < 5, $"P95 响应时间 {p95}ms 超过 5ms");
}
```

**测试 3: 内存使用测试**

```csharp
[Fact]
public async Task MemoryUsage_BenchmarkTest()
{
    var initialMemory = GC.GetTotalMemory(true);
    
    // 加载大量数据到缓存
    for (int i = 0; i < 10000; i++)
    {
        var character = new Character { Id = Guid.NewGuid(), Name = $"Char{i}" };
        _memoryManager.Add(character);
    }
    
    var usedMemory = GC.GetTotalMemory(false) - initialMemory;
    var usedMemoryMB = usedMemory / 1024.0 / 1024.0;
    
    _logger.LogInformation("缓存 10000 个角色，内存使用: {MemoryMB:F2} MB", usedMemoryMB);
    
    Assert.True(usedMemoryMB < 50, $"内存使用 {usedMemoryMB:F2} MB 超过 50 MB");
}
```

### 压力测试方案

**测试场景 1: 高并发查询**

```csharp
[Fact]
public async Task HighConcurrency_StressTest()
{
    var characterIds = GenerateTestCharacterIds(100);
    var tasks = new List<Task>();
    
    // 100 个并发任务，每个任务查询 100 次
    for (int i = 0; i < 100; i++)
    {
        tasks.Add(Task.Run(async () =>
        {
            var random = new Random();
            for (int j = 0; j < 100; j++)
            {
                var id = characterIds[random.Next(characterIds.Count)];
                await _characterRepo.GetAsync(id);
            }
        }));
    }
    
    await Task.WhenAll(tasks);
    
    // 验证：无异常，缓存状态正常
    var stats = _memoryManager.GetCacheStatistics();
    Assert.True(stats.HitRate > 0.5);
}
```

**测试场景 2: 长时间运行**

```csharp
[Fact]
public async Task LongRunning_StressTest()
{
    var cts = new CancellationTokenSource(TimeSpan.FromMinutes(60));
    var queryCount = 0;
    
    while (!cts.Token.IsCancellationRequested)
    {
        // 模拟正常业务流量
        await SimulateUserActivityAsync();
        queryCount++;
        
        // 每 1000 次查询检查一次内存
        if (queryCount % 1000 == 0)
        {
            var memory = GC.GetTotalMemory(false);
            _logger.LogInformation("查询 {Count} 次，内存使用: {MemoryMB:F2} MB",
                queryCount, memory / 1024.0 / 1024.0);
        }
        
        await Task.Delay(100); // 模拟请求间隔
    }
    
    // 验证：内存无泄漏
    GC.Collect();
    var finalMemory = GC.GetTotalMemory(true);
    Assert.True(finalMemory < 500 * 1024 * 1024, "内存泄漏检测失败");
}
```

### 性能调优指南

#### 调优参数

| 参数 | 初始值 | 调优建议 | 说明 |
|-----|-------|---------|------|
| TtlSeconds (Character) | 3600 | 根据在线时长调整 | 活跃用户可延长至 7200 |
| TtlSeconds (GearInstance) | 1800 | 根据装备变更频率 | 很少变更可延长至 3600 |
| MaxCachedCount | 10000 | 根据实际用户数 | 避免频繁 LRU 清理 |
| CleanupIntervalMinutes | 5 | 根据过期速度 | 可延长至 10 减少开销 |

#### 调优步骤

1. **收集基准数据**
   ```bash
   # 启动监控
   curl http://localhost:5000/api/database/cache-stats
   
   # 记录初始指标
   - 缓存命中率
   - 内存使用
   - API 响应时间
   ```

2. **识别瓶颈**
   - 命中率低于 70%？→ 增加 TTL 或 MaxCachedCount
   - 内存使用过高？→ 减少 MaxCachedCount 或 TTL
   - LRU 清理频繁？→ 增加 MaxCachedCount

3. **调整参数**
   ```json
   {
     "CacheConfiguration": {
       "EntityStrategies": {
         "Character": {
           "TtlSeconds": 7200,  // 从 3600 增加到 7200
           "MaxCachedCount": 20000  // 从 10000 增加到 20000
         }
       }
     }
   }
   ```

4. **重新测试**
   - 重启服务
   - 运行相同的测试
   - 对比指标改善

5. **迭代优化**
   - 重复步骤 2-4
   - 直到达到性能目标

---

## 监控完善

### 性能日志增强

#### 定期日志输出

**在 CacheCoordinator 中添加**：

```csharp
/// <summary>
/// 定期输出缓存统计信息
/// Periodic cache statistics logging
/// </summary>
private async Task LogCacheStatisticsAsync(CancellationToken ct)
{
    var interval = TimeSpan.FromMinutes(
        _cacheConfig.Value.GlobalSettings.HitRateLogIntervalMinutes);
    
    while (!ct.IsCancellationRequested)
    {
        try
        {
            await Task.Delay(interval, ct);
            
            _logger.LogInformation("=== 缓存统计报告 ===");
            
            // 输出各实体类型的统计
            LogEntityStatistics("GearDefinition", _gearDefManager);
            LogEntityStatistics("Affix", _affixManager);
            LogEntityStatistics("Character", _characterManager);
            LogEntityStatistics("GearInstance", _gearInstanceManager);
            LogEntityStatistics("ActivityPlan", _activityPlanManager);
            
            _logger.LogInformation("==================");
        }
        catch (OperationCanceledException)
        {
            break;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "输出缓存统计信息失败");
        }
    }
}

private void LogEntityStatistics<T>(
    string entityType,
    IMemoryStateManager<T>? manager) where T : class, IEntity
{
    if (manager == null)
        return;
    
    var stats = manager.GetCacheStatistics();
    
    _logger.LogInformation(
        "{EntityType}: 缓存 {CachedCount} 个, Dirty {DirtyCount} 个, " +
        "命中 {Hits} 次, 未命中 {Misses} 次, 命中率 {HitRate:P}",
        entityType, stats.CachedCount, stats.DirtyCount,
        stats.CacheHits, stats.CacheMisses, stats.HitRate
    );
}
```

#### 异常日志增强

```csharp
// 在 MemoryStateManager.TryGetAsync 中
try
{
    // ... 查询逻辑
}
catch (Exception ex)
{
    _logger.LogError(ex, 
        "缓存读取失败: EntityType={EntityType}, Id={Id}",
        typeof(T).Name, id);
    
    // 降级：直接查数据库
    return await databaseLoader(id, ct);
}
```

### Prometheus 集成（可选）

如果项目使用 Prometheus 监控，可以添加自定义指标：

```csharp
/// <summary>
/// Prometheus 指标收集器
/// </summary>
public class CachePrometheusMetrics
{
    private readonly Counter _cacheHits;
    private readonly Counter _cacheMisses;
    private readonly Gauge _cacheSize;
    private readonly Gauge _dirtySize;
    
    public CachePrometheusMetrics()
    {
        _cacheHits = Metrics.CreateCounter(
            "blazoridle_cache_hits_total",
            "Total number of cache hits",
            new CounterConfiguration { LabelNames = new[] { "entity_type" } }
        );
        
        _cacheMisses = Metrics.CreateCounter(
            "blazoridle_cache_misses_total",
            "Total number of cache misses",
            new CounterConfiguration { LabelNames = new[] { "entity_type" } }
        );
        
        _cacheSize = Metrics.CreateGauge(
            "blazoridle_cache_size",
            "Number of cached entities",
            new GaugeConfiguration { LabelNames = new[] { "entity_type" } }
        );
        
        _dirtySize = Metrics.CreateGauge(
            "blazoridle_cache_dirty_size",
            "Number of dirty entities",
            new GaugeConfiguration { LabelNames = new[] { "entity_type" } }
        );
    }
    
    public void RecordHit(string entityType) => _cacheHits.WithLabels(entityType).Inc();
    public void RecordMiss(string entityType) => _cacheMisses.WithLabels(entityType).Inc();
    public void UpdateCacheSize(string entityType, int count) 
        => _cacheSize.WithLabels(entityType).Set(count);
    public void UpdateDirtySize(string entityType, int count) 
        => _dirtySize.WithLabels(entityType).Set(count);
}
```

### 告警配置

**告警规则**（基于日志或 Prometheus）：

```yaml
# Prometheus 告警规则示例
groups:
  - name: blazoridle_cache_alerts
    rules:
      - alert: CacheHitRateLow
        expr: |
          (
            sum(rate(blazoridle_cache_hits_total[5m])) by (entity_type) /
            (
              sum(rate(blazoridle_cache_hits_total[5m])) by (entity_type) +
              sum(rate(blazoridle_cache_misses_total[5m])) by (entity_type)
            )
          ) < 0.7
        for: 10m
        labels:
          severity: warning
        annotations:
          summary: "缓存命中率低于 70%"
          description: "实体类型 {{ $labels.entity_type }} 的缓存命中率为 {{ $value | humanizePercentage }}"
      
      - alert: CacheSizeHigh
        expr: blazoridle_cache_size > 50000
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "缓存大小过大"
          description: "实体类型 {{ $labels.entity_type }} 的缓存数量为 {{ $value }}"
```

---

## 管理接口

### 缓存刷新 API

**文件**：`Api/Admin/CacheAdminController.cs`

```csharp
/// <summary>
/// 缓存管理 API 控制器
/// Cache Administration API Controller
/// 
/// 提供缓存管理功能：
/// - 刷新特定实体类型的缓存
/// - 刷新所有缓存
/// - 查看缓存诊断信息
/// 
/// 需要管理员权限
/// </summary>
[ApiController]
[Route("api/admin/cache")]
[Authorize(Roles = "Admin")] // 需要管理员权限
public class CacheAdminController : ControllerBase
{
    private readonly CacheCoordinator _cacheCoordinator;
    private readonly ILogger<CacheAdminController> _logger;
    
    public CacheAdminController(
        CacheCoordinator cacheCoordinator,
        ILogger<CacheAdminController> logger)
    {
        _cacheCoordinator = cacheCoordinator;
        _logger = logger;
    }
    
    /// <summary>
    /// 刷新特定实体类型的缓存
    /// Refresh cache for a specific entity type
    /// </summary>
    /// <param name="entityType">实体类型名称（如 "GearDefinition", "Character"）</param>
    /// <returns>刷新结果</returns>
    /// <response code="200">刷新成功</response>
    /// <response code="400">实体类型不支持</response>
    /// <response code="401">未授权</response>
    [HttpPost("refresh/{entityType}")]
    [ProducesResponseType(typeof(CacheRefreshResponse), StatusCodes.Status200OK)]
    [ProducesResponseType(StatusCodes.Status400BadRequest)]
    public async Task<ActionResult<CacheRefreshResponse>> RefreshCache(string entityType)
    {
        try
        {
            _logger.LogInformation(
                "管理员 {Admin} 请求刷新 {EntityType} 缓存",
                User.Identity?.Name, entityType
            );
            
            var result = await _cacheCoordinator.RefreshCacheAsync(entityType);
            
            if (!result.Success)
            {
                return BadRequest(new { error = result.ErrorMessage });
            }
            
            return Ok(new CacheRefreshResponse
            {
                EntityType = entityType,
                RefreshedCount = result.RefreshedCount,
                Message = $"已刷新 {entityType} 缓存，共 {result.RefreshedCount} 个实体"
            });
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "刷新缓存失败: {EntityType}", entityType);
            return StatusCode(500, new { error = "刷新缓存失败" });
        }
    }
    
    /// <summary>
    /// 刷新所有缓存
    /// Refresh all caches
    /// </summary>
    /// <returns>刷新结果</returns>
    /// <response code="200">刷新成功</response>
    /// <response code="401">未授权</response>
    [HttpPost("refresh-all")]
    [ProducesResponseType(typeof(CacheRefreshAllResponse), StatusCodes.Status200OK)]
    public async Task<ActionResult<CacheRefreshAllResponse>> RefreshAllCaches()
    {
        try
        {
            _logger.LogWarning(
                "管理员 {Admin} 请求刷新所有缓存",
                User.Identity?.Name
            );
            
            var results = await _cacheCoordinator.RefreshAllCachesAsync();
            
            return Ok(new CacheRefreshAllResponse
            {
                TotalRefreshed = results.Sum(r => r.RefreshedCount),
                EntityResults = results.ToDictionary(r => r.EntityType, r => r.RefreshedCount),
                Message = $"已刷新所有缓存，共 {results.Sum(r => r.RefreshedCount)} 个实体"
            });
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "刷新所有缓存失败");
            return StatusCode(500, new { error = "刷新所有缓存失败" });
        }
    }
    
    /// <summary>
    /// 获取缓存诊断信息
    /// Get cache diagnostics
    /// </summary>
    /// <returns>详细的缓存状态信息</returns>
    [HttpGet("diagnostics")]
    [ProducesResponseType(typeof(CacheDiagnosticsResponse), StatusCodes.Status200OK)]
    public ActionResult<CacheDiagnosticsResponse> GetDiagnostics()
    {
        try
        {
            var diagnostics = _cacheCoordinator.GetDiagnostics();
            
            return Ok(diagnostics);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "获取缓存诊断信息失败");
            return StatusCode(500, new { error = "获取诊断信息失败" });
        }
    }
}

/// <summary>
/// 缓存刷新响应
/// </summary>
public class CacheRefreshResponse
{
    public string EntityType { get; set; } = string.Empty;
    public int RefreshedCount { get; set; }
    public string Message { get; set; } = string.Empty;
}

/// <summary>
/// 刷新所有缓存响应
/// </summary>
public class CacheRefreshAllResponse
{
    public int TotalRefreshed { get; set; }
    public Dictionary<string, int> EntityResults { get; set; } = new();
    public string Message { get; set; } = string.Empty;
}

/// <summary>
/// 缓存诊断响应
/// </summary>
public class CacheDiagnosticsResponse
{
    public DateTime Timestamp { get; set; }
    public bool CacheEnabled { get; set; }
    public Dictionary<string, EntityDiagnostics> EntityDiagnostics { get; set; } = new();
}

public class EntityDiagnostics
{
    public int CachedCount { get; set; }
    public int DirtyCount { get; set; }
    public long CacheHits { get; set; }
    public long CacheMisses { get; set; }
    public double HitRate { get; set; }
    public string Strategy { get; set; } = string.Empty;
    public int TtlSeconds { get; set; }
}
```

### CacheCoordinator 支持方法

在 `CacheCoordinator` 中添加管理方法：

```csharp
/// <summary>
/// 刷新特定实体类型的缓存
/// </summary>
public async Task<RefreshResult> RefreshCacheAsync(string entityType)
{
    switch (entityType)
    {
        case "GearDefinition":
            return await RefreshEntityCacheAsync(_gearDefManager, entityType);
        case "Affix":
            return await RefreshEntityCacheAsync(_affixManager, entityType);
        case "Character":
            return await RefreshEntityCacheAsync(_characterManager, entityType);
        case "GearInstance":
            return await RefreshEntityCacheAsync(_gearInstanceManager, entityType);
        case "ActivityPlan":
            return await RefreshEntityCacheAsync(_activityPlanManager, entityType);
        default:
            return new RefreshResult
            {
                Success = false,
                ErrorMessage = $"不支持的实体类型: {entityType}"
            };
    }
}

private async Task<RefreshResult> RefreshEntityCacheAsync<T>(
    IMemoryStateManager<T>? manager,
    string entityType) where T : class, IEntity
{
    if (manager == null)
    {
        return new RefreshResult
        {
            Success = false,
            ErrorMessage = $"MemoryStateManager for {entityType} not registered"
        };
    }
    
    // 1. 清空现有缓存
    manager.ClearAll();
    
    // 2. 从数据库重新加载
    using var scope = _scopeFactory.CreateScope();
    var db = scope.ServiceProvider.GetRequiredService<GameDbContext>();
    
    await manager.PreloadFromDatabaseAsync(db);
    
    var stats = manager.GetCacheStatistics();
    
    return new RefreshResult
    {
        Success = true,
        EntityType = entityType,
        RefreshedCount = stats.CachedCount
    };
}

public class RefreshResult
{
    public bool Success { get; set; }
    public string EntityType { get; set; } = string.Empty;
    public int RefreshedCount { get; set; }
    public string? ErrorMessage { get; set; }
}
```

---

## 文档和验收

### 技术文档

#### 1. 缓存架构文档

创建 `docs/CacheArchitecture.md`：

```markdown
# BlazorIdle 缓存架构文档

## 概述

BlazorIdle 实现了一个分层缓存系统，优先使用内存缓存，未命中时才查询数据库。

## 架构图

```
[API Layer]
     ↓
[Repository Layer]
     ↓
[MemoryStateManager] ← 内存缓存层
     ↓ (cache miss)
[DbContext / EF Core]
     ↓
[SQLite Database]
```

## 缓存策略

### 永久缓存（Permanent）
- 适用于：静态配置数据
- 实体：GearDefinition, Affix, GearSet
- 特点：启动时预加载，不过期

### 临时缓存（Temporary）
- 适用于：用户数据
- 实体：Character, GearInstance, ActivityPlan
- 特点：按需加载，TTL 过期，LRU 清理

## 读写协同

写入操作和读取操作共享同一个 MemoryStateManager，确保数据一致性。

...
```

#### 2. 配置参数详解

创建 `docs/CacheConfiguration.md`（参考上篇、中篇中的配置说明）

#### 3. 故障排查指南

创建 `docs/CacheTroubleshooting.md`：

```markdown
# 缓存系统故障排查指南

## 常见问题

### 问题 1: 缓存命中率低

**症状**：
- 监控显示命中率 < 70%
- 数据库查询频繁

**可能原因**：
1. TTL 设置过短
2. MaxCachedCount 过小导致频繁清理
3. 缓存未启用

**解决方案**：
1. 检查配置：`EnableReadCaching = true`
2. 增加 TTL：Character 从 3600 → 7200
3. 增加 MaxCachedCount：10000 → 20000
4. 查看日志：是否有频繁的 LRU 清理

### 问题 2: 内存使用过高

**症状**：
- 内存使用持续增长
- GC 频繁

**可能原因**：
1. MaxCachedCount 设置过大
2. 内存泄漏

**解决方案**：
1. 减少 MaxCachedCount
2. 减少 TTL
3. 运行压力测试检测泄漏

...
```

### 运维文档

#### 1. 部署流程

创建 `docs/DeploymentGuide.md`：

```markdown
# 缓存系统部署指南

## 部署前检查

1. 确认 Phase 1-2 已完成
2. 运行所有测试：`dotnet test`
3. 性能测试通过
4. 备份数据库

## 部署步骤

### 1. 配置更新

更新 `appsettings.json` 或 `appsettings.Production.json`：

```json
{
  "CacheConfiguration": {
    "GlobalSettings": {
      "EnableReadCaching": true  // 启用缓存
    }
  }
}
```

### 2. 发布应用

```bash
dotnet publish -c Release
```

### 3. 重启服务

```bash
systemctl restart blazoridle
```

### 4. 验证部署

```bash
# 检查服务状态
systemctl status blazoridle

# 检查缓存统计
curl http://localhost:5000/api/database/cache-stats

# 检查日志
tail -f /var/log/blazoridle/app.log | grep "缓存"
```

## 回退流程

如果部署后出现问题：

1. 禁用缓存：
   ```json
   {
     "CacheConfiguration": {
       "GlobalSettings": {
         "EnableReadCaching": false
       }
     }
   }
   ```

2. 重启服务
3. 验证功能恢复

...
```

### 验收文档

创建独立的验收文档（见下一节）。

---

## 生产部署指南

### 部署前清单

- [ ] 所有单元测试通过
- [ ] 所有集成测试通过
- [ ] 性能测试达标
- [ ] 压力测试完成
- [ ] 文档齐全
- [ ] 备份数据库
- [ ] 准备回退方案

### 灰度发布建议

**阶段 1: 小范围验证（1-2天）**
- 仅在测试环境启用
- 监控日志和指标
- 验证功能正确性

**阶段 2: 部分生产环境（3-5天）**
- 在 10-20% 的服务器启用
- 密切监控性能和错误
- 收集用户反馈

**阶段 3: 全量部署（7天后）**
- 在所有服务器启用
- 持续监控 24-48 小时
- 生成最终报告

### 监控指标

**必须监控的指标**：
- 缓存命中率（目标 >80%）
- 数据库读取次数（目标减少 >85%）
- API 响应时间（目标改善 >30%）
- 内存使用（目标增加 <200MB）
- 错误率（目标无增长）

### 告警阈值

| 指标 | 告警阈值 | 处理方式 |
|-----|---------|---------|
| 缓存命中率 | <70% | 调整 TTL 或 MaxCachedCount |
| 内存使用 | >2GB | 减少缓存大小或检查泄漏 |
| 错误率 | 增长 >10% | 回退配置 |
| API 响应时间 | P95 >500ms | 调查性能瓶颈 |

---

## 验收标准

### 功能验收

- [ ] 所有实体类型已迁移到缓存读取
- [ ] 配置开关功能正常（EnableReadCaching）
- [ ] 手动刷新缓存 API 工作正常
- [ ] 缓存诊断 API 返回正确信息
- [ ] 读写数据一致性

### 性能验收

- [ ] 数据库读取减少 ≥85%
- [ ] 缓存命中率：静态数据 ≥95%, 用户数据 ≥80%
- [ ] API 响应时间 P95 改善 ≥30%
- [ ] 内存增加 ≤200MB
- [ ] 无性能退化

### 测试验收

- [ ] 单元测试覆盖 ≥80%
- [ ] 所有测试通过
- [ ] 压力测试完成（100 用户 × 1 小时）
- [ ] 无内存泄漏

### 文档验收

- [ ] 技术文档完整
- [ ] 运维文档完整
- [ ] 配置参数文档完整
- [ ] 故障排查指南完整

### 监控验收

- [ ] 缓存统计日志正常输出
- [ ] 健康检查 API 工作正常
- [ ] 告警规则配置完成（如适用）

---

## 最终交付物

### 代码交付

- [ ] 上篇（Phase 1）：缓存基础设施
- [ ] 中篇（Phase 2）：分阶段迁移
- [ ] 下篇（Phase 3）：优化和管理接口
- [ ] 所有测试代码

### 文档交付

- [ ] 数据库读取优化方案-完整分析.md
- [ ] 数据库读取优化实施方案-上篇.md
- [ ] 数据库读取优化实施方案-中篇.md
- [ ] 数据库读取优化实施方案-下篇.md（本文档）
- [ ] 数据库读取优化验收文档.md
- [ ] docs/CacheArchitecture.md
- [ ] docs/CacheConfiguration.md
- [ ] docs/CacheTroubleshooting.md
- [ ] docs/DeploymentGuide.md

### 性能报告

- [ ] 基准测试报告
- [ ] 压力测试报告
- [ ] 性能对比报告（优化前 vs 优化后）

---

**阶段状态**：⏳ 待实施  
**预计完成时间**：2-3 天  
**责任人**：开发团队  
**最后更新**：2025-10-18
