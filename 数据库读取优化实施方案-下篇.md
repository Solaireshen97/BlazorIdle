# BlazorIdle 数据库读取优化实施方案 - 下篇

**项目名称**: BlazorIdle 数据库读取操作优化  
**文档类型**: 测试计划、验收标准与部署指南  
**文档版本**: 1.0  
**创建日期**: 2025-10-18  
**状态**: 测试与验收标准 - 待审核

---

## 📋 目录

1. [测试计划](#测试计划)
2. [验收标准](#验收标准)
3. [部署策略](#部署策略)
4. [监控指标](#监控指标)
5. [故障排查](#故障排查)
6. [性能调优](#性能调优)
7. [回滚方案](#回滚方案)
8. [运维手册](#运维手册)

---

## 测试计划

### 测试层次

```
单元测试 → 集成测试 → 功能测试 → 性能测试 → 压力测试 → 用户验收测试
```

### 单元测试

#### 缓存基础功能测试

**测试目标**: 验证缓存的基本功能

**测试用例**:

| 编号 | 测试用例 | 预期结果 |
|------|---------|---------|
| UT-01 | 缓存命中测试 | 第二次读取命中缓存 |
| UT-02 | 缓存未命中测试 | 首次读取查询数据库 |
| UT-03 | TTL 过期测试 | 过期后重新加载 |
| UT-04 | LRU 清理测试 | 最久未访问的被清理 |
| UT-05 | 批量获取测试 | 正确返回多个实体 |
| UT-06 | 条件查询测试 | 正确筛选实体 |
| UT-07 | 缓存失效测试 | 失效后重新加载 |
| UT-08 | 预热测试 | 启动时加载数据 |
| UT-09 | 统计信息测试 | 准确记录命中率 |
| UT-10 | 并发访问测试 | 线程安全 |

**代码示例**:

```csharp
[Fact]
public async Task GetAsync_FirstAccess_ShouldLoadFromDatabase()
{
    // Arrange
    var testId = Guid.NewGuid();
    
    // Act
    var result = await _manager.GetAsync(testId);
    
    // Assert
    var stats = _manager.GetStatistics();
    Assert.Equal(1, stats.TotalQueries);
    Assert.Equal(1, stats.TotalMisses);  // 首次应该未命中
    Assert.Equal(0, stats.TotalHits);
}

[Fact]
public async Task GetAsync_SecondAccess_ShouldHitCache()
{
    // Arrange
    var testId = Guid.NewGuid();
    await _manager.GetAsync(testId);  // 首次加载
    
    // Act
    var result = await _manager.GetAsync(testId);  // 第二次访问
    
    // Assert
    var stats = _manager.GetStatistics();
    Assert.Equal(2, stats.TotalQueries);
    Assert.Equal(1, stats.TotalMisses);
    Assert.Equal(1, stats.TotalHits);  // 第二次应该命中
    Assert.True(stats.HitRate >= 50);  // 命中率应该 ≥ 50%
}

[Fact]
public async Task GetAsync_ExpiredEntry_ShouldReload()
{
    // Arrange
    // 配置极短的 TTL（1秒）
    var testId = Guid.NewGuid();
    await _manager.GetAsync(testId);
    
    // Act
    await Task.Delay(TimeSpan.FromSeconds(2));  // 等待过期
    var result = await _manager.GetAsync(testId);
    
    // Assert
    var stats = _manager.GetStatistics();
    Assert.True(stats.ExpirationEvictionCount > 0);
}

[Fact]
public void Update_ShouldInvalidateCache()
{
    // Arrange
    var entity = CreateTestEntity();
    _manager.Add(entity);
    
    // Act
    entity.Name = "Updated";
    _manager.Update(entity);
    
    // Assert
    var stats = _manager.GetStatistics();
    Assert.True(stats.InvalidationCount >= 0);  // 根据配置可能触发失效
}

[Fact]
public async Task GetManyAsync_ShouldBatchLoad()
{
    // Arrange
    var ids = Enumerable.Range(1, 20).Select(_ => Guid.NewGuid()).ToList();
    
    // Act
    var results = await _manager.GetManyAsync(ids);
    
    // Assert
    Assert.Equal(20, results.Count);
    var stats = _manager.GetStatistics();
    Assert.Equal(20, stats.TotalQueries);
}
```

#### 缓存失效机制测试

**测试目标**: 验证缓存失效的正确性

**测试用例**:

```csharp
[Fact]
public async Task WriteOperation_WithInvalidateOnWrite_ShouldInvalidateCache()
{
    // Arrange
    var entity = CreateTestEntity();
    await _manager.GetAsync(entity.Id);  // 加载到缓存
    
    // Act
    entity.Value = 999;
    _manager.Update(entity);  // 更新应该触发失效
    
    // 等待延迟失效处理
    await Task.Delay(TimeSpan.FromMilliseconds(150));
    
    // Assert
    var stats = _manager.GetStatistics();
    Assert.True(stats.InvalidationCount > 0);
}

[Fact]
public void InvalidateAll_ShouldClearAllCache()
{
    // Arrange
    for (int i = 0; i < 10; i++)
    {
        _manager.Add(CreateTestEntity());
    }
    
    // Act
    _manager.InvalidateAll();
    
    // Assert
    var stats = _manager.GetStatistics();
    Assert.Equal(0, stats.CachedCount);
    Assert.Equal(10, stats.InvalidationCount);
}
```

### 集成测试

#### 端到端读取流程测试

**测试目标**: 验证从 API 到数据库的完整读取流程

**测试场景**:

1. **场景 1: 首次读取**
   ```
   API 请求 → Service → CacheManager → Database → 缓存 → 返回
   ```
   
2. **场景 2: 缓存命中**
   ```
   API 请求 → Service → CacheManager → 缓存命中 → 返回
   ```
   
3. **场景 3: 写入后读取**
   ```
   API 写入 → MemoryStateManager 更新 → 缓存失效
   API 读取 → CacheManager → 重新加载 → 返回最新数据
   ```

**代码示例**:

```csharp
[Fact]
public async Task Integration_GetCharacter_FirstAccess_ShouldLoadFromDatabase()
{
    // Arrange
    var characterId = await CreateTestCharacterInDatabase();
    
    // Act
    var response = await _client.GetAsync($"/api/characters/{characterId}");
    
    // Assert
    response.EnsureSuccessStatusCode();
    var character = await response.Content.ReadFromJsonAsync<Character>();
    Assert.NotNull(character);
    
    // 验证缓存统计
    var statsResponse = await _client.GetAsync("/api/cache/statistics");
    var stats = await statsResponse.Content.ReadFromJsonAsync<CacheStatistics>();
    Assert.True(stats.TotalMisses > 0);  // 首次应该未命中
}

[Fact]
public async Task Integration_GetCharacter_SecondAccess_ShouldHitCache()
{
    // Arrange
    var characterId = await CreateTestCharacterInDatabase();
    await _client.GetAsync($"/api/characters/{characterId}");  // 首次访问
    
    // Act
    var response = await _client.GetAsync($"/api/characters/{characterId}");  // 第二次访问
    
    // Assert
    response.EnsureSuccessStatusCode();
    
    // 验证缓存统计
    var statsResponse = await _client.GetAsync("/api/cache/statistics");
    var stats = await statsResponse.Content.ReadFromJsonAsync<CacheStatistics>();
    Assert.True(stats.TotalHits > 0);  // 第二次应该命中
    Assert.True(stats.HitRate > 0);
}

[Fact]
public async Task Integration_UpdateCharacter_ShouldInvalidateCacheAndReload()
{
    // Arrange
    var characterId = await CreateTestCharacterInDatabase();
    await _client.GetAsync($"/api/characters/{characterId}");  // 加载到缓存
    
    // Act
    var updateRequest = new { Name = "Updated Name" };
    await _client.PutAsJsonAsync($"/api/characters/{characterId}/heartbeat", updateRequest);
    
    // 短暂等待缓存失效
    await Task.Delay(TimeSpan.FromMilliseconds(200));
    
    // 再次读取
    var response = await _client.GetAsync($"/api/characters/{characterId}");
    
    // Assert
    var character = await response.Content.ReadFromJsonAsync<Character>();
    Assert.Equal("Updated Name", character.Name);  // 应该是最新数据
}
```

#### 读写一致性测试

**测试目标**: 确保写入后立即读取能获得最新数据

**测试用例**:

```csharp
[Fact]
public async Task ReadWriteConsistency_UpdateThenRead_ShouldGetLatestData()
{
    // Arrange
    var character = CreateTestCharacter();
    _characterManager.Add(character);
    await _characterManager.GetAsync(character.Id);  // 加载到缓存
    
    // Act
    character.LastSeenAtUtc = DateTime.UtcNow;
    _characterManager.Update(character);  // 更新（写入内存，标记dirty）
    
    // 立即读取
    var result = await _characterManager.GetAsync(character.Id);
    
    // Assert
    Assert.NotNull(result);
    Assert.Equal(character.LastSeenAtUtc, result.LastSeenAtUtc);  // 应该是最新值
}

[Fact]
public async Task ReadWriteConsistency_MultipleUpdates_ShouldReflectLatest()
{
    // Arrange
    var character = CreateTestCharacter();
    _characterManager.Add(character);
    
    // Act
    for (int i = 0; i < 10; i++)
    {
        character.Level = i;
        _characterManager.Update(character);
        
        var result = await _characterManager.GetAsync(character.Id);
        
        // Assert
        Assert.Equal(i, result.Level);  // 每次读取应该都是最新值
    }
}
```

### 性能测试

#### 响应时间测试

**测试目标**: 验证缓存对响应时间的改善

**测试方法**:

```csharp
[Fact]
public async Task Performance_CacheVsDatabase_ResponseTime()
{
    // Arrange
    var testIds = Enumerable.Range(1, 100)
        .Select(_ => CreateTestCharacter().Id)
        .ToList();
    
    // 预热缓存
    foreach (var id in testIds)
    {
        await _manager.GetAsync(id);
    }
    
    // Act & Measure
    var sw1 = Stopwatch.StartNew();
    foreach (var id in testIds)
    {
        await _manager.GetAsync(id);  // 从缓存读取
    }
    sw1.Stop();
    var cacheTime = sw1.ElapsedMilliseconds;
    
    // 清空缓存，强制从数据库读取
    _manager.InvalidateAll();
    
    var sw2 = Stopwatch.StartNew();
    foreach (var id in testIds)
    {
        await _manager.GetAsync(id);  // 从数据库读取
    }
    sw2.Stop();
    var dbTime = sw2.ElapsedMilliseconds;
    
    // Assert
    var improvement = (double)(dbTime - cacheTime) / dbTime * 100;
    _output.WriteLine($"缓存时间: {cacheTime}ms, 数据库时间: {dbTime}ms, 改善: {improvement:F2}%");
    
    Assert.True(improvement > 30, $"性能改善应该 > 30%，实际: {improvement:F2}%");
}
```

**预期结果**:
- 缓存命中时响应时间 < 5ms
- 数据库查询响应时间 10-50ms
- 性能改善 **50-90%**

#### 并发压力测试

**测试目标**: 验证缓存在高并发下的稳定性

**测试方法**:

```csharp
[Fact]
public async Task Stress_ConcurrentReads_ShouldHandleHighLoad()
{
    // Arrange
    var characterId = CreateTestCharacter().Id;
    var concurrentRequests = 1000;
    var tasks = new List<Task<Character?>>();
    
    // Act
    for (int i = 0; i < concurrentRequests; i++)
    {
        tasks.Add(_manager.GetAsync(characterId));
    }
    
    var results = await Task.WhenAll(tasks);
    
    // Assert
    Assert.All(results, r => Assert.NotNull(r));
    
    var stats = _manager.GetStatistics();
    _output.WriteLine($"总请求: {stats.TotalQueries}, 命中率: {stats.HitRate:F2}%");
    
    Assert.True(stats.HitRate > 95, $"高并发下命中率应该 > 95%，实际: {stats.HitRate:F2}%");
    Assert.Equal(concurrentRequests, stats.TotalQueries);
}

[Fact]
public async Task Stress_MixedReadWrite_ShouldMaintainConsistency()
{
    // Arrange
    var character = CreateTestCharacter();
    _manager.Add(character);
    
    var readTasks = new List<Task>();
    var writeTasks = new List<Task>();
    
    // Act - 混合读写
    for (int i = 0; i < 500; i++)
    {
        readTasks.Add(_manager.GetAsync(character.Id));
    }
    
    for (int i = 0; i < 50; i++)
    {
        writeTasks.Add(Task.Run(() => {
            character.Level++;
            _manager.Update(character);
        }));
    }
    
    await Task.WhenAll(readTasks.Concat(writeTasks));
    
    // Assert
    var result = await _manager.GetAsync(character.Id);
    Assert.NotNull(result);
    // 验证数据一致性（最终状态正确）
}
```

### 功能测试

#### 静态数据缓存测试

**测试目标**: 验证静态配置数据的缓存功能

**测试用例**:

```csharp
[Fact]
public async Task StaticCache_SkillDefinitions_ShouldLoadOnce()
{
    // Arrange
    var staticCache = _serviceProvider.GetRequiredService<StaticDataCacheManager<SkillDefinition>>();
    
    // Act
    var skills1 = await staticCache.GetAllAsync();
    var skills2 = await staticCache.GetAllAsync();  // 第二次不应该查数据库
    
    // Assert
    Assert.NotEmpty(skills1);
    Assert.Same(skills1, skills2);  // 应该是同一个实例
}

[Fact]
public async Task StaticCache_Refresh_ShouldReloadData()
{
    // Arrange
    var staticCache = _serviceProvider.GetRequiredService<StaticDataCacheManager<SkillDefinition>>();
    await staticCache.GetAllAsync();  // 初次加载
    
    // Act
    await staticCache.RefreshAsync();  // 刷新
    var skillsAfterRefresh = await staticCache.GetAllAsync();
    
    // Assert
    Assert.NotEmpty(skillsAfterRefresh);
}
```

---

## 验收标准

### 功能验收

#### 必须满足的功能需求

| 编号 | 需求 | 验收条件 | 状态 |
|------|------|---------|------|
| FR-01 | 读取缓存功能 | 首次查数据库，后续读缓存 | [ ] |
| FR-02 | 缓存命中率 | ≥ 80% | [ ] |
| FR-03 | TTL 失效 | 过期后自动重新加载 | [ ] |
| FR-04 | LRU 清理 | 超容量时清理最久未用 | [ ] |
| FR-05 | 写入失效 | 更新后缓存失效 | [ ] |
| FR-06 | 读写一致性 | 写入后立即读取到最新数据 | [ ] |
| FR-07 | 静态数据缓存 | 配置数据长期缓存 | [ ] |
| FR-08 | 批量读取 | 支持批量获取实体 | [ ] |
| FR-09 | 条件查询 | 支持条件筛选（有限） | [ ] |
| FR-10 | 缓存预热 | 启动时可选预热 | [ ] |

#### 配置化验收

| 编号 | 配置项 | 验收条件 | 状态 |
|------|-------|---------|------|
| CF-01 | EnableReadCache | 可通过配置开关启用/禁用 | [ ] |
| CF-02 | TimeToLiveSeconds | 可配置 TTL | [ ] |
| CF-03 | MaxCachedEntities | 可配置容量限制 | [ ] |
| CF-04 | EvictionPolicy | 可配置清理策略 | [ ] |
| CF-05 | InvalidateOnWrite | 可配置是否写入失效 | [ ] |
| CF-06 | EntityCacheStrategies | 支持实体类型差异化配置 | [ ] |
| CF-07 | Monitoring | 支持监控配置 | [ ] |
| CF-08 | WarmUp | 支持预热配置 | [ ] |

### 性能验收

#### 量化指标

| 指标 | 基准值（优化前） | 目标值 | 验收条件 | 状态 |
|------|---------------|--------|---------|------|
| 数据库读取次数 | 120,000次/小时 | 12,000-36,000次/小时 | 减少 70-90% | [ ] |
| 缓存命中率 | 0% | 80-95% | ≥ 80% | [ ] |
| API 响应时间 P95 | 150-200ms | <100ms | 改善 30-50% | [ ] |
| 数据库连接池利用率 | 60-80% | 30-50% | 降低 30-50% | [ ] |
| 内存使用 | ~350MB | ~500-650MB | 增加 <300MB | [ ] |
| 缓存失效延迟 | N/A | <100ms | <100ms | [ ] |

#### 性能基准测试

**测试场景**：
- 100 个并发用户
- 每个用户每分钟 10 次请求
- 持续测试 30 分钟

**预期结果**：
- 平均响应时间 < 50ms
- P95 响应时间 < 100ms
- P99 响应时间 < 200ms
- 缓存命中率 > 80%
- 无内存溢出
- 无数据不一致

### 质量验收

#### 代码质量

| 编号 | 检查项 | 验收标准 | 状态 |
|------|--------|---------|------|
| QA-01 | 编译成功 | 0 错误 | [ ] |
| QA-02 | 代码规范 | 符合项目编码规范 | [ ] |
| QA-03 | 注释完整性 | 所有公共API有XML文档注释 | [ ] |
| QA-04 | 单元测试覆盖率 | ≥ 80% | [ ] |
| QA-05 | 集成测试通过率 | 100% | [ ] |

#### 向后兼容性

| 编号 | 检查项 | 验收标准 | 状态 |
|------|--------|---------|------|
| BC-01 | API 接口不变 | 不修改现有 API 签名 | [ ] |
| BC-02 | 配置回滚 | EnableReadCache=false 恢复原行为 | [ ] |
| BC-03 | 数据格式不变 | 不修改数据模型 | [ ] |
| BC-04 | Fallback 机制 | 缓存未启用时正常工作 | [ ] |

### 文档验收

| 编号 | 文档 | 验收标准 | 状态 |
|------|------|---------|------|
| DOC-01 | 需求分析文档 | 上篇完成 | [ ] |
| DOC-02 | 实施方案文档 | 中篇完成 | [ ] |
| DOC-03 | 测试与验收文档 | 下篇完成 | [ ] |
| DOC-04 | 验收文档 | 独立验收文档完成 | [ ] |
| DOC-05 | 配置说明 | appsettings.json 说明完整 | [ ] |
| DOC-06 | 运维手册 | 监控、故障排查指南完成 | [ ] |

---

## 部署策略

### 分阶段部署

#### 阶段 1: 开发环境验证（1-2天）

**目标**: 在开发环境完整测试所有功能

**步骤**:
1. 备份开发环境数据库
2. 部署新代码
3. 启用缓存（EnableReadCache=true）
4. 执行完整测试套件
5. 监控性能指标
6. 验证功能正确性

**验收标准**:
- 所有单元测试通过
- 所有集成测试通过
- 性能指标达标
- 无数据不一致

#### 阶段 2: 测试环境验证（3-5天）

**目标**: 在接近生产环境的测试环境验证

**步骤**:
1. 恢复生产数据到测试环境
2. 部署新代码
3. 启用缓存
4. 执行性能基准测试
5. 执行压力测试
6. 执行用户验收测试

**验收标准**:
- 性能基准测试通过
- 压力测试无问题
- 用户验收测试通过
- 内存使用在合理范围

#### 阶段 3: 灰度发布（5-7天）

**目标**: 小范围生产环境验证

**策略**:
- 选择 10% 的服务器启用缓存
- 密切监控性能和错误
- 对比缓存组和非缓存组的性能

**步骤**:
1. 选择 10% 服务器启用 EnableReadCache=true
2. 其余 90% 服务器保持 EnableReadCache=false
3. 监控 24-48 小时
4. 收集性能数据对比
5. 验证无问题后扩大范围到 50%
6. 再监控 24 小时
7. 验证无问题后全面启用

**监控指标**:
- API 响应时间
- 数据库查询次数
- 缓存命中率
- 错误率
- 内存使用

**回滚条件**:
- 错误率增加 > 5%
- 内存溢出
- API 响应时间退化
- 数据不一致

#### 阶段 4: 全面启用（7-10天后）

**目标**: 在所有服务器启用缓存

**步骤**:
1. 在所有服务器启用 EnableReadCache=true
2. 持续监控 7 天
3. 收集完整的性能对比数据
4. 生成项目验收报告

---

## 监控指标

### 关键指标

#### 缓存性能指标

| 指标 | 描述 | 目标值 | 告警阈值 |
|------|------|--------|---------|
| 缓存命中率 | TotalHits / TotalQueries | ≥ 80% | < 70% |
| 平均查询时间 | 缓存读取平均耗时 | < 5ms | > 10ms |
| 缓存容量 | 当前缓存实体数 | - | > 90% MaxCachedEntities |
| 失效次数 | 每分钟失效次数 | - | > 1000/min |
| LRU 清理次数 | 每分钟 LRU 清理 | - | > 100/min |

#### 数据库性能指标

| 指标 | 描述 | 目标值 | 告警阈值 |
|------|------|--------|---------|
| 数据库查询次数 | 每分钟查询次数 | 200-600/min | > 2000/min |
| 连接池利用率 | 活跃连接 / 总连接 | 30-50% | > 80% |
| 查询耗时 P95 | 95% 查询耗时 | < 50ms | > 100ms |

#### 系统资源指标

| 指标 | 描述 | 目标值 | 告警阈值 |
|------|------|--------|---------|
| 内存使用 | 进程内存 | 500-650MB | > 1GB |
| GC 频率 | 每分钟 GC 次数 | < 10 | > 30 |
| CPU 利用率 | CPU 使用百分比 | < 50% | > 80% |

### 监控 API

```csharp
// GET /api/cache/statistics
{
  "character": {
    "totalHits": 15420,
    "totalMisses": 3580,
    "hitRate": 81.2,
    "cachedCount": 2345,
    "dirtyCount": 123,
    "invalidationCount": 456,
    "averageQueryMs": 3.5
  },
  "battle": { ... },
  "activityPlan": { ... }
}

// GET /api/cache/health
{
  "status": "Healthy",
  "checks": [
    {
      "name": "CacheHitRate",
      "status": "Healthy",
      "description": "Hit rate: 81.2% (>= 70%)"
    },
    {
      "name": "MemoryUsage",
      "status": "Healthy",
      "description": "Memory: 580MB (< 1GB)"
    }
  ]
}
```

---

## 故障排查

### 常见问题

#### 问题 1: 缓存命中率低 (<70%)

**可能原因**:
1. TTL 设置过短
2. 数据变更频繁触发失效
3. 查询模式不适合缓存

**排查步骤**:
1. 检查 TTL 配置
2. 查看失效统计
3. 分析查询模式

**解决方案**:
- 延长 TTL（如从 5 分钟改为 10 分钟）
- 调整 InvalidateOnWrite 策略
- 禁用不适合缓存的实体类型

#### 问题 2: 内存占用过高

**可能原因**:
1. MaxCachedEntities 设置过大
2. LRU 清理不生效
3. 内存泄漏

**排查步骤**:
1. 检查 CachedCount
2. 查看 LRU 清理统计
3. 使用内存分析工具

**解决方案**:
- 降低 MaxCachedEntities
- 缩短 TTL
- 手动触发 InvalidateAll

#### 问题 3: 数据不一致

**可能原因**:
1. 缓存失效机制未生效
2. 并发更新冲突
3. 数据库直接修改未通知缓存

**排查步骤**:
1. 检查 InvalidateOnWrite 配置
2. 查看失效日志
3. 验证并发控制

**解决方案**:
- 确保 InvalidateOnWrite=true
- 手动调用 Invalidate
- 暂时禁用缓存验证

---

## 性能调优

### 调优指南

#### 1. 根据业务特性调整 TTL

**动态数据**（如角色在线状态）:
```json
{
  "Character": {
    "TimeToLiveSeconds": 60  // 1分钟，快速反映变化
  }
}
```

**半静态数据**（如装备）:
```json
{
  "EquipmentInstance": {
    "TimeToLiveSeconds": 1800  // 30分钟
  }
}
```

**静态数据**（如技能定义）:
```json
{
  "SkillDefinition": {
    "TimeToLiveSeconds": 86400  // 24小时
  }
}
```

#### 2. 根据负载调整容量

**低负载场景** (<50 在线用户):
```json
{
  "MaxCachedEntities": 10000
}
```

**中负载场景** (50-200 在线用户):
```json
{
  "MaxCachedEntities": 50000
}
```

**高负载场景** (>200 在线用户):
```json
{
  "MaxCachedEntities": 100000
}
```

#### 3. 优化预热策略

**仅预热静态数据**:
```json
{
  "WarmUp": {
    "EnableOnStartup": true,
    "EntityTypes": [
      "SkillDefinition",
      "ItemDefinition",
      "MonsterTemplate"
    ]
  }
}
```

---

## 回滚方案

### 快速回滚

**步骤 1**: 修改配置
```json
{
  "Cache": {
    "EnableReadCache": false  // 改为 false
  }
}
```

**步骤 2**: 重启服务
```bash
systemctl restart blazoridle-server
```

**步骤 3**: 验证功能
```bash
curl http://localhost:5000/api/characters/{id}
```

**步骤 4**: 监控日志
```bash
tail -f /var/log/blazoridle/app.log
```

### 完全回滚

如果需要回滚到优化前的版本：

1. 恢复代码到上一个稳定版本
2. 恢复数据库（如有变更）
3. 重启服务
4. 验证功能

---

## 运维手册

### 日常监控清单

#### 每天检查

- [ ] 检查缓存命中率 (应该 ≥ 80%)
- [ ] 检查内存使用 (应该 < 1GB)
- [ ] 检查错误日志
- [ ] 检查 API 响应时间

#### 每周检查

- [ ] 生成性能对比报告
- [ ] 分析缓存失效模式
- [ ] 评估 TTL 配置是否合理
- [ ] 检查数据库查询次数趋势

#### 每月检查

- [ ] 完整性能基准测试
- [ ] 评估容量规划
- [ ] 优化缓存策略
- [ ] 更新监控阈值

### 常用命令

**查看缓存统计**:
```bash
curl http://localhost:5000/api/cache/statistics | jq
```

**手动失效所有缓存**:
```bash
curl -X POST http://localhost:5000/api/cache/invalidate-all?entityType=Character
```

**检查健康状态**:
```bash
curl http://localhost:5000/api/cache/health
```

---

## 总结

### 下篇要点回顾

1. **完整的测试计划**
   - 单元测试、集成测试、性能测试
   - 详细的测试用例和代码示例

2. **明确的验收标准**
   - 功能验收、性能验收、质量验收
   - 量化指标和验收条件

3. **渐进式部署策略**
   - 开发环境 → 测试环境 → 灰度发布 → 全面启用
   - 每个阶段的验收标准和回滚条件

4. **完善的监控体系**
   - 关键指标定义
   - 告警阈值设置
   - 监控 API 设计

5. **故障排查指南**
   - 常见问题和解决方案
   - 排查步骤和诊断方法

6. **性能调优指南**
   - 根据业务特性调整参数
   - 容量规划建议

7. **回滚方案**
   - 快速回滚步骤
   - 完全回滚流程

8. **运维手册**
   - 日常监控清单
   - 常用命令

---

**文档状态**: ✅ 测试与验收文档完成  
**下一文档**: 数据库读取优化验收文档.md
