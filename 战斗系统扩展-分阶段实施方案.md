# 战斗系统扩展 - 详细分阶段实施方案

**版本**: 1.0  
**日期**: 2025年1月  
**状态**: 设计方案 - 待审核

---

## 目录

1. [执行摘要](#执行摘要)
2. [当前系统分析](#当前系统分析)
3. [需求分析](#需求分析)
4. [架构设计原则](#架构设计原则)
5. [阶段1: 玩家复活机制](#阶段1-玩家复活机制)
6. [阶段2: 目标选取优化](#阶段2-目标选取优化)
7. [阶段3: Enhanced Dungeon模式预留](#阶段3-enhanced-dungeon模式预留)
8. [阶段4: 怪物攻击与技能系统](#阶段4-怪物攻击与技能系统)
9. [阶段5: 测试与验证策略](#阶段5-测试与验证策略)
10. [风险评估与缓解](#风险评估与缓解)
11. [性能影响分析](#性能影响分析)
12. [向后兼容性保证](#向后兼容性保证)
13. [实施时间表](#实施时间表)
14. [附录](#附录)

---

## 执行摘要

本方案旨在扩展现有战斗系统，引入以下核心功能：

1. **玩家复活机制** - 死亡后进入复活计时，降低挂机挫败感
2. **智能目标选取** - 基于权重的随机目标选择，为未来嘲讽系统预留接口
3. **Enhanced Dungeon** - 可配置的高难度模式，支持死亡重置+强化掉落
4. **怪物攻击与技能** - 将怪物从"木桩"升级为具有基础攻击和简化技能的战斗单位

**核心设计原则**:
- 最小增量修改，不重构现有系统
- 保持RNG可重放性，确保战斗回放一致
- 向后兼容，现有功能不受影响
- 不引入复杂资源系统，采用轻量化设计

---

## 当前系统分析

### 2.1 现有战斗架构

```
BattleEngine (战斗引擎)
├── GameClock (游戏时钟 - 事件驱动时间推进)
├── EventScheduler (事件调度器 - 优先队列)
├── BattleContext (战斗上下文)
│   ├── Encounter/EncounterGroup (敌人实例)
│   ├── Stats (玩家属性)
│   ├── AutoCaster (技能自动释放)
│   ├── Buffs (增益管理器)
│   ├── Procs (触发效果)
│   └── RngContext (可重放随机数)
└── TrackState[] (攻击/特殊轨道)
```

### 2.2 当前战斗流程

1. **事件调度**: 按时间戳从优先队列取出下一个事件
2. **时钟推进**: `Clock.AdvanceTo(event.ExecuteAt)`
3. **事件执行**: 
   - `AttackTickEvent` - 玩家普攻
   - `SpecialPulseEvent` - 特殊资源生成
   - `SkillCastEvent` - 技能释放 (via AutoCaster)
   - `BuffExpireEvent` - Buff过期
   - `ProcPulseEvent` - 触发效果检查
4. **RNG记录**: 事件前后记录 `Rng.Index`
5. **段聚合**: 定期刷新 `CombatSegment` 供离线快进使用

### 2.3 现有敌人模型

```csharp
public class EnemyDefinition
{
    public string Id { get; }
    public string Name { get; }
    public int MaxHp { get; }
    public double Armor { get; }
    public double MagicResist { get; }
    // 注: 当前敌人是"被动木桩"，不会主动攻击
}

public class Encounter
{
    public EnemyDefinition Enemy { get; }
    public int CurrentHp { get; }
    public bool IsDead => CurrentHp <= 0;
    // 注: 只能受伤，不能攻击
}
```

### 2.4 当前玩家模型

- **状态**: 玩家当前是"不死之身"，血量仅用于UI显示
- **计算方式**: `PlayerMaxHp = Stamina * 10`
- **战斗结束**: 仅当敌人全灭时战斗才结束

### 2.5 现有优势

1. ✅ **事件驱动架构** - 易于添加新事件类型
2. ✅ **RNG可重放** - 所有随机操作通过 `RngContext`
3. ✅ **Segment聚合** - 支持高效离线快进
4. ✅ **模块化设计** - 玩家技能/Buff/Proc独立于战斗核心

### 2.6 现有局限

1. ❌ **玩家无死亡** - 战斗体验单向，缺乏风险感
2. ❌ **敌人无攻击** - "木桩模式"限制策略深度
3. ❌ **固定目标** - 多怪战斗中总是攻击"主目标"
4. ❌ **无难度分级** - 缺乏高难度挑战选项

---

## 需求分析

### 3.1 功能需求

| 需求ID | 描述 | 优先级 | 来源 |
|--------|------|--------|------|
| FR-01 | 玩家死亡后进入复活计时，而非立即结束战斗 | P0 | 用户反馈 |
| FR-02 | 玩家死亡时暂停攻击和技能进度 | P0 | 需求1 |
| FR-03 | 怪物在无存活玩家时暂停攻击 | P0 | 需求1 |
| FR-04 | 多目标时随机选择攻击对象 | P1 | 需求2 |
| FR-05 | 支持修改目标仇恨权重（嘲讽预留） | P2 | 需求2 |
| FR-06 | Enhanced Dungeon模式: 可禁用自动复活 | P2 | 需求3 |
| FR-07 | Enhanced Dungeon模式: 死亡触发战斗重置 | P2 | 需求3 |
| FR-08 | Enhanced Dungeon模式: 强化掉落倍率 | P2 | 需求3 |
| FR-09 | 怪物具有基础攻击能力 | P1 | 需求4 |
| FR-10 | 怪物具有简化技能系统 | P1 | 需求4 |
| FR-11 | 怪物技能不引入复杂资源 | P0 | 需求4 |
| FR-12 | 采用"冷却+概率+触发"轻量模型 | P0 | 需求4 |

### 3.2 非功能需求

| 需求ID | 描述 | 指标 |
|--------|------|------|
| NFR-01 | 保持RNG可重放性 | 100% 确定性回放 |
| NFR-02 | 向后兼容 | 现有战斗0修改可运行 |
| NFR-03 | 性能影响 | 离线快进性能下降 < 10% |
| NFR-04 | 代码质量 | 新增测试覆盖率 > 80% |
| NFR-05 | 可维护性 | 模块化，单一职责 |

---

## 架构设计原则

### 4.1 核心原则

1. **最小侵入性 (Minimal Intrusion)**
   - 不修改现有类的核心逻辑
   - 通过扩展而非修改实现新功能
   - 新增代码独立于旧代码

2. **向后兼容性 (Backward Compatibility)**
   - 默认行为保持不变
   - 通过配置标志启用新功能
   - 现有战斗数据可无缝迁移

3. **确定性 (Determinism)**
   - 所有随机操作使用 `RngContext`
   - 事件执行前后记录 `Rng.Index`
   - 战斗可通过相同种子完全重放

4. **模块化 (Modularity)**
   - 玩家复活系统独立
   - 怪物攻击系统独立
   - 目标选取系统独立

5. **轻量化 (Lightweight)**
   - 不引入新的资源类型
   - 使用简单数据结构
   - 避免深层嵌套逻辑

### 4.2 扩展点识别

当前系统已提供的扩展点：

1. **事件系统**: 实现 `IGameEvent` 接口可添加新事件
2. **配置系统**: `BattleMeta` 可携带自定义标志
3. **RNG系统**: `RngContext` 支持子流生成
4. **段聚合**: `SegmentCollector` 支持自定义标签

需要新增的扩展点：

1. **目标选取接口**: `ITargetSelector`
2. **怪物行为接口**: `IMonsterBehavior`
3. **复活策略接口**: `IRevivalStrategy`

---

## 阶段1: 玩家复活机制

### 5.1 功能概述

当玩家血量降至0时：
1. 进入"死亡状态"，但不立即结束战斗
2. 启动复活计时器（默认10秒）
3. 暂停玩家的所有攻击和技能进度
4. 怪物暂停攻击（如果没有其他存活玩家）
5. 复活后恢复满血，继续战斗

### 5.2 设计细节

#### 5.2.1 玩家状态扩展

```csharp
// 在 BattleContext 中添加
public class PlayerState
{
    public int CurrentHp { get; private set; }
    public int MaxHp { get; }
    public bool IsDead => CurrentHp <= 0;
    public double? DeathTime { get; private set; }
    public double? RevivalTime { get; private set; }
    
    public PlayerState(int maxHp)
    {
        MaxHp = maxHp;
        CurrentHp = maxHp;
    }
    
    public void TakeDamage(int amount, double now)
    {
        if (IsDead) return;
        CurrentHp = Math.Max(0, CurrentHp - amount);
        if (CurrentHp == 0 && DeathTime == null)
        {
            DeathTime = now;
        }
    }
    
    public void Revive(double now)
    {
        CurrentHp = MaxHp;
        DeathTime = null;
        RevivalTime = now;
    }
}

// 在 BattleContext 中添加
public PlayerState Player { get; }
```

#### 5.2.2 复活事件

```csharp
public record PlayerRevivalEvent(double ExecuteAt) : IGameEvent
{
    public string EventType => "PlayerRevival";
    
    public void Execute(BattleContext context)
    {
        if (!context.Player.IsDead) return;
        
        context.Player.Revive(context.Clock.CurrentTime);
        context.SegmentCollector.OnTag("player_revived", 1);
        
        // 恢复攻击进度 (不重置，从暂停处继续)
        var attackTrack = context.Tracks.FirstOrDefault(t => t.TrackType == TrackType.Attack);
        if (attackTrack != null)
        {
            // 重新调度下一次攻击
            context.Scheduler.Schedule(
                new AttackTickEvent(attackTrack.NextTriggerAt, attackTrack));
        }
    }
}
```

#### 5.2.3 攻击暂停逻辑

```csharp
// 修改 AttackTickEvent.Execute
public void Execute(BattleContext context)
{
    // 检查玩家是否存活
    if (context.Player.IsDead)
    {
        // 不调度下一次攻击，等待复活事件重新启动
        return;
    }
    
    // 原有攻击逻辑...
    
    // 调度下一次攻击
    Track.NextTriggerAt = ExecuteAt + Track.CurrentInterval;
    context.Scheduler.Schedule(new AttackTickEvent(Track.NextTriggerAt, Track));
}
```

#### 5.2.4 玩家受伤机制

```csharp
// 在 DamageCalculator 中添加
public static void ApplyDamageToPlayer(
    BattleContext context,
    string source,
    int amount,
    double now)
{
    context.Player.TakeDamage(amount, now);
    context.SegmentCollector.OnTag($"player_damage_taken:{source}", amount);
    
    if (context.Player.IsDead && context.Player.DeathTime == now)
    {
        // 第一次死亡，调度复活事件
        double revivalDelay = GetRevivalDelay(context);
        context.Scheduler.Schedule(
            new PlayerRevivalEvent(now + revivalDelay));
        context.SegmentCollector.OnTag("player_died", 1);
    }
}

private static double GetRevivalDelay(BattleContext context)
{
    // 可从 BattleMeta 读取配置，默认10秒
    return 10.0;
}
```

### 5.3 RNG一致性保证

**关键点**: 玩家死亡/复活不消耗RNG，确保回放一致性

```csharp
// 玩家受伤是确定性计算，不使用 RNG
public void TakeDamage(int amount, double now)
{
    // 不调用 context.Rng.Next*()
    CurrentHp = Math.Max(0, CurrentHp - amount);
}

// 复活时间是确定性的（配置值）
double revivalDelay = 10.0; // 不使用随机
```

### 5.4 配置扩展

```csharp
public class BattleMeta
{
    // 现有字段...
    
    // 新增
    public double? PlayerRevivalDelaySeconds { get; set; } = 10.0;
    public bool EnablePlayerDeath { get; set; } = false; // 默认关闭，向后兼容
}
```

### 5.5 初始化修改

```csharp
// 在 BattleEngine 构造函数中
Context = new BattleContext(
    // ... 现有参数
    player: new PlayerState(stats.Stamina * 10)
);
```

### 5.6 测试策略

```csharp
[Fact]
public void Player_Dies_And_Revives_After_Delay()
{
    // 创建启用玩家死亡的战斗
    var meta = new BattleMeta { EnablePlayerDeath = true };
    var engine = CreateEngine(meta);
    
    // 让怪物攻击玩家直到死亡
    // ... 执行战斗
    
    // 验证
    Assert.True(engine.Context.Player.IsDead);
    Assert.NotNull(engine.Context.Player.DeathTime);
    
    // 推进时间到复活点
    engine.AdvanceTo(engine.Context.Player.DeathTime.Value + 10.0, 1000);
    
    // 验证复活
    Assert.False(engine.Context.Player.IsDead);
    Assert.Equal(engine.Context.Player.MaxHp, engine.Context.Player.CurrentHp);
}

[Fact]
public void Player_Death_Pauses_Attack_Progress()
{
    // 玩家死亡时，攻击事件不再调度
    // 验证事件队列中无新的 AttackTickEvent
}

[Fact]
public void RNG_Consistency_With_Player_Revival()
{
    // 用相同种子运行两次战斗（含玩家死亡复活）
    // 验证所有伤害、技能触发完全相同
}
```

---

## 阶段2: 目标选取优化

### 6.1 功能概述

- 多个敌人时，每次攻击随机选择一个目标
- 每个敌人有"仇恨权重"（默认1.0，所有敌人概率相等）
- 为未来嘲讽技能预留 `ModifyThreatWeight()` 接口

### 6.2 设计细节

#### 6.2.1 仇恨权重模型

```csharp
// 在 Encounter 中添加
public class Encounter
{
    // 现有字段...
    
    public double ThreatWeight { get; private set; } = 1.0;
    
    public void ModifyThreatWeight(double multiplier)
    {
        ThreatWeight *= multiplier;
        ThreatWeight = Math.Max(0.01, ThreatWeight); // 最小权重防止除0
    }
    
    public void ResetThreatWeight()
    {
        ThreatWeight = 1.0;
    }
}
```

#### 6.2.2 目标选取器

```csharp
// 新增类
public static class TargetSelector
{
    /// <summary>
    /// 从存活敌人中基于仇恨权重随机选择一个目标
    /// </summary>
    public static Encounter? SelectWeightedRandomTarget(
        EncounterGroup group,
        RngContext rng)
    {
        var alive = group.All.Where(e => !e.IsDead).ToList();
        if (alive.Count == 0) return null;
        if (alive.Count == 1) return alive[0];
        
        // 计算总权重
        double totalWeight = alive.Sum(e => e.ThreatWeight);
        
        // 加权随机选择
        double roll = rng.NextDouble() * totalWeight;
        double cumulative = 0;
        
        foreach (var enc in alive)
        {
            cumulative += enc.ThreatWeight;
            if (roll < cumulative)
                return enc;
        }
        
        return alive[alive.Count - 1]; // 容错
    }
    
    /// <summary>
    /// 简化版：等概率随机选择（当所有权重为1.0时）
    /// </summary>
    public static Encounter? SelectRandomTarget(
        EncounterGroup group,
        RngContext rng)
    {
        var alive = group.All.Where(e => !e.IsDead).ToList();
        if (alive.Count == 0) return null;
        if (alive.Count == 1) return alive[0];
        
        int index = rng.NextInt(0, alive.Count);
        return alive[index];
    }
}
```

#### 6.2.3 攻击事件修改

```csharp
// 修改 AttackTickEvent.Execute
public void Execute(BattleContext context)
{
    // ... 玩家死亡检查
    
    // 选择目标 (使用RNG保证可重放)
    var target = TargetSelector.SelectRandomTarget(
        context.EncounterGroup,
        context.Rng);
    
    if (target == null)
    {
        // 没有存活敌人，不调度下一次攻击
        return;
    }
    
    // 暂存当前主目标（用于技能系统兼容）
    var originalPrimary = context.Encounter;
    context.Encounter = target;
    
    // 执行伤害
    DamageCalculator.ApplyDamage(context, "basic_attack", finalDamage, DamageType.Physical);
    
    // 恢复主目标
    context.Encounter = originalPrimary;
    
    // 调度下一次攻击
    Track.NextTriggerAt = ExecuteAt + Track.CurrentInterval;
    context.Scheduler.Schedule(new AttackTickEvent(Track.NextTriggerAt, Track));
}
```

### 6.3 配置扩展

```csharp
public class BattleMeta
{
    // 新增
    public bool UseWeightedTargetSelection { get; set; } = false; // 默认关闭
}
```

### 6.4 嘲讽技能接口预留

```csharp
// 示例：未来的嘲讽技能实现
public class TauntSkill
{
    public void Execute(BattleContext context)
    {
        // 将所有敌人的仇恨转向某个目标（玩家）
        foreach (var enc in context.EncounterGroup.All)
        {
            enc.ModifyThreatWeight(3.0); // 3倍仇恨
        }
        
        // 10秒后重置
        context.Scheduler.Schedule(
            new ThreatResetEvent(context.Clock.CurrentTime + 10.0));
    }
}
```

### 6.5 测试策略

```csharp
[Fact]
public void Random_Target_Selection_Has_Equal_Distribution()
{
    // 3个敌人，运行1000次攻击
    // 统计每个敌人被攻击次数
    // 验证分布接近 33.3% ± 5%
}

[Fact]
public void Weighted_Target_Selection_Respects_ThreatWeight()
{
    // 3个敌人：权重 1.0, 2.0, 3.0
    // 预期分布: 16.7%, 33.3%, 50%
    // 运行1000次验证
}

[Fact]
public void RNG_Consistency_With_Random_Target_Selection()
{
    // 相同种子运行两次战斗
    // 验证每次攻击选中的目标完全相同
}
```

---

## 阶段3: Enhanced Dungeon模式预留

### 7.1 功能概述

为未来的"强化地下城"模式预留配置和逻辑：
- 可关闭自动复活
- 玩家死亡触发战斗重置（失败）
- 强化掉落倍率

### 7.2 设计细节

#### 7.2.1 配置扩展

```csharp
public class BattleMeta
{
    // 现有字段...
    
    // Enhanced Dungeon 相关
    public bool AllowAutoRevival { get; set; } = true; // 允许自动复活
    public bool EnhancedDungeonMode { get; set; } = false; // 强化模式
    public double EnhancedDropMultiplier { get; set; } = 1.0; // 掉落倍率
}
```

#### 7.2.2 复活逻辑修改

```csharp
// 在 ApplyDamageToPlayer 中
if (context.Player.IsDead && context.Player.DeathTime == now)
{
    context.SegmentCollector.OnTag("player_died", 1);
    
    // 检查是否允许自动复活
    if (context.Battle.Meta?.AllowAutoRevival ?? true)
    {
        // 调度复活事件
        double revivalDelay = GetRevivalDelay(context);
        context.Scheduler.Schedule(
            new PlayerRevivalEvent(now + revivalDelay));
    }
    else
    {
        // Enhanced Dungeon 模式：触发战斗失败
        context.Scheduler.Schedule(
            new BattleFailureEvent(now));
    }
}
```

#### 7.2.3 战斗失败事件

```csharp
public record BattleFailureEvent(double ExecuteAt) : IGameEvent
{
    public string EventType => "BattleFailure";
    
    public void Execute(BattleContext context)
    {
        context.SegmentCollector.OnTag("battle_failed", 1);
        
        // 标记战斗结束（失败）
        // 注: BattleEngine 需要添加 Failed 标志
    }
}

// 在 BattleEngine 中添加
public bool Failed { get; private set; }
```

#### 7.2.4 掉落倍率应用

```csharp
// 在掉落计算时应用倍率（未来实现）
public static Loot CalculateLoot(BattleContext context, EnemyDefinition enemy)
{
    var baseLoot = /* ... 计算基础掉落 ... */;
    
    double multiplier = context.Battle.Meta?.EnhancedDropMultiplier ?? 1.0;
    
    return new Loot
    {
        Gold = (int)(baseLoot.Gold * multiplier),
        Experience = (int)(baseLoot.Experience * multiplier),
        // ...
    };
}
```

### 7.3 文档化

创建 `EnhancedDungeon设计文档.md`，描述：
- 触发条件（如何启用Enhanced模式）
- 失败惩罚（是否扣除资源）
- 掉落倍率曲线
- UI交互设计

### 7.4 测试策略

```csharp
[Fact]
public void Enhanced_Mode_Disabled_Auto_Revival()
{
    var meta = new BattleMeta 
    { 
        EnablePlayerDeath = true,
        AllowAutoRevival = false,
        EnhancedDungeonMode = true
    };
    
    var engine = CreateEngine(meta);
    
    // 让玩家死亡
    // ...
    
    // 验证战斗失败而非复活
    Assert.True(engine.Failed);
    Assert.False(engine.Completed);
}

[Fact]
public void Enhanced_Mode_Drop_Multiplier_Applied()
{
    var meta = new BattleMeta 
    { 
        EnhancedDungeonMode = true,
        EnhancedDropMultiplier = 2.0
    };
    
    // 击杀敌人，验证掉落翻倍
}
```

---

## 阶段4: 怪物攻击与技能系统

### 8.1 功能概述

将怪物从"被动木桩"升级为：
1. 具有基础攻击能力（定期对玩家造成伤害）
2. 具有简化技能系统（冷却+概率+触发类型）
3. 不引入复杂资源，使用轻量化模型

### 8.2 设计细节

#### 8.2.1 敌人定义扩展

```csharp
public class EnemyDefinition
{
    // 现有字段...
    
    // 攻击相关
    public int AttackPower { get; init; } = 0; // 0表示不攻击(向后兼容)
    public double AttackInterval { get; init; } = 2.0; // 攻击间隔(秒)
    public DamageType AttackDamageType { get; init; } = DamageType.Physical;
    
    // 技能池
    public List<MonsterSkillDefinition> Skills { get; init; } = new();
}
```

#### 8.2.2 怪物技能定义

```csharp
/// <summary>
/// 简化版怪物技能定义
/// 采用 "冷却 + 概率 + 触发类型" 轻量模型
/// </summary>
public class MonsterSkillDefinition
{
    public string Id { get; init; }
    public string Name { get; init; }
    
    // 冷却
    public double Cooldown { get; init; } // 秒
    
    // 触发
    public TriggerType Trigger { get; init; }
    public double TriggerProbability { get; init; } = 1.0; // 0.0~1.0
    
    // 效果
    public SkillEffect Effect { get; init; }
}

public enum TriggerType
{
    OnCooldown,      // 冷却好了就用
    OnHpThreshold,   // 血量低于X%时使用
    OnPlayerAttack,  // 玩家攻击时有概率触发
}

public class SkillEffect
{
    public SkillEffectType Type { get; init; }
    public int Damage { get; init; } = 0;
    public DamageType DamageType { get; init; } = DamageType.Physical;
    public string BuffId { get; init; } = ""; // 施加Buff (可选)
    public double BuffDuration { get; init; } = 0;
}

public enum SkillEffectType
{
    Damage,          // 造成伤害
    Heal,            // 自我治疗
    ApplyBuff,       // 施加Buff到玩家
    ApplyDebuff,     // 施加Debuff到玩家
}
```

#### 8.2.3 怪物攻击事件

```csharp
public record MonsterAttackTickEvent(
    double ExecuteAt,
    Encounter Monster,
    double Interval) : IGameEvent
{
    public string EventType => "MonsterAttackTick";
    
    public void Execute(BattleContext context)
    {
        // 检查怪物是否存活
        if (Monster.IsDead)
            return;
        
        // 检查是否有存活玩家
        if (context.Player.IsDead)
        {
            // 玩家死亡，不攻击，等待复活后重新调度
            return;
        }
        
        // 计算伤害
        int damage = Monster.Enemy.AttackPower;
        
        // 应用伤害到玩家
        DamageCalculator.ApplyDamageToPlayer(
            context,
            $"monster:{Monster.Enemy.Id}",
            damage,
            context.Clock.CurrentTime);
        
        context.SegmentCollector.OnTag(
            $"monster_attack:{Monster.Enemy.Id}", 1);
        
        // 调度下一次攻击
        double nextAttackAt = ExecuteAt + Interval;
        context.Scheduler.Schedule(
            new MonsterAttackTickEvent(nextAttackAt, Monster, Interval));
    }
}
```

#### 8.2.4 怪物技能系统

```csharp
/// <summary>
/// 怪物技能管理器 (每个 Encounter 一个实例)
/// </summary>
public class MonsterSkillSystem
{
    private readonly Encounter _monster;
    private readonly Dictionary<string, double> _cooldowns = new();
    
    public MonsterSkillSystem(Encounter monster)
    {
        _monster = monster;
    }
    
    public void Initialize(BattleContext context, double now)
    {
        foreach (var skill in _monster.Enemy.Skills)
        {
            _cooldowns[skill.Id] = now; // 初始可用
            
            // 为 OnCooldown 类型的技能调度初次检查
            if (skill.Trigger == TriggerType.OnCooldown)
            {
                context.Scheduler.Schedule(
                    new MonsterSkillCheckEvent(now + skill.Cooldown, _monster, skill));
            }
        }
    }
    
    public void TryTriggerSkill(
        BattleContext context,
        MonsterSkillDefinition skill,
        double now)
    {
        // 检查冷却
        if (_cooldowns[skill.Id] > now)
            return;
        
        // 检查概率
        if (!context.Rng.NextBool(skill.TriggerProbability))
            return;
        
        // 执行技能
        ExecuteSkill(context, skill, now);
        
        // 设置冷却
        _cooldowns[skill.Id] = now + skill.Cooldown;
    }
    
    private void ExecuteSkill(
        BattleContext context,
        MonsterSkillDefinition skill,
        double now)
    {
        context.SegmentCollector.OnTag(
            $"monster_skill:{skill.Id}", 1);
        
        switch (skill.Effect.Type)
        {
            case SkillEffectType.Damage:
                DamageCalculator.ApplyDamageToPlayer(
                    context,
                    $"skill:{skill.Id}",
                    skill.Effect.Damage,
                    now);
                break;
            
            case SkillEffectType.Heal:
                int healAmount = skill.Effect.Damage; // 复用字段
                _monster.Heal(healAmount);
                context.SegmentCollector.OnTag(
                    $"monster_heal:{skill.Id}", healAmount);
                break;
            
            // ... 其他效果类型
        }
    }
}

// 在 Encounter 中添加
public class Encounter
{
    // 现有字段...
    
    public MonsterSkillSystem? SkillSystem { get; private set; }
    
    public void InitializeSkills(BattleContext context, double now)
    {
        if (Enemy.Skills.Count > 0)
        {
            SkillSystem = new MonsterSkillSystem(this);
            SkillSystem.Initialize(context, now);
        }
    }
    
    public void Heal(int amount)
    {
        CurrentHp = Math.Min(CurrentHp + amount, Enemy.MaxHp);
    }
}
```

#### 8.2.5 技能检查事件

```csharp
public record MonsterSkillCheckEvent(
    double ExecuteAt,
    Encounter Monster,
    MonsterSkillDefinition Skill) : IGameEvent
{
    public string EventType => "MonsterSkillCheck";
    
    public void Execute(BattleContext context)
    {
        if (Monster.IsDead)
            return;
        
        // 尝试触发技能
        Monster.SkillSystem?.TryTriggerSkill(context, Skill, ExecuteAt);
        
        // 调度下次检查 (OnCooldown 类型)
        if (Skill.Trigger == TriggerType.OnCooldown)
        {
            context.Scheduler.Schedule(
                new MonsterSkillCheckEvent(
                    ExecuteAt + Skill.Cooldown,
                    Monster,
                    Skill));
        }
    }
}
```

#### 8.2.6 初始化修改

```csharp
// 在 BattleEngine 构造函数中
foreach (var encounter in Context.EncounterGroup.All)
{
    // 初始化怪物技能
    encounter.InitializeSkills(Context, Clock.CurrentTime);
    
    // 调度怪物攻击 (如果有攻击力)
    if (encounter.Enemy.AttackPower > 0)
    {
        double firstAttackAt = Clock.CurrentTime + encounter.Enemy.AttackInterval;
        Scheduler.Schedule(
            new MonsterAttackTickEvent(
                firstAttackAt,
                encounter,
                encounter.Enemy.AttackInterval));
    }
}
```

### 8.3 示例怪物定义

```csharp
// 在 EnemyRegistry 中添加
public static EnemyDefinition GoblinWarrior => new EnemyDefinition(
    id: "goblin_warrior",
    name: "Goblin Warrior",
    level: 5,
    maxHp: 150,
    armor: 10,
    attackPower: 15,
    attackInterval: 2.5,
    skills: new List<MonsterSkillDefinition>
    {
        new MonsterSkillDefinition
        {
            Id = "goblin_slash",
            Name = "Power Slash",
            Cooldown = 8.0,
            Trigger = TriggerType.OnCooldown,
            TriggerProbability = 1.0,
            Effect = new SkillEffect
            {
                Type = SkillEffectType.Damage,
                Damage = 30,
                DamageType = DamageType.Physical
            }
        },
        new MonsterSkillDefinition
        {
            Id = "goblin_enrage",
            Name = "Enrage",
            Cooldown = 15.0,
            Trigger = TriggerType.OnHpThreshold,
            TriggerProbability = 1.0,
            Effect = new SkillEffect
            {
                Type = SkillEffectType.ApplyBuff,
                BuffId = "enrage",
                BuffDuration = 6.0
            }
        }
    }
);
```

### 8.4 向后兼容保证

```csharp
// 现有敌人默认 AttackPower = 0，不调度攻击事件
// 现有敌人 Skills 列表为空，不初始化技能系统
// 行为完全保持"木桩模式"
```

### 8.5 测试策略

```csharp
[Fact]
public void Monster_Attacks_Player_At_Regular_Intervals()
{
    var enemy = new EnemyDefinition(
        "test", "Test", 1, 100,
        attackPower: 10,
        attackInterval: 1.0);
    
    var engine = CreateEngine(enemy, meta: new BattleMeta 
    { 
        EnablePlayerDeath = true 
    });
    
    engine.AdvanceTo(10.0, 1000);
    
    // 验证玩家受到约10次攻击 (10秒 / 1秒间隔)
    int damageCount = /* 从 segment 获取 */;
    Assert.InRange(damageCount, 8, 12);
}

[Fact]
public void Monster_Skill_Triggers_On_Cooldown()
{
    var skill = new MonsterSkillDefinition
    {
        Id = "test_skill",
        Cooldown = 5.0,
        Trigger = TriggerType.OnCooldown,
        TriggerProbability = 1.0,
        Effect = new SkillEffect { Type = SkillEffectType.Damage, Damage = 50 }
    };
    
    var enemy = new EnemyDefinition(
        "test", "Test", 1, 100,
        skills: new List<MonsterSkillDefinition> { skill });
    
    var engine = CreateEngine(enemy, meta: new BattleMeta 
    { 
        EnablePlayerDeath = true 
    });
    
    engine.AdvanceTo(25.0, 1000);
    
    // 验证技能触发约5次 (25秒 / 5秒CD)
    int skillCount = /* 从 segment 获取 monster_skill:test_skill */;
    Assert.InRange(skillCount, 4, 6);
}

[Fact]
public void RNG_Consistency_With_Monster_Skills()
{
    // 相同种子运行两次
    // 验证怪物技能触发次数和概率事件完全相同
}
```

---

## 阶段5: 测试与验证策略

### 9.1 单元测试

| 测试类 | 覆盖范围 | 优先级 |
|--------|---------|--------|
| PlayerRevivalTests | 玩家死亡、复活、状态检查 | P0 |
| TargetSelectionTests | 随机目标选取、权重分布 | P1 |
| MonsterAttackTests | 怪物攻击、伤害计算 | P1 |
| MonsterSkillTests | 技能触发、冷却、概率 | P1 |
| EnhancedDungeonTests | 战斗失败、掉落倍率 | P2 |
| RngConsistencyTests | 所有新功能的RNG一致性 | P0 |

### 9.2 集成测试

```csharp
[Fact]
public void Full_Combat_With_All_New_Features()
{
    // 创建包含所有新功能的战斗
    var meta = new BattleMeta
    {
        EnablePlayerDeath = true,
        UseWeightedTargetSelection = true,
        AllowAutoRevival = true,
        PlayerRevivalDelaySeconds = 5.0
    };
    
    var enemy = new EnemyDefinition(
        "boss", "Test Boss", 10, 500,
        attackPower: 20,
        attackInterval: 2.0,
        skills: new List<MonsterSkillDefinition> { /* 3个技能 */ });
    
    var engine = CreateEngine(enemy, enemyCount: 3, meta: meta);
    
    // 运行60秒战斗
    engine.AdvanceTo(60.0, 10000);
    
    // 验证
    Assert.True(engine.Completed || engine.Failed || engine.Context.Player.IsDead);
    
    // 验证段数据完整性
    Assert.True(engine.Segments.Count > 0);
    
    // 验证RNG一致性
    var seed = engine.Context.Rng.Index;
    var replay = CreateEngine(enemy, enemyCount: 3, meta: meta, seed: seed);
    replay.AdvanceTo(60.0, 10000);
    Assert.Equal(engine.Context.Rng.Index, replay.Context.Rng.Index);
}
```

### 9.3 性能测试

```csharp
[Fact]
public void Performance_Offline_FastForward_With_Monster_Attacks()
{
    // 测试离线快进性能
    var engine = CreateEngine(/* 启用怪物攻击 */);
    
    var sw = Stopwatch.StartNew();
    engine.AdvanceTo(3600.0, 100000); // 1小时战斗
    sw.Stop();
    
    // 验证性能下降 < 10%
    Assert.True(sw.ElapsedMilliseconds < baselineMs * 1.1);
}
```

### 9.4 回归测试

```csharp
[Fact]
public void Backward_Compatibility_Existing_Battles_Still_Work()
{
    // 使用旧版配置（不启用新功能）
    var meta = new BattleMeta
    {
        EnablePlayerDeath = false, // 关键
        UseWeightedTargetSelection = false
    };
    
    // 使用旧版敌人（无攻击力）
    var enemy = EnemyRegistry.Get("dummy"); // 现有木桩敌人
    
    var engine = CreateEngine(enemy, meta: meta);
    engine.AdvanceTo(30.0, 1000);
    
    // 验证行为与旧版完全相同
    Assert.Equal(1.0, engine.Context.Player.HpPercent); // 玩家不受伤
    Assert.True(engine.Completed); // 战斗正常结束
}
```

---

## 风险评估与缓解

### 10.1 风险矩阵

| 风险 | 概率 | 影响 | 缓解策略 |
|------|------|------|---------|
| RNG不一致破坏回放 | 中 | 高 | 严格单测 + RNG审查流程 |
| 性能退化 > 10% | 低 | 中 | 性能基准测试 + 优化 |
| 向后兼容性破坏 | 低 | 高 | 完整回归测试套件 |
| 复活机制引入死锁 | 中 | 中 | 边界条件测试 |
| 怪物技能配置错误 | 高 | 低 | 配置验证器 + 单测 |

### 10.2 缓解措施

1. **RNG一致性**
   - 每次添加 `context.Rng.Next*()` 调用时，必须通过回放测试
   - 建立 RNG 调用日志工具，用于调试

2. **性能保证**
   - 设置性能基准测试（baseline）
   - 每次提交运行性能测试，超过阈值自动失败

3. **向后兼容**
   - 所有新配置项默认为"关闭"或"旧行为"
   - 回归测试覆盖所有旧用例

4. **死锁检测**
   - 添加事件循环计数器，超过阈值强制终止
   - 单测覆盖"玩家死亡+怪物死亡"等边界情况

---

## 性能影响分析

### 11.1 预期开销

| 组件 | 额外开销 | 说明 |
|------|---------|------|
| PlayerState | +8 bytes | 2个double字段 |
| Encounter.ThreatWeight | +8 bytes | 1个double字段 |
| MonsterSkillSystem | +64 bytes | 每个怪物(如果有技能) |
| 事件数量 | +30% | 怪物攻击+技能检查 |
| 目标选取 | +O(n) | n=怪物数量，通常 < 10 |

### 11.2 优化策略

1. **懒加载技能系统**
   - 只为有技能的怪物创建 `MonsterSkillSystem`
   
2. **目标缓存**
   - 缓存"存活敌人列表"，仅在敌人死亡时更新

3. **批量事件**
   - 考虑将多个怪物攻击合并为一个批量事件（未来优化）

4. **Segment压缩**
   - 怪物攻击标签使用短名称
   - 相同事件类型合并计数

### 11.3 基准测试

```csharp
// 基准：现有战斗系统（无怪物攻击）
// 1小时战斗，3个敌人，耗时 ~50ms

// 预期：新系统（含怪物攻击）
// 1小时战斗，3个敌人，耗时 ~55ms (+10%)
```

---

## 向后兼容性保证

### 12.1 兼容性原则

1. **默认关闭新功能**
   - `EnablePlayerDeath = false`
   - `UseWeightedTargetSelection = false`
   - `AllowAutoRevival = true`

2. **现有敌人保持木桩模式**
   - `AttackPower = 0` → 不调度攻击事件
   - `Skills = []` → 不初始化技能系统

3. **API不变**
   - 现有 `BattleEngine` 构造函数不修改
   - 仅添加可选参数或重载

4. **数据库兼容**
   - 新字段为可空或有默认值
   - 不删除现有字段

### 12.2 迁移路径

**阶段1: 共存期**（1-2周）
- 新旧代码共存，通过配置标志切换
- 前端不强制更新

**阶段2: 灰度发布**（1周）
- 部分玩家启用新功能（Beta测试）
- 收集反馈和性能数据

**阶段3: 全量启用**（1周后）
- 新创建的战斗默认启用新功能
- 现有战斗保持旧配置

**阶段4: 淘汰旧模式**（3个月后）
- 可选：强制迁移旧配置到新配置
- 移除兼容性代码

---

## 实施时间表

### 13.1 时间估算

| 阶段 | 开发 | 测试 | 总计 | 依赖 |
|------|------|------|------|------|
| 阶段1: 玩家复活 | 3天 | 2天 | 5天 | - |
| 阶段2: 目标选取 | 2天 | 1天 | 3天 | - |
| 阶段3: Enhanced Dungeon | 1天 | 1天 | 2天 | 阶段1 |
| 阶段4: 怪物攻击与技能 | 5天 | 3天 | 8天 | 阶段1 |
| 阶段5: 集成测试 | - | 3天 | 3天 | 全部 |
| 文档与审查 | 2天 | - | 2天 | 全部 |
| **总计** | **13天** | **10天** | **23天** | - |

### 13.2 里程碑

| 里程碑 | 日期 | 可交付成果 |
|--------|------|-----------|
| M1: 玩家复活完成 | Day 5 | 玩家死亡/复活机制 + 单测 |
| M2: 目标选取完成 | Day 8 | 随机目标选取 + 单测 |
| M3: Enhanced Dungeon完成 | Day 10 | 配置扩展 + 文档 |
| M4: 怪物系统完成 | Day 18 | 怪物攻击+技能 + 单测 |
| M5: 集成测试完成 | Day 21 | 全功能集成测试 |
| M6: 文档审查完成 | Day 23 | 实施完成报告 |

### 13.3 并行化机会

- 阶段1和阶段2可并行开发（不同模块）
- 阶段3可在阶段1完成后立即开始
- 阶段4依赖阶段1（玩家受伤机制）

---

## 附录

### 附录A: 代码文件清单

#### 新增文件

```
BlazorIdle.Server/Domain/Combat/
├── PlayerState.cs                      // 玩家状态
├── PlayerRevivalEvent.cs               // 复活事件
├── BattleFailureEvent.cs               // 战斗失败事件
├── TargetSelector.cs                   // 目标选取器
├── MonsterAttackTickEvent.cs           // 怪物攻击事件
├── MonsterSkillDefinition.cs           // 怪物技能定义
├── MonsterSkillSystem.cs               // 怪物技能管理
├── MonsterSkillCheckEvent.cs           // 技能检查事件
└── SkillEffect.cs                      // 技能效果

tests/BlazorIdle.Tests/
├── PlayerRevivalTests.cs
├── TargetSelectionTests.cs
├── MonsterAttackTests.cs
├── MonsterSkillTests.cs
├── EnhancedDungeonTests.cs
└── CombatSystemRegressionTests.cs

docs/
├── 战斗系统扩展-实施完成报告.md
├── EnhancedDungeon设计文档.md
└── 怪物技能配置指南.md
```

#### 修改文件

```
BlazorIdle.Server/Domain/Combat/
├── BattleContext.cs                    // +PlayerState 字段
├── BattleEngine.cs                     // +怪物初始化逻辑
├── Encounter.cs                        // +ThreatWeight, +SkillSystem
├── AttackTickEvent.cs                  // +玩家死亡检查, +随机目标
├── DamageCalculator.cs                 // +ApplyDamageToPlayer()
└── Enemies/EnemyDefinition.cs          // +攻击属性, +技能池

BlazorIdle.Shared/Models/
└── BattleMeta.cs                       // +复活/Enhanced配置

BlazorIdle.Server/Domain/Combat/Enemies/
└── EnemyRegistry.cs                    // +示例怪物定义
```

### 附录B: 配置示例

```csharp
// 示例1: 启用所有新功能
var meta = new BattleMeta
{
    EnablePlayerDeath = true,
    PlayerRevivalDelaySeconds = 10.0,
    UseWeightedTargetSelection = true,
    AllowAutoRevival = true,
    EnhancedDungeonMode = false
};

// 示例2: Enhanced Dungeon 模式
var meta = new BattleMeta
{
    EnablePlayerDeath = true,
    AllowAutoRevival = false,
    EnhancedDungeonMode = true,
    EnhancedDropMultiplier = 2.5
};

// 示例3: 向后兼容（默认配置）
var meta = new BattleMeta(); // 所有新功能关闭
```

### 附录C: 术语表

| 术语 | 英文 | 定义 |
|------|------|------|
| 复活机制 | Revival System | 玩家死亡后自动复活的功能 |
| 仇恨权重 | Threat Weight | 决定敌人被攻击概率的数值 |
| Enhanced Dungeon | Enhanced Dungeon | 高难度地下城模式 |
| 木桩模式 | Dummy Mode | 敌人不攻击，只作为攻击目标 |
| 轻量化技能 | Lightweight Skill | 基于冷却+概率的简化技能模型 |
| RNG一致性 | RNG Consistency | 相同种子产生相同随机序列 |

### 附录D: 参考资料

1. 整合设计总结.txt - 战斗系统架构概述
2. 战斗攻击进度优化报告.md - 现有攻击进度机制
3. 战斗信息优化报告.md - 多怪物血量传输
4. BattleInfoTransmissionTests.cs - 现有测试参考
5. BattleEngine.cs - 事件调度实现

---

## 结论

本方案采用**分阶段、最小增量**的方式扩展战斗系统，确保：

✅ **向后兼容** - 现有功能不受影响  
✅ **RNG一致** - 战斗回放完全可重现  
✅ **可测试** - 每个阶段独立测试  
✅ **可扩展** - 为未来功能预留接口  
✅ **高质量** - 详细设计+完整测试覆盖

预计总开发时间: **23个工作日**  
推荐实施策略: **按阶段串行实施，每个阶段完成后进行审查**

---

**文档版本**: 1.0  
**创建日期**: 2025-01-09  
**最后更新**: 2025-01-09  
**状态**: 待审核 ✋

