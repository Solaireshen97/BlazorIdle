# BlazorIdle æ•°æ®åº“è¿›ä¸€æ­¥ä¼˜åŒ–å®æ–½æ–¹æ¡ˆ - ä¸­ç¯‡

**é¡¹ç›®åç§°**: BlazorIdle æ•°æ®åº“è¿›ä¸€æ­¥ä¼˜åŒ–  
**æ–¹æ¡ˆç‰ˆæœ¬**: 1.0  
**ç¼–åˆ¶æ—¥æœŸ**: 2025-10-19  
**é€‚ç”¨èŒƒå›´**: Phase 5 - æ™ºèƒ½é¢„åŠ è½½ä¸ç¼“å­˜é¢„çƒ­

---

## ğŸ“‹ æ–‡æ¡£è¯´æ˜

æœ¬æ–‡æ¡£æ˜¯ã€Šæ•°æ®åº“æ“ä½œæ·±åº¦åˆ†ææŠ¥å‘Šã€‹çš„é…å¥—å®æ–½æ–¹æ¡ˆï¼ˆä¸­ç¯‡ï¼‰ï¼š
- **ä¸Šç¯‡**: Phase 4 - æŸ¥è¯¢ä¼˜åŒ–ä¸ç´¢å¼•å¢å¼º
- **ä¸­ç¯‡ (æœ¬æ–‡æ¡£)**: Phase 5 - æ™ºèƒ½é¢„åŠ è½½ä¸ç¼“å­˜é¢„çƒ­
- **ä¸‹ç¯‡**: Phase 6 - å®æ—¶ç›‘æ§ä¸å¯è§†åŒ–

**é‡è¦æç¤º**: 
- å»ºè®®å…ˆå®æ–½ Phase 4 å’Œ Phase 6ï¼Œæ ¹æ®ç›‘æ§æ•°æ®å†³å®šæ˜¯å¦éœ€è¦ Phase 5
- Phase 5 ä¸º**å¯é€‰å¢å¼º**ï¼Œéå¿…é¡»
- å®æ–½å¤æ‚åº¦è¾ƒé«˜ï¼Œå»ºè®®å……åˆ†è¯„ä¼°æ”¶ç›Š

---

## ğŸ¯ Phase 5: æ™ºèƒ½é¢„åŠ è½½ä¸ç¼“å­˜é¢„çƒ­

### ç›®æ ‡ä¸é¢„æœŸæ•ˆæœ

**ä¼˜åŒ–ç›®æ ‡**:
1. æå‡ç¼“å­˜å‘½ä¸­ç‡ 5-10%
2. å‡å°‘ç”¨æˆ·ç™»å½•åçš„"å†·å¯åŠ¨"å»¶è¿Ÿ
3. åŸºäºè®¿é—®æ¨¡å¼æ™ºèƒ½é¢„æµ‹å’Œé¢„åŠ è½½æ•°æ®
4. å®šæœŸé¢„çƒ­çƒ­ç‚¹æ•°æ®

**é¢„æœŸæ•ˆæœ**:
- âœ… ç¼“å­˜å‘½ä¸­ç‡ä» 80-90% æå‡åˆ° 85-95%
- âœ… ç™»å½•åé¦–æ¬¡æ•°æ®è®¿é—®å»¶è¿Ÿé™ä½ 70%
- âœ… ç”¨æˆ·ä½“éªŒæ”¹å–„ï¼ˆæ•°æ®åŠ è½½æ›´æµç•…ï¼‰
- âœ… é¢„åŠ è½½å‡†ç¡®ç‡ > 60%

**ä¼˜å…ˆçº§**: â­â­â­ (ä¸­ä¼˜å…ˆçº§)

**å·¥æ—¶ä¼°ç®—**: 25-30 äººæ—¥

**é£é™©çº§åˆ«**: ä¸­-é«˜

---

## ğŸ“Š é˜¶æ®µè§„åˆ’

### æ€»ä½“åˆ†ä¸º 6 ä¸ªå­é˜¶æ®µ

| é˜¶æ®µ | ä»»åŠ¡ | å·¥æ—¶ | é£é™© | ä¼˜å…ˆçº§ |
|------|------|------|------|--------|
| 5.1 | è®¿é—®æ¨¡å¼åˆ†æå™¨è®¾è®¡ä¸å®ç° | 5-6 å¤© | ä¸­ | P0 |
| 5.2 | ç”¨æˆ·ç™»å½•é¢„åŠ è½½æœåŠ¡ | 4-5 å¤© | ä½ | P0 |
| 5.3 | æ™ºèƒ½é¢„æµ‹å¼•æ“ | 6-7 å¤© | é«˜ | P1 |
| 5.4 | å®šæœŸç¼“å­˜é¢„çƒ­ä»»åŠ¡ | 4-5 å¤© | ä½ | P1 |
| 5.5 | ç›‘æ§ä¸è°ƒä¼˜ | 3-4 å¤© | ä½ | P0 |
| 5.6 | A/B æµ‹è¯•ä¸éªŒè¯ | 3-4 å¤© | ä½ | P0 |

**æ€»å·¥æ—¶**: 25-31 å¤©

---

## ğŸ” é˜¶æ®µ 5.1: è®¿é—®æ¨¡å¼åˆ†æå™¨

### 5.1.1 è®¾è®¡æ€è·¯

**æ ¸å¿ƒæ¦‚å¿µ**: è®°å½•ç”¨æˆ·è®¿é—®å®ä½“çš„åºåˆ—ï¼Œå­¦ä¹ è®¿é—®æ¨¡å¼ï¼Œé¢„æµ‹ä¸‹æ¬¡å¯èƒ½è®¿é—®çš„å®ä½“

**è®¿é—®æ¨¡å¼ç¤ºä¾‹**:
```
ç”¨æˆ·ç™»å½• â†’ æŸ¥è¯¢è§’è‰² â†’ æŸ¥è¯¢è£…å¤‡ â†’ æŸ¥è¯¢æˆ˜æ–—å¿«ç…§ â†’ æŸ¥è¯¢æ´»åŠ¨è®¡åˆ’
```

**é¢„æµ‹é€»è¾‘**:
```
è®¿é—® Character#123 â†’ é¢„æµ‹å¯èƒ½è®¿é—® GearInstance#456, #789
è®¿é—® Battle#111 â†’ é¢„æµ‹å¯èƒ½è®¿é—® Character#123, Enemy#222
```

### 5.1.2 æ•°æ®ç»“æ„è®¾è®¡

**æ–‡ä»¶**: `BlazorIdle.Server/Infrastructure/DatabaseOptimization/IntelligentCache/AccessPatternAnalyzer.cs`

```csharp
using System.Collections.Concurrent;

namespace BlazorIdle.Server.Infrastructure.DatabaseOptimization.IntelligentCache;

/// <summary>
/// è®¿é—®æ¨¡å¼åˆ†æå™¨ - å­¦ä¹ å’Œé¢„æµ‹æ•°æ®è®¿é—®æ¨¡å¼
/// Access Pattern Analyzer - Learn and predict data access patterns
/// </summary>
public class AccessPatternAnalyzer
{
    // è®¿é—®åºåˆ—å­˜å‚¨: UserId â†’ è®¿é—®åºåˆ—
    private readonly ConcurrentDictionary<Guid, AccessSequence> _userSequences = new();
    
    // æ¨¡å¼åº“: EntityType+EntityId â†’ åç»­è®¿é—®çš„å®ä½“åˆ—è¡¨
    private readonly ConcurrentDictionary<string, EntityAccessPattern> _patterns = new();
    
    private readonly ILogger<AccessPatternAnalyzer> _logger;
    private readonly IOptions<IntelligentCacheOptions> _options;
    
    public AccessPatternAnalyzer(
        ILogger<AccessPatternAnalyzer> logger,
        IOptions<IntelligentCacheOptions> options)
    {
        _logger = logger;
        _options = options;
    }
    
    /// <summary>
    /// è®°å½•è®¿é—®äº‹ä»¶
    /// Record access event
    /// </summary>
    public void RecordAccess(
        Guid userId,
        string entityType,
        Guid entityId,
        string? relatedType = null,
        Guid? relatedId = null)
    {
        if (!_options.Value.EnableAccessPatternAnalysis)
            return;
        
        // æ›´æ–°ç”¨æˆ·è®¿é—®åºåˆ—
        var sequence = _userSequences.GetOrAdd(userId, _ => new AccessSequence());
        sequence.AddAccess(new AccessEvent
        {
            Timestamp = DateTime.UtcNow,
            EntityType = entityType,
            EntityId = entityId,
            RelatedType = relatedType,
            RelatedId = relatedId
        });
        
        // æ›´æ–°æ¨¡å¼åº“
        UpdatePattern(entityType, entityId, relatedType, relatedId);
    }
    
    /// <summary>
    /// é¢„æµ‹ä¸‹æ¬¡å¯èƒ½è®¿é—®çš„å®ä½“
    /// Predict next possible entities
    /// </summary>
    public IEnumerable<PredictedEntity> PredictNext(
        string currentEntityType,
        Guid currentEntityId,
        int topN = 5)
    {
        if (!_options.Value.EnableIntelligentPreload)
            return Enumerable.Empty<PredictedEntity>();
        
        var key = GetPatternKey(currentEntityType, currentEntityId);
        
        if (_patterns.TryGetValue(key, out var pattern))
        {
            return pattern.GetTopPredictions(topN);
        }
        
        return Enumerable.Empty<PredictedEntity>();
    }
    
    private void UpdatePattern(
        string entityType,
        Guid entityId,
        string? nextType,
        Guid? nextId)
    {
        if (string.IsNullOrEmpty(nextType) || !nextId.HasValue)
            return;
        
        var key = GetPatternKey(entityType, entityId);
        var pattern = _patterns.GetOrAdd(key, _ => new EntityAccessPattern());
        
        pattern.RecordFollowUp(nextType, nextId.Value);
    }
    
    private string GetPatternKey(string entityType, Guid entityId)
    {
        return $"{entityType}:{entityId}";
    }
}

/// <summary>
/// è®¿é—®åºåˆ—
/// Access sequence
/// </summary>
public class AccessSequence
{
    private readonly Queue<AccessEvent> _events = new();
    private readonly object _lock = new();
    private const int MaxSequenceLength = 100;
    
    public void AddAccess(AccessEvent @event)
    {
        lock (_lock)
        {
            _events.Enqueue(@event);
            
            // ä¿æŒåºåˆ—é•¿åº¦
            while (_events.Count > MaxSequenceLength)
                _events.Dequeue();
        }
    }
    
    public IEnumerable<AccessEvent> GetRecentEvents(int count = 10)
    {
        lock (_lock)
        {
            return _events.TakeLast(count).ToList();
        }
    }
}

/// <summary>
/// è®¿é—®äº‹ä»¶
/// Access event
/// </summary>
public class AccessEvent
{
    public DateTime Timestamp { get; set; }
    public required string EntityType { get; set; }
    public Guid EntityId { get; set; }
    public string? RelatedType { get; set; }
    public Guid? RelatedId { get; set; }
}

/// <summary>
/// å®ä½“è®¿é—®æ¨¡å¼
/// Entity access pattern
/// </summary>
public class EntityAccessPattern
{
    // åç»­è®¿é—®: EntityType+EntityId â†’ è®¿é—®æ¬¡æ•°
    private readonly ConcurrentDictionary<string, int> _followUps = new();
    
    public void RecordFollowUp(string entityType, Guid entityId)
    {
        var key = $"{entityType}:{entityId}";
        _followUps.AddOrUpdate(key, 1, (_, count) => count + 1);
    }
    
    public IEnumerable<PredictedEntity> GetTopPredictions(int topN)
    {
        return _followUps
            .OrderByDescending(kv => kv.Value)
            .Take(topN)
            .Select(kv =>
            {
                var parts = kv.Key.Split(':');
                return new PredictedEntity
                {
                    EntityType = parts[0],
                    EntityId = Guid.Parse(parts[1]),
                    Confidence = CalculateConfidence(kv.Value)
                };
            });
    }
    
    private double CalculateConfidence(int accessCount)
    {
        var total = _followUps.Values.Sum();
        return total > 0 ? (double)accessCount / total : 0.0;
    }
}

/// <summary>
/// é¢„æµ‹å®ä½“
/// Predicted entity
/// </summary>
public class PredictedEntity
{
    public required string EntityType { get; set; }
    public Guid EntityId { get; set; }
    public double Confidence { get; set; } // 0.0 - 1.0
}
```

### 5.1.3 é›†æˆåˆ° Repository

**æ›´æ–°**: `RepositoryBase<T>.GetAsync`

```csharp
public override async Task<T?> GetAsync(Guid id, CancellationToken ct = default)
{
    // åŸæœ‰é€»è¾‘...
    var entity = await base_GetAsync(id, ct);
    
    // è®°å½•è®¿é—®ï¼ˆç”¨äºæ¨¡å¼å­¦ä¹ ï¼‰
    var userId = GetCurrentUserId(); // ä»ä¸Šä¸‹æ–‡è·å–
    if (userId.HasValue)
    {
        _accessPatternAnalyzer?.RecordAccess(
            userId.Value,
            typeof(T).Name,
            id
        );
    }
    
    return entity;
}
```

### 5.1.4 é…ç½®

```json
{
  "IntelligentCache": {
    "EnableAccessPatternAnalysis": true,
    "MaxPatternHistoryDays": 7,
    "MaxSequenceLength": 100,
    "MinPatternConfidence": 0.3
  }
}
```

---

## ğŸš€ é˜¶æ®µ 5.2: ç”¨æˆ·ç™»å½•é¢„åŠ è½½æœåŠ¡

### 5.2.1 è®¾è®¡æ€è·¯

ç”¨æˆ·ç™»å½•æ—¶ï¼Œé¢„åŠ è½½å¸¸ç”¨æ•°æ®ï¼š
1. ç”¨æˆ·çš„æ‰€æœ‰è§’è‰²
2. æ´»è·ƒè§’è‰²çš„è£…å¤‡
3. è¿›è¡Œä¸­çš„æˆ˜æ–—å¿«ç…§
4. æ´»åŠ¨è®¡åˆ’

### 5.2.2 å®ç°

**æ–‡ä»¶**: `BlazorIdle.Server/Infrastructure/DatabaseOptimization/IntelligentCache/LoginPreloadService.cs`

```csharp
namespace BlazorIdle.Server.Infrastructure.DatabaseOptimization.IntelligentCache;

/// <summary>
/// ç™»å½•é¢„åŠ è½½æœåŠ¡ - ç”¨æˆ·ç™»å½•æ—¶é¢„åŠ è½½å¸¸ç”¨æ•°æ®
/// Login Preload Service - Preload frequently used data on user login
/// </summary>
public class LoginPreloadService
{
    private readonly IServiceScopeFactory _scopeFactory;
    private readonly ILogger<LoginPreloadService> _logger;
    private readonly IOptions<IntelligentCacheOptions> _options;
    private readonly AccessPatternAnalyzer? _patternAnalyzer;
    
    public LoginPreloadService(
        IServiceScopeFactory scopeFactory,
        ILogger<LoginPreloadService> logger,
        IOptions<IntelligentCacheOptions> options,
        AccessPatternAnalyzer? patternAnalyzer = null)
    {
        _scopeFactory = scopeFactory;
        _logger = logger;
        _options = options;
        _patternAnalyzer = patternAnalyzer;
    }
    
    /// <summary>
    /// ç”¨æˆ·ç™»å½•æ—¶è§¦å‘é¢„åŠ è½½
    /// Trigger preload on user login
    /// </summary>
    public async Task PreloadUserDataAsync(
        Guid userId,
        CancellationToken ct = default)
    {
        if (!_options.Value.PreloadOnLogin)
            return;
        
        _logger.LogInformation("å¼€å§‹ä¸ºç”¨æˆ· {UserId} é¢„åŠ è½½æ•°æ®", userId);
        var stopwatch = Stopwatch.StartNew();
        
        try
        {
            using var scope = _scopeFactory.CreateScope();
            
            // 1. é¢„åŠ è½½è§’è‰²åŸºæœ¬ä¿¡æ¯
            var characterRepo = scope.ServiceProvider
                .GetRequiredService<ICharacterRepository>();
            var characters = await characterRepo.GetByUserIdAsync(userId, ct);
            
            _logger.LogDebug("é¢„åŠ è½½äº† {Count} ä¸ªè§’è‰²", characters.Count);
            
            // 2. å¹¶è¡Œé¢„åŠ è½½å…³è”æ•°æ®
            var preloadTasks = new List<Task>();
            
            foreach (var character in characters)
            {
                preloadTasks.Add(PreloadCharacterDataAsync(
                    scope.ServiceProvider,
                    character.Id,
                    ct));
            }
            
            await Task.WhenAll(preloadTasks);
            
            // 3. åŸºäºè®¿é—®æ¨¡å¼é¢„æµ‹å¹¶é¢„åŠ è½½
            if (_patternAnalyzer != null && _options.Value.EnableIntelligentPreload)
            {
                await PreloadPredictedDataAsync(
                    scope.ServiceProvider,
                    userId,
                    characters,
                    ct);
            }
            
            stopwatch.Stop();
            _logger.LogInformation(
                "ç”¨æˆ· {UserId} æ•°æ®é¢„åŠ è½½å®Œæˆï¼Œè€—æ—¶ {ElapsedMs}ms",
                userId, stopwatch.ElapsedMilliseconds);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "ç”¨æˆ· {UserId} æ•°æ®é¢„åŠ è½½å¤±è´¥", userId);
            // ä¸æŠ›å‡ºå¼‚å¸¸ï¼Œå…è®¸ç™»å½•ç»§ç»­
        }
    }
    
    private async Task PreloadCharacterDataAsync(
        IServiceProvider services,
        Guid characterId,
        CancellationToken ct)
    {
        var batchSize = _options.Value.PreloadBatchSize;
        
        // é¢„åŠ è½½è£…å¤‡
        var gearRepo = services.GetRequiredService<IGearInstanceRepository>();
        // å‡è®¾æœ‰æ–¹æ³•è·å–è§’è‰²è£…å¤‡
        // await gearRepo.GetByCharacterIdAsync(characterId, ct);
        
        // é¢„åŠ è½½æ´»åŠ¨è®¡åˆ’
        var activityRepo = services.GetRequiredService<IActivityPlanRepository>();
        // await activityRepo.GetByCharacterIdAsync(characterId, ct);
        
        // é¢„åŠ è½½æˆ˜æ–—å¿«ç…§
        var battleRepo = services.GetRequiredService<IBattleRepository>();
        // await battleRepo.GetActiveByCharacterIdAsync(characterId, ct);
    }
    
    private async Task PreloadPredictedDataAsync(
        IServiceProvider services,
        Guid userId,
        IReadOnlyList<Character> characters,
        CancellationToken ct)
    {
        if (_patternAnalyzer == null)
            return;
        
        var predictions = new List<PredictedEntity>();
        
        // åŸºäºæœ€è¿‘è®¿é—®çš„è§’è‰²é¢„æµ‹
        foreach (var character in characters.Take(3)) // æœ€å¤š3ä¸ªè§’è‰²
        {
            var predicted = _patternAnalyzer.PredictNext(
                "Character",
                character.Id,
                topN: 5
            );
            
            predictions.AddRange(predicted);
        }
        
        // è¿‡æ»¤ä½ç½®ä¿¡åº¦é¢„æµ‹
        var minConfidence = _options.Value.MinPatternConfidence;
        var filteredPredictions = predictions
            .Where(p => p.Confidence >= minConfidence)
            .ToList();
        
        _logger.LogDebug(
            "åŸºäºæ¨¡å¼é¢„æµ‹äº† {Count} ä¸ªå®ä½“ï¼ˆç½®ä¿¡åº¦ >= {MinConfidence}ï¼‰",
            filteredPredictions.Count, minConfidence);
        
        // é¢„åŠ è½½é¢„æµ‹çš„å®ä½“
        // TODO: æ ¹æ® EntityType åˆ†å‘åˆ°å¯¹åº”çš„ Repository
    }
}
```

### 5.2.3 é›†æˆåˆ°ç™»å½•æµç¨‹

**æ–‡ä»¶**: `BlazorIdle.Server/Api/AuthController.cs`

```csharp
[HttpPost("login")]
public async Task<IActionResult> Login([FromBody] LoginRequest request)
{
    // åŸæœ‰ç™»å½•é€»è¾‘...
    var result = await _authService.LoginAsync(request.Username, request.Password);
    
    if (result.Success)
    {
        var userId = result.UserId;
        
        // è§¦å‘é¢„åŠ è½½ï¼ˆå¼‚æ­¥ï¼Œä¸é˜»å¡ç™»å½•å“åº”ï¼‰
        _ = Task.Run(async () =>
        {
            try
            {
                await _preloadService.PreloadUserDataAsync(userId);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "é¢„åŠ è½½å¤±è´¥");
            }
        });
    }
    
    return Ok(result);
}
```

---

## ğŸ§  é˜¶æ®µ 5.3: æ™ºèƒ½é¢„æµ‹å¼•æ“ï¼ˆå¯é€‰é«˜çº§åŠŸèƒ½ï¼‰

### 5.3.1 è®¾è®¡æ€è·¯

åŸºäºæœºå™¨å­¦ä¹ æˆ–å¯å‘å¼ç®—æ³•ï¼Œé¢„æµ‹ç”¨æˆ·ä¸‹æ¬¡å¯èƒ½è®¿é—®çš„æ•°æ®ã€‚

**ç®€åŒ–æ–¹æ¡ˆ**: åŸºäºç»Ÿè®¡çš„å¯å‘å¼é¢„æµ‹
**é«˜çº§æ–¹æ¡ˆ**: ä½¿ç”¨ ML.NET è®­ç»ƒé¢„æµ‹æ¨¡å‹

æœ¬æ–¹æ¡ˆé‡‡ç”¨**ç®€åŒ–æ–¹æ¡ˆ**ã€‚

### 5.3.2 å¯å‘å¼é¢„æµ‹è§„åˆ™

```csharp
/// <summary>
/// å¯å‘å¼é¢„æµ‹å¼•æ“
/// Heuristic prediction engine
/// </summary>
public class HeuristicPredictionEngine
{
    /// <summary>
    /// é¢„æµ‹è§’è‰²å¯èƒ½è®¿é—®çš„å®ä½“
    /// </summary>
    public IEnumerable<PredictedEntity> PredictForCharacter(Character character)
    {
        var predictions = new List<PredictedEntity>();
        
        // è§„åˆ™1: å¦‚æœè§’è‰²åœ¨æˆ˜æ–—ä¸­ï¼Œé¢„åŠ è½½æˆ˜æ–—å¿«ç…§
        if (character.InBattle)
        {
            predictions.Add(new PredictedEntity
            {
                EntityType = "BattleSnapshot",
                EntityId = character.CurrentBattleId!.Value,
                Confidence = 0.9
            });
        }
        
        // è§„åˆ™2: å¦‚æœè§’è‰²æœ‰æ´»åŠ¨è®¡åˆ’ï¼Œé¢„åŠ è½½è®¡åˆ’è¯¦æƒ…
        if (character.HasActivePlans)
        {
            // é¢„æµ‹åŠ è½½æ´»åŠ¨è®¡åˆ’
            predictions.Add(new PredictedEntity
            {
                EntityType = "ActivityPlan",
                EntityId = character.Id, // ç®€åŒ–ï¼Œå®é™…éœ€æŸ¥è¯¢
                Confidence = 0.8
            });
        }
        
        // è§„åˆ™3: è£…å¤‡æ°¸è¿œæ˜¯é«˜é¢‘è®¿é—®
        predictions.Add(new PredictedEntity
        {
            EntityType = "Equipment",
            EntityId = character.Id,
            Confidence = 0.95
        });
        
        return predictions;
    }
}
```

---

## ğŸ”¥ é˜¶æ®µ 5.4: å®šæœŸç¼“å­˜é¢„çƒ­ä»»åŠ¡

### 5.4.1 è®¾è®¡æ€è·¯

å®šæœŸï¼ˆå¦‚æ¯å°æ—¶ï¼‰é¢„çƒ­çƒ­ç‚¹æ•°æ®ï¼Œç¡®ä¿ç¼“å­˜å‘½ä¸­ç‡ã€‚

### 5.4.2 å®ç°

**æ–‡ä»¶**: `BlazorIdle.Server/Infrastructure/DatabaseOptimization/IntelligentCache/CacheWarmingTask.cs`

```csharp
/// <summary>
/// ç¼“å­˜é¢„çƒ­åå°ä»»åŠ¡
/// Cache warming background task
/// </summary>
public class CacheWarmingTask : BackgroundService
{
    private readonly IServiceScopeFactory _scopeFactory;
    private readonly ILogger<CacheWarmingTask> _logger;
    private readonly IOptions<IntelligentCacheOptions> _options;
    
    public CacheWarmingTask(
        IServiceScopeFactory scopeFactory,
        ILogger<CacheWarmingTask> logger,
        IOptions<IntelligentCacheOptions> options)
    {
        _scopeFactory = scopeFactory;
        _logger = logger;
        _options = options;
    }
    
    protected override async Task ExecuteAsync(CancellationToken ct)
    {
        if (!_options.Value.EnablePeriodicWarming)
        {
            _logger.LogInformation("å®šæœŸç¼“å­˜é¢„çƒ­å·²ç¦ç”¨");
            return;
        }
        
        var interval = TimeSpan.FromHours(_options.Value.WarmingIntervalHours);
        
        _logger.LogInformation(
            "ç¼“å­˜é¢„çƒ­ä»»åŠ¡å·²å¯åŠ¨ï¼Œé—´éš”ï¼š{Interval}",
            interval);
        
        while (!ct.IsCancellationRequested)
        {
            try
            {
                await Task.Delay(interval, ct);
                
                _logger.LogInformation("å¼€å§‹ç¼“å­˜é¢„çƒ­...");
                var stopwatch = Stopwatch.StartNew();
                
                using var scope = _scopeFactory.CreateScope();
                
                // 1. é¢„çƒ­åœ¨çº¿è§’è‰²
                await WarmOnlineCharactersAsync(scope.ServiceProvider, ct);
                
                // 2. é¢„çƒ­é™æ€é…ç½®æ•°æ®
                await WarmStaticDataAsync(scope.ServiceProvider, ct);
                
                // 3. é¢„çƒ­çƒ­é—¨è£…å¤‡
                await WarmPopularGearAsync(scope.ServiceProvider, ct);
                
                stopwatch.Stop();
                _logger.LogInformation(
                    "ç¼“å­˜é¢„çƒ­å®Œæˆï¼Œè€—æ—¶ {ElapsedMs}ms",
                    stopwatch.ElapsedMilliseconds);
            }
            catch (OperationCanceledException)
            {
                _logger.LogInformation("ç¼“å­˜é¢„çƒ­ä»»åŠ¡å·²å–æ¶ˆ");
                break;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "ç¼“å­˜é¢„çƒ­å¤±è´¥");
                // ç»§ç»­ä¸‹ä¸€æ¬¡å¾ªç¯
            }
        }
    }
    
    private async Task WarmOnlineCharactersAsync(
        IServiceProvider services,
        CancellationToken ct)
    {
        if (!_options.Value.WarmOnlineCharactersOnly)
            return;
        
        var characterRepo = services.GetRequiredService<ICharacterRepository>();
        
        // æŸ¥è¯¢åœ¨çº¿è§’è‰²ï¼ˆæœ€è¿‘5åˆ†é’Ÿæ´»è·ƒï¼‰
        var onlineThreshold = DateTime.UtcNow.AddMinutes(-5);
        // var onlineCharacters = await characterRepo.GetOnlineAsync(onlineThreshold, ct);
        
        // é¢„åŠ è½½åˆ°ç¼“å­˜
        // foreach (var character in onlineCharacters) { ... }
        
        _logger.LogDebug("é¢„çƒ­äº†åœ¨çº¿è§’è‰²æ•°æ®");
    }
    
    private async Task WarmStaticDataAsync(
        IServiceProvider services,
        CancellationToken ct)
    {
        // é¢„çƒ­ GearDefinition, Affix, GearSet ç­‰é™æ€æ•°æ®
        // è¿™äº›é€šå¸¸å·²åœ¨ CacheCoordinator å¯åŠ¨æ—¶é¢„åŠ è½½
        _logger.LogDebug("é¢„çƒ­äº†é™æ€é…ç½®æ•°æ®");
    }
    
    private async Task WarmPopularGearAsync(
        IServiceProvider services,
        CancellationToken ct)
    {
        // é¢„çƒ­æœ€å¸¸è¢«è£…å¤‡çš„è£…å¤‡å®ä¾‹
        // å¯åŸºäºç»Ÿè®¡æˆ–è§„åˆ™
        _logger.LogDebug("é¢„çƒ­äº†çƒ­é—¨è£…å¤‡æ•°æ®");
    }
}
```

### 5.4.3 æ³¨å†ŒæœåŠ¡

**æ–‡ä»¶**: `BlazorIdle.Server/Infrastructure/DependencyInjection.cs`

```csharp
// æ³¨å†Œæ™ºèƒ½ç¼“å­˜æœåŠ¡
services.AddSingleton<AccessPatternAnalyzer>();
services.AddScoped<LoginPreloadService>();
services.AddHostedService<CacheWarmingTask>();
```

---

## ğŸ“Š é˜¶æ®µ 5.5: ç›‘æ§ä¸è°ƒä¼˜

### 5.5.1 ç›‘æ§æŒ‡æ ‡

**æ–°å¢ç›‘æ§æŒ‡æ ‡**:
```csharp
public class IntelligentCacheMetrics
{
    // é¢„åŠ è½½ç»Ÿè®¡
    public long TotalPreloads { get; set; }
    public long SuccessfulPreloads { get; set; }
    public long FailedPreloads { get; set; }
    
    // é¢„æµ‹å‡†ç¡®ç‡
    public long TotalPredictions { get; set; }
    public long AccuratePredictions { get; set; }
    public double AccuracyRate => TotalPredictions > 0 
        ? (double)AccuratePredictions / TotalPredictions 
        : 0.0;
    
    // é¢„çƒ­ç»Ÿè®¡
    public long TotalWarmingCycles { get; set; }
    public long EntitiesWarmed { get; set; }
}
```

### 5.5.2 API ç«¯ç‚¹

```csharp
[ApiController]
[Route("api/cache/intelligent")]
public class IntelligentCacheController : ControllerBase
{
    [HttpGet("metrics")]
    public IActionResult GetMetrics()
    {
        var metrics = _metricsCollector.GetIntelligentCacheMetrics();
        return Ok(metrics);
    }
    
    [HttpGet("predictions/{entityType}/{entityId}")]
    public IActionResult GetPredictions(string entityType, Guid entityId)
    {
        var predictions = _patternAnalyzer.PredictNext(entityType, entityId);
        return Ok(predictions);
    }
}
```

---

## âœ… é˜¶æ®µ 5.6: A/B æµ‹è¯•ä¸éªŒè¯

### 5.6.1 A/B æµ‹è¯•æ–¹æ¡ˆ

**å¯¹ç…§ç»„**: ä¸å¯ç”¨æ™ºèƒ½é¢„åŠ è½½
**å®éªŒç»„**: å¯ç”¨æ™ºèƒ½é¢„åŠ è½½

**æµ‹è¯•æŒ‡æ ‡**:
1. ç¼“å­˜å‘½ä¸­ç‡
2. ç™»å½•åé¦–æ¬¡æ•°æ®è®¿é—®å»¶è¿Ÿ
3. ç”¨æˆ·ä½“éªŒå¾—åˆ†ï¼ˆä¸»è§‚ï¼‰
4. æœåŠ¡å™¨å†…å­˜ä½¿ç”¨

**æµ‹è¯•æ—¶é•¿**: 2 å‘¨

### 5.6.2 é…ç½®

```json
{
  "IntelligentCache": {
    "EnableABTesting": true,
    "ExperimentGroupPercentage": 50
  }
}
```

---

## ğŸ“‹ é…ç½®å‚æ•°æ€»è§ˆ

```json
{
  "IntelligentCache": {
    "EnableAccessPatternAnalysis": true,
    "EnableIntelligentPreload": true,
    "PreloadOnLogin": true,
    "PreloadBatchSize": 50,
    "EnablePeriodicWarming": true,
    "WarmingIntervalHours": 1,
    "WarmOnlineCharactersOnly": true,
    "MaxPatternHistoryDays": 7,
    "MinPatternConfidence": 0.3,
    "EnableABTesting": false,
    "ExperimentGroupPercentage": 50
  }
}
```

---

## ğŸ“Š éªŒæ”¶æ ‡å‡†

- [ ] AccessPatternAnalyzer å·²å®ç°å¹¶é›†æˆ
- [ ] LoginPreloadService å·²å®ç°å¹¶é›†æˆåˆ°ç™»å½•æµç¨‹
- [ ] CacheWarmingTask å·²å®ç°å¹¶æ­£å¸¸è¿è¡Œ
- [ ] ç›‘æ§æŒ‡æ ‡å·²å®ç°å¹¶å¯è®¿é—®
- [ ] A/B æµ‹è¯•å·²å®Œæˆï¼Œæ•°æ®åˆ†æå·²å®Œæˆ
- [ ] ç¼“å­˜å‘½ä¸­ç‡æå‡ >= 5%
- [ ] ç™»å½•å»¶è¿Ÿé™ä½ >= 50%
- [ ] é¢„æµ‹å‡†ç¡®ç‡ >= 60%
- [ ] é…ç½®å®Œå…¨å¯é…ç½®åŒ–
- [ ] æ–‡æ¡£é½å…¨

---

**æ–‡æ¡£çŠ¶æ€**: ä¸­ç¯‡å®Œæˆ  
**ä¸‹ä¸€æ­¥**: ä¸‹ç¯‡ (Phase 6: å®æ—¶ç›‘æ§ä¸å¯è§†åŒ–)  
**é¢„è®¡å®Œæˆæ—¶é—´**: Phase 5 å…¨éƒ¨å®Œæˆéœ€ 25-30 äººæ—¥
