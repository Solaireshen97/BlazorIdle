# BlazorIdle 下一步功能实现方向与实施方案

**文档版本**: 1.0  
**创建日期**: 2025年1月  
**基于**: 整合设计总结.txt (V3.1) + 项目进度与规划.md  
**作者**: 系统规划  
**状态**: 仅方案，不包含实际修改

---

## 📋 目录

1. [执行摘要](#1-执行摘要)
2. [当前项目状态评估](#2-当前项目状态评估)
3. [核心瓶颈分析](#3-核心瓶颈分析)
4. [功能实现优先级矩阵](#4-功能实现优先级矩阵)
5. [详细实施方案](#5-详细实施方案)
6. [技术债务清理计划](#6-技术债务清理计划)
7. [风险评估与缓解](#7-风险评估与缓解)
8. [资源估算与时间线](#8-资源估算与时间线)
9. [成功标准与验收](#9-成功标准与验收)

---

## 1. 执行摘要

### 1.1 项目现状

BlazorIdle 是一款"服务端权威 + 放置循环 + 构筑深度"的 Web RPG 游戏，当前已完成：

- ✅ **事件驱动战斗引擎** (95% 完成)
- ✅ **双轨战斗系统** (100% 完成)
- ✅ **资源与 Buff 系统** (90% 完成)
- ✅ **技能与自动施放** (85% 完成)
- ✅ **基础经济系统** (80% 完成)

**总体完成度**: 约 **28%**

### 1.2 关键问题

1. **服务器端注册问题**（已分析，见配套文档）
2. **离线快进系统缺失**（放置游戏核心）
3. **活动计划系统缺失**（多任务管理）
4. **装备强化生态缺失**（构筑深度）

### 1.3 战略目标

**3 个月目标**（Q1 2025）:
- 修复 DI 问题，确保服务器可启动
- 实现活动计划系统（多槽调度）
- 实现离线快进引擎
- 完成地图区域基础

**6 个月目标**（Q2 2025）:
- 完整装备系统（Tier/Affix/分解/重铸）
- 经济闭环建立
- 任务与声望系统

**12 个月目标**（2025全年）:
- 多角色 Roster 系统
- 配置版本化与热更新
- 初步社交功能（组队/副本）

---

## 2. 当前项目状态评估

### 2.1 已实现功能清单

#### 2.1.1 战斗引擎（核心）⭐⭐⭐⭐⭐

| 功能模块 | 完成度 | 质量评估 | 备注 |
|---------|--------|---------|------|
| **GameClock** | 100% | ⭐⭐⭐⭐⭐ | 逻辑时钟，单调递增 |
| **EventScheduler** | 100% | ⭐⭐⭐⭐⭐ | 优先队列调度，O(log n) |
| **TrackState** | 100% | ⭐⭐⭐⭐⭐ | 双轨（Attack + Special） |
| **BattleRunner** | 100% | ⭐⭐⭐⭐ | 事件循环，可回放 |
| **StepBattleCoordinator** | 100% | ⭐⭐⭐⭐⭐ | 异步战斗管理 |
| **回放系统** | 100% | ⭐⭐⭐⭐ | 基于 BattleRecord |

**亮点**:
- 确定性时间推进
- RNG 可回放（段级种子）
- 快照恢复机制完善
- 幂等 Finalizer 设计优秀

#### 2.1.2 资源与状态管理 ⭐⭐⭐⭐

| 功能模块 | 完成度 | 质量评估 | 备注 |
|---------|--------|---------|------|
| **ResourceBucket** | 100% | ⭐⭐⭐⭐⭐ | 三种溢出策略 |
| **BuffInstance** | 90% | ⭐⭐⭐⭐ | 缺少溢出转换 |
| **BuffAggregate** | 100% | ⭐⭐⭐⭐⭐ | 属性聚合公式完善 |
| **DoT/HoT** | 100% | ⭐⭐⭐⭐ | 周期性效果 |

**亮点**:
- 资源溢出转换机制（Convert）
- Buff 叠加策略完整
- Haste 快照支持

#### 2.1.3 技能系统 ⭐⭐⭐⭐

| 功能模块 | 完成度 | 质量评估 | 备注 |
|---------|--------|---------|------|
| **SkillDefinition** | 100% | ⭐⭐⭐⭐ | 数据驱动 |
| **SkillRuntime** | 100% | ⭐⭐⭐⭐⭐ | 多充能机制 |
| **AutoCastEngine** | 85% | ⭐⭐⭐⭐ | 基础优先级 |
| **施法打断** | 100% | ⭐⭐⭐⭐ | 充能返还 |

**亮点**:
- 多充能链式触发
- Off-GCD 编织
- 打断机制完善

#### 2.1.4 Proc 系统 ⭐⭐⭐⭐⭐

| 功能模块 | 完成度 | 质量评估 | 备注 |
|---------|--------|---------|------|
| **RPPM** | 100% | ⭐⭐⭐⭐⭐ | 真实触发频率 |
| **触发类型** | 100% | ⭐⭐⭐⭐⭐ | OnHit/OnCrit/OnCast |
| **ICD** | 100% | ⭐⭐⭐⭐ | 冷却管理 |
| **来源过滤** | 100% | ⭐⭐⭐⭐ | 可配置不含 DoT |

**评价**: 设计优秀，功能完整

#### 2.1.5 经济系统 ⭐⭐⭐

| 功能模块 | 完成度 | 质量评估 | 备注 |
|---------|--------|---------|------|
| **LootTable** | 100% | ⭐⭐⭐⭐ | 掉落表定义 |
| **EconomyCalculator** | 100% | ⭐⭐⭐⭐⭐ | 双模式（期望/抽样） |
| **RewardGrantService** | 100% | ⭐⭐⭐⭐ | 幂等性保证 |
| **InventoryItem** | 100% | ⭐⭐⭐ | 基础背包 |
| **经济监控** | 0% | - | 未实现 |

**亮点**:
- 独立经济 RNG
- 幂等性设计
- 双模式支持

**缺失**:
- 监控指标
- 产出/消耗平衡

### 2.2 未实现功能清单

#### 2.2.1 核心系统（P0 - 必须完成）

| 系统 | 影响 | 紧急度 |
|-----|------|-------|
| **活动计划系统** | 无法多任务，无法队列 | ⭐⭐⭐⭐⭐ |
| **离线快进引擎** | 放置游戏核心缺失 | ⭐⭐⭐⭐⭐ |
| **装备强化生态** | 构筑深度不足 | ⭐⭐⭐⭐ |
| **地图与区域系统** | 内容平坦，无进度感 | ⭐⭐⭐⭐ |

#### 2.2.2 增强系统（P1 - 应该完成）

| 系统 | 影响 | 紧急度 |
|-----|------|-------|
| **条件解锁 DSL** | 无法实现复杂逻辑 | ⭐⭐⭐ |
| **任务与声望** | 缺少引导和长期目标 | ⭐⭐⭐ |
| **CombatSegment 聚合** | 查询性能待优化 | ⭐⭐⭐ |
| **经济监控** | 无法控制通胀 | ⭐⭐⭐ |

#### 2.2.3 扩展系统（P2 - 可以考虑）

| 系统 | 影响 | 紧急度 |
|-----|------|-------|
| **多角色 Roster** | 单角色体验单薄 | ⭐⭐ |
| **配置版本化** | 运维便利性 | ⭐⭐ |
| **组队与副本** | 社交功能 | ⭐ |
| **消耗品系统** | 额外玩法 | ⭐ |

---

## 3. 核心瓶颈分析

### 3.1 技术瓶颈

#### 3.1.1 依赖注入问题（已识别）

**问题**: `CombatActivityExecutor` (Singleton) 依赖 `ICharacterRepository` (Scoped)

**影响**:
- 服务器无法启动
- 活动计划系统完全不可用
- 前端集成无法测试

**解决方案**: 参见《服务器端注册问题分析与解决方案.md》

#### 3.1.2 EventScheduler 未独立

**问题**: 当前事件调度混杂在 `BattleRunner` 中

**影响**:
- 难以在离线系统中复用
- 代码耦合度高
- 难以单独测试

**解决方案**:
```csharp
// 抽取为独立组件
public class EventScheduler
{
    private PriorityQueue<IGameEvent, double> _queue;
    
    public void Schedule(IGameEvent evt);
    public IGameEvent PopNext();
    public bool HasEvents { get; }
}
```

#### 3.1.3 ResourceBucket 缺少职业资源

**问题**: 当前仅支持 Health/Mana

**影响**:
- 职业差异化不明显
- 无法实现怒气、碎片等机制
- 溢出转换无法充分利用

**解决方案**: 参见 Phase 1 详细方案

### 3.2 架构瓶颈

#### 3.2.1 活动系统缺失

**问题**: 角色只能进行单一战斗活动

**影响**:
- 无法同时挂机和采集
- 无法队列多个任务
- 离线系统无法实现

**解决方案**: 参见 Phase 3 详细方案

#### 3.2.2 数据聚合不足

**问题**: `CombatSegment` 存储原始事件，无聚合统计

**影响**:
- 查询慢（需遍历所有事件）
- 存储成本高
- 离线登录卡顿

**解决方案**: 参见 Phase 4 详细方案

### 3.3 内容瓶颈

#### 3.3.1 装备系统简单

**问题**: 装备无动态生成，无词条系统

**影响**:
- 构筑深度严重不足
- 玩家无长期追求目标
- 经济循环无消耗端

**解决方案**: 参见 Phase 6 详细方案

#### 3.3.2 地图平坦

**问题**: 无区域概念，无解锁链

**影响**:
- 内容无层次
- 缺少进度感
- 玩家迷失方向

**解决方案**: 参见 Phase 5 详细方案

---

## 4. 功能实现优先级矩阵

### 4.1 影响 vs 紧急度矩阵

```
影响度
  ↑
  |  P0-Critical        P0-High
  |  ┌─────────────────┬─────────────────┐
高 |  │ 1. 活动计划     │ 3. 装备系统     │
  |  │ 2. 离线快进     │ 4. 地图区域     │
  |  ├─────────────────┼─────────────────┤
  |  │ 5. 条件 DSL     │ 7. 经济监控     │
中 |  │ 6. 任务声望     │ 8. Segment 优化 │
  |  ├─────────────────┼─────────────────┤
  |  │ 9. Roster       │11. Debug 面板   │
低 |  │10. Config 版本  │12. 组队副本     │
  |  └─────────────────┴─────────────────┘
  |        高                   低
  +────────────────────────────────────→ 紧急度
```

### 4.2 依赖关系图

```
Phase 0: DI 问题修复
  ↓
Phase 1: 战斗引擎重构
  ├─> EventScheduler 独立
  ├─> ResourceBucket 扩展
  └─> Buff 溢出转换
  ↓
Phase 2/3: 活动计划系统 ← 必须依赖 Phase 1
  ↓
Phase 4: 离线快进引擎 ← 依赖 Phase 2/3
  ↓
Phase 5: 地图/条件 DSL ← 可与 Phase 4 并行
  ↓
Phase 6: 装备系统 ← 依赖 Phase 5（掉落场景）
  ↓
Phase 7-9: 增强与优化
  ↓
Phase 10-12: 扩展功能
```

### 4.3 推荐实施顺序

| 阶段 | 时间 | 核心交付 | 依赖 |
|-----|------|---------|-----|
| **Phase 0** | 1周 | DI 问题修复 | 无 |
| **Phase 1** | 2周 | 战斗引擎重构 | Phase 0 |
| **Phase 2** | 3周 | 活动计划基础 | Phase 1 |
| **Phase 3** | 2周 | 活动计划完善 | Phase 2 |
| **Phase 4** | 3周 | 离线快进引擎 | Phase 3 |
| **Phase 5** | 4周 | 地图/条件 DSL | Phase 4 |
| **Phase 6** | 6周 | 装备系统 | Phase 5 |
| **Phase 7+** | 持续 | 增强与扩展 | Phase 6 |

**总计**: 约 4-5 个月完成核心系统

---

## 5. 详细实施方案

### Phase 0: DI 问题修复（1 周）

#### 目标
✅ 服务器可正常启动
✅ 活动计划 API 可调用
✅ 前端集成可测试

#### 详细方案

参见《服务器端注册问题分析与解决方案.md》，核心改动：

1. **修改 CombatActivityExecutor 构造函数**
   - 删除 `ICharacterRepository` 参数
   - 添加 `IServiceScopeFactory` 参数

2. **修改 StartAsync 方法**
   - 创建临时 Scope
   - 从 Scope 获取 Repository
   - 使用 `using` 语句确保释放

3. **测试验证**
   - 单元测试
   - 集成测试
   - 手动测试

#### 交付物
- [x] `CombatActivityExecutor.cs` 修改
- [x] 单元测试
- [x] 服务器启动成功
- [x] API 端点可调用

---

### Phase 1: 战斗引擎重构（2 周）

#### 目标
✅ EventScheduler 独立可复用
✅ ResourceBucket 支持职业资源
✅ Buff 溢出转换完善

#### 1.1 EventScheduler 独立化

**当前问题**: 事件调度逻辑混杂在 `BattleRunner` 中

**改造方案**:

```csharp
// 新文件: Domain/Combat/EventScheduler.cs
public class EventScheduler
{
    private PriorityQueue<IGameEvent, double> _queue = new();
    
    public void Schedule(IGameEvent evt)
    {
        _queue.Enqueue(evt, evt.ExecuteAt);
    }
    
    public IGameEvent PopNext()
    {
        return _queue.Dequeue();
    }
    
    public bool HasEvents => _queue.Count > 0;
    
    public int Count => _queue.Count;
}
```

**BattleRunner 改造**:

```csharp
// 修改: Application/Battles/BattleRunner.cs
public class BattleRunner
{
    public BattleResult Run(BattleContext context)
    {
        var scheduler = new EventScheduler();  // 使用独立调度器
        var clock = new GameClock();
        
        // 初始化事件
        scheduler.Schedule(new AttackTickEvent(...));
        scheduler.Schedule(new SpecialPulseEvent(...));
        
        while (scheduler.HasEvents)
        {
            var evt = scheduler.PopNext();
            clock.AdvanceTo(evt.ExecuteAt);
            evt.Execute(context);
            
            // 可能调度新事件
            // scheduler.Schedule(...)
        }
        
        return BuildResult(context);
    }
}
```

**优势**:
- ✅ 可在离线系统中复用
- ✅ 易于单独测试
- ✅ 代码更清晰

#### 1.2 ResourceBucket 职业资源扩展

**当前状态**: 仅 Health/Mana

**扩展方案**:

```csharp
// 扩展: Domain/Combat/Resources/ResourceBucket.cs
public enum ResourceType
{
    Health,
    Mana,
    Rage,           // 战士：怒气
    ShardIce,       // 法师：冰碎片
    Focus,          // 游侠：集中值
    Energy,         // 盗贼：能量
    ComboPoints,    // 盗贼：连击点
    HolyPower,      // 圣骑士：圣能
    // 未来扩展...
}

public class ResourceBucket
{
    public ResourceType Type { get; init; }
    public double Current { get; private set; }
    public double Max { get; init; }
    public OverflowPolicy OverflowPolicy { get; init; }
    
    // 溢出转换配置
    public double ConvertUnit { get; init; }  // 每 N 点转换 1 次
    public string? ConversionTag { get; init; }  // 转换目标（Buff ID 等）
    
    // 溢出计数器
    public int ConversionCount { get; private set; }
    
    public void Add(double amount, out int conversions)
    {
        conversions = 0;
        Current += amount;
        
        if (Current > Max)
        {
            var overflow = Current - Max;
            
            switch (OverflowPolicy)
            {
                case OverflowPolicy.Clamp:
                    Current = Max;
                    break;
                    
                case OverflowPolicy.Convert:
                    if (ConvertUnit > 0 && ConversionTag != null)
                    {
                        conversions = (int)(overflow / ConvertUnit);
                        ConversionCount += conversions;
                        Current = Max;  // 溢出部分转换后归零
                    }
                    break;
                    
                case OverflowPolicy.Ignore:
                    // 允许超出
                    break;
            }
        }
    }
}
```

**职业集成示例 - 战士**:

```csharp
// Domain/Combat/Professions/WarriorProfession.cs
public class WarriorProfession : IProfessionModule
{
    public void InitializeResources(BattleContext context)
    {
        // 怒气资源
        var rage = new ResourceBucket
        {
            Type = ResourceType.Rage,
            Current = 0,
            Max = 100,
            OverflowPolicy = OverflowPolicy.Convert,
            ConvertUnit = 20,  // 每 20 怒气溢出 → 1 层战意 Buff
            ConversionTag = "buff_battle_focus"
        };
        
        context.Resources.Add(ResourceType.Rage, rage);
    }
    
    public void OnAttackTick(BattleContext context, TrackState track)
    {
        // 普攻生成 10 怒气
        var rage = context.Resources[ResourceType.Rage];
        rage.Add(10, out int conversions);
        
        // 如果产生转换，添加 Buff
        if (conversions > 0)
        {
            var buff = new BuffInstance
            {
                Id = "buff_battle_focus",
                Stacks = conversions,
                MaxStacks = 5,
                DurationSeconds = 10
            };
            context.Buffs.Add(buff);
        }
    }
}
```

#### 1.3 Buff 溢出转换完善

**当前问题**: Buff 层数溢出处理不完整

**改造方案**:

```csharp
// 扩展: Domain/Combat/Buffs/BuffInstance.cs
public class BuffInstance
{
    public string Id { get; init; }
    public int Stacks { get; set; }
    public int MaxStacks { get; init; }
    public double ExpireAt { get; set; }
    
    // 新增：层数溢出策略
    public BuffStackOverflowPolicy StackOverflowPolicy { get; init; }
    
    public void AddStacks(int count, out int overflow)
    {
        overflow = 0;
        Stacks += count;
        
        if (Stacks > MaxStacks)
        {
            overflow = Stacks - MaxStacks;
            
            switch (StackOverflowPolicy)
            {
                case BuffStackOverflowPolicy.Clamp:
                    Stacks = MaxStacks;
                    break;
                    
                case BuffStackOverflowPolicy.Refresh:
                    Stacks = MaxStacks;
                    // ExpireAt 刷新在外部处理
                    break;
                    
                case BuffStackOverflowPolicy.Trigger:
                    Stacks = 0;  // 触发效果后清零
                    // 触发事件由外部处理
                    break;
            }
        }
    }
}

public enum BuffStackOverflowPolicy
{
    Clamp,      // 截断到上限
    Refresh,    // 刷新时长
    Trigger     // 触发特殊效果并清零（如"蓄势"触发后爆发）
}
```

#### 交付物
- [ ] `EventScheduler.cs` 新文件
- [ ] `BattleRunner.cs` 重构
- [ ] `ResourceBucket.cs` 扩展
- [ ] `WarriorProfession.cs` 集成
- [ ] `MageProfession.cs` 集成（可选）
- [ ] `BuffInstance.cs` 溢出策略
- [ ] 单元测试
- [ ] 集成测试

#### 验收标准
- [ ] EventScheduler 可独立运行
- [ ] 战士怒气溢出正确转换为战意 Buff
- [ ] Buff 层数溢出策略正确工作
- [ ] 原有战斗逻辑不受影响

---

### Phase 2: 活动计划基础（3 周）

#### 目标
✅ ActivityPlan 数据模型
✅ ActivitySlot 多槽调度
✅ 限制类型支持

#### 2.1 数据模型设计

```csharp
// 新文件: Domain/Activity/ActivityPlan.cs
public class ActivityPlan
{
    public Guid Id { get; init; }
    public Guid CharacterId { get; init; }
    public ActivityType Type { get; init; }
    public LimitSpec Limit { get; init; }
    public PlanState State { get; set; }
    public string PayloadJson { get; init; }
    
    // 进度跟踪
    public ActivityProgress Progress { get; set; }
    
    // 时间戳
    public DateTime CreatedAtUtc { get; init; }
    public DateTime? StartedAtUtc { get; set; }
    public DateTime? CompletedAtUtc { get; set; }
    
    // 方法
    public bool IsLimitReached();
    public void UpdateProgress(double simulatedSeconds, int completedCount);
    public void Complete();
    public void Cancel();
}

public enum ActivityType
{
    Combat,      // 战斗
    Gather,      // 采集（未来）
    Craft,       // 制作（未来）
    Idle         // 空闲
}

public enum PlanState
{
    Pending,     // 待执行（队列中）
    Running,     // 运行中
    Completed,   // 已完成
    Cancelled    // 已取消
}

// 限制规格
public abstract record LimitSpec;

public record DurationLimit(double DurationSeconds) : LimitSpec;
public record CountLimit(int TargetCount) : LimitSpec;
public record InfiniteLimit() : LimitSpec;

// 进度
public class ActivityProgress
{
    public double SimulatedSeconds { get; set; }
    public int CompletedCount { get; set; }
}
```

#### 2.2 槽位系统设计

```csharp
// 新文件: Domain/Activity/ActivitySlot.cs
public class ActivitySlot
{
    public int SlotIndex { get; init; }
    public Guid CharacterId { get; init; }
    
    // 当前运行的计划
    public Guid? CurrentPlanId { get; set; }
    
    // 队列中的计划（按顺序）
    public List<Guid> QueuedPlanIds { get; } = new();
    
    // 方法
    public bool IsIdle => CurrentPlanId == null;
    public bool HasQueue => QueuedPlanIds.Count > 0;
    
    public void StartPlan(Guid planId);
    public Guid? DequeueNext();
    public void EnqueuePlan(Guid planId);
    public void ClearCurrent();
}
```

#### 2.3 协调器设计

```csharp
// 新文件: Application/Activities/ActivityCoordinator.cs
public class ActivityCoordinator
{
    private readonly ConcurrentDictionary<Guid, ActivityPlan> _plans = new();
    private readonly ConcurrentDictionary<Guid, ActivitySlot[]> _characterSlots = new();
    private readonly ConcurrentDictionary<Guid, ActivityExecutionContext> _contexts = new();
    private readonly IEnumerable<IActivityExecutor> _executors;
    
    public ActivityCoordinator(IEnumerable<IActivityExecutor> executors)
    {
        _executors = executors;
    }
    
    // 创建计划
    public async Task<Guid> CreatePlanAsync(
        Guid characterId, 
        int slotIndex, 
        ActivityType type, 
        LimitSpec limit, 
        string payloadJson);
    
    // 推进活动（由 HostedService 调用）
    public async Task AdvanceAsync(CancellationToken ct);
    
    // 取消计划
    public async Task CancelPlanAsync(Guid planId);
    
    // 获取槽位状态
    public ActivitySlot[] GetCharacterSlots(Guid characterId);
    
    // 获取计划详情
    public ActivityPlan? GetPlan(Guid planId);
}
```

#### 2.4 执行器接口

```csharp
// 新文件: Application/Activities/IActivityExecutor.cs
public interface IActivityExecutor
{
    ActivityType SupportedType { get; }
    
    // 启动活动
    Task<ActivityExecutionContext> StartAsync(
        ActivityPlan plan, 
        CancellationToken ct = default);
    
    // 推进活动
    Task AdvanceAsync(
        ActivityPlan plan, 
        ActivityExecutionContext context, 
        CancellationToken ct = default);
    
    // 停止活动
    Task StopAsync(
        ActivityPlan plan, 
        ActivityExecutionContext context, 
        CancellationToken ct = default);
    
    // 检查是否完成
    Task<bool> CheckCompletionAsync(
        ActivityPlan plan, 
        ActivityExecutionContext context, 
        CancellationToken ct = default);
}

// 执行上下文
public class ActivityExecutionContext
{
    public Guid PlanId { get; init; }
    public Guid? UnderlyingExecutionId { get; set; }  // 如战斗 ID
    public Dictionary<string, object> Data { get; } = new();
    public DateTime LastUpdatedAtUtc { get; set; }
}
```

#### 2.5 API 端点设计

```csharp
// 新文件: Presentation/Controllers/ActivityController.cs
[ApiController]
[Route("api/activities")]
public class ActivityController : ControllerBase
{
    private readonly ActivityCoordinator _coordinator;
    
    // POST /api/activities/plans
    [HttpPost("plans")]
    public async Task<IActionResult> CreatePlan(
        [FromBody] CreateActivityPlanRequest request);
    
    // GET /api/activities/plans/{planId}
    [HttpGet("plans/{planId:guid}")]
    public IActionResult GetPlan(Guid planId);
    
    // GET /api/activities/characters/{characterId}/slots
    [HttpGet("characters/{characterId:guid}/slots")]
    public IActionResult GetCharacterSlots(Guid characterId);
    
    // POST /api/activities/plans/{planId}/cancel
    [HttpPost("plans/{planId:guid}/cancel")]
    public async Task<IActionResult> CancelPlan(Guid planId);
}
```

#### 交付物
- [ ] `ActivityPlan.cs` 领域模型
- [ ] `ActivitySlot.cs` 槽位模型
- [ ] `ActivityCoordinator.cs` 协调器
- [ ] `IActivityExecutor.cs` 执行器接口
- [ ] `CombatActivityExecutor.cs` 战斗执行器实现
- [ ] `ActivityController.cs` API 控制器
- [ ] `ActivityHostedService.cs` 后台服务
- [ ] 数据库迁移
- [ ] 单元测试
- [ ] 集成测试

#### 验收标准
- [ ] 可创建活动计划
- [ ] 槽位正确管理当前和队列计划
- [ ] 计划自动推进
- [ ] 计划完成后自动启动队列下一个
- [ ] 可取消运行中或队列中的计划

---

### Phase 3: 活动计划完善（2 周）

#### 目标
✅ 前端集成完善
✅ 自动刷新机制
✅ 错误处理优化

#### 3.1 前端组件改进

**当前状态**: 前端已实现基础 UI（见 `前端集成说明.md`）

**改进方向**:

1. **进度条优化**
   - 平滑动画
   - 颜色编码（绿色=运行中，蓝色=已完成，灰色=已取消）
   - 百分比显示

2. **错误提示**
   - Toast 通知
   - 详细错误信息
   - 重试机制

3. **批量操作**
   - 批量取消
   - 批量创建（模板）

#### 3.2 后端优化

1. **幂等性保证**
   - 创建计划幂等（基于 characterId + slotIndex + 时间窗口）
   - 取消计划幂等

2. **并发控制**
   - 乐观锁或悲观锁（防止同一槽位并发创建）

3. **监控埋点**
   - 计划创建/完成/取消次数
   - 平均执行时长
   - 队列深度

#### 交付物
- [ ] 前端 UI 优化
- [ ] 错误处理完善
- [ ] 幂等性实现
- [ ] 监控埋点
- [ ] 用户文档

---

### Phase 4: 离线快进引擎（3 周）

#### 目标
✅ 离线时间计算
✅ 快速推进战斗
✅ Segment 批量生成

#### 4.1 核心设计

```csharp
// 新文件: Application/Activities/OfflineFastForwardEngine.cs
public class OfflineFastForwardEngine
{
    private readonly IServiceScopeFactory _scopeFactory;
    private readonly ActivityCoordinator _coordinator;
    
    public async Task<OfflineResult> ProcessOfflinePeriodAsync(
        Guid characterId,
        DateTime lastOnlineUtc,
        DateTime nowUtc,
        CancellationToken ct = default)
    {
        // 1. 计算离线时长（上限 12 小时）
        var offlineSeconds = Math.Min(
            (nowUtc - lastOnlineUtc).TotalSeconds,
            12 * 3600);
        
        // 2. 加载角色的活动计划
        await LoadCharacterPlansAsync(characterId, ct);
        
        // 3. 获取槽位
        var slots = _coordinator.GetCharacterSlots(characterId);
        
        // 4. 对每个槽位推进活动
        var results = new List<SlotOfflineResult>();
        
        foreach (var slot in slots)
        {
            if (slot.CurrentPlanId.HasValue)
            {
                var plan = _coordinator.GetPlan(slot.CurrentPlanId.Value);
                if (plan?.State == PlanState.Running)
                {
                    var result = await FastForwardPlanAsync(
                        plan, 
                        offlineSeconds, 
                        ct);
                    results.Add(result);
                }
            }
        }
        
        // 5. 汇总结果
        return AggregateResults(results);
    }
    
    private async Task<SlotOfflineResult> FastForwardPlanAsync(
        ActivityPlan plan, 
        double seconds, 
        CancellationToken ct)
    {
        // 使用 EventScheduler 快速推进
        // 生成 CombatSegment 而非详细事件
        // ...
    }
}
```

#### 4.2 快进策略

**关键原则**: 使用与在线相同的战斗引擎，但：

1. **跳跃时间推进**
   - 不记录详细事件
   - 直接生成 Segment 聚合数据

2. **分段结算**
   - 每 5 分钟生成一个 Segment
   - 防止单次推进时间过长

3. **限制检查**
   - 每段检查是否达到限制
   - 达到限制立即停止

#### 4.3 数据结构

```csharp
public class OfflineResult
{
    public double ProcessedSeconds { get; init; }
    public long TotalGold { get; init; }
    public long TotalExp { get; init; }
    public Dictionary<string, int> TotalItems { get; init; }
    public int CompletedPlans { get; init; }
    public List<SlotOfflineResult> SlotResults { get; init; }
}

public class SlotOfflineResult
{
    public int SlotIndex { get; init; }
    public Guid PlanId { get; init; }
    public double SimulatedSeconds { get; init; }
    public int CompletedCount { get; init; }
    public bool ReachedLimit { get; init; }
    public List<CombatSegment> Segments { get; init; }
}
```

#### 4.4 API 端点

```csharp
// POST /api/offline/process
[HttpPost("process")]
public async Task<IActionResult> ProcessOffline(
    [FromBody] ProcessOfflineRequest request)
{
    var result = await _offlineEngine.ProcessOfflinePeriodAsync(
        request.CharacterId,
        request.LastOnlineUtc,
        DateTime.UtcNow);
    
    return Ok(result);
}
```

#### 4.5 前端集成

```razor
<!-- OfflineRewardPanel.razor -->
@if (offlineResult != null)
{
    <div class="offline-panel">
        <h3>离线收益</h3>
        <p>离线时长: @FormatDuration(offlineResult.ProcessedSeconds)</p>
        <p>金币: +@offlineResult.TotalGold</p>
        <p>经验: +@offlineResult.TotalExp</p>
        <h4>物品:</h4>
        <ul>
            @foreach (var item in offlineResult.TotalItems)
            {
                <li>@item.Key x @item.Value</li>
            }
        </ul>
        <button @onclick="ClaimRewards">领取</button>
    </div>
}
```

#### 交付物
- [ ] `OfflineFastForwardEngine.cs`
- [ ] `OfflineController.cs` API
- [ ] `OfflineRewardPanel.razor` 前端
- [ ] 数据库迁移（存储最后在线时间）
- [ ] 单元测试
- [ ] 性能测试（12小时推进 < 5秒）

#### 验收标准
- [ ] 离线登录自动结算
- [ ] 离线收益正确计算
- [ ] 12 小时推进在 5 秒内完成
- [ ] 内存占用合理（< 100MB）

---

### Phase 5: 地图/条件 DSL（4 周）

#### 目标
✅ MapRegion 数据模型
✅ ConditionExpr 解析引擎
✅ 区域解锁逻辑

#### 5.1 MapRegion 设计

```csharp
// 新文件: Domain/World/MapRegion.cs
public class MapRegion
{
    public string Id { get; init; }
    public string Name { get; init; }
    public (int min, int max) LevelRange { get; init; }
    
    // 怪物池
    public List<EnemyPoolEntry> MonsterPool { get; init; }
    
    // 采集节点（未来）
    public List<GatheringNode> GatheringNodes { get; init; }
    
    // 地城（未来）
    public List<string> DungeonIds { get; init; }
    
    // 解锁条件
    public string? UnlockConditionExpr { get; init; }
    
    // 区域特性
    public Dictionary<string, double> Modifiers { get; init; }  // 如 "gold_bonus": 1.2
}

public class EnemyPoolEntry
{
    public string EnemyId { get; init; }
    public double Weight { get; init; }
}
```

#### 5.2 ConditionExpr 引擎

```csharp
// 新文件: Domain/Unlock/ConditionExpr.cs
public class ConditionExpr
{
    public string Id { get; init; }
    public string Raw { get; init; }  // "AND(level>=20, quest.completed('Q123'))"
    
    // 解析后的 AST
    private IConditionNode? _ast;
    
    // 依赖键
    public List<string> Dependencies { get; private set; } = new();
    
    public bool Evaluate(ConditionContext ctx)
    {
        if (_ast == null)
        {
            _ast = ConditionParser.Parse(Raw);
            Dependencies = _ast.GetDependencies();
        }
        
        return _ast.Evaluate(ctx);
    }
}

// 条件上下文
public class ConditionContext
{
    public int Level { get; init; }
    public Dictionary<string, int> Reputations { get; init; }
    public HashSet<string> CompletedQuests { get; init; }
    // 更多...
}
```

**DSL 语法示例**:

```
AND(level>=20, reputation.factionA>=300)
OR(quest.completed('Q123'), achievement.earned('ACH_001'))
NOT(region.visited('darkforest'))
level>=10 AND level<=20
```

#### 5.3 解析器实现

```csharp
// 新文件: Domain/Unlock/ConditionParser.cs
public static class ConditionParser
{
    public static IConditionNode Parse(string expr)
    {
        // 简单递归下降解析器
        var tokens = Tokenize(expr);
        return ParseExpression(tokens);
    }
    
    private static List<Token> Tokenize(string expr)
    {
        // AND, OR, NOT, (,), >=, <=, ==, !=, 数字, 字符串
    }
    
    private static IConditionNode ParseExpression(List<Token> tokens)
    {
        // 解析为 AST
    }
}

// AST 节点接口
public interface IConditionNode
{
    bool Evaluate(ConditionContext ctx);
    List<string> GetDependencies();
}

// 示例节点
public class AndNode : IConditionNode
{
    public List<IConditionNode> Children { get; init; }
    
    public bool Evaluate(ConditionContext ctx)
    {
        return Children.All(c => c.Evaluate(ctx));
    }
    
    public List<string> GetDependencies()
    {
        return Children.SelectMany(c => c.GetDependencies()).Distinct().ToList();
    }
}

public class ComparisonNode : IConditionNode
{
    public string Key { get; init; }  // "level", "reputation.factionA"
    public ComparisonOperator Operator { get; init; }
    public object Value { get; init; }
    
    public bool Evaluate(ConditionContext ctx)
    {
        var actual = ctx.GetValue(Key);
        return Compare(actual, Value, Operator);
    }
    
    public List<string> GetDependencies() => new() { Key };
}
```

#### 5.4 缓存层

```csharp
// 新文件: Application/Unlock/ConditionCache.cs
public class ConditionCache
{
    // 解析缓存（AST）
    private ConcurrentDictionary<string, ConditionExpr> _parseCache = new();
    
    // 结果缓存
    private ConcurrentDictionary<string, (bool result, DateTime cachedAt)> _resultCache = new();
    
    // 依赖索引（反向索引）
    private Dictionary<string, HashSet<string>> _dependencyIndex = new();
    
    public bool Evaluate(string exprId, ConditionContext ctx)
    {
        // 1. 检查结果缓存
        if (_resultCache.TryGetValue(exprId, out var cached))
        {
            // 可选：检查缓存是否过期
            return cached.result;
        }
        
        // 2. 获取或解析表达式
        var expr = _parseCache.GetOrAdd(exprId, id => new ConditionExpr { Raw = LoadRaw(id) });
        
        // 3. 评估
        var result = expr.Evaluate(ctx);
        
        // 4. 缓存结果
        _resultCache[exprId] = (result, DateTime.UtcNow);
        
        // 5. 更新依赖索引
        foreach (var dep in expr.Dependencies)
        {
            if (!_dependencyIndex.ContainsKey(dep))
                _dependencyIndex[dep] = new HashSet<string>();
            _dependencyIndex[dep].Add(exprId);
        }
        
        return result;
    }
    
    // 失效特定依赖键
    public void Invalidate(string dependencyKey)
    {
        if (_dependencyIndex.TryGetValue(dependencyKey, out var affectedExprs))
        {
            foreach (var exprId in affectedExprs)
            {
                _resultCache.TryRemove(exprId, out _);
            }
        }
    }
}
```

#### 5.5 区域解锁 API

```csharp
// GET /api/world/regions
[HttpGet("regions")]
public IActionResult GetRegions([FromQuery] Guid characterId)
{
    var character = _characters.GetAsync(characterId).Result;
    var ctx = BuildConditionContext(character);
    
    var regions = _regionRegistry.GetAll();
    var result = regions.Select(r => new
    {
        r.Id,
        r.Name,
        r.LevelRange,
        Unlocked = EvaluateUnlock(r, ctx)
    });
    
    return Ok(result);
}
```

#### 交付物
- [ ] `MapRegion.cs` 数据模型
- [ ] `ConditionExpr.cs` 条件引擎
- [ ] `ConditionParser.cs` 解析器
- [ ] `ConditionCache.cs` 缓存层
- [ ] `RegionRegistry.cs` 区域注册表
- [ ] `WorldController.cs` API
- [ ] 前端地图界面
- [ ] 单元测试（解析器 + 评估器）

#### 验收标准
- [ ] 条件表达式正确解析
- [ ] 区域解锁逻辑正确
- [ ] 前端地图可视化清晰
- [ ] 缓存有效提升性能

---

### Phase 6: 装备系统（6 周）

#### 目标
✅ GearInstance 动态生成
✅ Affix 词条系统
✅ Tier 升级
✅ 分解与重铸

#### 详细方案参见《项目进度与规划.md》第 506-650 行

**核心交付**:
1. GearDefinition / GearInstance
2. Affix 生成器
3. DisenchantService
4. ReforgeTierService
5. RerollService
6. SetBonus 套装

**时间分配**:
- Week 1-3: GearInstance + 基础 Affix
- Week 4-5: 分解与材料
- Week 6: Tier 升级 + Reroll

---

## 6. 技术债务清理计划

### 6.1 命名空间统一（1 天）

**问题**: `BlazorWebGame.*` 与 `BlazorIdle.Server.*` 混用

**方案**: 全局重命名为 `BlazorIdle.Server.*`

**工具**: Rider / Visual Studio 的 "Rename Namespace"

### 6.2 持久化层解耦（3-5 天）

**问题**: 领域模型与 EF 实体混用

**方案**: 引入 Mapper 层

```csharp
// Domain
public class Character { /* 纯领域逻辑 */ }

// Infrastructure
public class CharacterEntity { /* EF 实体 */ }

// Mapper
public static class CharacterMapper
{
    public static Character ToDomain(CharacterEntity entity);
    public static CharacterEntity ToEntity(Character domain);
}
```

### 6.3 RNG 种子范围记录（1 天）

**问题**: CombatSegment 未记录 RNG 种子范围

**方案**: 添加字段

```csharp
public class CombatSegment
{
    // 新增
    public long RngSeedStart { get; set; }
    public long RngSeedEnd { get; set; }
}
```

---

## 7. 风险评估与缓解

### 7.1 技术风险

| 风险 | 概率 | 影响 | 缓解措施 |
|-----|------|------|---------|
| **EventScheduler 重构破坏现有战斗** | 中 | 高 | 完整单元测试 + 集成测试 |
| **离线快进性能不达标** | 中 | 高 | 性能基准测试 + 优化 |
| **条件 DSL 解析器 Bug** | 中 | 中 | 全面语法测试 |
| **装备系统复杂度超预期** | 高 | 中 | 分阶段交付，先简化 |

### 7.2 进度风险

| 风险 | 概率 | 影响 | 缓解措施 |
|-----|------|------|---------|
| **Phase 1 延期影响后续** | 中 | 高 | 预留缓冲时间 |
| **开发人力不足** | 中 | 高 | 优先级排序，削减 P2 功能 |
| **测试不充分导致返工** | 高 | 中 | 每 Phase 必须通过验收 |

### 7.3 业务风险

| 风险 | 概率 | 影响 | 缓解措施 |
|-----|------|------|---------|
| **玩家需求变化** | 低 | 中 | 快速迭代，灵活调整 |
| **竞品抢先** | 低 | 低 | 专注核心特色 |

---

## 8. 资源估算与时间线

### 8.1 开发工时估算

| Phase | 工作日 | 人天 | 备注 |
|-------|--------|------|------|
| **Phase 0** | 5 | 5 | DI 问题修复 |
| **Phase 1** | 10 | 10 | 战斗引擎重构 |
| **Phase 2** | 15 | 15 | 活动计划基础 |
| **Phase 3** | 10 | 10 | 活动计划完善 |
| **Phase 4** | 15 | 15 | 离线快进 |
| **Phase 5** | 20 | 20 | 地图/条件 DSL |
| **Phase 6** | 30 | 30 | 装备系统 |
| **总计** | 105 天 | 105 人天 | 约 5 个月 |

### 8.2 甘特图（简化）

```
2025 Q1          │ Jan  │ Feb  │ Mar  │
────────────────┼──────┼──────┼──────┤
Phase 0 (DI)    │ ██   │      │      │
Phase 1 (战斗)  │   ███│██    │      │
Phase 2 (活动)  │      │  ████│██    │
Phase 3 (活动)  │      │      │  ████│

2025 Q2          │ Apr  │ May  │ Jun  │
────────────────┼──────┼──────┼──────┤
Phase 4 (离线)  │ ████ │██    │      │
Phase 5 (地图)  │      │  ████│████  │
Phase 6 (装备)  │      │      │  ████│
```

### 8.3 里程碑

| 里程碑 | 日期 | 交付 |
|--------|------|------|
| **M1: 服务器可运行** | Week 1 | DI 问题修复 |
| **M2: 战斗引擎重构** | Week 3 | EventScheduler + ResourceBucket |
| **M3: 活动计划可用** | Week 8 | 多槽调度 + 队列 |
| **M4: 离线快进上线** | Week 11 | 离线收益 |
| **M5: 地图系统上线** | Week 15 | 区域解锁 + 条件 DSL |
| **M6: 装备系统上线** | Week 21 | Tier/Affix/分解/重铸 |

---

## 9. 成功标准与验收

### 9.1 技术指标

| 指标 | 目标 | 测量方法 |
|-----|------|---------|
| **服务器启动时间** | < 5 秒 | 手动测试 |
| **API 响应时间（P95）** | < 200ms | 性能测试 |
| **离线快进速度** | 12 小时 < 5 秒 | 性能测试 |
| **内存占用** | < 500MB | 监控工具 |
| **单元测试覆盖率** | > 80% | dotCover |

### 9.2 功能指标

| 功能 | 验收标准 |
|-----|---------|
| **活动计划** | 可创建/取消/队列 3 个计划 |
| **离线快进** | 离线 12 小时正确结算 |
| **地图解锁** | 5 个区域正确解锁链 |
| **装备系统** | 可生成/分解/重铸装备 |

### 9.3 用户体验指标

| 指标 | 目标 |
|-----|------|
| **首次上手时间** | < 5 分钟 |
| **操作响应感** | 无明显卡顿 |
| **错误提示** | 清晰易懂 |

---

## 10. 总结与建议

### 10.1 关键成功因素

1. ✅ **优先修复 DI 问题**（最高优先级）
2. ✅ **分阶段交付**（每 Phase 独立可测试）
3. ✅ **保持向后兼容**（不破坏现有功能）
4. ✅ **充分测试**（单元 + 集成 + 手动）
5. ✅ **文档同步**（代码与文档一致）

### 10.2 建议的开发顺序

```
1. 修复 DI 问题（1 周）  ← 立即开始
   ↓
2. 重构战斗引擎（2 周）
   ↓
3. 实现活动计划（5 周）
   ↓
4. 实现离线快进（3 周）  ← 核心体验
   ↓
5. 实现地图区域（4 周）
   ↓
6. 实现装备系统（6 周）  ← 长期目标
```

### 10.3 最后的话

BlazorIdle 项目的技术基座非常扎实，设计文档也极其完善。当前的关键是：

1. **快速修复 DI 问题**，让服务器可运行
2. **完成核心玩法系统**（活动 + 离线 + 装备）
3. **建立经济闭环**，让游戏有长期目标

完成这些后，游戏将从"技术 Demo"蜕变为"可玩的 Alpha 版本"。

**建议采用敏捷开发**，每 2-3 周发布一个可玩版本，快速验证设计。

祝项目成功！🚀

---

**文档维护**:
- 每完成一个 Phase 后更新进度
- 发现新问题或风险及时记录
- 定期回顾优先级
