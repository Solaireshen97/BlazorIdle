# BlazorIdle 服务器端注册问题分析与解决方案

**文档版本**: 1.0  
**创建日期**: 2025年1月  
**作者**: 系统分析  
**状态**: 仅方案，不包含实际修改

---

## 目录

1. [问题诊断](#1-问题诊断)
2. [根本原因分析](#2-根本原因分析)
3. [解决方案设计](#3-解决方案设计)
4. [实施步骤](#4-实施步骤)
5. [风险评估与注意事项](#5-风险评估与注意事项)
6. [测试验证方案](#6-测试验证方案)

---

## 1. 问题诊断

### 1.1 错误现象

服务器启动时抛出以下异常：

```
System.InvalidOperationException: Cannot consume scoped service 
'BlazorIdle.Server.Application.Abstractions.ICharacterRepository' 
from singleton 'BlazorIdle.Server.Application.Activities.IActivityExecutor'.
```

### 1.2 影响范围

- ✅ **编译阶段**: 正常通过，无编译错误
- ❌ **运行阶段**: 服务器启动失败，无法启动Web应用
- ❌ **活动计划系统**: 完全不可用
- ❌ **前端集成**: 无法调用活动计划API
- ❌ **开发测试**: 整个应用无法运行

### 1.3 问题复现

```bash
cd BlazorIdle.Server
dotnet run

# 输出错误信息并立即退出（Exit Code 134）
```

---

## 2. 根本原因分析

### 2.1 ASP.NET Core 依赖注入生命周期规则

ASP.NET Core DI 系统有三种服务生命周期：

| 生命周期 | 范围 | 创建时机 | 典型用途 |
|---------|------|---------|---------|
| **Singleton** | 应用全局 | 应用启动时创建一次 | 无状态服务、缓存、配置 |
| **Scoped** | HTTP请求 | 每个请求创建一次 | DbContext、Repository |
| **Transient** | 每次注入 | 每次依赖注入时创建 | 轻量级无状态服务 |

**核心规则**: **长生命周期的服务不能直接依赖短生命周期的服务**

原因：
- Singleton 在应用启动时创建，持续整个应用生命周期
- Scoped 服务每个请求都会创建新实例
- 如果 Singleton 持有 Scoped 服务的引用，会导致：
  1. Scoped 服务被"捕获"，无法在请求结束时释放
  2. 多个请求可能会共享同一个 Scoped 实例（违反隔离性）
  3. DbContext 等资源可能泄漏或状态混乱

### 2.2 当前代码问题定位

#### 问题代码 1：服务注册

**文件**: `BlazorIdle.Server/Application/DependencyInjection.cs`

```csharp
// Line 54 - 问题注册
services.AddSingleton<IActivityExecutor, CombatActivityExecutor>();
```

**分析**:
- `CombatActivityExecutor` 被注册为 **Singleton**
- 设计意图：全局单例，无状态，可复用

#### 问题代码 2：构造函数依赖

**文件**: `BlazorIdle.Server/Application/Activities/CombatActivityExecutor.cs`

```csharp
public CombatActivityExecutor(
    StepBattleCoordinator battleCoordinator,  // Singleton - OK
    ICharacterRepository characters)           // Scoped - 问题!
{
    _battleCoordinator = battleCoordinator;
    _characters = characters;  // Singleton 持有 Scoped 引用
}
```

**分析**:
- `ICharacterRepository` 在 `Infrastructure/DependencyInjection/Repositories.cs` 中注册为 **Scoped**
- 原因：Repository 依赖 `GameDbContext`，而 `DbContext` 必须是 Scoped（EF Core 要求）
- 违反规则：Singleton → Scoped

#### 问题代码 3：实际使用场景

```csharp
public async Task<ActivityExecutionContext> StartAsync(
    ActivityPlan plan, 
    CancellationToken ct = default)
{
    // Line 37 - 直接使用 Scoped 服务
    var character = await _characters.GetAsync(plan.CharacterId, ct);
    // ...
}
```

**问题**:
- `_characters` 是 Scoped，但在 Singleton 的方法中被调用
- 可能跨多个请求共享同一个 Repository 实例
- DbContext 状态混乱风险

### 2.3 相关联的依赖链

```
ActivityHostedService (Singleton HostedService)
  └─> ActivityCoordinator (Singleton)
        └─> IActivityExecutor[] (Singleton)
              └─> CombatActivityExecutor (Singleton)
                    └─> ICharacterRepository (Scoped) ❌
                          └─> GameDbContext (Scoped)
```

**连锁影响**:
- `ActivityHostedService` 也因此无法启动
- `ActivityCoordinator` 间接依赖 Scoped 服务
- 整个活动计划系统瘫痪

---

## 3. 解决方案设计

### 3.1 方案对比

| 方案 | 优点 | 缺点 | 推荐度 |
|-----|------|------|-------|
| **方案1: IServiceScopeFactory** | ✅ 符合DI最佳实践<br>✅ 保持Executor为Singleton<br>✅ 按需创建Scope | ⚠️ 需要修改Executor代码<br>⚠️ 手动管理Scope生命周期 | ⭐⭐⭐⭐⭐ **推荐** |
| **方案2: 改为Scoped** | ✅ 简单直接<br>✅ 不需要手动管理Scope | ❌ 需要重构ActivityCoordinator<br>❌ 需要重构HostedService<br>❌ 架构级别变更 | ⭐⭐ 不推荐 |
| **方案3: 直接注入DbContext** | ⚠️ 绕过Repository | ❌ 违反分层原则<br>❌ 同样会有DI问题 | ⭐ 不推荐 |

### 3.2 推荐方案：IServiceScopeFactory（方案1）

#### 3.2.1 核心思路

使用 `IServiceScopeFactory` 在需要时动态创建 Scope，从中获取 Scoped 服务。

**原理**:
```
Singleton Service
  └─> IServiceScopeFactory (Singleton) ✅
        └─> CreateScope() → IServiceScope
              └─> ServiceProvider.GetService<ICharacterRepository>() (Scoped) ✅
```

#### 3.2.2 代码改造方案

##### 改造点1: CombatActivityExecutor 构造函数

**当前代码**:
```csharp
public CombatActivityExecutor(
    StepBattleCoordinator battleCoordinator, 
    ICharacterRepository characters)
{
    _battleCoordinator = battleCoordinator;
    _characters = characters;
}
```

**改造后**:
```csharp
public CombatActivityExecutor(
    StepBattleCoordinator battleCoordinator,
    IServiceScopeFactory scopeFactory)  // 注入 ScopeFactory
{
    _battleCoordinator = battleCoordinator;
    _scopeFactory = scopeFactory;  // 存储 Factory
}
```

**字段声明**:
```csharp
private readonly StepBattleCoordinator _battleCoordinator;
private readonly IServiceScopeFactory _scopeFactory;  // 新增
```

##### 改造点2: StartAsync 方法

**当前代码**:
```csharp
public async Task<ActivityExecutionContext> StartAsync(
    ActivityPlan plan, 
    CancellationToken ct = default)
{
    var character = await _characters.GetAsync(plan.CharacterId, ct);
    // ...
}
```

**改造后**:
```csharp
public async Task<ActivityExecutionContext> StartAsync(
    ActivityPlan plan, 
    CancellationToken ct = default)
{
    // 创建临时 Scope
    using var scope = _scopeFactory.CreateScope();
    
    // 从 Scope 中获取 Scoped 服务
    var characters = scope.ServiceProvider
        .GetRequiredService<ICharacterRepository>();
    
    // 使用 Repository
    var character = await characters.GetAsync(plan.CharacterId, ct);
    
    // Scope 在方法结束时自动释放（using 语句）
    // ...
}
```

##### 改造点3: AdvanceAsync 方法（如果需要）

如果 `AdvanceAsync` 也使用了 `_characters`，需要同样改造：

```csharp
public async Task AdvanceAsync(
    ActivityPlan plan, 
    ActivityExecutionContext context, 
    CancellationToken ct = default)
{
    using var scope = _scopeFactory.CreateScope();
    var characters = scope.ServiceProvider
        .GetRequiredService<ICharacterRepository>();
    
    // 使用 characters ...
}
```

**注意**: 根据当前代码，`AdvanceAsync` 不使用 Repository，可能不需要改动。

##### 改造点4: StopAsync 方法（如果需要）

根据当前代码，`StopAsync` 也不使用 Repository，无需改动。

##### 改造点5: CheckCompletionAsync 方法（如果需要）

根据当前代码，`CheckCompletionAsync` 不使用 Repository，无需改动。

#### 3.2.3 关键技术点

**IServiceScopeFactory 的作用**:
- 本身是 **Singleton** 生命周期
- 提供 `CreateScope()` 方法创建新的 Scope
- 每个 Scope 有独立的 `ServiceProvider`
- Scope 内的 Scoped 服务相互隔离

**using 语句的作用**:
```csharp
using var scope = _scopeFactory.CreateScope();
// scope 在方法结束时自动调用 Dispose()
// 释放 Scope 内的所有 Scoped 服务（包括 DbContext）
```

**性能考虑**:
- ✅ CreateScope() 是轻量级操作
- ✅ Scope 内的服务按需创建（延迟初始化）
- ✅ 自动释放资源，无内存泄漏
- ⚠️ 不要在热路径（每秒数千次）中频繁创建 Scope

**当前使用场景评估**:
- `StartAsync`: 活动开始时调用（频率低）✅
- `AdvanceAsync`: 由 HostedService 定期调用（秒级）✅
- 性能影响：**可忽略**

---

## 4. 实施步骤

### 4.1 第一步：修改 CombatActivityExecutor

**文件**: `BlazorIdle.Server/Application/Activities/CombatActivityExecutor.cs`

#### 4.1.1 修改构造函数

删除 `ICharacterRepository` 参数，添加 `IServiceScopeFactory` 参数：

```csharp
public CombatActivityExecutor(
    StepBattleCoordinator battleCoordinator,
    IServiceScopeFactory scopeFactory)
{
    _battleCoordinator = battleCoordinator;
    _scopeFactory = scopeFactory;
}
```

#### 4.1.2 修改字段声明

删除：
```csharp
private readonly ICharacterRepository _characters;
```

添加：
```csharp
private readonly IServiceScopeFactory _scopeFactory;
```

#### 4.1.3 修改 StartAsync 方法

在方法开头添加 Scope 创建：

```csharp
public async Task<ActivityExecutionContext> StartAsync(
    ActivityPlan plan, 
    CancellationToken ct = default)
{
    if (plan.Type != ActivityType.Combat)
        throw new InvalidOperationException(
            $"CombatActivityExecutor only supports Combat activities, got {plan.Type}");
    
    // 创建 Scope 并获取 Repository
    using var scope = _scopeFactory.CreateScope();
    var characters = scope.ServiceProvider
        .GetRequiredService<ICharacterRepository>();
    
    // 解析战斗载荷
    var payload = JsonSerializer.Deserialize<CombatPayload>(plan.PayloadJson) 
        ?? throw new InvalidOperationException("Invalid combat payload");
    
    // 获取角色信息（使用局部 characters 变量）
    var character = await characters.GetAsync(plan.CharacterId, ct) 
        ?? throw new InvalidOperationException($"Character {plan.CharacterId} not found");
    
    // 后续代码保持不变...
    var baseStats = ProfessionBaseStatsRegistry.Resolve(character.Profession);
    // ...
}
```

#### 4.1.4 检查其他方法

- `AdvanceAsync`: 不使用 Repository，无需修改
- `StopAsync`: 不使用 Repository，无需修改
- `CheckCompletionAsync`: 不使用 Repository，无需修改

### 4.2 第二步：添加 using 指令

在文件顶部添加（如果尚未存在）：

```csharp
using Microsoft.Extensions.DependencyInjection;
```

### 4.3 第三步：验证编译

```bash
cd BlazorIdle.Server
dotnet build
```

预期输出：
```
Build succeeded.
    0 Warning(s)
    0 Error(s)
```

### 4.4 第四步：验证运行

```bash
cd BlazorIdle.Server
dotnet run
```

预期输出：
```
info: Microsoft.Hosting.Lifetime[14]
      Now listening on: http://localhost:5000
info: Microsoft.Hosting.Lifetime[0]
      Application started. Press Ctrl+C to shut down.
```

### 4.5 第五步：功能测试

#### 测试1：创建活动计划

```bash
curl -X POST http://localhost:5000/api/activities/plans \
  -H "Content-Type: application/json" \
  -d '{
    "characterId": "00000000-0000-0000-0000-000000000001",
    "slotIndex": 0,
    "type": "Combat",
    "limitType": "duration",
    "limitValue": 60,
    "payloadJson": "{\"enemyId\":\"dummy\",\"mode\":\"duration\"}"
  }'
```

预期：返回 200 OK 或 201 Created

#### 测试2：查看槽位状态

```bash
curl http://localhost:5000/api/activities/characters/00000000-0000-0000-0000-000000000001/slots
```

预期：返回槽位列表 JSON

#### 测试3：前端集成测试

在前端 `Characters.razor` 页面：
1. 创建角色
2. 在"活动计划管理"部分创建战斗计划
3. 启用自动刷新
4. 观察进度条更新

---

## 5. 风险评估与注意事项

### 5.1 技术风险

| 风险 | 影响 | 概率 | 缓解措施 |
|-----|------|------|---------|
| **Scope 未释放导致内存泄漏** | 高 | 低 | 使用 `using` 语句确保自动释放 |
| **并发调用时 DbContext 冲突** | 中 | 低 | 每个 Scope 有独立的 DbContext |
| **性能下降** | 低 | 极低 | CreateScope 是轻量级操作 |
| **未来扩展时忘记创建 Scope** | 中 | 中 | 代码审查和文档说明 |

### 5.2 实施注意事项

#### 5.2.1 务必使用 using 语句

❌ **错误示例**:
```csharp
var scope = _scopeFactory.CreateScope();
var characters = scope.ServiceProvider.GetRequiredService<ICharacterRepository>();
// 忘记释放 scope - 内存泄漏!
```

✅ **正确示例**:
```csharp
using var scope = _scopeFactory.CreateScope();
var characters = scope.ServiceProvider.GetRequiredService<ICharacterRepository>();
// scope 自动释放
```

#### 5.2.2 不要跨方法持有 Scope

❌ **错误示例**:
```csharp
private IServiceScope _scope;  // 不要这样做!

public void Start()
{
    _scope = _scopeFactory.CreateScope();
}

public void Stop()
{
    _scope.Dispose();
}
```

原因：
- Scope 生命周期难以管理
- 容易忘记释放
- 跨请求共享状态风险

✅ **正确做法**:
```csharp
public void DoWork()
{
    using var scope = _scopeFactory.CreateScope();
    // 使用 scope
    // 方法结束自动释放
}
```

#### 5.2.3 注意异步方法中的 Scope

✅ **正确示例**:
```csharp
public async Task<Result> DoWorkAsync()
{
    using var scope = _scopeFactory.CreateScope();
    var service = scope.ServiceProvider.GetRequiredService<ISomeService>();
    return await service.DoAsync();  // OK - scope 在 await 后仍有效
}  // scope 在这里释放
```

#### 5.2.4 避免在循环中频繁创建 Scope

⚠️ **性能敏感场景**:
```csharp
// 如果 items 有数千条，考虑优化
foreach (var item in items)
{
    using var scope = _scopeFactory.CreateScope();  // 每次循环创建新 Scope
    // ...
}
```

✅ **优化方案**:
```csharp
using var scope = _scopeFactory.CreateScope();  // 循环外创建一次
foreach (var item in items)
{
    // 复用同一个 Scope
}
```

**当前项目评估**:
- `StartAsync` 等方法**不在热路径**
- 活动开始/停止频率低（秒级或更低）
- **无需优化**，当前方案最佳

### 5.3 未来扩展建议

#### 5.3.1 如果添加新的 IActivityExecutor 实现

模板代码：

```csharp
public class GatherActivityExecutor : IActivityExecutor
{
    private readonly IServiceScopeFactory _scopeFactory;
    
    public GatherActivityExecutor(IServiceScopeFactory scopeFactory)
    {
        _scopeFactory = scopeFactory;
    }
    
    public async Task<ActivityExecutionContext> StartAsync(
        ActivityPlan plan, 
        CancellationToken ct = default)
    {
        using var scope = _scopeFactory.CreateScope();
        var characters = scope.ServiceProvider
            .GetRequiredService<ICharacterRepository>();
        
        // 实现采集逻辑...
    }
}
```

#### 5.3.2 如果需要多个 Scoped 服务

```csharp
using var scope = _scopeFactory.CreateScope();
var sp = scope.ServiceProvider;

var characters = sp.GetRequiredService<ICharacterRepository>();
var battles = sp.GetRequiredService<IBattleRepository>();
var rewards = sp.GetRequiredService<IRewardGrantService>();

// 使用多个服务...
```

#### 5.3.3 文档化这一模式

在 `README.md` 或开发者文档中添加：

```markdown
## 依赖注入指南

### Singleton 服务如何使用 Scoped 服务

如果你的 Singleton 服务需要访问 Scoped 服务（如 Repository），
请使用 `IServiceScopeFactory` 模式：

\`\`\`csharp
public class MySingletonService
{
    private readonly IServiceScopeFactory _scopeFactory;
    
    public MySingletonService(IServiceScopeFactory scopeFactory)
    {
        _scopeFactory = scopeFactory;
    }
    
    public async Task DoWork()
    {
        using var scope = _scopeFactory.CreateScope();
        var repo = scope.ServiceProvider
            .GetRequiredService<IMyRepository>();
        
        await repo.DoSomethingAsync();
    }
}
\`\`\`

**关键点**：
- ✅ 始终使用 `using` 语句
- ✅ 在需要时创建 Scope
- ✅ 避免在循环中频繁创建（除非必要）
- ❌ 不要将 Scope 存储为字段
```

---

## 6. 测试验证方案

### 6.1 单元测试

#### 测试1：验证 Scope 正确创建和释放

```csharp
[Fact]
public async Task StartAsync_ShouldCreateAndDisposeScope()
{
    // Arrange
    var scopeFactoryMock = new Mock<IServiceScopeFactory>();
    var scopeMock = new Mock<IServiceScope>();
    var serviceProviderMock = new Mock<IServiceProvider>();
    var charactersRepoMock = new Mock<ICharacterRepository>();
    
    var character = new Character { Id = Guid.NewGuid(), /* ... */ };
    charactersRepoMock
        .Setup(x => x.GetAsync(It.IsAny<Guid>(), It.IsAny<CancellationToken>()))
        .ReturnsAsync(character);
    
    serviceProviderMock
        .Setup(x => x.GetService(typeof(ICharacterRepository)))
        .Returns(charactersRepoMock.Object);
    
    scopeMock.SetupGet(x => x.ServiceProvider).Returns(serviceProviderMock.Object);
    
    scopeFactoryMock
        .Setup(x => x.CreateScope())
        .Returns(scopeMock.Object);
    
    var executor = new CombatActivityExecutor(
        Mock.Of<StepBattleCoordinator>(),
        scopeFactoryMock.Object);
    
    var plan = new ActivityPlan { /* ... */ };
    
    // Act
    await executor.StartAsync(plan);
    
    // Assert
    scopeFactoryMock.Verify(x => x.CreateScope(), Times.Once);
    scopeMock.Verify(x => x.Dispose(), Times.Once);  // 验证 Scope 被释放
}
```

#### 测试2：验证角色不存在时的异常

```csharp
[Fact]
public async Task StartAsync_WhenCharacterNotFound_ShouldThrow()
{
    // Arrange
    var scopeFactoryMock = new Mock<IServiceScopeFactory>();
    var scopeMock = new Mock<IServiceScope>();
    var serviceProviderMock = new Mock<IServiceProvider>();
    var charactersRepoMock = new Mock<ICharacterRepository>();
    
    charactersRepoMock
        .Setup(x => x.GetAsync(It.IsAny<Guid>(), It.IsAny<CancellationToken>()))
        .ReturnsAsync((Character)null);  // 角色不存在
    
    serviceProviderMock
        .Setup(x => x.GetService(typeof(ICharacterRepository)))
        .Returns(charactersRepoMock.Object);
    
    scopeMock.SetupGet(x => x.ServiceProvider).Returns(serviceProviderMock.Object);
    
    scopeFactoryMock
        .Setup(x => x.CreateScope())
        .Returns(scopeMock.Object);
    
    var executor = new CombatActivityExecutor(
        Mock.Of<StepBattleCoordinator>(),
        scopeFactoryMock.Object);
    
    var plan = new ActivityPlan { CharacterId = Guid.NewGuid(), /* ... */ };
    
    // Act & Assert
    await Assert.ThrowsAsync<InvalidOperationException>(
        () => executor.StartAsync(plan));
}
```

### 6.2 集成测试

#### 测试3：端到端活动计划创建

```csharp
[Fact]
public async Task CreateActivityPlan_ShouldStartCombatSuccessfully()
{
    // Arrange
    using var factory = new WebApplicationFactory<Program>();
    var client = factory.CreateClient();
    
    // 创建测试角色
    var characterId = await CreateTestCharacterAsync(client);
    
    var request = new CreateActivityPlanRequest
    {
        CharacterId = characterId,
        SlotIndex = 0,
        Type = "Combat",
        LimitType = "duration",
        LimitValue = 60,
        PayloadJson = JsonSerializer.Serialize(new CombatPayload
        {
            EnemyId = "dummy",
            Mode = "duration"
        })
    };
    
    // Act
    var response = await client.PostAsJsonAsync(
        "/api/activities/plans", 
        request);
    
    // Assert
    response.EnsureSuccessStatusCode();
    var result = await response.Content.ReadFromJsonAsync<ActivityPlanDto>();
    Assert.NotNull(result);
    Assert.Equal(characterId, result.CharacterId);
    Assert.Equal("Running", result.State);
}
```

### 6.3 手动测试清单

#### 测试场景1：基本活动创建

- [ ] 启动服务器（无错误）
- [ ] 创建角色
- [ ] 创建战斗活动计划
- [ ] 验证计划状态为 "Running"
- [ ] 等待计划完成
- [ ] 验证计划状态为 "Completed"

#### 测试场景2：多槽位并发

- [ ] 在槽位 0 创建计划
- [ ] 在槽位 1 创建计划
- [ ] 在槽位 2 创建计划
- [ ] 验证三个计划同时运行
- [ ] 验证各自进度独立

#### 测试场景3：队列管理

- [ ] 在槽位 0 创建计划 A（运行中）
- [ ] 在槽位 0 创建计划 B（队列中）
- [ ] 等待计划 A 完成
- [ ] 验证计划 B 自动开始

#### 测试场景4：取消计划

- [ ] 创建运行中的计划
- [ ] 调用取消 API
- [ ] 验证计划状态变为 "Cancelled"
- [ ] 验证战斗正确停止

#### 测试场景5：错误处理

- [ ] 尝试为不存在的角色创建计划（应返回错误）
- [ ] 尝试创建无效的 payload（应返回错误）
- [ ] 并发创建多个计划到同一槽位（验证队列）

### 6.4 性能测试

#### 测试6：Scope 创建性能

```csharp
[Fact]
public void CreateScope_PerformanceBenchmark()
{
    var services = new ServiceCollection();
    services.AddDbContext<GameDbContext>(opt => opt.UseInMemoryDatabase("test"));
    services.AddScoped<ICharacterRepository, CharacterRepository>();
    
    var serviceProvider = services.BuildServiceProvider();
    var scopeFactory = serviceProvider.GetRequiredService<IServiceScopeFactory>();
    
    var stopwatch = Stopwatch.StartNew();
    const int iterations = 10000;
    
    for (int i = 0; i < iterations; i++)
    {
        using var scope = scopeFactory.CreateScope();
        var repo = scope.ServiceProvider.GetRequiredService<ICharacterRepository>();
    }
    
    stopwatch.Stop();
    
    var avgMs = stopwatch.ElapsedMilliseconds / (double)iterations;
    Console.WriteLine($"Average CreateScope time: {avgMs:F4} ms");
    
    // 预期：< 0.1 ms per scope
    Assert.True(avgMs < 0.1, $"Scope creation too slow: {avgMs} ms");
}
```

### 6.5 内存泄漏检测

使用 dotMemory 或类似工具：

1. 启动服务器
2. 创建 1000 个活动计划
3. 等待全部完成
4. 触发 GC
5. 检查内存是否恢复到初始状态（允许 5% 误差）

预期：无 Scope 对象残留

---

## 7. 总结

### 7.1 问题根源

- **ASP.NET Core DI 规则**：Singleton 不能直接依赖 Scoped
- **当前设计**：`CombatActivityExecutor` (Singleton) → `ICharacterRepository` (Scoped)
- **根本原因**：违反了生命周期依赖规则

### 7.2 解决方案

- **推荐方案**：使用 `IServiceScopeFactory` 按需创建 Scope
- **核心改动**：
  1. 构造函数注入 `IServiceScopeFactory`
  2. 在 `StartAsync` 等方法中创建临时 Scope
  3. 使用 `using` 语句确保自动释放
- **影响范围**：仅 `CombatActivityExecutor.cs` 一个文件

### 7.3 优势

✅ **符合最佳实践**：遵循 ASP.NET Core DI 规范
✅ **最小改动**：只需修改一个类
✅ **性能优秀**：CreateScope 开销可忽略
✅ **线程安全**：每个 Scope 独立隔离
✅ **易于维护**：模式清晰，可复用
✅ **向后兼容**：不影响其他代码

### 7.4 下一步

1. ✅ 按照第4节实施步骤修改代码
2. ✅ 编译和运行验证
3. ✅ 执行第6节的测试方案
4. ✅ 更新开发者文档
5. ✅ 代码审查和合并

---

**文档维护**：
- 如有新的 `IActivityExecutor` 实现，参考本方案
- 如遇到类似 DI 问题，优先考虑 `IServiceScopeFactory` 模式
